{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { isString, stringValue } from 'vega-util';\nimport { forEachSelection, STORE } from '.';\nimport { warn } from '../../log';\nimport { duplicate, keys, logicalExpr, varName } from '../../util';\nimport { OutputNode } from '../data/dataflow';\nimport { FilterNode } from '../data/filter';\nimport { forEachTransform } from './transforms/transforms';\nimport { DataSourceType } from '../../data';\nexport function parseUnitSelection(model, selDefs) {\n  var _a;\n\n  var selCmpts = {};\n  var selectionConfig = model.config.selection;\n\n  var _iterator = _createForOfIteratorHelper(keys(selDefs !== null && selDefs !== void 0 ? selDefs : {})),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var name = _step.value;\n      var selDef = duplicate(selDefs[name]);\n\n      var _b = selectionConfig[selDef.type],\n          fields = _b.fields,\n          encodings = _b.encodings,\n          cfg = __rest(_b, [\"fields\", \"encodings\"]); // Project transform applies its defaults.\n      // Set default values from config if a property hasn't been specified,\n      // or if it is true. E.g., \"translate\": true should use the default\n      // event handlers for translate. However, true may be a valid value for\n      // a property (e.g., \"nearest\": true).\n\n\n      for (var key in cfg) {\n        // A selection should contain either `encodings` or `fields`, only use\n        // default values for these two values if neither of them is specified.\n        if (key === 'encodings' && selDef.fields || key === 'fields' && selDef.encodings) {\n          continue;\n        }\n\n        if (key === 'mark') {\n          selDef[key] = Object.assign(Object.assign({}, cfg[key]), selDef[key]);\n        }\n\n        if (selDef[key] === undefined || selDef[key] === true) {\n          selDef[key] = (_a = cfg[key]) !== null && _a !== void 0 ? _a : selDef[key];\n        }\n      }\n\n      var safeName = varName(name);\n      var selCmpt = selCmpts[safeName] = Object.assign(Object.assign({}, selDef), {\n        name: safeName,\n        events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : duplicate(selDef.on)\n      });\n      forEachTransform(selCmpt, function (txCompiler) {\n        if (txCompiler.has(selCmpt) && txCompiler.parse) {\n          txCompiler.parse(model, selCmpt, selDef, selDefs[name]);\n        }\n      });\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return selCmpts;\n}\nexport function parseSelectionPredicate(model, selections, dfnode) {\n  var datum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'datum';\n  var stores = [];\n\n  function expr(name) {\n    var vname = varName(name);\n    var selCmpt = model.getSelectionComponent(vname, name);\n    var store = stringValue(vname + STORE);\n\n    if (selCmpt.project.timeUnit) {\n      var child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;\n      var tunode = selCmpt.project.timeUnit.clone();\n\n      if (child.parent) {\n        tunode.insertAsParentOf(child);\n      } else {\n        child.parent = tunode;\n      }\n    }\n\n    if (selCmpt.empty !== 'none') {\n      stores.push(store);\n    }\n\n    return \"vlSelectionTest(\".concat(store, \", \").concat(datum) + (selCmpt.resolve === 'global' ? ')' : \", \".concat(stringValue(selCmpt.resolve), \")\"));\n  }\n\n  var predicateStr = logicalExpr(selections, expr);\n  return (stores.length ? '!(' + stores.map(function (s) {\n    return \"length(data(\".concat(s, \"))\");\n  }).join(' || ') + ') || ' : '') + \"(\".concat(predicateStr, \")\");\n}\nexport function parseSelectionBinExtent(selCmpt, extent) {\n  var encoding = extent['encoding'];\n  var field = extent['field'];\n\n  if (!encoding && !field) {\n    field = selCmpt.project.items[0].field;\n\n    if (selCmpt.project.items.length > 1) {\n      warn('A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' + \"Using \\\"field\\\": \".concat(stringValue(field), \".\"));\n    }\n  } else if (encoding && !field) {\n    var encodings = selCmpt.project.items.filter(function (p) {\n      return p.channel === encoding;\n    });\n\n    if (!encodings.length || encodings.length > 1) {\n      field = selCmpt.project.items[0].field;\n      warn((!encodings.length ? 'No ' : 'Multiple ') + \"matching \".concat(stringValue(encoding), \" encoding found for selection \").concat(stringValue(extent.selection), \". \") + \"Using \\\"field\\\": \".concat(stringValue(field), \".\"));\n    } else {\n      field = encodings[0].field;\n    }\n  }\n\n  return \"\".concat(selCmpt.name, \"[\").concat(stringValue(field), \"]\");\n}\nexport function materializeSelections(model, main) {\n  forEachSelection(model, function (selCmpt) {\n    var selection = selCmpt.name;\n    var lookupName = model.getName(\"lookup_\".concat(selection));\n    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main, model, {\n      selection: selection\n    }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);\n  });\n}","map":{"version":3,"sources":["../../../../src/compile/selection/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { isString, stringValue } from 'vega-util';\nimport { forEachSelection, STORE } from '.';\nimport { warn } from '../../log';\nimport { duplicate, keys, logicalExpr, varName } from '../../util';\nimport { OutputNode } from '../data/dataflow';\nimport { FilterNode } from '../data/filter';\nimport { forEachTransform } from './transforms/transforms';\nimport { DataSourceType } from '../../data';\nexport function parseUnitSelection(model, selDefs) {\n    var _a;\n    const selCmpts = {};\n    const selectionConfig = model.config.selection;\n    for (const name of keys(selDefs !== null && selDefs !== void 0 ? selDefs : {})) {\n        const selDef = duplicate(selDefs[name]);\n        const _b = selectionConfig[selDef.type], { fields, encodings } = _b, cfg = __rest(_b, [\"fields\", \"encodings\"]); // Project transform applies its defaults.\n        // Set default values from config if a property hasn't been specified,\n        // or if it is true. E.g., \"translate\": true should use the default\n        // event handlers for translate. However, true may be a valid value for\n        // a property (e.g., \"nearest\": true).\n        for (const key in cfg) {\n            // A selection should contain either `encodings` or `fields`, only use\n            // default values for these two values if neither of them is specified.\n            if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {\n                continue;\n            }\n            if (key === 'mark') {\n                selDef[key] = Object.assign(Object.assign({}, cfg[key]), selDef[key]);\n            }\n            if (selDef[key] === undefined || selDef[key] === true) {\n                selDef[key] = (_a = cfg[key]) !== null && _a !== void 0 ? _a : selDef[key];\n            }\n        }\n        const safeName = varName(name);\n        const selCmpt = (selCmpts[safeName] = Object.assign(Object.assign({}, selDef), { name: safeName, events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : duplicate(selDef.on) }));\n        forEachTransform(selCmpt, txCompiler => {\n            if (txCompiler.has(selCmpt) && txCompiler.parse) {\n                txCompiler.parse(model, selCmpt, selDef, selDefs[name]);\n            }\n        });\n    }\n    return selCmpts;\n}\nexport function parseSelectionPredicate(model, selections, dfnode, datum = 'datum') {\n    const stores = [];\n    function expr(name) {\n        const vname = varName(name);\n        const selCmpt = model.getSelectionComponent(vname, name);\n        const store = stringValue(vname + STORE);\n        if (selCmpt.project.timeUnit) {\n            const child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;\n            const tunode = selCmpt.project.timeUnit.clone();\n            if (child.parent) {\n                tunode.insertAsParentOf(child);\n            }\n            else {\n                child.parent = tunode;\n            }\n        }\n        if (selCmpt.empty !== 'none') {\n            stores.push(store);\n        }\n        return (`vlSelectionTest(${store}, ${datum}` + (selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`));\n    }\n    const predicateStr = logicalExpr(selections, expr);\n    return ((stores.length ? '!(' + stores.map(s => `length(data(${s}))`).join(' || ') + ') || ' : '') + `(${predicateStr})`);\n}\nexport function parseSelectionBinExtent(selCmpt, extent) {\n    const encoding = extent['encoding'];\n    let field = extent['field'];\n    if (!encoding && !field) {\n        field = selCmpt.project.items[0].field;\n        if (selCmpt.project.items.length > 1) {\n            warn('A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' +\n                `Using \"field\": ${stringValue(field)}.`);\n        }\n    }\n    else if (encoding && !field) {\n        const encodings = selCmpt.project.items.filter(p => p.channel === encoding);\n        if (!encodings.length || encodings.length > 1) {\n            field = selCmpt.project.items[0].field;\n            warn((!encodings.length ? 'No ' : 'Multiple ') +\n                `matching ${stringValue(encoding)} encoding found for selection ${stringValue(extent.selection)}. ` +\n                `Using \"field\": ${stringValue(field)}.`);\n        }\n        else {\n            field = encodings[0].field;\n        }\n    }\n    return `${selCmpt.name}[${stringValue(field)}]`;\n}\nexport function materializeSelections(model, main) {\n    forEachSelection(model, selCmpt => {\n        const selection = selCmpt.name;\n        const lookupName = model.getName(`lookup_${selection}`);\n        model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main, model, { selection }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);\n    });\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}