{"ast":null,"code":"import { earcut } from '@math.gl/polygon';\nexport function featuresToBinary(features, firstPassData, options) {\n  const propArrayTypes = extractNumericPropTypes(features);\n  const numericPropKeys = Object.keys(propArrayTypes).filter(k => propArrayTypes[k] !== Array);\n  return fillArrays(features, firstPassData, {\n    numericPropKeys: options ? options.numericPropKeys : numericPropKeys,\n    propArrayTypes,\n    PositionDataType: options ? options.PositionDataType : Float32Array\n  });\n}\nexport const TEST_EXPORTS = {\n  fillArrays\n};\n\nfunction extractNumericPropTypes(features) {\n  const propArrayTypes = {};\n\n  for (const feature of features) {\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        const val = feature.properties[key];\n        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n      }\n    }\n  }\n\n  return propArrayTypes;\n}\n\nfunction fillArrays(features, firstPassData, options) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount\n  } = firstPassData;\n  const {\n    numericPropKeys,\n    propArrayTypes,\n    PositionDataType = Float32Array\n  } = options;\n  const hasGlobalId = features[0] && 'id' in features[0];\n  const coordLength = 2;\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points = {\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const lines = {\n    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const polygons = {\n    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    triangles: [],\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys) {\n      const TypedArray = propArrayTypes[propName];\n      object.numericProps[propName] = new TypedArray(object.positions.length / coordLength);\n    }\n  }\n\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n      case 'MultiPoint':\n        handlePoint(geometry, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n\n        if (hasGlobalId) {\n          points.fields.push({\n            id: feature.id\n          });\n        }\n\n        indexMap.pointFeature++;\n        break;\n\n      case 'LineString':\n      case 'MultiLineString':\n        handleLineString(geometry, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n\n        if (hasGlobalId) {\n          lines.fields.push({\n            id: feature.id\n          });\n        }\n\n        indexMap.lineFeature++;\n        break;\n\n      case 'Polygon':\n      case 'MultiPolygon':\n        handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n\n        if (hasGlobalId) {\n          polygons.fields.push({\n            id: feature.id\n          });\n        }\n\n        indexMap.polygonFeature++;\n        break;\n\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\nfunction handlePoint(geometry, points, indexMap, coordLength, properties) {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  indexMap.pointPosition += nPositions;\n}\n\nfunction handleLineString(geometry, lines, indexMap, coordLength, properties) {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);\n  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);\n\n  for (let i = 0, il = geometry.lines.length; i < il; ++i) {\n    const start = geometry.lines[i];\n    const end = i === il - 1 ? geometry.data.length : geometry.lines[i + 1];\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n\nfunction handlePolygon(geometry, polygons, indexMap, coordLength, properties) {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n\n  for (let l = 0, ll = geometry.lines.length; l < ll; ++l) {\n    const startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n    const areas = geometry.areas[l];\n    const lines = geometry.lines[l];\n    const nextLines = geometry.lines[l + 1];\n\n    for (let i = 0, il = lines.length; i < il; ++i) {\n      const start = lines[i];\n      const end = i === il - 1 ? nextLines === undefined ? geometry.data.length : nextLines[0] : lines[i + 1];\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n\n    const endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, lines, {\n      startPosition,\n      endPosition,\n      coordLength\n    });\n  }\n}\n\nfunction triangulatePolygon(polygons, areas, lines, _ref) {\n  let {\n    startPosition,\n    endPosition,\n    coordLength\n  } = _ref;\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n  const polygonPositions = polygons.positions.subarray(start, end);\n  const offset = lines[0];\n  const holes = lines.slice(1).map(n => (n - offset) / coordLength);\n  const indices = earcut(polygonPositions, holes, coordLength, areas);\n\n  for (let t = 0, tl = indices.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + indices[t]);\n  }\n}\n\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n  const returnObj = {\n    points: { ...points,\n      positions: {\n        value: points.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: points.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: points.featureIds,\n        size: 1\n      }\n    },\n    lines: { ...lines,\n      pathIndices: {\n        value: lines.pathIndices,\n        size: 1\n      },\n      positions: {\n        value: lines.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: lines.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: lines.featureIds,\n        size: 1\n      }\n    },\n    polygons: { ...polygons,\n      polygonIndices: {\n        value: polygons.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: polygons.primitivePolygonIndices,\n        size: 1\n      },\n      positions: {\n        value: polygons.positions,\n        size: coordLength\n      },\n      triangles: {\n        value: new Uint32Array(polygons.triangles),\n        size: 1\n      },\n      globalFeatureIds: {\n        value: polygons.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: polygons.featureIds,\n        size: 1\n      }\n    }\n  };\n\n  for (const geomType in returnObj) {\n    for (const numericProp in returnObj[geomType].numericProps) {\n      returnObj[geomType].numericProps[numericProp] = {\n        value: returnObj[geomType].numericProps[numericProp],\n        size: 1\n      };\n    }\n  }\n\n  return returnObj;\n}\n\nfunction fillNumericProperties(object, properties, index, length) {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      object.numericProps[numericPropName].fill(properties[numericPropName], index, index + length);\n    }\n  }\n}\n\nfunction keepStringProperties(properties, numericKeys) {\n  const props = {};\n\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n\n  return props;\n}\n\nfunction deduceArrayType(x, constructor) {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}","map":{"version":3,"sources":["../../../../src/lib/binary-vector-tile/features-to-binary.ts"],"names":["propArrayTypes","extractNumericPropTypes","numericPropKeys","Object","k","fillArrays","options","PositionDataType","Float32Array","TEST_EXPORTS","feature","val","deduceArrayType","polygonFeaturesCount","hasGlobalId","features","coordLength","GlobalFeatureIdsDataType","points","positions","pointPositionsCount","globalFeatureIds","featureIds","pointFeaturesCount","numericProps","properties","fields","lines","pathIndices","linePositionsCount","linePathsCount","lineFeaturesCount","polygons","polygonIndices","polygonPositionsCount","polygonObjectsCount","primitivePolygonIndices","polygonRingsCount","triangles","TypedArray","object","indexMap","pointPosition","pointFeature","linePosition","linePath","lineFeature","polygonPosition","polygonObject","polygonRing","polygonFeature","geometry","handlePoint","keepStringProperties","id","handleLineString","handlePolygon","makeAccessorObjects","nPositions","fillNumericProperties","i","il","start","end","l","ll","startPosition","areas","nextLines","endPosition","triangulatePolygon","polygonPositions","offset","holes","n","indices","earcut","t","tl","returnObj","value","size","numericPropName","index","props","numericKeys","constructor","Number","Math"],"mappings":"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","sourcesContent":["/* eslint-disable indent */\nimport {earcut} from '@math.gl/polygon';\nimport {\n  MvtBinaryCoordinates,\n  MvtBinaryGeometry,\n  MvtBinaryOptions,\n  MvtPropArrayConstructor,\n  MvtFirstPassedData,\n  MvtLines,\n  MvtPoints,\n  MvtPolygons\n} from '../types';\n\n/**\n * Convert binary features to flat binary arrays. Similar to\n * `geojsonToBinary` helper function, except that it expects\n * a binary representation of the feature data, which enables\n * 2X-3X speed increase in parse speed, compared to using\n * geoJSON. See `binary-vector-tile/VectorTileFeature` for\n * data format detais\n *\n * @param features\n * @param firstPassData\n * @param options\n * @returns filled arrays\n */\nexport function featuresToBinary(\n  features: MvtBinaryCoordinates[],\n  firstPassData: MvtFirstPassedData,\n  options?: MvtBinaryOptions\n) {\n  const propArrayTypes = extractNumericPropTypes(features);\n  const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);\n  return fillArrays(features, firstPassData, {\n    numericPropKeys: options ? options.numericPropKeys : numericPropKeys,\n    propArrayTypes,\n    PositionDataType: options ? options.PositionDataType : Float32Array\n  });\n}\n\nexport const TEST_EXPORTS = {\n  fillArrays\n};\n\n/**\n * Extracts properties that are always numeric\n *\n * @param features\n * @returns object with numeric types\n */\nfunction extractNumericPropTypes(features: MvtBinaryCoordinates[]): {\n  [key: string]: MvtPropArrayConstructor;\n} {\n  const propArrayTypes = {};\n  for (const feature of features) {\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        // If property has not been seen before, or if property has been numeric\n        // in all previous features, check if numeric in this feature\n        // If not numeric, Array is stored to prevent rechecking in the future\n        // Additionally, detects if 64 bit precision is required\n        const val = feature.properties[key];\n        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n      }\n    }\n  }\n\n  return propArrayTypes;\n}\n\n/**\n * Fills coordinates into pre-allocated typed arrays\n *\n * @param features\n * @param firstPassData\n * @param options\n * @returns an accessor object with value and size keys\n */\n// eslint-disable-next-line complexity\nfunction fillArrays(\n  features: MvtBinaryCoordinates[],\n  firstPassData: MvtFirstPassedData,\n  options: MvtBinaryOptions\n) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount\n  } = firstPassData;\n  const {numericPropKeys, propArrayTypes, PositionDataType = Float32Array} = options;\n  const hasGlobalId = features[0] && 'id' in features[0];\n  const coordLength = 2;\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points: MvtPoints = {\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds:\n      pointFeaturesCount > 65535\n        ? new Uint32Array(pointPositionsCount)\n        : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const lines: MvtLines = {\n    pathIndices:\n      linePositionsCount > 65535\n        ? new Uint32Array(linePathsCount + 1)\n        : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds:\n      lineFeaturesCount > 65535\n        ? new Uint32Array(linePositionsCount)\n        : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const polygons: MvtPolygons = {\n    polygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonObjectsCount + 1)\n        : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonRingsCount + 1)\n        : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    triangles: [],\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds:\n      polygonFeaturesCount > 65535\n        ? new Uint32Array(polygonPositionsCount)\n        : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n\n  // Instantiate numeric properties arrays; one value per vertex\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys) {\n      // If property has been numeric in all previous features in which the property existed, check\n      // if numeric in this feature\n      const TypedArray = propArrayTypes[propName];\n      object.numericProps[propName] = new TypedArray(object.positions.length / coordLength);\n    }\n  }\n\n  // Set last element of path/polygon indices as positions length\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n      case 'MultiPoint':\n        handlePoint(geometry, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          points.fields.push({id: feature.id});\n        }\n        indexMap.pointFeature++;\n        break;\n      case 'LineString':\n      case 'MultiLineString':\n        handleLineString(geometry, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          lines.fields.push({id: feature.id});\n        }\n        indexMap.lineFeature++;\n        break;\n      case 'Polygon':\n      case 'MultiPolygon':\n        handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          polygons.fields.push({id: feature.id});\n        }\n        indexMap.polygonFeature++;\n        break;\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  // Wrap each array in an accessor object with value and size keys\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\n/**\n * Fills (Multi)Point coordinates into points object of arrays\n *\n * @param geometry\n * @param points\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePoint(\n  geometry: MvtBinaryGeometry,\n  points: MvtPoints,\n  indexMap: {\n    pointPosition: number;\n    pointFeature: number;\n    linePosition?: number;\n    linePath?: number;\n    lineFeature?: number;\n    polygonPosition?: number;\n    polygonObject?: number;\n    polygonRing?: number;\n    polygonFeature?: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n  points.featureIds.fill(\n    indexMap.pointFeature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n\n  indexMap.pointPosition += nPositions;\n}\n\n/**\n * Fills (Multi)LineString coordinates into lines object of arrays\n *\n * @param geometry\n * @param lines\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handleLineString(\n  geometry: MvtBinaryGeometry,\n  lines: MvtLines,\n  indexMap: {\n    pointPosition?: number;\n    pointFeature?: number;\n    linePosition: number;\n    linePath: number;\n    lineFeature: number;\n    polygonPosition?: number;\n    polygonObject?: number;\n    polygonRing?: number;\n    polygonFeature?: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n\n  lines.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n  lines.featureIds.fill(\n    indexMap.lineFeature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n\n  for (let i = 0, il = geometry.lines.length; i < il; ++i) {\n    // Extract range of data we are working with, defined by start\n    // and end indices (these index into the geometry.data array)\n    const start = geometry.lines[i];\n    const end =\n      i === il - 1\n        ? geometry.data.length // last line, so read to end of data\n        : geometry.lines[i + 1]; // start index for next line\n\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n\n/**\n * Fills (Multi)Polygon coordinates into polygons object of arrays\n *\n * @param geometry\n * @param polygons\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePolygon(\n  geometry: MvtBinaryGeometry,\n  polygons: MvtPolygons,\n  indexMap: {\n    pointPosition?: number;\n    pointFeature?: number;\n    linePosition?: number;\n    linePath?: number;\n    lineFeature?: number;\n    polygonPosition: number;\n    polygonObject: number;\n    polygonRing: number;\n    polygonFeature: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n  polygons.featureIds.fill(\n    indexMap.polygonFeature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n\n  // Unlike Point & LineString geometry.lines is a 2D array\n  for (let l = 0, ll = geometry.lines.length; l < ll; ++l) {\n    const startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n\n    const areas = geometry.areas![l];\n    const lines = geometry.lines[l];\n    const nextLines = geometry.lines[l + 1];\n\n    for (let i = 0, il = lines.length; i < il; ++i) {\n      const start = lines[i];\n      const end =\n        i === il - 1\n          ? // last line, so either read to:\n            nextLines === undefined\n            ? geometry.data.length // end of data (no next lines)\n            : nextLines[0] // start of first line in nextLines\n          : lines[i + 1]; // start index for next line\n\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n\n    const endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, lines, {startPosition, endPosition, coordLength});\n  }\n}\n\n/**\n * Triangulate polygon using earcut\n *\n * @param polygons\n * @param areas\n * @param lines\n * @param param3\n */\nfunction triangulatePolygon(\n  polygons: MvtPolygons,\n  areas: number,\n  lines: number[],\n  {\n    startPosition,\n    endPosition,\n    coordLength\n  }: {startPosition: number; endPosition: number; coordLength: number}\n): void {\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n\n  // Extract positions and holes for just this polygon\n  const polygonPositions = polygons.positions.subarray(start, end);\n\n  // Holes are referenced relative to outer polygon\n  const offset = lines[0];\n  const holes = lines.slice(1).map((n: number) => (n - offset) / coordLength);\n\n  // Compute triangulation\n  const indices = earcut(polygonPositions, holes, coordLength, areas);\n\n  // Indices returned by triangulation are relative to start\n  // of polygon, so we need to offset\n  for (let t = 0, tl = indices.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + indices[t]);\n  }\n}\n\n/**\n * Wrap each array in an accessor object with value and size keys\n *\n * @param points\n * @param lines\n * @param polygons\n * @param coordLength\n * @returns object\n */\nfunction makeAccessorObjects(\n  points: MvtPoints,\n  lines: MvtLines,\n  polygons: MvtPolygons,\n  coordLength: number\n) {\n  const returnObj = {\n    points: {\n      ...points,\n      positions: {value: points.positions, size: coordLength},\n      globalFeatureIds: {value: points.globalFeatureIds, size: 1},\n      featureIds: {value: points.featureIds, size: 1}\n    },\n    lines: {\n      ...lines,\n      pathIndices: {value: lines.pathIndices, size: 1},\n      positions: {value: lines.positions, size: coordLength},\n      globalFeatureIds: {value: lines.globalFeatureIds, size: 1},\n      featureIds: {value: lines.featureIds, size: 1}\n    },\n    polygons: {\n      ...polygons,\n      polygonIndices: {value: polygons.polygonIndices, size: 1},\n      primitivePolygonIndices: {value: polygons.primitivePolygonIndices, size: 1},\n      positions: {value: polygons.positions, size: coordLength},\n      triangles: {value: new Uint32Array(polygons.triangles), size: 1},\n      globalFeatureIds: {value: polygons.globalFeatureIds, size: 1},\n      featureIds: {value: polygons.featureIds, size: 1}\n    }\n  };\n\n  for (const geomType in returnObj) {\n    for (const numericProp in returnObj[geomType].numericProps) {\n      returnObj[geomType].numericProps[numericProp] = {\n        value: returnObj[geomType].numericProps[numericProp],\n        size: 1\n      };\n    }\n  }\n  return returnObj;\n}\n\n/**\n * Add numeric properties to object\n *\n * @param object\n * @param properties\n * @param index\n * @param length\n */\nfunction fillNumericProperties(\n  object: MvtPoints,\n  properties: {[x: string]: string | number | boolean | null},\n  index: number,\n  length: number\n): void {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      object.numericProps[numericPropName].fill(properties[numericPropName], index, index + length);\n    }\n  }\n}\n\n/**\n * Keep string properties in object\n *\n * @param properties\n * @param numericKeys\n * @returns object\n */\nfunction keepStringProperties(\n  properties: {[x: string]: string | number | boolean | null},\n  numericKeys: string[]\n) {\n  const props = {};\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n  return props;\n}\n\nfunction deduceArrayType(x: any, constructor: MvtPropArrayConstructor): MvtPropArrayConstructor {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n\n  // If this or previous value required 64bits use Float64Array\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}\n"]},"metadata":{},"sourceType":"module"}