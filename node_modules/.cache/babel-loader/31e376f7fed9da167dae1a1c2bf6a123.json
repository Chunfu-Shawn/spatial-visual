{"ast":null,"code":"import _defineProperty from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../../bin';\nimport { getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isPolarPositionChannel, isXorY } from '../../../channel';\nimport { getBand, isFieldDef, isFieldOrDatumDef, vgField } from '../../../channeldef';\nimport { DEFAULT_STEP, getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { hasDiscreteDomain, ScaleType } from '../../../scale';\nimport { getFirstDefined } from '../../../util';\nimport { isSignalRef, isVgRangeStep } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrStringValue } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { getOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPositionDefaultRef } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel, mark) {\n  var _a, _b, _c, _d;\n\n  var config = model.config,\n      encoding = model.encoding,\n      markDef = model.markDef,\n      stack = model.stack;\n  var channel2 = getSecondaryRangeChannel(channel);\n  var sizeChannel = getSizeChannel(channel);\n  var channelDef = encoding[channel];\n  var channelDef2 = encoding[channel2];\n  var scale = model.getScaleComponent(channel);\n  var scaleType = scale ? scale.get('type') : undefined;\n  var scaleName = model.scaleName(channel);\n  var orient = markDef.orient;\n  var hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  });\n  var isBarBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal'); // x, x2, and width -- we must specify two of these in all conditions\n\n  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !hasSizeDef && !hasDiscreteDomain(scaleType)) {\n    var band = getBand({\n      channel: channel,\n      fieldDef: channelDef,\n      stack: stack,\n      markDef: markDef,\n      config: config\n    });\n    var axis = (_c = model.component.axes[channel]) === null || _c === void 0 ? void 0 : _c[0];\n    var axisTranslate = (_d = axis === null || axis === void 0 ? void 0 : axis.get('translate')) !== null && _d !== void 0 ? _d : 0.5; // vega default is 0.5\n\n    return rectBinPosition({\n      fieldDef: channelDef,\n      fieldDef2: channelDef2,\n      channel: channel,\n      markDef: markDef,\n      scaleName: scaleName,\n      band: band,\n      axisTranslate: axisTranslate,\n      spacing: isXorY(channel) ? getMarkPropOrConfig('binSpacing', markDef, config) : undefined,\n      reverse: scale.get('reverse'),\n      config: config\n    });\n  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType) || isBarBand) && !channelDef2) {\n    return positionAndSize(mark, channelDef, channel, model);\n  } else {\n    return rangePosition(channel, model, {\n      defaultPos: 'zeroOrMax',\n      defaultPos2: 'zeroOrMin'\n    });\n  }\n}\n\nfunction defaultSizeRef(mark, sizeChannel, scaleName, scale, config, band) {\n  if (scale) {\n    var scaleType = scale.get('type');\n\n    if (scaleType === 'point' || scaleType === 'band') {\n      if (config[mark].discreteBandSize !== undefined) {\n        return {\n          value: config[mark].discreteBandSize\n        };\n      }\n\n      if (scaleType === ScaleType.POINT) {\n        var scaleRange = scale.get('range');\n\n        if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n          return {\n            value: scaleRange.step - 2\n          };\n        }\n\n        return {\n          value: DEFAULT_STEP - 2\n        };\n      } else {\n        // BAND\n        return {\n          scale: scaleName,\n          band: band\n        };\n      }\n    } else {\n      // continuous scale\n      return {\n        value: config[mark].continuousBandSize\n      };\n    }\n  } // No Scale\n\n\n  var step = getViewConfigDiscreteStep(config.view, sizeChannel);\n  var value = getFirstDefined( // No scale is like discrete bar (with one item)\n  config[mark].discreteBandSize, step - 2);\n  return value !== undefined ? {\n    value: value\n  } : undefined;\n}\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\n\n\nfunction positionAndSize(mark, fieldDef, channel, model) {\n  var _a;\n\n  var markDef = model.markDef,\n      encoding = model.encoding,\n      config = model.config,\n      stack = model.stack;\n  var orient = markDef.orient;\n  var scaleName = model.scaleName(channel);\n  var scale = model.getScaleComponent(channel);\n  var vgSizeChannel = getSizeChannel(channel);\n  var channel2 = getSecondaryRangeChannel(channel); // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n\n  var useVlSizeChannel = orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x';\n  var sizeFromMarkOrConfig = getMarkPropOrConfig(useVlSizeChannel ? 'size' : vgSizeChannel, markDef, config, {\n    vgChannel: vgSizeChannel\n  }); // Use size encoding / mark property / config if it exists\n\n  var sizeMixins;\n\n  if (encoding.size || sizeFromMarkOrConfig !== undefined) {\n    if (useVlSizeChannel) {\n      sizeMixins = nonPosition('size', model, {\n        vgChannel: vgSizeChannel,\n        defaultValue: sizeFromMarkOrConfig\n      });\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n    }\n  } // Otherwise, apply default value\n\n\n  var band = (_a = isFieldOrDatumDef(fieldDef) ? getBand({\n    channel: channel,\n    fieldDef: fieldDef,\n    markDef: markDef,\n    stack: stack,\n    config: config\n  }) : undefined) !== null && _a !== void 0 ? _a : 1;\n  sizeMixins = sizeMixins || _defineProperty({}, vgSizeChannel, defaultSizeRef(mark, vgSizeChannel, scaleName, scale, config, band));\n  /*\n    Band scales with size value and all point scales, use xc/yc + band=0.5\n       Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n    In this case, size_band is the band specified in the x/y-encoding.\n    By default band is 1, so `(1 - band) / 2` = 0.\n    If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n   */\n\n  var center = (scale === null || scale === void 0 ? void 0 : scale.get('type')) !== 'band' || !('band' in sizeMixins[vgSizeChannel]);\n  var vgChannel = vgAlignedPositionChannel(channel, markDef, config, center ? 'middle' : 'top');\n  var offset = getOffset(channel, markDef);\n  var posRef = ref.midPointRefWithPositionInvalidTest({\n    channel: channel,\n    channelDef: fieldDef,\n    markDef: markDef,\n    config: config,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    offset: offset,\n    defaultRef: pointPositionDefaultRef({\n      model: model,\n      defaultPos: 'mid',\n      channel: channel,\n      scaleName: scaleName,\n      scale: scale\n    }),\n    band: center ? 0.5 : (1 - band) / 2\n  });\n\n  if (vgSizeChannel) {\n    return Object.assign(_defineProperty({}, vgChannel, posRef), sizeMixins);\n  } else {\n    var _ref2;\n\n    // otherwise, we must simulate size by setting position2 = position + size\n    // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n    var vgChannel2 = getVgPositionChannel(channel2);\n    var sizeRef = sizeMixins[vgSizeChannel];\n    var sizeOffset = offset ? Object.assign(Object.assign({}, sizeRef), {\n      offset: offset\n    }) : sizeRef;\n    return _ref2 = {}, _defineProperty(_ref2, vgChannel, posRef), _defineProperty(_ref2, vgChannel2, isArray(posRef) ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), {\n      offset: sizeOffset\n    })] : Object.assign(Object.assign({}, posRef), {\n      offset: sizeOffset\n    })), _ref2;\n  }\n}\n\nfunction getBinSpacing(channel, spacing, reverse, translate, offset) {\n  if (isPolarPositionChannel(channel)) {\n    return 0;\n  }\n\n  var spacingOffset = channel === 'x' || channel === 'y2' ? -spacing / 2 : spacing / 2;\n\n  if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(translate)) {\n    var reverseExpr = signalOrStringValue(reverse);\n    var offsetExpr = signalOrStringValue(offset);\n    var translateExpr = signalOrStringValue(translate);\n    var t = translateExpr ? \"\".concat(translateExpr, \" + \") : '';\n    var r = reverseExpr ? \"(\".concat(reverseExpr, \" ? -1 : 1) * \") : '';\n    var o = offsetExpr ? \"(\".concat(offsetExpr, \" + \").concat(spacingOffset, \")\") : spacingOffset;\n    return {\n      signal: t + r + o\n    };\n  } else {\n    offset = offset || 0;\n    return translate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n  }\n}\n\nexport function rectBinPosition(_ref3) {\n  var fieldDef = _ref3.fieldDef,\n      fieldDef2 = _ref3.fieldDef2,\n      channel = _ref3.channel,\n      band = _ref3.band,\n      scaleName = _ref3.scaleName,\n      markDef = _ref3.markDef,\n      _ref3$spacing = _ref3.spacing,\n      spacing = _ref3$spacing === void 0 ? 0 : _ref3$spacing,\n      axisTranslate = _ref3.axisTranslate,\n      reverse = _ref3.reverse,\n      config = _ref3.config;\n  var channel2 = getSecondaryRangeChannel(channel);\n  var vgChannel = getVgPositionChannel(channel);\n  var vgChannel2 = getVgPositionChannel(channel2);\n  var offset = getOffset(channel, markDef);\n\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    var _ref4;\n\n    return _ref4 = {}, _defineProperty(_ref4, vgChannel2, rectBinRef({\n      channel: channel,\n      fieldDef: fieldDef,\n      scaleName: scaleName,\n      markDef: markDef,\n      band: (1 - band) / 2,\n      offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset),\n      config: config\n    })), _defineProperty(_ref4, vgChannel, rectBinRef({\n      channel: channel,\n      fieldDef: fieldDef,\n      scaleName: scaleName,\n      markDef: markDef,\n      band: 1 - (1 - band) / 2,\n      offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset),\n      config: config\n    })), _ref4;\n  } else if (isBinned(fieldDef.bin)) {\n    var startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, {\n      offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset)\n    });\n\n    if (isFieldDef(fieldDef2)) {\n      var _ref5;\n\n      return _ref5 = {}, _defineProperty(_ref5, vgChannel2, startRef), _defineProperty(_ref5, vgChannel, ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, {\n        offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n      })), _ref5;\n    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n      var _ref6;\n\n      return _ref6 = {}, _defineProperty(_ref6, vgChannel2, startRef), _defineProperty(_ref6, vgChannel, {\n        signal: \"scale(\\\"\".concat(scaleName, \"\\\", \").concat(vgField(fieldDef, {\n          expr: 'datum'\n        }), \" + \").concat(fieldDef.bin.step, \")\"),\n        offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n      }), _ref6;\n    }\n  }\n\n  log.warn(log.message.channelRequiredForBinned(channel2));\n  return undefined;\n}\n/**\n * Value Ref for binned fields\n */\n\nexport function rectBinRef(_ref7) {\n  var channel = _ref7.channel,\n      fieldDef = _ref7.fieldDef,\n      scaleName = _ref7.scaleName,\n      markDef = _ref7.markDef,\n      band = _ref7.band,\n      offset = _ref7.offset,\n      config = _ref7.config;\n  var r = ref.interpolatedSignalRef({\n    scaleName: scaleName,\n    fieldOrDatumDef: fieldDef,\n    band: band,\n    offset: offset\n  });\n  return ref.wrapPositionInvalidTest({\n    fieldDef: fieldDef,\n    channel: channel,\n    markDef: markDef,\n    ref: r,\n    config: config\n  });\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-rect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../../bin';\nimport { getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isPolarPositionChannel, isXorY } from '../../../channel';\nimport { getBand, isFieldDef, isFieldOrDatumDef, vgField } from '../../../channeldef';\nimport { DEFAULT_STEP, getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { hasDiscreteDomain, ScaleType } from '../../../scale';\nimport { getFirstDefined } from '../../../util';\nimport { isSignalRef, isVgRangeStep } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrStringValue } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { getOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPositionDefaultRef } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel, mark) {\n    var _a, _b, _c, _d;\n    const { config, encoding, markDef, stack } = model;\n    const channel2 = getSecondaryRangeChannel(channel);\n    const sizeChannel = getSizeChannel(channel);\n    const channelDef = encoding[channel];\n    const channelDef2 = encoding[channel2];\n    const scale = model.getScaleComponent(channel);\n    const scaleType = scale ? scale.get('type') : undefined;\n    const scaleName = model.scaleName(channel);\n    const orient = markDef.orient;\n    const hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig('size', markDef, config, { vgChannel: sizeChannel });\n    const isBarBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal');\n    // x, x2, and width -- we must specify two of these in all conditions\n    if (isFieldDef(channelDef) &&\n        (isBinning(channelDef.bin) || isBinned(channelDef.bin) || (channelDef.timeUnit && !channelDef2)) &&\n        !hasSizeDef &&\n        !hasDiscreteDomain(scaleType)) {\n        const band = getBand({ channel, fieldDef: channelDef, stack, markDef, config });\n        const axis = (_c = model.component.axes[channel]) === null || _c === void 0 ? void 0 : _c[0];\n        const axisTranslate = (_d = axis === null || axis === void 0 ? void 0 : axis.get('translate')) !== null && _d !== void 0 ? _d : 0.5; // vega default is 0.5\n        return rectBinPosition({\n            fieldDef: channelDef,\n            fieldDef2: channelDef2,\n            channel,\n            markDef,\n            scaleName,\n            band,\n            axisTranslate,\n            spacing: isXorY(channel) ? getMarkPropOrConfig('binSpacing', markDef, config) : undefined,\n            reverse: scale.get('reverse'),\n            config\n        });\n    }\n    else if (((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType)) || isBarBand) && !channelDef2) {\n        return positionAndSize(mark, channelDef, channel, model);\n    }\n    else {\n        return rangePosition(channel, model, { defaultPos: 'zeroOrMax', defaultPos2: 'zeroOrMin' });\n    }\n}\nfunction defaultSizeRef(mark, sizeChannel, scaleName, scale, config, band) {\n    if (scale) {\n        const scaleType = scale.get('type');\n        if (scaleType === 'point' || scaleType === 'band') {\n            if (config[mark].discreteBandSize !== undefined) {\n                return { value: config[mark].discreteBandSize };\n            }\n            if (scaleType === ScaleType.POINT) {\n                const scaleRange = scale.get('range');\n                if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n                    return { value: scaleRange.step - 2 };\n                }\n                return { value: DEFAULT_STEP - 2 };\n            }\n            else {\n                // BAND\n                return { scale: scaleName, band };\n            }\n        }\n        else {\n            // continuous scale\n            return { value: config[mark].continuousBandSize };\n        }\n    }\n    // No Scale\n    const step = getViewConfigDiscreteStep(config.view, sizeChannel);\n    const value = getFirstDefined(\n    // No scale is like discrete bar (with one item)\n    config[mark].discreteBandSize, step - 2);\n    return value !== undefined ? { value } : undefined;\n}\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\nfunction positionAndSize(mark, fieldDef, channel, model) {\n    var _a;\n    const { markDef, encoding, config, stack } = model;\n    const orient = markDef.orient;\n    const scaleName = model.scaleName(channel);\n    const scale = model.getScaleComponent(channel);\n    const vgSizeChannel = getSizeChannel(channel);\n    const channel2 = getSecondaryRangeChannel(channel);\n    // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n    const useVlSizeChannel = (orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x');\n    const sizeFromMarkOrConfig = getMarkPropOrConfig(useVlSizeChannel ? 'size' : vgSizeChannel, markDef, config, {\n        vgChannel: vgSizeChannel\n    });\n    // Use size encoding / mark property / config if it exists\n    let sizeMixins;\n    if (encoding.size || sizeFromMarkOrConfig !== undefined) {\n        if (useVlSizeChannel) {\n            sizeMixins = nonPosition('size', model, { vgChannel: vgSizeChannel, defaultValue: sizeFromMarkOrConfig });\n        }\n        else {\n            log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n        }\n    }\n    // Otherwise, apply default value\n    const band = (_a = (isFieldOrDatumDef(fieldDef) ? getBand({ channel, fieldDef, markDef, stack, config }) : undefined)) !== null && _a !== void 0 ? _a : 1;\n    sizeMixins = sizeMixins || { [vgSizeChannel]: defaultSizeRef(mark, vgSizeChannel, scaleName, scale, config, band) };\n    /*\n      Band scales with size value and all point scales, use xc/yc + band=0.5\n  \n      Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n      In this case, size_band is the band specified in the x/y-encoding.\n      By default band is 1, so `(1 - band) / 2` = 0.\n      If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n     */\n    const center = (scale === null || scale === void 0 ? void 0 : scale.get('type')) !== 'band' || !('band' in sizeMixins[vgSizeChannel]);\n    const vgChannel = vgAlignedPositionChannel(channel, markDef, config, center ? 'middle' : 'top');\n    const offset = getOffset(channel, markDef);\n    const posRef = ref.midPointRefWithPositionInvalidTest({\n        channel,\n        channelDef: fieldDef,\n        markDef,\n        config,\n        scaleName,\n        scale,\n        stack,\n        offset,\n        defaultRef: pointPositionDefaultRef({ model, defaultPos: 'mid', channel, scaleName, scale }),\n        band: center ? 0.5 : (1 - band) / 2\n    });\n    if (vgSizeChannel) {\n        return Object.assign({ [vgChannel]: posRef }, sizeMixins);\n    }\n    else {\n        // otherwise, we must simulate size by setting position2 = position + size\n        // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n        const vgChannel2 = getVgPositionChannel(channel2);\n        const sizeRef = sizeMixins[vgSizeChannel];\n        const sizeOffset = offset ? Object.assign(Object.assign({}, sizeRef), { offset }) : sizeRef;\n        return {\n            [vgChannel]: posRef,\n            // posRef might be an array that wraps position invalid test\n            [vgChannel2]: isArray(posRef)\n                ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), { offset: sizeOffset })]\n                : Object.assign(Object.assign({}, posRef), { offset: sizeOffset })\n        };\n    }\n}\nfunction getBinSpacing(channel, spacing, reverse, translate, offset) {\n    if (isPolarPositionChannel(channel)) {\n        return 0;\n    }\n    const spacingOffset = channel === 'x' || channel === 'y2' ? -spacing / 2 : spacing / 2;\n    if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(translate)) {\n        const reverseExpr = signalOrStringValue(reverse);\n        const offsetExpr = signalOrStringValue(offset);\n        const translateExpr = signalOrStringValue(translate);\n        const t = translateExpr ? `${translateExpr} + ` : '';\n        const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : '';\n        const o = offsetExpr ? `(${offsetExpr} + ${spacingOffset})` : spacingOffset;\n        return {\n            signal: t + r + o\n        };\n    }\n    else {\n        offset = offset || 0;\n        return translate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n    }\n}\nexport function rectBinPosition({ fieldDef, fieldDef2, channel, band, scaleName, markDef, spacing = 0, axisTranslate, reverse, config }) {\n    const channel2 = getSecondaryRangeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    const vgChannel2 = getVgPositionChannel(channel2);\n    const offset = getOffset(channel, markDef);\n    if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n        return {\n            [vgChannel2]: rectBinRef({\n                channel,\n                fieldDef,\n                scaleName,\n                markDef,\n                band: (1 - band) / 2,\n                offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset),\n                config\n            }),\n            [vgChannel]: rectBinRef({\n                channel,\n                fieldDef,\n                scaleName,\n                markDef,\n                band: 1 - (1 - band) / 2,\n                offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset),\n                config\n            })\n        };\n    }\n    else if (isBinned(fieldDef.bin)) {\n        const startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, { offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset) });\n        if (isFieldDef(fieldDef2)) {\n            return {\n                [vgChannel2]: startRef,\n                [vgChannel]: ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, { offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset) })\n            };\n        }\n        else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n            return {\n                [vgChannel2]: startRef,\n                [vgChannel]: {\n                    signal: `scale(\"${scaleName}\", ${vgField(fieldDef, { expr: 'datum' })} + ${fieldDef.bin.step})`,\n                    offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n                }\n            };\n        }\n    }\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n}\n/**\n * Value Ref for binned fields\n */\nexport function rectBinRef({ channel, fieldDef, scaleName, markDef, band, offset, config }) {\n    const r = ref.interpolatedSignalRef({\n        scaleName,\n        fieldOrDatumDef: fieldDef,\n        band,\n        offset\n    });\n    return ref.wrapPositionInvalidTest({\n        fieldDef,\n        channel,\n        markDef,\n        ref: r,\n        config\n    });\n}\n//# sourceMappingURL=position-rect.js.map"]},"metadata":{},"sourceType":"module"}