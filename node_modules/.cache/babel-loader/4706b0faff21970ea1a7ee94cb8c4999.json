{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { TUPLE, unitName } from '.';\nimport { TUPLE_FIELDS } from './transforms/project';\nexport function singleOrMultiSignals(model, selCmpt) {\n  var name = selCmpt.name;\n  var fieldsSg = name + TUPLE_FIELDS;\n  var project = selCmpt.project;\n  var datum = '(item().isVoronoi ? datum.datum : datum)';\n  var values = project.items.map(function (p) {\n    var fieldDef = model.fieldDef(p.channel); // Binned fields should capture extents, for a range test against the raw field.\n\n    return fieldDef && fieldDef.bin ? \"[\".concat(datum, \"[\").concat(stringValue(model.vgField(p.channel, {})), \"], \") + \"\".concat(datum, \"[\").concat(stringValue(model.vgField(p.channel, {\n      binSuffix: 'end'\n    })), \"]]\") : \"\".concat(datum, \"[\").concat(stringValue(p.field), \"]\");\n  }).join(', '); // Only add a discrete selection to the store if a datum is present _and_\n  // the interaction isn't occurring on a group mark. This guards against\n  // polluting interactive state with invalid values in faceted displays\n  // as the group marks are also data-driven. We force the update to account\n  // for constant null states but varying toggles (e.g., shift-click in\n  // whitespace followed by a click in whitespace; the store should only\n  // be cleared on the second click).\n\n  var update = \"unit: \".concat(unitName(model), \", fields: \").concat(fieldsSg, \", values\");\n  var events = selCmpt.events;\n  return [{\n    name: name + TUPLE,\n    on: events ? [{\n      events: events,\n      update: \"datum && item().mark.marktype !== 'group' ? {\".concat(update, \": [\").concat(values, \"]} : null\"),\n      force: true\n    }] : []\n  }];\n}\nvar multi = {\n  signals: singleOrMultiSignals,\n  modifyExpr: function modifyExpr(model, selCmpt) {\n    var tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' + (selCmpt.resolve === 'global' ? 'null' : \"{unit: \".concat(unitName(model), \"}\"));\n  }\n};\nexport default multi;","map":{"version":3,"sources":["../../../../src/compile/selection/multi.ts"],"names":[],"mappings":"AACA,SAAQ,WAAR,QAA0B,WAA1B;AACA,SAA+C,KAA/C,EAAsD,QAAtD,QAAqE,GAArE;AAEA,SAAQ,YAAR,QAA2B,sBAA3B;AAEA,OAAM,SAAU,oBAAV,CAA+B,KAA/B,EAAiD,OAAjD,EAAgG;AACpG,MAAM,IAAI,GAAG,OAAO,CAAC,IAArB;AACA,MAAM,QAAQ,GAAG,IAAI,GAAG,YAAxB;AACA,MAAM,OAAO,GAAG,OAAO,CAAC,OAAxB;AACA,MAAM,KAAK,GAAG,0CAAd;AACA,MAAM,MAAM,GAAG,OAAO,CAAC,KAAR,CACZ,GADY,CACR,UAAA,CAAC,EAAG;AACP,QAAM,QAAQ,GAAG,KAAK,CAAC,QAAN,CAAe,CAAC,CAAC,OAAjB,CAAjB,CADO,CAEP;;AACA,WAAO,QAAQ,IAAI,QAAQ,CAAC,GAArB,GACH,WAAI,KAAJ,cAAa,WAAW,CAAC,KAAK,CAAC,OAAN,CAAc,CAAC,CAAC,OAAhB,EAAyB,EAAzB,CAAD,CAAxB,qBACK,KADL,cACc,WAAW,CAAC,KAAK,CAAC,OAAN,CAAc,CAAC,CAAC,OAAhB,EAAyB;AAAC,MAAA,SAAS,EAAE;AAAZ,KAAzB,CAAD,CADzB,OADG,aAGA,KAHA,cAGS,WAAW,CAAC,CAAC,CAAC,KAAH,CAHpB,MAAP;AAID,GARY,EASZ,IATY,CASP,IATO,CAAf,CALoG,CAgBpG;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAM,MAAM,mBAAY,QAAQ,CAAC,KAAD,CAApB,uBAAwC,QAAxC,aAAZ;AAEA,MAAM,MAAM,GAAa,OAAO,CAAC,MAAjC;AAEA,SAAO,CACL;AACE,IAAA,IAAI,EAAE,IAAI,GAAG,KADf;AAEE,IAAA,EAAE,EAAE,MAAM,GACN,CACE;AACE,MAAA,MAAM,EAAN,MADF;AAEE,MAAA,MAAM,yDAAkD,MAAlD,gBAA8D,MAA9D,cAFR;AAGE,MAAA,KAAK,EAAE;AAHT,KADF,CADM,GAQN;AAVN,GADK,CAAP;AAcD;AAED,IAAM,KAAK,GAA+B;AACxC,EAAA,OAAO,EAAE,oBAD+B;AAGxC,EAAA,UAAU,EAAE,oBAAC,KAAD,EAAQ,OAAR,EAAmB;AAC7B,QAAM,GAAG,GAAG,OAAO,CAAC,IAAR,GAAe,KAA3B;AACA,WAAO,GAAG,GAAG,IAAN,IAAc,OAAO,CAAC,OAAR,KAAoB,QAApB,GAA+B,MAA/B,oBAAkD,QAAQ,CAAC,KAAD,CAA1D,MAAd,CAAP;AACD;AANuC,CAA1C;AASA,eAAe,KAAf","sourceRoot":"","sourcesContent":["import { stringValue } from 'vega-util';\nimport { TUPLE, unitName } from '.';\nimport { TUPLE_FIELDS } from './transforms/project';\nexport function singleOrMultiSignals(model, selCmpt) {\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const project = selCmpt.project;\n    const datum = '(item().isVoronoi ? datum.datum : datum)';\n    const values = project.items\n        .map(p => {\n        const fieldDef = model.fieldDef(p.channel);\n        // Binned fields should capture extents, for a range test against the raw field.\n        return fieldDef && fieldDef.bin\n            ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` +\n                `${datum}[${stringValue(model.vgField(p.channel, { binSuffix: 'end' }))}]]`\n            : `${datum}[${stringValue(p.field)}]`;\n    })\n        .join(', ');\n    // Only add a discrete selection to the store if a datum is present _and_\n    // the interaction isn't occurring on a group mark. This guards against\n    // polluting interactive state with invalid values in faceted displays\n    // as the group marks are also data-driven. We force the update to account\n    // for constant null states but varying toggles (e.g., shift-click in\n    // whitespace followed by a click in whitespace; the store should only\n    // be cleared on the second click).\n    const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n    const events = selCmpt.events;\n    return [\n        {\n            name: name + TUPLE,\n            on: events\n                ? [\n                    {\n                        events,\n                        update: `datum && item().mark.marktype !== 'group' ? {${update}: [${values}]} : null`,\n                        force: true\n                    }\n                ]\n                : []\n        }\n    ];\n}\nconst multi = {\n    signals: singleOrMultiSignals,\n    modifyExpr: (model, selCmpt) => {\n        const tpl = selCmpt.name + TUPLE;\n        return tpl + ', ' + (selCmpt.resolve === 'global' ? 'null' : `{unit: ${unitName(model)}}`);\n    }\n};\nexport default multi;\n//# sourceMappingURL=multi.js.map"]},"metadata":{},"sourceType":"module"}