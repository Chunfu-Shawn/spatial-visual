{"ast":null,"code":"import { log } from '@deck.gl/core';\nexport default class Tile2DHeader {\n  constructor(_ref) {\n    let {\n      x,\n      y,\n      z,\n      onTileLoad,\n      onTileError\n    } = _ref;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.isVisible = false;\n    this.isSelected = false;\n    this.parent = null;\n    this.children = [];\n    this.content = null;\n    this._isLoaded = false;\n    this._isCancelled = false;\n    this.onTileLoad = onTileLoad;\n    this.onTileError = onTileError;\n  }\n\n  get data() {\n    return this._isLoaded ? this.content : this._loader;\n  }\n\n  get isLoaded() {\n    return this._isLoaded;\n  }\n\n  get isLoading() {\n    return Boolean(this._loader);\n  }\n\n  get isCancelled() {\n    return this._isCancelled;\n  }\n\n  get byteLength() {\n    const result = this.content ? this.content.byteLength : 0;\n\n    if (!Number.isFinite(result)) {\n      log.error('byteLength not defined in tile data')();\n    }\n\n    return result;\n  }\n\n  async _loadData(getTileData, requestScheduler) {\n    const {\n      x,\n      y,\n      z,\n      bbox\n    } = this;\n    this._abortController = new AbortController();\n    const {\n      signal\n    } = this._abortController;\n    const requestToken = await requestScheduler.scheduleRequest(this, tile => {\n      return tile.isSelected ? 1 : -1;\n    });\n\n    if (!requestToken) {\n      this._isCancelled = true;\n      return;\n    }\n\n    if (this._isCancelled) {\n      requestToken.done();\n      return;\n    }\n\n    let tileData;\n    let error;\n\n    try {\n      tileData = await getTileData({\n        x,\n        y,\n        z,\n        bbox,\n        signal\n      });\n    } catch (err) {\n      error = err || true;\n    } finally {\n      requestToken.done();\n\n      if (this._isCancelled && !tileData) {\n        this._isLoaded = false;\n      } else {\n        this._isLoaded = true;\n        this._isCancelled = false;\n      }\n    }\n\n    if (!this._isLoaded) {\n      return;\n    }\n\n    if (error) {\n      this.onTileError(error, this);\n    } else {\n      this.content = tileData;\n      this.onTileLoad(this);\n    }\n  }\n\n  loadData(getTileData, requestScheduler) {\n    if (!getTileData) {\n      return;\n    }\n\n    this._isCancelled = false;\n    this._loader = this._loadData(getTileData, requestScheduler);\n\n    this._loader.finally(() => {\n      this._loader = undefined;\n    });\n  }\n\n  abort() {\n    if (this.isLoaded) {\n      return;\n    }\n\n    this._isCancelled = true;\n\n    this._abortController.abort();\n  }\n\n}","map":{"version":3,"sources":["../../../src/tile-layer/tile-2d-header.js"],"names":["constructor","onTileError","data","isLoaded","isLoading","Boolean","isCancelled","byteLength","result","Number","log","_loadData","bbox","signal","requestToken","tile","tileData","getTileData","error","err","loadData","abort"],"mappings":"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","sourcesContent":["/* eslint-env browser */\nimport {log} from '@deck.gl/core';\n\nexport default class Tile2DHeader {\n  constructor({x, y, z, onTileLoad, onTileError}) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.isVisible = false;\n    this.isSelected = false;\n    this.parent = null;\n    this.children = [];\n\n    this.content = null;\n    this._isLoaded = false;\n    this._isCancelled = false;\n\n    this.onTileLoad = onTileLoad;\n    this.onTileError = onTileError;\n  }\n\n  get data() {\n    return this._isLoaded ? this.content : this._loader;\n  }\n\n  get isLoaded() {\n    return this._isLoaded;\n  }\n\n  get isLoading() {\n    return Boolean(this._loader);\n  }\n\n  get isCancelled() {\n    return this._isCancelled;\n  }\n\n  get byteLength() {\n    const result = this.content ? this.content.byteLength : 0;\n    if (!Number.isFinite(result)) {\n      log.error('byteLength not defined in tile data')();\n    }\n    return result;\n  }\n\n  /* eslint-disable max-statements */\n  async _loadData(getTileData, requestScheduler) {\n    const {x, y, z, bbox} = this;\n\n    this._abortController = new AbortController(); // eslint-disable-line no-undef\n    const {signal} = this._abortController;\n\n    const requestToken = await requestScheduler.scheduleRequest(this, tile => {\n      return tile.isSelected ? 1 : -1;\n    });\n\n    if (!requestToken) {\n      this._isCancelled = true;\n      return;\n    }\n    // A tile can be cancelled while being scheduled\n    if (this._isCancelled) {\n      requestToken.done();\n      return;\n    }\n\n    let tileData;\n    let error;\n    try {\n      tileData = await getTileData({x, y, z, bbox, signal});\n    } catch (err) {\n      error = err || true;\n    } finally {\n      requestToken.done();\n\n      if (this._isCancelled && !tileData) {\n        this._isLoaded = false;\n      } else {\n        // Consider it loaded if we tried to cancel but `getTileData` still returned data\n        this._isLoaded = true;\n        this._isCancelled = false;\n      }\n    }\n\n    if (!this._isLoaded) {\n      return;\n    }\n\n    if (error) {\n      this.onTileError(error, this);\n    } else {\n      this.content = tileData;\n      this.onTileLoad(this);\n    }\n  }\n  /* eslint-enable max-statements */\n\n  loadData(getTileData, requestScheduler) {\n    if (!getTileData) {\n      return;\n    }\n\n    this._isCancelled = false;\n    this._loader = this._loadData(getTileData, requestScheduler);\n    this._loader.finally(() => {\n      this._loader = undefined;\n    });\n  }\n\n  abort() {\n    if (this.isLoaded) {\n      return;\n    }\n\n    this._isCancelled = true;\n    this._abortController.abort();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}