{"ast":null,"code":"export function geojsonToBinary(features) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const firstPassData = firstPass(features);\n  return secondPass(features, firstPassData, {\n    coordLength: options.coordLength || firstPassData.coordLength,\n    numericPropKeys: options.numericPropKeys || firstPassData.numericPropKeys,\n    PositionDataType: options.PositionDataType || Float32Array\n  });\n}\nexport const TEST_EXPORTS = {\n  firstPass,\n  secondPass\n};\n\nfunction firstPass(features) {\n  let pointPositionsCount = 0;\n  let pointFeaturesCount = 0;\n  let linePositionsCount = 0;\n  let linePathsCount = 0;\n  let lineFeaturesCount = 0;\n  let polygonPositionsCount = 0;\n  let polygonObjectsCount = 0;\n  let polygonRingsCount = 0;\n  let polygonFeaturesCount = 0;\n  const coordLengths = new Set();\n  const propArrayTypes = {};\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n\n    switch (geometry.type) {\n      case 'Point':\n        pointFeaturesCount++;\n        pointPositionsCount++;\n        coordLengths.add(geometry.coordinates.length);\n        break;\n\n      case 'MultiPoint':\n        pointFeaturesCount++;\n        pointPositionsCount += geometry.coordinates.length;\n\n        for (const point of geometry.coordinates) {\n          coordLengths.add(point.length);\n        }\n\n        break;\n\n      case 'LineString':\n        lineFeaturesCount++;\n        linePositionsCount += geometry.coordinates.length;\n        linePathsCount++;\n\n        for (const coord of geometry.coordinates) {\n          coordLengths.add(coord.length);\n        }\n\n        break;\n\n      case 'MultiLineString':\n        lineFeaturesCount++;\n\n        for (const line of geometry.coordinates) {\n          linePositionsCount += line.length;\n          linePathsCount++;\n\n          for (const coord of line) {\n            coordLengths.add(coord.length);\n          }\n        }\n\n        break;\n\n      case 'Polygon':\n        polygonFeaturesCount++;\n        polygonObjectsCount++;\n        polygonRingsCount += geometry.coordinates.length;\n        polygonPositionsCount += flatten(geometry.coordinates).length;\n\n        for (const coord of flatten(geometry.coordinates)) {\n          coordLengths.add(coord.length);\n        }\n\n        break;\n\n      case 'MultiPolygon':\n        polygonFeaturesCount++;\n\n        for (const polygon of geometry.coordinates) {\n          polygonObjectsCount++;\n          polygonRingsCount += polygon.length;\n          polygonPositionsCount += flatten(polygon).length;\n\n          for (const coord of flatten(polygon)) {\n            coordLengths.add(coord.length);\n          }\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unsupported geometry type: \".concat(geometry.type));\n    }\n\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        const val = feature.properties[key];\n        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n      }\n    }\n  }\n\n  return {\n    coordLength: coordLengths.size > 0 ? Math.max(...coordLengths) : 2,\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount,\n    numericPropKeys: Object.keys(propArrayTypes).filter(k => propArrayTypes[k] !== Array),\n    propArrayTypes\n  };\n}\n\nfunction secondPass(features, firstPassData, options) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    propArrayTypes,\n    polygonFeaturesCount\n  } = firstPassData;\n  const {\n    coordLength,\n    numericPropKeys,\n    PositionDataType = Float32Array\n  } = options;\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points = {\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: Array(),\n    fields: Array()\n  };\n  const lines = {\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: Array(),\n    fields: Array()\n  };\n  const polygons = {\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: Array(),\n    fields: Array()\n  };\n\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys || []) {\n      const TypedArray = propArrayTypes[propName];\n      object.numericProps[propName] = new TypedArray(object.positions.length / coordLength);\n    }\n  }\n\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n        handlePoint(geometry.coordinates, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.pointFeature++;\n        break;\n\n      case 'MultiPoint':\n        handleMultiPoint(geometry.coordinates, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.pointFeature++;\n        break;\n\n      case 'LineString':\n        handleLineString(geometry.coordinates, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.lineFeature++;\n        break;\n\n      case 'MultiLineString':\n        handleMultiLineString(geometry.coordinates, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.lineFeature++;\n        break;\n\n      case 'Polygon':\n        handlePolygon(geometry.coordinates, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.polygonFeature++;\n        break;\n\n      case 'MultiPolygon':\n        handleMultiPolygon(geometry.coordinates, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.polygonFeature++;\n        break;\n\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\nfunction handlePoint(coords, points, indexMap, coordLength, properties) {\n  points.positions.set(coords, indexMap.pointPosition * coordLength);\n  points.globalFeatureIds[indexMap.pointPosition] = indexMap.feature;\n  points.featureIds[indexMap.pointPosition] = indexMap.pointFeature;\n  fillNumericProperties(points, properties, indexMap.pointPosition, 1);\n  indexMap.pointPosition++;\n}\n\nfunction handleMultiPoint(coords, points, indexMap, coordLength, properties) {\n  for (const point of coords) {\n    handlePoint(point, points, indexMap, coordLength, properties);\n  }\n}\n\nfunction handleLineString(coords, lines, indexMap, coordLength, properties) {\n  lines.pathIndices[indexMap.linePath] = indexMap.linePosition;\n  indexMap.linePath++;\n  fillCoords(lines.positions, coords, indexMap.linePosition, coordLength);\n  const nPositions = coords.length;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n  lines.globalFeatureIds.set(new Uint32Array(nPositions).fill(indexMap.feature), indexMap.linePosition);\n  lines.featureIds.set(new Uint32Array(nPositions).fill(indexMap.lineFeature), indexMap.linePosition);\n  indexMap.linePosition += nPositions;\n}\n\nfunction handleMultiLineString(coords, lines, indexMap, coordLength, properties) {\n  for (const line of coords) {\n    handleLineString(line, lines, indexMap, coordLength, properties);\n  }\n}\n\nfunction handlePolygon(coords, polygons, indexMap, coordLength, properties) {\n  polygons.polygonIndices[indexMap.polygonObject] = indexMap.polygonPosition;\n  indexMap.polygonObject++;\n\n  for (const ring of coords) {\n    polygons.primitivePolygonIndices[indexMap.polygonRing] = indexMap.polygonPosition;\n    indexMap.polygonRing++;\n    fillCoords(polygons.positions, ring, indexMap.polygonPosition, coordLength);\n    const nPositions = ring.length;\n    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n    polygons.globalFeatureIds.set(new Uint32Array(nPositions).fill(indexMap.feature), indexMap.polygonPosition);\n    polygons.featureIds.set(new Uint32Array(nPositions).fill(indexMap.polygonFeature), indexMap.polygonPosition);\n    indexMap.polygonPosition += nPositions;\n  }\n}\n\nfunction handleMultiPolygon(coords, polygons, indexMap, coordLength, properties) {\n  for (const polygon of coords) {\n    handlePolygon(polygon, polygons, indexMap, coordLength, properties);\n  }\n}\n\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n  const returnObj = {\n    points: { ...points,\n      positions: {\n        value: points.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: points.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: points.featureIds,\n        size: 1\n      },\n      type: 'Point'\n    },\n    lines: { ...lines,\n      pathIndices: {\n        value: lines.pathIndices,\n        size: 1\n      },\n      positions: {\n        value: lines.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: lines.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: lines.featureIds,\n        size: 1\n      },\n      type: 'LineString'\n    },\n    polygons: { ...polygons,\n      polygonIndices: {\n        value: polygons.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: polygons.primitivePolygonIndices,\n        size: 1\n      },\n      positions: {\n        value: polygons.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: polygons.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: polygons.featureIds,\n        size: 1\n      },\n      type: 'Polygon'\n    }\n  };\n\n  for (const geomType in returnObj) {\n    for (const numericProp in returnObj[geomType].numericProps) {\n      returnObj[geomType].numericProps[numericProp] = {\n        value: returnObj[geomType].numericProps[numericProp],\n        size: 1\n      };\n    }\n  }\n\n  return returnObj;\n}\n\nfunction fillNumericProperties(object, properties, index, length) {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      object.numericProps[numericPropName].set(new Array(length).fill(properties[numericPropName]), index);\n    }\n  }\n}\n\nfunction keepStringProperties(properties, numericKeys) {\n  const props = {};\n\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n\n  return props;\n}\n\nfunction fillCoords(array, coords, startVertex, coordLength) {\n  let index = startVertex * coordLength;\n\n  for (const coord of coords) {\n    array.set(coord, index);\n    index += coordLength;\n  }\n}\n\nfunction flatten(arrays) {\n  return [].concat(...arrays);\n}\n\nfunction deduceArrayType(x, constructor) {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}","map":{"version":3,"sources":["../../../src/lib/geojson-to-binary.ts"],"names":["options","firstPassData","firstPass","secondPass","coordLength","numericPropKeys","PositionDataType","Float32Array","TEST_EXPORTS","pointPositionsCount","pointFeaturesCount","linePositionsCount","linePathsCount","lineFeaturesCount","polygonPositionsCount","polygonObjectsCount","polygonRingsCount","polygonFeaturesCount","coordLengths","propArrayTypes","geometry","feature","point","coord","line","flatten","polygon","val","deduceArrayType","Math","Object","k","GlobalFeatureIdsDataType","features","points","positions","globalFeatureIds","featureIds","numericProps","properties","Array","fields","lines","pathIndices","polygons","polygonIndices","primitivePolygonIndices","TypedArray","object","indexMap","pointPosition","pointFeature","linePosition","linePath","lineFeature","polygonPosition","polygonObject","polygonRing","polygonFeature","handlePoint","keepStringProperties","handleMultiPoint","handleLineString","handleMultiLineString","handlePolygon","handleMultiPolygon","makeAccessorObjects","fillNumericProperties","fillCoords","nPositions","coords","ring","returnObj","value","size","type","numericPropName","props","numericKeys","index","startVertex","array","constructor","Number"],"mappings":"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","sourcesContent":["import {Feature, GeoJsonProperties} from '@loaders.gl/schema';\nimport type {BinaryFeatures} from '@loaders.gl/schema';\n\nexport type GeojsonToBinaryOptions = {\n  coordLength?: number;\n  numericPropKeys?: string[];\n  PositionDataType?: Function;\n};\n\n/** Convert GeoJSON features to flat binary arrays */\nexport function geojsonToBinary(\n  features: Feature[],\n  options: GeojsonToBinaryOptions = {}\n): BinaryFeatures {\n  const firstPassData = firstPass(features);\n  return secondPass(features, firstPassData, {\n    coordLength: options.coordLength || firstPassData.coordLength,\n    numericPropKeys: options.numericPropKeys || firstPassData.numericPropKeys,\n    PositionDataType: options.PositionDataType || Float32Array\n  });\n}\n\nexport const TEST_EXPORTS = {\n  firstPass,\n  secondPass\n};\n\ntype PropArrayConstructor = Float32ArrayConstructor | Float64ArrayConstructor | ArrayConstructor;\n\ntype FirstPassData = {\n  coordLength: number;\n  numericPropKeys: string[];\n  propArrayTypes: {[key: string]: PropArrayConstructor};\n\n  pointPositionsCount: number;\n  pointFeaturesCount: number;\n  linePositionsCount: number;\n  linePathsCount: number;\n  lineFeaturesCount: number;\n  polygonPositionsCount: number;\n  polygonObjectsCount: number;\n  polygonRingsCount: number;\n  polygonFeaturesCount: number;\n};\n\n/**\n *  Initial scan over GeoJSON features\n *  Counts number of coordinates of each geometry type and\n *  keeps track of the max coordinate dimensions\n */\n// eslint-disable-next-line complexity, max-statements\nfunction firstPass(features: Feature[]): FirstPassData {\n  // Counts the number of _positions_, so [x, y, z] counts as one\n  let pointPositionsCount = 0;\n  let pointFeaturesCount = 0;\n  let linePositionsCount = 0;\n  let linePathsCount = 0;\n  let lineFeaturesCount = 0;\n  let polygonPositionsCount = 0;\n  let polygonObjectsCount = 0;\n  let polygonRingsCount = 0;\n  let polygonFeaturesCount = 0;\n  const coordLengths = new Set<number>();\n  const propArrayTypes = {};\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    switch (geometry.type) {\n      case 'Point':\n        pointFeaturesCount++;\n        pointPositionsCount++;\n        coordLengths.add(geometry.coordinates.length);\n        break;\n      case 'MultiPoint':\n        pointFeaturesCount++;\n        pointPositionsCount += geometry.coordinates.length;\n        for (const point of geometry.coordinates) {\n          coordLengths.add(point.length);\n        }\n        break;\n      case 'LineString':\n        lineFeaturesCount++;\n        linePositionsCount += geometry.coordinates.length;\n        linePathsCount++;\n\n        for (const coord of geometry.coordinates) {\n          coordLengths.add(coord.length);\n        }\n        break;\n      case 'MultiLineString':\n        lineFeaturesCount++;\n        for (const line of geometry.coordinates) {\n          linePositionsCount += line.length;\n          linePathsCount++;\n\n          // eslint-disable-next-line max-depth\n          for (const coord of line) {\n            coordLengths.add(coord.length);\n          }\n        }\n        break;\n      case 'Polygon':\n        polygonFeaturesCount++;\n        polygonObjectsCount++;\n        polygonRingsCount += geometry.coordinates.length;\n        polygonPositionsCount += flatten(geometry.coordinates).length;\n\n        for (const coord of flatten(geometry.coordinates)) {\n          coordLengths.add(coord.length);\n        }\n        break;\n      case 'MultiPolygon':\n        polygonFeaturesCount++;\n        for (const polygon of geometry.coordinates) {\n          polygonObjectsCount++;\n          polygonRingsCount += polygon.length;\n          polygonPositionsCount += flatten(polygon).length;\n\n          // eslint-disable-next-line max-depth\n          for (const coord of flatten(polygon)) {\n            coordLengths.add(coord.length);\n          }\n        }\n        break;\n      default:\n        throw new Error(`Unsupported geometry type: ${geometry.type}`);\n    }\n\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        const val = feature.properties[key];\n\n        // If property has not been seen before, or if property has been numeric\n        // in all previous features, check if numeric in this feature\n        // If not numeric, Array is stored to prevent rechecking in the future\n        // Additionally, detects if 64 bit precision is required\n        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n      }\n    }\n  }\n\n  return {\n    coordLength: coordLengths.size > 0 ? Math.max(...coordLengths) : 2,\n\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount,\n\n    // Array of keys whose values are always numeric\n    numericPropKeys: Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array),\n    propArrayTypes\n  };\n}\n\n/**\n * Second scan over GeoJSON features\n * Fills coordinates into pre-allocated typed arrays\n */\n// eslint-disable-next-line complexity\nfunction secondPass(\n  features,\n  firstPassData: FirstPassData,\n  options: Required<GeojsonToBinaryOptions>\n) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    propArrayTypes,\n    polygonFeaturesCount\n  } = firstPassData;\n  const {coordLength, numericPropKeys, PositionDataType = Float32Array} = options;\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points = {\n    // @ts-ignore Typescript doesn't like dynamic constructors\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds:\n      pointFeaturesCount > 65535\n        ? new Uint32Array(pointPositionsCount)\n        : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: Array<any>(),\n    fields: Array<any>()\n  };\n  const lines = {\n    // @ts-ignore Typescript doesn't like dynamic constructors\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    pathIndices:\n      linePositionsCount > 65535\n        ? new Uint32Array(linePathsCount + 1)\n        : new Uint16Array(linePathsCount + 1),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds:\n      lineFeaturesCount > 65535\n        ? new Uint32Array(linePositionsCount)\n        : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: Array<any>(),\n    fields: Array<any>()\n  };\n  const polygons = {\n    // @ts-ignore Typescript doesn't like dynamic constructors\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    polygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonObjectsCount + 1)\n        : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonRingsCount + 1)\n        : new Uint16Array(polygonRingsCount + 1),\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds:\n      polygonFeaturesCount > 65535\n        ? new Uint32Array(polygonPositionsCount)\n        : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: Array<any>(),\n    fields: Array<any>()\n  };\n\n  // Instantiate numeric properties arrays; one value per vertex\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys || []) {\n      // If property has been numeric in all previous features in which the property existed, check\n      // if numeric in this feature\n      const TypedArray = propArrayTypes[propName];\n      object.numericProps[propName] = new TypedArray(object.positions.length / coordLength);\n    }\n  }\n\n  // Set last element of path/polygon indices as positions length\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties: GeoJsonProperties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n        handlePoint(geometry.coordinates, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.pointFeature++;\n        break;\n      case 'MultiPoint':\n        handleMultiPoint(geometry.coordinates, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.pointFeature++;\n        break;\n      case 'LineString':\n        handleLineString(geometry.coordinates, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.lineFeature++;\n        break;\n      case 'MultiLineString':\n        handleMultiLineString(geometry.coordinates, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.lineFeature++;\n        break;\n      case 'Polygon':\n        handlePolygon(geometry.coordinates, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.polygonFeature++;\n        break;\n      case 'MultiPolygon':\n        handleMultiPolygon(geometry.coordinates, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.polygonFeature++;\n        break;\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  // Wrap each array in an accessor object with value and size keys\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\n/** Fills Point coordinates into points object of arrays */\nfunction handlePoint(coords, points, indexMap, coordLength, properties) {\n  points.positions.set(coords, indexMap.pointPosition * coordLength);\n  points.globalFeatureIds[indexMap.pointPosition] = indexMap.feature;\n  points.featureIds[indexMap.pointPosition] = indexMap.pointFeature;\n\n  fillNumericProperties(points, properties, indexMap.pointPosition, 1);\n  indexMap.pointPosition++;\n}\n\n/** Fills MultiPoint coordinates into points object of arrays */\nfunction handleMultiPoint(coords, points, indexMap, coordLength, properties) {\n  for (const point of coords) {\n    handlePoint(point, points, indexMap, coordLength, properties);\n  }\n}\n\n/** Fills LineString coordinates into lines object of arrays */\nfunction handleLineString(coords, lines, indexMap, coordLength, properties) {\n  lines.pathIndices[indexMap.linePath] = indexMap.linePosition;\n  indexMap.linePath++;\n\n  fillCoords(lines.positions, coords, indexMap.linePosition, coordLength);\n\n  const nPositions = coords.length;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n\n  lines.globalFeatureIds.set(\n    new Uint32Array(nPositions).fill(indexMap.feature),\n    indexMap.linePosition\n  );\n  lines.featureIds.set(\n    new Uint32Array(nPositions).fill(indexMap.lineFeature),\n    indexMap.linePosition\n  );\n  indexMap.linePosition += nPositions;\n}\n\n/** Fills MultiLineString coordinates into lines object of arrays */\nfunction handleMultiLineString(coords, lines, indexMap, coordLength, properties) {\n  for (const line of coords) {\n    handleLineString(line, lines, indexMap, coordLength, properties);\n  }\n}\n\n/** Fills Polygon coordinates into polygons object of arrays */\nfunction handlePolygon(coords, polygons, indexMap, coordLength, properties) {\n  polygons.polygonIndices[indexMap.polygonObject] = indexMap.polygonPosition;\n  indexMap.polygonObject++;\n\n  for (const ring of coords) {\n    polygons.primitivePolygonIndices[indexMap.polygonRing] = indexMap.polygonPosition;\n    indexMap.polygonRing++;\n\n    fillCoords(polygons.positions, ring, indexMap.polygonPosition, coordLength);\n\n    const nPositions = ring.length;\n    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n\n    polygons.globalFeatureIds.set(\n      new Uint32Array(nPositions).fill(indexMap.feature),\n      indexMap.polygonPosition\n    );\n    polygons.featureIds.set(\n      new Uint32Array(nPositions).fill(indexMap.polygonFeature),\n      indexMap.polygonPosition\n    );\n    indexMap.polygonPosition += nPositions;\n  }\n}\n\n/** Fills MultiPolygon coordinates into polygons object of arrays */\nfunction handleMultiPolygon(coords, polygons, indexMap, coordLength, properties) {\n  for (const polygon of coords) {\n    handlePolygon(polygon, polygons, indexMap, coordLength, properties);\n  }\n}\n\n/** Wrap each array in an accessor object with value and size keys */\nfunction makeAccessorObjects(points, lines, polygons, coordLength): BinaryFeatures {\n  const returnObj = {\n    points: {\n      ...points,\n      positions: {value: points.positions, size: coordLength},\n      globalFeatureIds: {value: points.globalFeatureIds, size: 1},\n      featureIds: {value: points.featureIds, size: 1},\n      type: 'Point'\n    },\n    lines: {\n      ...lines,\n      pathIndices: {value: lines.pathIndices, size: 1},\n      positions: {value: lines.positions, size: coordLength},\n      globalFeatureIds: {value: lines.globalFeatureIds, size: 1},\n      featureIds: {value: lines.featureIds, size: 1},\n      type: 'LineString'\n    },\n    polygons: {\n      ...polygons,\n      polygonIndices: {value: polygons.polygonIndices, size: 1},\n      primitivePolygonIndices: {value: polygons.primitivePolygonIndices, size: 1},\n      positions: {value: polygons.positions, size: coordLength},\n      globalFeatureIds: {value: polygons.globalFeatureIds, size: 1},\n      featureIds: {value: polygons.featureIds, size: 1},\n      type: 'Polygon'\n    }\n  };\n\n  for (const geomType in returnObj) {\n    for (const numericProp in returnObj[geomType].numericProps) {\n      returnObj[geomType].numericProps[numericProp] = {\n        value: returnObj[geomType].numericProps[numericProp],\n        size: 1\n      };\n    }\n  }\n\n  return returnObj as unknown as BinaryFeatures;\n}\n\n/** Add numeric properties to object */\nfunction fillNumericProperties(object, properties, index, length) {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      object.numericProps[numericPropName].set(\n        new Array(length).fill(properties[numericPropName]),\n        index\n      );\n    }\n  }\n}\n\n/** Keep string properties in object */\nfunction keepStringProperties(properties, numericKeys: string[]): GeoJsonProperties {\n  const props = {};\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n  return props;\n}\n\n/** @param coords is expected to be a list of arrays, each with length 2-3 */\nfunction fillCoords(array, coords, startVertex, coordLength): void {\n  let index = startVertex * coordLength;\n  for (const coord of coords) {\n    array.set(coord, index);\n    index += coordLength;\n  }\n}\n\n// TODO - how does this work? Different `coordinates` have different nesting\nfunction flatten(arrays): number[][] {\n  return [].concat(...arrays);\n}\n\nfunction deduceArrayType(x: any, constructor: PropArrayConstructor): PropArrayConstructor {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n\n  // If this or previous value required 64bits use Float64Array\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}\n"]},"metadata":{},"sourceType":"module"}