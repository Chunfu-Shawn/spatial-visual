{"ast":null,"code":"import _defineProperty from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isArray, isBoolean, isNumber, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, isCountingAggregateOp } from './aggregate';\nimport { autoMaxBins, binToString, isBinned, isBinning } from './bin';\nimport { ANGLE, COLOR, COLUMN, DESCRIPTION, DETAIL, FACET, FILL, FILLOPACITY, HREF, isScaleChannel, isSecondaryRangeChannel, isXorY, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, TEXT, THETA, THETA2, TOOLTIP, URL, X, X2, Y, Y2 } from './channel';\nimport { getMarkConfig } from './compile/common';\nimport { isCustomFormatType } from './compile/format';\nimport { dateTimeToExpr, isDateTime } from './datetime';\nimport { isExprRef } from './expr';\nimport * as log from './log';\nimport { isRectBasedMark } from './mark';\nimport { SCALE_CATEGORY_INDEX } from './scale';\nimport { isSortByChannel } from './sort';\nimport { isFacetFieldDef } from './spec/facet';\nimport { getTimeUnitParts, isLocalSingleTimeUnit, normalizeTimeUnit, timeUnitToString } from './timeunit';\nimport { getFullName, QUANTITATIVE } from './type';\nimport { contains, flatAccessWithDatum, getFirstDefined, internalField, omit, removePathFromField, replacePathInField, titleCase } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isConditionalSelection(c) {\n  return c['selection'];\n}\nexport function isRepeatRef(field) {\n  return field && !isString(field) && 'repeat' in field;\n}\nexport function toFieldDefBase(fieldDef) {\n  var field = fieldDef.field,\n      timeUnit = fieldDef.timeUnit,\n      bin = fieldDef.bin,\n      aggregate = fieldDef.aggregate;\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, timeUnit ? {\n    timeUnit: timeUnit\n  } : {}), bin ? {\n    bin: bin\n  } : {}), aggregate ? {\n    aggregate: aggregate\n  } : {}), {\n    field: field\n  });\n}\nexport function isSortableFieldDef(fieldDef) {\n  return 'sort' in fieldDef;\n}\nexport function getBand(_ref) {\n  var channel = _ref.channel,\n      fieldDef = _ref.fieldDef,\n      fieldDef2 = _ref.fieldDef2,\n      mark = _ref.markDef,\n      stack = _ref.stack,\n      config = _ref.config,\n      isMidPoint = _ref.isMidPoint;\n\n  if (isFieldOrDatumDef(fieldDef) && fieldDef.band !== undefined) {\n    return fieldDef.band;\n  }\n\n  if (isFieldDef(fieldDef)) {\n    var timeUnit = fieldDef.timeUnit,\n        bin = fieldDef.bin;\n\n    if (timeUnit && !fieldDef2) {\n      if (isMidPoint) {\n        return getMarkConfig('timeUnitBandPosition', mark, config);\n      } else {\n        return isRectBasedMark(mark.type) ? getMarkConfig('timeUnitBand', mark, config) : 0;\n      }\n    } else if (isBinning(bin)) {\n      return isRectBasedMark(mark.type) && !isMidPoint ? 1 : 0.5;\n    }\n  }\n\n  if ((stack === null || stack === void 0 ? void 0 : stack.fieldChannel) === channel && isMidPoint) {\n    return 0.5;\n  }\n\n  return undefined;\n}\nexport function hasBand(channel, fieldDef, fieldDef2, stack, markDef, config) {\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === 'temporal') {\n    return !!getBand({\n      channel: channel,\n      fieldDef: fieldDef,\n      fieldDef2: fieldDef2,\n      stack: stack,\n      markDef: markDef,\n      config: config\n    });\n  }\n\n  return false;\n}\nexport function isConditionalDef(channelDef) {\n  return !!channelDef && 'condition' in channelDef;\n}\n/**\n * Return if a channelDef is a ConditionalValueDef with ConditionFieldDef\n */\n\nexport function hasConditionalFieldDef(channelDef) {\n  var condition = channelDef && channelDef['condition'];\n  return !!condition && !isArray(condition) && isFieldDef(condition);\n}\nexport function hasConditionalFieldOrDatumDef(channelDef) {\n  var condition = channelDef && channelDef['condition'];\n  return !!condition && !isArray(condition) && isFieldOrDatumDef(condition);\n}\nexport function hasConditionalValueDef(channelDef) {\n  var condition = channelDef && channelDef['condition'];\n  return !!condition && (isArray(condition) || isValueDef(condition));\n}\nexport function isFieldDef(channelDef) {\n  // TODO: we can't use field in channelDef here as it's somehow failing runtime test\n  return !!channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\nexport function channelDefType(channelDef) {\n  return channelDef && channelDef['type'];\n}\nexport function isDatumDef(channelDef) {\n  return !!channelDef && 'datum' in channelDef;\n}\nexport function isContinuousFieldOrDatumDef(cd) {\n  // TODO: make datum support DateTime object\n  return isTypedFieldDef(cd) && isContinuous(cd) || isNumericDataDef(cd);\n}\nexport function isQuantitativeFieldOrDatumDef(cd) {\n  // TODO: make datum support DateTime object\n  return channelDefType(cd) === 'quantitative' || isNumericDataDef(cd);\n}\nexport function isNumericDataDef(cd) {\n  return isDatumDef(cd) && isNumber(cd.datum);\n}\nexport function isFieldOrDatumDef(channelDef) {\n  return isFieldDef(channelDef) || isDatumDef(channelDef);\n}\nexport function isTypedFieldDef(channelDef) {\n  return !!channelDef && ('field' in channelDef || channelDef['aggregate'] === 'count') && 'type' in channelDef;\n}\nexport function isValueDef(channelDef) {\n  return channelDef && 'value' in channelDef && 'value' in channelDef;\n}\nexport function isScaleFieldDef(channelDef) {\n  return !!channelDef && ('scale' in channelDef || 'sort' in channelDef);\n}\nexport function isPositionFieldOrDatumDef(channelDef) {\n  return channelDef && ('axis' in channelDef || 'stack' in channelDef || 'impute' in channelDef);\n}\nexport function isMarkPropFieldOrDatumDef(channelDef) {\n  return !!channelDef && 'legend' in channelDef;\n}\nexport function isStringFieldOrDatumDef(channelDef) {\n  return !!channelDef && ('format' in channelDef || 'formatType' in channelDef);\n}\nexport function toStringFieldDef(fieldDef) {\n  // omit properties that don't exist in string field defs\n  return omit(fieldDef, ['legend', 'axis', 'header', 'scale']);\n}\n\nfunction isOpFieldDef(fieldDef) {\n  return 'op' in fieldDef;\n}\n/**\n * Get a Vega field reference from a Vega-Lite field def.\n */\n\n\nexport function vgField(fieldDef) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a, _b, _c;\n\n  var field = fieldDef.field;\n  var prefix = opt.prefix;\n  var suffix = opt.suffix;\n  var argAccessor = ''; // for accessing argmin/argmax field at the end without getting escaped\n\n  if (isCount(fieldDef)) {\n    field = internalField('count');\n  } else {\n    var fn;\n\n    if (!opt.nofn) {\n      if (isOpFieldDef(fieldDef)) {\n        fn = fieldDef.op;\n      } else {\n        var bin = fieldDef.bin,\n            aggregate = fieldDef.aggregate,\n            timeUnit = fieldDef.timeUnit;\n\n        if (isBinning(bin)) {\n          fn = binToString(bin);\n          suffix = ((_a = opt.binSuffix) !== null && _a !== void 0 ? _a : '') + ((_b = opt.suffix) !== null && _b !== void 0 ? _b : '');\n        } else if (aggregate) {\n          if (isArgmaxDef(aggregate)) {\n            argAccessor = \"[\\\"\".concat(field, \"\\\"]\");\n            field = \"argmax_\".concat(aggregate.argmax);\n          } else if (isArgminDef(aggregate)) {\n            argAccessor = \"[\\\"\".concat(field, \"\\\"]\");\n            field = \"argmin_\".concat(aggregate.argmin);\n          } else {\n            fn = String(aggregate);\n          }\n        } else if (timeUnit) {\n          fn = timeUnitToString(timeUnit);\n          suffix = (!contains(['range', 'mid'], opt.binSuffix) && opt.binSuffix || '') + ((_c = opt.suffix) !== null && _c !== void 0 ? _c : '');\n        }\n      }\n    }\n\n    if (fn) {\n      field = field ? \"\".concat(fn, \"_\").concat(field) : fn;\n    }\n  }\n\n  if (suffix) {\n    field = \"\".concat(field, \"_\").concat(suffix);\n  }\n\n  if (prefix) {\n    field = \"\".concat(prefix, \"_\").concat(field);\n  }\n\n  if (opt.forAs) {\n    return removePathFromField(field);\n  } else if (opt.expr) {\n    // Expression to access flattened field. No need to escape dots.\n    return flatAccessWithDatum(field, opt.expr) + argAccessor;\n  } else {\n    // We flattened all fields so paths should have become dot.\n    return replacePathInField(field) + argAccessor;\n  }\n}\nexport function isDiscrete(def) {\n  switch (def.type) {\n    case 'nominal':\n    case 'ordinal':\n    case 'geojson':\n      return true;\n\n    case 'quantitative':\n      return isFieldDef(def) && !!def.bin;\n\n    case 'temporal':\n      return false;\n  }\n\n  throw new Error(log.message.invalidFieldType(def.type));\n}\nexport function isContinuous(fieldDef) {\n  return !isDiscrete(fieldDef);\n}\nexport function isCount(fieldDef) {\n  return fieldDef.aggregate === 'count';\n}\nexport function verbalTitleFormatter(fieldDef, config) {\n  var _a;\n\n  var field = fieldDef.field,\n      bin = fieldDef.bin,\n      timeUnit = fieldDef.timeUnit,\n      aggregate = fieldDef.aggregate;\n\n  if (aggregate === 'count') {\n    return config.countTitle;\n  } else if (isBinning(bin)) {\n    return \"\".concat(field, \" (binned)\");\n  } else if (timeUnit) {\n    var unit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n\n    if (unit) {\n      return \"\".concat(field, \" (\").concat(getTimeUnitParts(unit).join('-'), \")\");\n    }\n  } else if (aggregate) {\n    if (isArgmaxDef(aggregate)) {\n      return \"\".concat(field, \" for max \").concat(aggregate.argmax);\n    } else if (isArgminDef(aggregate)) {\n      return \"\".concat(field, \" for min \").concat(aggregate.argmin);\n    } else {\n      return \"\".concat(titleCase(aggregate), \" of \").concat(field);\n    }\n  }\n\n  return field;\n}\nexport function functionalTitleFormatter(fieldDef) {\n  var aggregate = fieldDef.aggregate,\n      bin = fieldDef.bin,\n      timeUnit = fieldDef.timeUnit,\n      field = fieldDef.field;\n\n  if (isArgmaxDef(aggregate)) {\n    return \"\".concat(field, \" for argmax(\").concat(aggregate.argmax, \")\");\n  } else if (isArgminDef(aggregate)) {\n    return \"\".concat(field, \" for argmin(\").concat(aggregate.argmin, \")\");\n  }\n\n  var timeUnitParams = normalizeTimeUnit(timeUnit);\n  var fn = aggregate || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.unit) || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.maxbins) && 'timeunit' || isBinning(bin) && 'bin';\n\n  if (fn) {\n    return fn.toUpperCase() + '(' + field + ')';\n  } else {\n    return field;\n  }\n}\nexport var defaultTitleFormatter = function defaultTitleFormatter(fieldDef, config) {\n  switch (config.fieldTitle) {\n    case 'plain':\n      return fieldDef.field;\n\n    case 'functional':\n      return functionalTitleFormatter(fieldDef);\n\n    default:\n      return verbalTitleFormatter(fieldDef, config);\n  }\n};\nvar titleFormatter = defaultTitleFormatter;\nexport function setTitleFormatter(formatter) {\n  titleFormatter = formatter;\n}\nexport function resetTitleFormatter() {\n  setTitleFormatter(defaultTitleFormatter);\n}\nexport function title(fieldOrDatumDef, config, _ref2) {\n  var allowDisabling = _ref2.allowDisabling,\n      _ref2$includeDefault = _ref2.includeDefault,\n      includeDefault = _ref2$includeDefault === void 0 ? true : _ref2$includeDefault;\n\n  var _a, _b;\n\n  var guideTitle = (_a = getGuide(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.title;\n\n  if (!isFieldDef(fieldOrDatumDef)) {\n    return guideTitle;\n  }\n\n  var fieldDef = fieldOrDatumDef;\n  var def = includeDefault ? defaultTitle(fieldDef, config) : undefined;\n\n  if (allowDisabling) {\n    return getFirstDefined(guideTitle, fieldDef.title, def);\n  } else {\n    return (_b = guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldDef.title) !== null && _b !== void 0 ? _b : def;\n  }\n}\nexport function getGuide(fieldDef) {\n  if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {\n    return fieldDef.axis;\n  } else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {\n    return fieldDef.legend;\n  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {\n    return fieldDef.header;\n  }\n\n  return undefined;\n}\nexport function defaultTitle(fieldDef, config) {\n  return titleFormatter(fieldDef, config);\n}\nexport function getFormatMixins(fieldDef) {\n  var _a;\n\n  if (isStringFieldOrDatumDef(fieldDef)) {\n    var format = fieldDef.format,\n        formatType = fieldDef.formatType;\n    return {\n      format: format,\n      formatType: formatType\n    };\n  } else {\n    var guide = (_a = getGuide(fieldDef)) !== null && _a !== void 0 ? _a : {};\n    var _format = guide.format,\n        _formatType = guide.formatType;\n    return {\n      format: _format,\n      formatType: _formatType\n    };\n  }\n}\nexport function defaultType(fieldDef, channel) {\n  var _a;\n\n  switch (channel) {\n    case 'latitude':\n    case 'longitude':\n      return 'quantitative';\n\n    case 'row':\n    case 'column':\n    case 'facet':\n    case 'shape':\n    case 'strokeDash':\n      return 'nominal';\n\n    case 'order':\n      return 'ordinal';\n  }\n\n  if (isSortableFieldDef(fieldDef) && isArray(fieldDef.sort)) {\n    return 'ordinal';\n  }\n\n  var aggregate = fieldDef.aggregate,\n      bin = fieldDef.bin,\n      timeUnit = fieldDef.timeUnit;\n\n  if (timeUnit) {\n    return 'temporal';\n  }\n\n  if (bin || aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n    return 'quantitative';\n  }\n\n  if (isScaleFieldDef(fieldDef) && ((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.type)) {\n    switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {\n      case 'numeric':\n      case 'discretizing':\n        return 'quantitative';\n\n      case 'time':\n        return 'temporal';\n    }\n  }\n\n  return 'nominal';\n}\n/**\n * Returns the fieldDef -- either from the outer channelDef or from the condition of channelDef.\n * @param channelDef\n */\n\nexport function getFieldDef(channelDef) {\n  if (isFieldDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldDef(channelDef)) {\n    return channelDef.condition;\n  }\n\n  return undefined;\n}\nexport function getFieldOrDatumDef(channelDef) {\n  if (isFieldOrDatumDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n    return channelDef.condition;\n  }\n\n  return undefined;\n}\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\n\nexport function initChannelDef(channelDef, channel, config) {\n  var opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (isString(channelDef) || isNumber(channelDef) || isBoolean(channelDef)) {\n    var primitiveType = isString(channelDef) ? 'string' : isNumber(channelDef) ? 'number' : 'boolean';\n    log.warn(log.message.primitiveChannelDef(channel, primitiveType, channelDef));\n    return {\n      value: channelDef\n    };\n  } // If a fieldDef contains a field, we need type.\n\n\n  if (isFieldOrDatumDef(channelDef)) {\n    return initFieldOrDatumDef(channelDef, channel, config, opt);\n  } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n    return Object.assign(Object.assign({}, channelDef), {\n      // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>\n      condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt)\n    });\n  }\n\n  return channelDef;\n}\nexport function initFieldOrDatumDef(fd, channel, config, opt) {\n  if (isStringFieldOrDatumDef(fd)) {\n    var format = fd.format,\n        formatType = fd.formatType,\n        rest = __rest(fd, [\"format\", \"formatType\"]);\n\n    if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n      log.warn(log.message.customFormatTypeNotAllowed(channel));\n      return initFieldOrDatumDef(rest, channel, config, opt);\n    }\n  } else {\n    var guideType = isPositionFieldOrDatumDef(fd) ? 'axis' : isMarkPropFieldOrDatumDef(fd) ? 'legend' : isFacetFieldDef(fd) ? 'header' : null;\n\n    if (guideType && fd[guideType]) {\n      var _a = fd[guideType],\n          _format2 = _a.format,\n          _formatType2 = _a.formatType,\n          newGuide = __rest(_a, [\"format\", \"formatType\"]);\n\n      if (isCustomFormatType(_formatType2) && !config.customFormatTypes) {\n        log.warn(log.message.customFormatTypeNotAllowed(channel));\n        return initFieldOrDatumDef(Object.assign(Object.assign({}, fd), _defineProperty({}, guideType, newGuide)), channel, config, opt);\n      }\n    }\n  }\n\n  if (isFieldDef(fd)) {\n    return initFieldDef(fd, channel, opt);\n  }\n\n  return initDatumDef(fd);\n}\n\nfunction initDatumDef(datumDef) {\n  var type = datumDef['type'];\n\n  if (type) {\n    return datumDef;\n  }\n\n  var datum = datumDef.datum;\n  type = isNumber(datum) ? 'quantitative' : isString(datum) ? 'nominal' : isDateTime(datum) ? 'temporal' : undefined;\n  return Object.assign(Object.assign({}, datumDef), {\n    type: type\n  });\n}\n\nexport function initFieldDef(fd, channel) {\n  var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref3$compositeMark = _ref3.compositeMark,\n      compositeMark = _ref3$compositeMark === void 0 ? false : _ref3$compositeMark;\n\n  var aggregate = fd.aggregate,\n      timeUnit = fd.timeUnit,\n      bin = fd.bin,\n      field = fd.field;\n  var fieldDef = Object.assign({}, fd); // Drop invalid aggregate\n\n  if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n    log.warn(log.message.invalidAggregate(aggregate));\n    delete fieldDef.aggregate;\n  } // Normalize Time Unit\n\n\n  if (timeUnit) {\n    fieldDef.timeUnit = normalizeTimeUnit(timeUnit);\n  }\n\n  if (field) {\n    fieldDef.field = \"\".concat(field);\n  } // Normalize bin\n\n\n  if (isBinning(bin)) {\n    fieldDef.bin = normalizeBin(bin, channel);\n  }\n\n  if (isBinned(bin) && !isXorY(channel)) {\n    log.warn(log.message.channelShouldNotBeUsedForBinned(channel));\n  } // Normalize Type\n\n\n  if (isTypedFieldDef(fieldDef)) {\n    var type = fieldDef.type;\n    var fullType = getFullName(type);\n\n    if (type !== fullType) {\n      // convert short type to full type\n      fieldDef.type = fullType;\n    }\n\n    if (type !== 'quantitative') {\n      if (isCountingAggregateOp(aggregate)) {\n        log.warn(log.message.invalidFieldTypeForCountAggregate(type, aggregate));\n        fieldDef.type = 'quantitative';\n      }\n    }\n  } else if (!isSecondaryRangeChannel(channel)) {\n    // If type is empty / invalid, then augment with default type\n    var newType = defaultType(fieldDef, channel);\n    fieldDef['type'] = newType;\n  }\n\n  if (isTypedFieldDef(fieldDef)) {\n    var _ref4 = channelCompatibility(fieldDef, channel) || {},\n        compatible = _ref4.compatible,\n        warning = _ref4.warning;\n\n    if (compatible === false) {\n      log.warn(warning);\n    }\n  }\n\n  if (isSortableFieldDef(fieldDef) && isString(fieldDef.sort)) {\n    var sort = fieldDef.sort;\n\n    if (isSortByChannel(sort)) {\n      return Object.assign(Object.assign({}, fieldDef), {\n        sort: {\n          encoding: sort\n        }\n      });\n    }\n\n    var sub = sort.substr(1);\n\n    if (sort.charAt(0) === '-' && isSortByChannel(sub)) {\n      return Object.assign(Object.assign({}, fieldDef), {\n        sort: {\n          encoding: sub,\n          order: 'descending'\n        }\n      });\n    }\n  }\n\n  if (isFacetFieldDef(fieldDef)) {\n    var header = fieldDef.header;\n\n    var orient = header.orient,\n        rest = __rest(header, [\"orient\"]);\n\n    if (orient) {\n      return Object.assign(Object.assign({}, fieldDef), {\n        header: Object.assign(Object.assign({}, rest), {\n          labelOrient: header.labelOrient || orient,\n          titleOrient: header.titleOrient || orient\n        })\n      });\n    }\n  }\n\n  return fieldDef;\n}\nexport function normalizeBin(bin, channel) {\n  if (isBoolean(bin)) {\n    return {\n      maxbins: autoMaxBins(channel)\n    };\n  } else if (bin === 'binned') {\n    return {\n      binned: true\n    };\n  } else if (!bin.maxbins && !bin.step) {\n    return Object.assign(Object.assign({}, bin), {\n      maxbins: autoMaxBins(channel)\n    });\n  } else {\n    return bin;\n  }\n}\nvar COMPATIBLE = {\n  compatible: true\n};\nexport function channelCompatibility(fieldDef, channel) {\n  var type = fieldDef.type;\n\n  if (type === 'geojson' && channel !== 'shape') {\n    return {\n      compatible: false,\n      warning: \"Channel \".concat(channel, \" should not be used with a geojson data.\")\n    };\n  }\n\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case FACET:\n      if (isContinuous(fieldDef)) {\n        return {\n          compatible: false,\n          warning: log.message.facetChannelShouldBeDiscrete(channel)\n        };\n      }\n\n      return COMPATIBLE;\n\n    case X:\n    case Y:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case TEXT:\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n    case ANGLE:\n    case THETA:\n    case RADIUS:\n    case DESCRIPTION:\n      return COMPATIBLE;\n\n    case LONGITUDE:\n    case LONGITUDE2:\n    case LATITUDE:\n    case LATITUDE2:\n      if (type !== QUANTITATIVE) {\n        return {\n          compatible: false,\n          warning: \"Channel \".concat(channel, \" should be used with a quantitative field only, not \").concat(fieldDef.type, \" field.\")\n        };\n      }\n\n      return COMPATIBLE;\n\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH:\n    case SIZE:\n    case THETA2:\n    case RADIUS2:\n    case X2:\n    case Y2:\n      if (type === 'nominal' && !fieldDef['sort']) {\n        return {\n          compatible: false,\n          warning: \"Channel \".concat(channel, \" should not be used with an unsorted discrete field.\")\n        };\n      }\n\n      return COMPATIBLE;\n\n    case STROKEDASH:\n      if (!contains(['ordinal', 'nominal'], fieldDef.type)) {\n        return {\n          compatible: false,\n          warning: 'StrokeDash channel should be used with only discrete data.'\n        };\n      }\n\n      return COMPATIBLE;\n\n    case SHAPE:\n      if (!contains(['ordinal', 'nominal', 'geojson'], fieldDef.type)) {\n        return {\n          compatible: false,\n          warning: 'Shape channel should be used with only either discrete or geojson data.'\n        };\n      }\n\n      return COMPATIBLE;\n\n    case ORDER:\n      if (fieldDef.type === 'nominal' && !('sort' in fieldDef)) {\n        return {\n          compatible: false,\n          warning: \"Channel order is inappropriate for nominal field, which has no inherent order.\"\n        };\n      }\n\n      return COMPATIBLE;\n  }\n}\n/**\n * Check if the field def uses a time format or does not use any format but is temporal\n * (this does not cover field defs that are temporal but use a number format).\n */\n\nexport function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {\n  var _getFormatMixins = getFormatMixins(fieldOrDatumDef),\n      formatType = _getFormatMixins.formatType;\n\n  return formatType === 'time' || !formatType && isTimeFieldDef(fieldOrDatumDef);\n}\n/**\n * Check if field def has type `temporal`. If you want to also cover field defs that use a time format, use `isTimeFormatFieldDef`.\n */\n\nexport function isTimeFieldDef(def) {\n  return def && (def['type'] === 'temporal' || isFieldDef(def) && !!def.timeUnit);\n}\n/**\n * Getting a value associated with a fielddef.\n * Convert the value to Vega expression if applicable (for datetime object, or string if the field def is temporal or has timeUnit)\n */\n\nexport function valueExpr(v, _ref5) {\n  var timeUnit = _ref5.timeUnit,\n      type = _ref5.type,\n      wrapTime = _ref5.wrapTime,\n      undefinedIfExprNotRequired = _ref5.undefinedIfExprNotRequired;\n\n  var _a;\n\n  var unit = timeUnit && ((_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit);\n  var isTime = unit || type === 'temporal';\n  var expr;\n\n  if (isExprRef(v)) {\n    expr = v.expr;\n  } else if (isSignalRef(v)) {\n    expr = v.signal;\n  } else if (isDateTime(v)) {\n    isTime = true;\n    expr = dateTimeToExpr(v);\n  } else if (isString(v) || isNumber(v)) {\n    if (isTime) {\n      expr = \"datetime(\".concat(JSON.stringify(v), \")\");\n\n      if (isLocalSingleTimeUnit(unit)) {\n        // for single timeUnit, we will use dateTimeToExpr to convert number/string to match the timeUnit\n        if (isNumber(v) && v < 10000 || isString(v) && isNaN(Date.parse(v))) {\n          expr = dateTimeToExpr(_defineProperty({}, unit, v));\n        }\n      }\n    }\n  }\n\n  if (expr) {\n    return wrapTime && isTime ? \"time(\".concat(expr, \")\") : expr;\n  } // number or boolean or normal string\n\n\n  return undefinedIfExprNotRequired ? undefined : JSON.stringify(v);\n}\n/**\n * Standardize value array -- convert each value to Vega expression if applicable\n */\n\nexport function valueArray(fieldOrDatumDef, values) {\n  var type = fieldOrDatumDef.type;\n  return values.map(function (v) {\n    var expr = valueExpr(v, {\n      timeUnit: isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.timeUnit : undefined,\n      type: type,\n      undefinedIfExprNotRequired: true\n    }); // return signal for the expression if we need an expression\n\n    if (expr !== undefined) {\n      return {\n        signal: expr\n      };\n    } // otherwise just return the original value\n\n\n    return v;\n  });\n}\n/**\n * Checks whether a fieldDef for a particular channel requires a computed bin range.\n */\n\nexport function binRequiresRange(fieldDef, channel) {\n  if (!isBinning(fieldDef.bin)) {\n    console.warn('Only call this method for binned field defs.');\n    return false;\n  } // We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.\n  // We could check whether the axis or legend exists (not disabled) but that seems overkill.\n\n\n  return isScaleChannel(channel) && contains(['ordinal', 'nominal'], fieldDef.type);\n}","map":{"version":3,"sources":["../../src/channeldef.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isArray, isBoolean, isNumber, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, isCountingAggregateOp } from './aggregate';\nimport { autoMaxBins, binToString, isBinned, isBinning } from './bin';\nimport { ANGLE, COLOR, COLUMN, DESCRIPTION, DETAIL, FACET, FILL, FILLOPACITY, HREF, isScaleChannel, isSecondaryRangeChannel, isXorY, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, TEXT, THETA, THETA2, TOOLTIP, URL, X, X2, Y, Y2 } from './channel';\nimport { getMarkConfig } from './compile/common';\nimport { isCustomFormatType } from './compile/format';\nimport { dateTimeToExpr, isDateTime } from './datetime';\nimport { isExprRef } from './expr';\nimport * as log from './log';\nimport { isRectBasedMark } from './mark';\nimport { SCALE_CATEGORY_INDEX } from './scale';\nimport { isSortByChannel } from './sort';\nimport { isFacetFieldDef } from './spec/facet';\nimport { getTimeUnitParts, isLocalSingleTimeUnit, normalizeTimeUnit, timeUnitToString } from './timeunit';\nimport { getFullName, QUANTITATIVE } from './type';\nimport { contains, flatAccessWithDatum, getFirstDefined, internalField, omit, removePathFromField, replacePathInField, titleCase } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isConditionalSelection(c) {\n    return c['selection'];\n}\nexport function isRepeatRef(field) {\n    return field && !isString(field) && 'repeat' in field;\n}\nexport function toFieldDefBase(fieldDef) {\n    const { field, timeUnit, bin, aggregate } = fieldDef;\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, (timeUnit ? { timeUnit } : {})), (bin ? { bin } : {})), (aggregate ? { aggregate } : {})), { field });\n}\nexport function isSortableFieldDef(fieldDef) {\n    return 'sort' in fieldDef;\n}\nexport function getBand({ channel, fieldDef, fieldDef2, markDef: mark, stack, config, isMidPoint }) {\n    if (isFieldOrDatumDef(fieldDef) && fieldDef.band !== undefined) {\n        return fieldDef.band;\n    }\n    if (isFieldDef(fieldDef)) {\n        const { timeUnit, bin } = fieldDef;\n        if (timeUnit && !fieldDef2) {\n            if (isMidPoint) {\n                return getMarkConfig('timeUnitBandPosition', mark, config);\n            }\n            else {\n                return isRectBasedMark(mark.type) ? getMarkConfig('timeUnitBand', mark, config) : 0;\n            }\n        }\n        else if (isBinning(bin)) {\n            return isRectBasedMark(mark.type) && !isMidPoint ? 1 : 0.5;\n        }\n    }\n    if ((stack === null || stack === void 0 ? void 0 : stack.fieldChannel) === channel && isMidPoint) {\n        return 0.5;\n    }\n    return undefined;\n}\nexport function hasBand(channel, fieldDef, fieldDef2, stack, markDef, config) {\n    if (isBinning(fieldDef.bin) || (fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === 'temporal')) {\n        return !!getBand({ channel, fieldDef, fieldDef2, stack, markDef, config });\n    }\n    return false;\n}\nexport function isConditionalDef(channelDef) {\n    return !!channelDef && 'condition' in channelDef;\n}\n/**\n * Return if a channelDef is a ConditionalValueDef with ConditionFieldDef\n */\nexport function hasConditionalFieldDef(channelDef) {\n    const condition = channelDef && channelDef['condition'];\n    return !!condition && !isArray(condition) && isFieldDef(condition);\n}\nexport function hasConditionalFieldOrDatumDef(channelDef) {\n    const condition = channelDef && channelDef['condition'];\n    return !!condition && !isArray(condition) && isFieldOrDatumDef(condition);\n}\nexport function hasConditionalValueDef(channelDef) {\n    const condition = channelDef && channelDef['condition'];\n    return !!condition && (isArray(condition) || isValueDef(condition));\n}\nexport function isFieldDef(channelDef) {\n    // TODO: we can't use field in channelDef here as it's somehow failing runtime test\n    return !!channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\nexport function channelDefType(channelDef) {\n    return channelDef && channelDef['type'];\n}\nexport function isDatumDef(channelDef) {\n    return !!channelDef && 'datum' in channelDef;\n}\nexport function isContinuousFieldOrDatumDef(cd) {\n    // TODO: make datum support DateTime object\n    return (isTypedFieldDef(cd) && isContinuous(cd)) || isNumericDataDef(cd);\n}\nexport function isQuantitativeFieldOrDatumDef(cd) {\n    // TODO: make datum support DateTime object\n    return channelDefType(cd) === 'quantitative' || isNumericDataDef(cd);\n}\nexport function isNumericDataDef(cd) {\n    return isDatumDef(cd) && isNumber(cd.datum);\n}\nexport function isFieldOrDatumDef(channelDef) {\n    return isFieldDef(channelDef) || isDatumDef(channelDef);\n}\nexport function isTypedFieldDef(channelDef) {\n    return !!channelDef && ('field' in channelDef || channelDef['aggregate'] === 'count') && 'type' in channelDef;\n}\nexport function isValueDef(channelDef) {\n    return channelDef && 'value' in channelDef && 'value' in channelDef;\n}\nexport function isScaleFieldDef(channelDef) {\n    return !!channelDef && ('scale' in channelDef || 'sort' in channelDef);\n}\nexport function isPositionFieldOrDatumDef(channelDef) {\n    return channelDef && ('axis' in channelDef || 'stack' in channelDef || 'impute' in channelDef);\n}\nexport function isMarkPropFieldOrDatumDef(channelDef) {\n    return !!channelDef && 'legend' in channelDef;\n}\nexport function isStringFieldOrDatumDef(channelDef) {\n    return !!channelDef && ('format' in channelDef || 'formatType' in channelDef);\n}\nexport function toStringFieldDef(fieldDef) {\n    // omit properties that don't exist in string field defs\n    return omit(fieldDef, ['legend', 'axis', 'header', 'scale']);\n}\nfunction isOpFieldDef(fieldDef) {\n    return 'op' in fieldDef;\n}\n/**\n * Get a Vega field reference from a Vega-Lite field def.\n */\nexport function vgField(fieldDef, opt = {}) {\n    var _a, _b, _c;\n    let field = fieldDef.field;\n    const prefix = opt.prefix;\n    let suffix = opt.suffix;\n    let argAccessor = ''; // for accessing argmin/argmax field at the end without getting escaped\n    if (isCount(fieldDef)) {\n        field = internalField('count');\n    }\n    else {\n        let fn;\n        if (!opt.nofn) {\n            if (isOpFieldDef(fieldDef)) {\n                fn = fieldDef.op;\n            }\n            else {\n                const { bin, aggregate, timeUnit } = fieldDef;\n                if (isBinning(bin)) {\n                    fn = binToString(bin);\n                    suffix = ((_a = opt.binSuffix) !== null && _a !== void 0 ? _a : '') + ((_b = opt.suffix) !== null && _b !== void 0 ? _b : '');\n                }\n                else if (aggregate) {\n                    if (isArgmaxDef(aggregate)) {\n                        argAccessor = `[\"${field}\"]`;\n                        field = `argmax_${aggregate.argmax}`;\n                    }\n                    else if (isArgminDef(aggregate)) {\n                        argAccessor = `[\"${field}\"]`;\n                        field = `argmin_${aggregate.argmin}`;\n                    }\n                    else {\n                        fn = String(aggregate);\n                    }\n                }\n                else if (timeUnit) {\n                    fn = timeUnitToString(timeUnit);\n                    suffix = ((!contains(['range', 'mid'], opt.binSuffix) && opt.binSuffix) || '') + ((_c = opt.suffix) !== null && _c !== void 0 ? _c : '');\n                }\n            }\n        }\n        if (fn) {\n            field = field ? `${fn}_${field}` : fn;\n        }\n    }\n    if (suffix) {\n        field = `${field}_${suffix}`;\n    }\n    if (prefix) {\n        field = `${prefix}_${field}`;\n    }\n    if (opt.forAs) {\n        return removePathFromField(field);\n    }\n    else if (opt.expr) {\n        // Expression to access flattened field. No need to escape dots.\n        return flatAccessWithDatum(field, opt.expr) + argAccessor;\n    }\n    else {\n        // We flattened all fields so paths should have become dot.\n        return replacePathInField(field) + argAccessor;\n    }\n}\nexport function isDiscrete(def) {\n    switch (def.type) {\n        case 'nominal':\n        case 'ordinal':\n        case 'geojson':\n            return true;\n        case 'quantitative':\n            return isFieldDef(def) && !!def.bin;\n        case 'temporal':\n            return false;\n    }\n    throw new Error(log.message.invalidFieldType(def.type));\n}\nexport function isContinuous(fieldDef) {\n    return !isDiscrete(fieldDef);\n}\nexport function isCount(fieldDef) {\n    return fieldDef.aggregate === 'count';\n}\nexport function verbalTitleFormatter(fieldDef, config) {\n    var _a;\n    const { field, bin, timeUnit, aggregate } = fieldDef;\n    if (aggregate === 'count') {\n        return config.countTitle;\n    }\n    else if (isBinning(bin)) {\n        return `${field} (binned)`;\n    }\n    else if (timeUnit) {\n        const unit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n        if (unit) {\n            return `${field} (${getTimeUnitParts(unit).join('-')})`;\n        }\n    }\n    else if (aggregate) {\n        if (isArgmaxDef(aggregate)) {\n            return `${field} for max ${aggregate.argmax}`;\n        }\n        else if (isArgminDef(aggregate)) {\n            return `${field} for min ${aggregate.argmin}`;\n        }\n        else {\n            return `${titleCase(aggregate)} of ${field}`;\n        }\n    }\n    return field;\n}\nexport function functionalTitleFormatter(fieldDef) {\n    const { aggregate, bin, timeUnit, field } = fieldDef;\n    if (isArgmaxDef(aggregate)) {\n        return `${field} for argmax(${aggregate.argmax})`;\n    }\n    else if (isArgminDef(aggregate)) {\n        return `${field} for argmin(${aggregate.argmin})`;\n    }\n    const timeUnitParams = normalizeTimeUnit(timeUnit);\n    const fn = aggregate || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.unit) || ((timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.maxbins) && 'timeunit') || (isBinning(bin) && 'bin');\n    if (fn) {\n        return fn.toUpperCase() + '(' + field + ')';\n    }\n    else {\n        return field;\n    }\n}\nexport const defaultTitleFormatter = (fieldDef, config) => {\n    switch (config.fieldTitle) {\n        case 'plain':\n            return fieldDef.field;\n        case 'functional':\n            return functionalTitleFormatter(fieldDef);\n        default:\n            return verbalTitleFormatter(fieldDef, config);\n    }\n};\nlet titleFormatter = defaultTitleFormatter;\nexport function setTitleFormatter(formatter) {\n    titleFormatter = formatter;\n}\nexport function resetTitleFormatter() {\n    setTitleFormatter(defaultTitleFormatter);\n}\nexport function title(fieldOrDatumDef, config, { allowDisabling, includeDefault = true }) {\n    var _a, _b;\n    const guideTitle = (_a = getGuide(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.title;\n    if (!isFieldDef(fieldOrDatumDef)) {\n        return guideTitle;\n    }\n    const fieldDef = fieldOrDatumDef;\n    const def = includeDefault ? defaultTitle(fieldDef, config) : undefined;\n    if (allowDisabling) {\n        return getFirstDefined(guideTitle, fieldDef.title, def);\n    }\n    else {\n        return (_b = guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldDef.title) !== null && _b !== void 0 ? _b : def;\n    }\n}\nexport function getGuide(fieldDef) {\n    if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {\n        return fieldDef.axis;\n    }\n    else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {\n        return fieldDef.legend;\n    }\n    else if (isFacetFieldDef(fieldDef) && fieldDef.header) {\n        return fieldDef.header;\n    }\n    return undefined;\n}\nexport function defaultTitle(fieldDef, config) {\n    return titleFormatter(fieldDef, config);\n}\nexport function getFormatMixins(fieldDef) {\n    var _a;\n    if (isStringFieldOrDatumDef(fieldDef)) {\n        const { format, formatType } = fieldDef;\n        return { format, formatType };\n    }\n    else {\n        const guide = (_a = getGuide(fieldDef)) !== null && _a !== void 0 ? _a : {};\n        const { format, formatType } = guide;\n        return { format, formatType };\n    }\n}\nexport function defaultType(fieldDef, channel) {\n    var _a;\n    switch (channel) {\n        case 'latitude':\n        case 'longitude':\n            return 'quantitative';\n        case 'row':\n        case 'column':\n        case 'facet':\n        case 'shape':\n        case 'strokeDash':\n            return 'nominal';\n        case 'order':\n            return 'ordinal';\n    }\n    if (isSortableFieldDef(fieldDef) && isArray(fieldDef.sort)) {\n        return 'ordinal';\n    }\n    const { aggregate, bin, timeUnit } = fieldDef;\n    if (timeUnit) {\n        return 'temporal';\n    }\n    if (bin || (aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate))) {\n        return 'quantitative';\n    }\n    if (isScaleFieldDef(fieldDef) && ((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.type)) {\n        switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {\n            case 'numeric':\n            case 'discretizing':\n                return 'quantitative';\n            case 'time':\n                return 'temporal';\n        }\n    }\n    return 'nominal';\n}\n/**\n * Returns the fieldDef -- either from the outer channelDef or from the condition of channelDef.\n * @param channelDef\n */\nexport function getFieldDef(channelDef) {\n    if (isFieldDef(channelDef)) {\n        return channelDef;\n    }\n    else if (hasConditionalFieldDef(channelDef)) {\n        return channelDef.condition;\n    }\n    return undefined;\n}\nexport function getFieldOrDatumDef(channelDef) {\n    if (isFieldOrDatumDef(channelDef)) {\n        return channelDef;\n    }\n    else if (hasConditionalFieldOrDatumDef(channelDef)) {\n        return channelDef.condition;\n    }\n    return undefined;\n}\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\nexport function initChannelDef(channelDef, channel, config, opt = {}) {\n    if (isString(channelDef) || isNumber(channelDef) || isBoolean(channelDef)) {\n        const primitiveType = isString(channelDef) ? 'string' : isNumber(channelDef) ? 'number' : 'boolean';\n        log.warn(log.message.primitiveChannelDef(channel, primitiveType, channelDef));\n        return { value: channelDef };\n    }\n    // If a fieldDef contains a field, we need type.\n    if (isFieldOrDatumDef(channelDef)) {\n        return initFieldOrDatumDef(channelDef, channel, config, opt);\n    }\n    else if (hasConditionalFieldOrDatumDef(channelDef)) {\n        return Object.assign(Object.assign({}, channelDef), { \n            // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>\n            condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt) });\n    }\n    return channelDef;\n}\nexport function initFieldOrDatumDef(fd, channel, config, opt) {\n    if (isStringFieldOrDatumDef(fd)) {\n        const { format, formatType } = fd, rest = __rest(fd, [\"format\", \"formatType\"]);\n        if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n            log.warn(log.message.customFormatTypeNotAllowed(channel));\n            return initFieldOrDatumDef(rest, channel, config, opt);\n        }\n    }\n    else {\n        const guideType = isPositionFieldOrDatumDef(fd)\n            ? 'axis'\n            : isMarkPropFieldOrDatumDef(fd)\n                ? 'legend'\n                : isFacetFieldDef(fd)\n                    ? 'header'\n                    : null;\n        if (guideType && fd[guideType]) {\n            const _a = fd[guideType], { format, formatType } = _a, newGuide = __rest(_a, [\"format\", \"formatType\"]);\n            if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n                log.warn(log.message.customFormatTypeNotAllowed(channel));\n                return initFieldOrDatumDef(Object.assign(Object.assign({}, fd), { [guideType]: newGuide }), channel, config, opt);\n            }\n        }\n    }\n    if (isFieldDef(fd)) {\n        return initFieldDef(fd, channel, opt);\n    }\n    return initDatumDef(fd);\n}\nfunction initDatumDef(datumDef) {\n    let type = datumDef['type'];\n    if (type) {\n        return datumDef;\n    }\n    const { datum } = datumDef;\n    type = isNumber(datum) ? 'quantitative' : isString(datum) ? 'nominal' : isDateTime(datum) ? 'temporal' : undefined;\n    return Object.assign(Object.assign({}, datumDef), { type });\n}\nexport function initFieldDef(fd, channel, { compositeMark = false } = {}) {\n    const { aggregate, timeUnit, bin, field } = fd;\n    const fieldDef = Object.assign({}, fd);\n    // Drop invalid aggregate\n    if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n        log.warn(log.message.invalidAggregate(aggregate));\n        delete fieldDef.aggregate;\n    }\n    // Normalize Time Unit\n    if (timeUnit) {\n        fieldDef.timeUnit = normalizeTimeUnit(timeUnit);\n    }\n    if (field) {\n        fieldDef.field = `${field}`;\n    }\n    // Normalize bin\n    if (isBinning(bin)) {\n        fieldDef.bin = normalizeBin(bin, channel);\n    }\n    if (isBinned(bin) && !isXorY(channel)) {\n        log.warn(log.message.channelShouldNotBeUsedForBinned(channel));\n    }\n    // Normalize Type\n    if (isTypedFieldDef(fieldDef)) {\n        const { type } = fieldDef;\n        const fullType = getFullName(type);\n        if (type !== fullType) {\n            // convert short type to full type\n            fieldDef.type = fullType;\n        }\n        if (type !== 'quantitative') {\n            if (isCountingAggregateOp(aggregate)) {\n                log.warn(log.message.invalidFieldTypeForCountAggregate(type, aggregate));\n                fieldDef.type = 'quantitative';\n            }\n        }\n    }\n    else if (!isSecondaryRangeChannel(channel)) {\n        // If type is empty / invalid, then augment with default type\n        const newType = defaultType(fieldDef, channel);\n        fieldDef['type'] = newType;\n    }\n    if (isTypedFieldDef(fieldDef)) {\n        const { compatible, warning } = channelCompatibility(fieldDef, channel) || {};\n        if (compatible === false) {\n            log.warn(warning);\n        }\n    }\n    if (isSortableFieldDef(fieldDef) && isString(fieldDef.sort)) {\n        const { sort } = fieldDef;\n        if (isSortByChannel(sort)) {\n            return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sort } });\n        }\n        const sub = sort.substr(1);\n        if (sort.charAt(0) === '-' && isSortByChannel(sub)) {\n            return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sub, order: 'descending' } });\n        }\n    }\n    if (isFacetFieldDef(fieldDef)) {\n        const { header } = fieldDef;\n        const { orient } = header, rest = __rest(header, [\"orient\"]);\n        if (orient) {\n            return Object.assign(Object.assign({}, fieldDef), { header: Object.assign(Object.assign({}, rest), { labelOrient: header.labelOrient || orient, titleOrient: header.titleOrient || orient }) });\n        }\n    }\n    return fieldDef;\n}\nexport function normalizeBin(bin, channel) {\n    if (isBoolean(bin)) {\n        return { maxbins: autoMaxBins(channel) };\n    }\n    else if (bin === 'binned') {\n        return {\n            binned: true\n        };\n    }\n    else if (!bin.maxbins && !bin.step) {\n        return Object.assign(Object.assign({}, bin), { maxbins: autoMaxBins(channel) });\n    }\n    else {\n        return bin;\n    }\n}\nconst COMPATIBLE = { compatible: true };\nexport function channelCompatibility(fieldDef, channel) {\n    const type = fieldDef.type;\n    if (type === 'geojson' && channel !== 'shape') {\n        return {\n            compatible: false,\n            warning: `Channel ${channel} should not be used with a geojson data.`\n        };\n    }\n    switch (channel) {\n        case ROW:\n        case COLUMN:\n        case FACET:\n            if (isContinuous(fieldDef)) {\n                return {\n                    compatible: false,\n                    warning: log.message.facetChannelShouldBeDiscrete(channel)\n                };\n            }\n            return COMPATIBLE;\n        case X:\n        case Y:\n        case COLOR:\n        case FILL:\n        case STROKE:\n        case TEXT:\n        case DETAIL:\n        case KEY:\n        case TOOLTIP:\n        case HREF:\n        case URL:\n        case ANGLE:\n        case THETA:\n        case RADIUS:\n        case DESCRIPTION:\n            return COMPATIBLE;\n        case LONGITUDE:\n        case LONGITUDE2:\n        case LATITUDE:\n        case LATITUDE2:\n            if (type !== QUANTITATIVE) {\n                return {\n                    compatible: false,\n                    warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`\n                };\n            }\n            return COMPATIBLE;\n        case OPACITY:\n        case FILLOPACITY:\n        case STROKEOPACITY:\n        case STROKEWIDTH:\n        case SIZE:\n        case THETA2:\n        case RADIUS2:\n        case X2:\n        case Y2:\n            if (type === 'nominal' && !fieldDef['sort']) {\n                return {\n                    compatible: false,\n                    warning: `Channel ${channel} should not be used with an unsorted discrete field.`\n                };\n            }\n            return COMPATIBLE;\n        case STROKEDASH:\n            if (!contains(['ordinal', 'nominal'], fieldDef.type)) {\n                return {\n                    compatible: false,\n                    warning: 'StrokeDash channel should be used with only discrete data.'\n                };\n            }\n            return COMPATIBLE;\n        case SHAPE:\n            if (!contains(['ordinal', 'nominal', 'geojson'], fieldDef.type)) {\n                return {\n                    compatible: false,\n                    warning: 'Shape channel should be used with only either discrete or geojson data.'\n                };\n            }\n            return COMPATIBLE;\n        case ORDER:\n            if (fieldDef.type === 'nominal' && !('sort' in fieldDef)) {\n                return {\n                    compatible: false,\n                    warning: `Channel order is inappropriate for nominal field, which has no inherent order.`\n                };\n            }\n            return COMPATIBLE;\n    }\n}\n/**\n * Check if the field def uses a time format or does not use any format but is temporal\n * (this does not cover field defs that are temporal but use a number format).\n */\nexport function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {\n    const { formatType } = getFormatMixins(fieldOrDatumDef);\n    return formatType === 'time' || (!formatType && isTimeFieldDef(fieldOrDatumDef));\n}\n/**\n * Check if field def has type `temporal`. If you want to also cover field defs that use a time format, use `isTimeFormatFieldDef`.\n */\nexport function isTimeFieldDef(def) {\n    return def && (def['type'] === 'temporal' || (isFieldDef(def) && !!def.timeUnit));\n}\n/**\n * Getting a value associated with a fielddef.\n * Convert the value to Vega expression if applicable (for datetime object, or string if the field def is temporal or has timeUnit)\n */\nexport function valueExpr(v, { timeUnit, type, wrapTime, undefinedIfExprNotRequired }) {\n    var _a;\n    const unit = timeUnit && ((_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit);\n    let isTime = unit || type === 'temporal';\n    let expr;\n    if (isExprRef(v)) {\n        expr = v.expr;\n    }\n    else if (isSignalRef(v)) {\n        expr = v.signal;\n    }\n    else if (isDateTime(v)) {\n        isTime = true;\n        expr = dateTimeToExpr(v);\n    }\n    else if (isString(v) || isNumber(v)) {\n        if (isTime) {\n            expr = `datetime(${JSON.stringify(v)})`;\n            if (isLocalSingleTimeUnit(unit)) {\n                // for single timeUnit, we will use dateTimeToExpr to convert number/string to match the timeUnit\n                if ((isNumber(v) && v < 10000) || (isString(v) && isNaN(Date.parse(v)))) {\n                    expr = dateTimeToExpr({ [unit]: v });\n                }\n            }\n        }\n    }\n    if (expr) {\n        return wrapTime && isTime ? `time(${expr})` : expr;\n    }\n    // number or boolean or normal string\n    return undefinedIfExprNotRequired ? undefined : JSON.stringify(v);\n}\n/**\n * Standardize value array -- convert each value to Vega expression if applicable\n */\nexport function valueArray(fieldOrDatumDef, values) {\n    const { type } = fieldOrDatumDef;\n    return values.map(v => {\n        const expr = valueExpr(v, {\n            timeUnit: isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.timeUnit : undefined,\n            type,\n            undefinedIfExprNotRequired: true\n        });\n        // return signal for the expression if we need an expression\n        if (expr !== undefined) {\n            return { signal: expr };\n        }\n        // otherwise just return the original value\n        return v;\n    });\n}\n/**\n * Checks whether a fieldDef for a particular channel requires a computed bin range.\n */\nexport function binRequiresRange(fieldDef, channel) {\n    if (!isBinning(fieldDef.bin)) {\n        console.warn('Only call this method for binned field defs.');\n        return false;\n    }\n    // We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.\n    // We could check whether the axis or legend exists (not disabled) but that seems overkill.\n    return isScaleChannel(channel) && contains(['ordinal', 'nominal'], fieldDef.type);\n}\n//# sourceMappingURL=channeldef.js.map"]},"metadata":{},"sourceType":"module"}