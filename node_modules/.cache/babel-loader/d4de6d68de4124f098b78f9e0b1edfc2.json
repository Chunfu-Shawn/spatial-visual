{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _defineProperty from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../../channel';\nimport * as log from '../../../log';\nimport { hasContinuousDomain } from '../../../scale';\nimport { hash, keys, replacePathInField, varName, isEmpty } from '../../../util';\nimport { TimeUnitNode } from '../../data/timeunit';\nexport var TUPLE_FIELDS = '_tuple_fields';\nexport var SelectionProjectionComponent = function SelectionProjectionComponent() {\n  _classCallCheck(this, SelectionProjectionComponent);\n\n  for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n    items[_key] = arguments[_key];\n  }\n\n  this.items = items;\n  this.hasChannel = {};\n  this.hasField = {};\n};\nvar project = {\n  has: function has() {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n  parse: function parse(model, selCmpt, selDef) {\n    var _a, _b, _c;\n\n    var name = selCmpt.name;\n    var proj = (_a = selCmpt.project) !== null && _a !== void 0 ? _a : selCmpt.project = new SelectionProjectionComponent();\n    var parsed = {};\n    var timeUnits = {};\n    var signals = new Set();\n\n    var signalName = function signalName(p, range) {\n      var suffix = range === 'visual' ? p.channel : p.field;\n      var sg = varName(\"\".concat(name, \"_\").concat(suffix));\n\n      for (var counter = 1; signals.has(sg); counter++) {\n        sg = varName(\"\".concat(name, \"_\").concat(suffix, \"_\").concat(counter));\n      }\n\n      signals.add(sg);\n      return _defineProperty({}, range, sg);\n    }; // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n    // Otherwise, use the default configuration.\n\n\n    if (!selDef.fields && !selDef.encodings) {\n      var cfg = model.config.selection[selDef.type];\n\n      if (selDef.init) {\n        var _iterator = _createForOfIteratorHelper(array(selDef.init)),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var init = _step.value;\n\n            var _iterator2 = _createForOfIteratorHelper(keys(init)),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var key = _step2.value;\n\n                if (isSingleDefUnitChannel(key)) {\n                  (selDef.encodings || (selDef.encodings = [])).push(key);\n                } else {\n                  if (selDef.type === 'interval') {\n                    log.warn(log.message.INTERVAL_INITIALIZED_WITH_X_Y);\n                    selDef.encodings = cfg.encodings;\n                  } else {\n                    (selDef.fields || (selDef.fields = [])).push(key);\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        selDef.encodings = cfg.encodings;\n        selDef.fields = cfg.fields;\n      }\n    } // TODO: find a possible channel mapping for these fields.\n\n\n    var _iterator3 = _createForOfIteratorHelper((_b = selDef.fields) !== null && _b !== void 0 ? _b : []),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var field = _step3.value;\n        var p = {\n          type: 'E',\n          field: field\n        };\n        p.signals = Object.assign({}, signalName(p, 'data'));\n        proj.items.push(p);\n        proj.hasField[field] = p;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var _iterator4 = _createForOfIteratorHelper((_c = selDef.encodings) !== null && _c !== void 0 ? _c : []),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var channel = _step4.value;\n        var fieldDef = model.fieldDef(channel);\n\n        if (fieldDef) {\n          var _field = fieldDef.field;\n\n          if (fieldDef.aggregate) {\n            log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n            continue;\n          } else if (!_field) {\n            log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n            continue;\n          }\n\n          if (fieldDef.timeUnit) {\n            _field = model.vgField(channel); // Construct TimeUnitComponents which will be combined into a\n            // TimeUnitNode. This node may need to be inserted into the\n            // dataflow if the selection is used across views that do not\n            // have these time units defined.\n\n            var component = {\n              timeUnit: fieldDef.timeUnit,\n              as: _field,\n              field: fieldDef.field\n            };\n            timeUnits[hash(component)] = component;\n          } // Prevent duplicate projections on the same field.\n          // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n\n\n          if (!parsed[_field]) {\n            // Determine whether the tuple will store enumerated or ranged values.\n            // Interval selections store ranges for continuous scales, and enumerations otherwise.\n            // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n            var type = 'E';\n\n            if (selCmpt.type === 'interval') {\n              var scaleType = model.getScaleComponent(channel).get('type');\n\n              if (hasContinuousDomain(scaleType)) {\n                type = 'R';\n              }\n            } else if (fieldDef.bin) {\n              type = 'R-RE';\n            }\n\n            var _p = {\n              field: _field,\n              channel: channel,\n              type: type\n            };\n            _p.signals = Object.assign(Object.assign({}, signalName(_p, 'data')), signalName(_p, 'visual'));\n            proj.items.push(parsed[_field] = _p);\n            proj.hasField[_field] = proj.hasChannel[channel] = parsed[_field];\n          }\n        } else {\n          log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    if (selDef.init) {\n      var parseInit = function parseInit(i) {\n        return proj.items.map(function (p) {\n          return i[p.channel] !== undefined ? i[p.channel] : i[p.field];\n        });\n      };\n\n      if (selDef.type === 'interval') {\n        selCmpt.init = parseInit(selDef.init);\n      } else {\n        var _init = array(selDef.init);\n\n        selCmpt.init = _init.map(parseInit);\n      }\n    }\n\n    if (!isEmpty(timeUnits)) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n  signals: function signals(model, selCmpt, allSignals) {\n    var name = selCmpt.name + TUPLE_FIELDS;\n    var hasSignal = allSignals.filter(function (s) {\n      return s.name === name;\n    });\n    return hasSignal.length > 0 ? allSignals : allSignals.concat({\n      name: name,\n      value: selCmpt.project.items.map(function (proj) {\n        var signals = proj.signals,\n            hasLegend = proj.hasLegend,\n            rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n\n        rest.field = replacePathInField(rest.field);\n        return rest;\n      })\n    });\n  }\n};\nexport default project;","map":{"version":3,"sources":["../../../../../src/compile/selection/transforms/project.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../../channel';\nimport * as log from '../../../log';\nimport { hasContinuousDomain } from '../../../scale';\nimport { hash, keys, replacePathInField, varName, isEmpty } from '../../../util';\nimport { TimeUnitNode } from '../../data/timeunit';\nexport const TUPLE_FIELDS = '_tuple_fields';\nexport class SelectionProjectionComponent {\n    constructor(...items) {\n        this.items = items;\n        this.hasChannel = {};\n        this.hasField = {};\n    }\n}\nconst project = {\n    has: () => {\n        return true; // This transform handles its own defaults, so always run parse.\n    },\n    parse: (model, selCmpt, selDef) => {\n        var _a, _b, _c;\n        const name = selCmpt.name;\n        const proj = (_a = selCmpt.project) !== null && _a !== void 0 ? _a : (selCmpt.project = new SelectionProjectionComponent());\n        const parsed = {};\n        const timeUnits = {};\n        const signals = new Set();\n        const signalName = (p, range) => {\n            const suffix = range === 'visual' ? p.channel : p.field;\n            let sg = varName(`${name}_${suffix}`);\n            for (let counter = 1; signals.has(sg); counter++) {\n                sg = varName(`${name}_${suffix}_${counter}`);\n            }\n            signals.add(sg);\n            return { [range]: sg };\n        };\n        // If no explicit projection (either fields or encodings) is specified, set some defaults.\n        // If an initial value is set, try to infer projections.\n        // Otherwise, use the default configuration.\n        if (!selDef.fields && !selDef.encodings) {\n            const cfg = model.config.selection[selDef.type];\n            if (selDef.init) {\n                for (const init of array(selDef.init)) {\n                    for (const key of keys(init)) {\n                        if (isSingleDefUnitChannel(key)) {\n                            (selDef.encodings || (selDef.encodings = [])).push(key);\n                        }\n                        else {\n                            if (selDef.type === 'interval') {\n                                log.warn(log.message.INTERVAL_INITIALIZED_WITH_X_Y);\n                                selDef.encodings = cfg.encodings;\n                            }\n                            else {\n                                (selDef.fields || (selDef.fields = [])).push(key);\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                selDef.encodings = cfg.encodings;\n                selDef.fields = cfg.fields;\n            }\n        }\n        // TODO: find a possible channel mapping for these fields.\n        for (const field of (_b = selDef.fields) !== null && _b !== void 0 ? _b : []) {\n            const p = { type: 'E', field };\n            p.signals = Object.assign({}, signalName(p, 'data'));\n            proj.items.push(p);\n            proj.hasField[field] = p;\n        }\n        for (const channel of (_c = selDef.encodings) !== null && _c !== void 0 ? _c : []) {\n            const fieldDef = model.fieldDef(channel);\n            if (fieldDef) {\n                let field = fieldDef.field;\n                if (fieldDef.aggregate) {\n                    log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n                    continue;\n                }\n                else if (!field) {\n                    log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n                    continue;\n                }\n                if (fieldDef.timeUnit) {\n                    field = model.vgField(channel);\n                    // Construct TimeUnitComponents which will be combined into a\n                    // TimeUnitNode. This node may need to be inserted into the\n                    // dataflow if the selection is used across views that do not\n                    // have these time units defined.\n                    const component = {\n                        timeUnit: fieldDef.timeUnit,\n                        as: field,\n                        field: fieldDef.field\n                    };\n                    timeUnits[hash(component)] = component;\n                }\n                // Prevent duplicate projections on the same field.\n                // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n                if (!parsed[field]) {\n                    // Determine whether the tuple will store enumerated or ranged values.\n                    // Interval selections store ranges for continuous scales, and enumerations otherwise.\n                    // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n                    let type = 'E';\n                    if (selCmpt.type === 'interval') {\n                        const scaleType = model.getScaleComponent(channel).get('type');\n                        if (hasContinuousDomain(scaleType)) {\n                            type = 'R';\n                        }\n                    }\n                    else if (fieldDef.bin) {\n                        type = 'R-RE';\n                    }\n                    const p = { field, channel, type };\n                    p.signals = Object.assign(Object.assign({}, signalName(p, 'data')), signalName(p, 'visual'));\n                    proj.items.push((parsed[field] = p));\n                    proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n                }\n            }\n            else {\n                log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n            }\n        }\n        if (selDef.init) {\n            const parseInit = (i) => {\n                return proj.items.map(p => (i[p.channel] !== undefined ? i[p.channel] : i[p.field]));\n            };\n            if (selDef.type === 'interval') {\n                selCmpt.init = parseInit(selDef.init);\n            }\n            else {\n                const init = array(selDef.init);\n                selCmpt.init = init.map(parseInit);\n            }\n        }\n        if (!isEmpty(timeUnits)) {\n            proj.timeUnit = new TimeUnitNode(null, timeUnits);\n        }\n    },\n    signals: (model, selCmpt, allSignals) => {\n        const name = selCmpt.name + TUPLE_FIELDS;\n        const hasSignal = allSignals.filter(s => s.name === name);\n        return hasSignal.length > 0\n            ? allSignals\n            : allSignals.concat({\n                name,\n                value: selCmpt.project.items.map(proj => {\n                    const { signals, hasLegend } = proj, rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n                    rest.field = replacePathInField(rest.field);\n                    return rest;\n                })\n            });\n    }\n};\nexport default project;\n//# sourceMappingURL=project.js.map"]},"metadata":{},"sourceType":"module"}