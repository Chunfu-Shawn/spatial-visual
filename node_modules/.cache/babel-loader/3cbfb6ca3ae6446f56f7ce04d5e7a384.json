{"ast":null,"code":"import _objectSpread from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport VectorTile from './mapbox-vector-tile/vector-tile';\nimport BinaryVectorTile from './binary-vector-tile/vector-tile';\nimport { featuresToBinary } from './binary-vector-tile/features-to-binary';\nimport Protobuf from 'pbf';\nexport default function parseMVT(arrayBuffer, options) {\n  options = normalizeOptions(options);\n  var features = [];\n\n  if (options) {\n    var binary = options.gis.format === 'binary';\n    var firstPassData = {\n      pointPositionsCount: 0,\n      pointFeaturesCount: 0,\n      linePositionsCount: 0,\n      linePathsCount: 0,\n      lineFeaturesCount: 0,\n      polygonPositionsCount: 0,\n      polygonObjectsCount: 0,\n      polygonRingsCount: 0,\n      polygonFeaturesCount: 0\n    };\n\n    if (arrayBuffer.byteLength > 0) {\n      var tile = binary ? new BinaryVectorTile(new Protobuf(arrayBuffer)) : new VectorTile(new Protobuf(arrayBuffer));\n      var loaderOptions = options.mvt;\n      var selectedLayers = Array.isArray(loaderOptions.layers) ? loaderOptions.layers : Object.keys(tile.layers);\n      selectedLayers.forEach(function (layerName) {\n        var vectorTileLayer = tile.layers[layerName];\n\n        var featureOptions = _objectSpread(_objectSpread({}, loaderOptions), {}, {\n          layerName: layerName\n        });\n\n        if (!vectorTileLayer) {\n          return;\n        }\n\n        for (var i = 0; i < vectorTileLayer.length; i++) {\n          var vectorTileFeature = vectorTileLayer.feature(i, firstPassData);\n          var decodedFeature = binary ? getDecodedFeatureBinary(vectorTileFeature, featureOptions) : getDecodedFeature(vectorTileFeature, featureOptions);\n          features.push(decodedFeature);\n        }\n      });\n    }\n\n    if (binary) {\n      var data = featuresToBinary(features, firstPassData);\n      data.byteLength = arrayBuffer.byteLength;\n      return data;\n    }\n  }\n\n  return features;\n}\n\nfunction normalizeOptions(options) {\n  if (options) {\n    options = _objectSpread(_objectSpread({}, options), {}, {\n      mvt: options.mvt || {},\n      gis: options.gis || {}\n    });\n    var wgs84Coordinates = options.coordinates === 'wgs84';\n    var _options = options,\n        tileIndex = _options.tileIndex;\n    var hasTileIndex = tileIndex && Number.isFinite(tileIndex.x) && Number.isFinite(tileIndex.y) && Number.isFinite(tileIndex.z);\n\n    if (wgs84Coordinates && !hasTileIndex) {\n      throw new Error('MVT Loader: WGS84 coordinates need tileIndex property. Check documentation.');\n    }\n  }\n\n  return options;\n}\n\nfunction getDecodedFeature(feature, options) {\n  var decodedFeature = feature.toGeoJSON(options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinates);\n\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n\nfunction getDecodedFeatureBinary(feature, options) {\n  var decodedFeature = feature.toBinaryCoordinates(options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinatesBinary);\n\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n\nfunction transformToLocalCoordinates(line, feature) {\n  var extent = feature.extent;\n\n  for (var i = 0; i < line.length; i++) {\n    var p = line[i];\n    p[0] /= extent;\n    p[1] /= extent;\n  }\n}\n\nfunction transformToLocalCoordinatesBinary(data, feature) {\n  var extent = feature.extent;\n\n  for (var i = 0, il = data.length; i < il; ++i) {\n    data[i] /= extent;\n  }\n}","map":{"version":3,"sources":["../../../src/lib/parse-mvt.ts"],"names":["options","normalizeOptions","features","binary","firstPassData","pointPositionsCount","pointFeaturesCount","linePositionsCount","linePathsCount","lineFeaturesCount","polygonPositionsCount","polygonObjectsCount","polygonRingsCount","polygonFeaturesCount","arrayBuffer","tile","loaderOptions","selectedLayers","Array","Object","layerName","vectorTileLayer","featureOptions","i","vectorTileFeature","decodedFeature","getDecodedFeatureBinary","getDecodedFeature","data","featuresToBinary","mvt","gis","wgs84Coordinates","tileIndex","hasTileIndex","Number","feature","extent","line","p","il"],"mappings":"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","sourcesContent":["// import {VectorTile} from '@mapbox/vector-tile';\nimport VectorTile from './mapbox-vector-tile/vector-tile';\nimport BinaryVectorTile from './binary-vector-tile/vector-tile';\n\nimport {featuresToBinary} from './binary-vector-tile/features-to-binary';\nimport Protobuf from 'pbf';\nimport {MvtBinaryCoordinates, MvtMapboxCoordinates, MvtOptions} from '../lib/types';\nimport VectorTileFeatureBinary from './binary-vector-tile/vector-tile-feature';\nimport VectorTileFeatureMapBox from './mapbox-vector-tile/vector-tile-feature';\nimport {LoaderOptions} from '@loaders.gl/loader-utils';\n\n/**\n * Parse MVT arrayBuffer and return GeoJSON.\n *\n * @param arrayBuffer A MVT arrayBuffer\n * @param options\n * @returns A GeoJSON geometry object or a binary representation\n */\nexport default function parseMVT(arrayBuffer: ArrayBuffer, options?: LoaderOptions) {\n  options = normalizeOptions(options);\n  const features: (MvtBinaryCoordinates | MvtMapboxCoordinates)[] = [];\n\n  if (options) {\n    const binary = options.gis.format === 'binary';\n    const firstPassData = {\n      pointPositionsCount: 0,\n      pointFeaturesCount: 0,\n      linePositionsCount: 0,\n      linePathsCount: 0,\n      lineFeaturesCount: 0,\n      polygonPositionsCount: 0,\n      polygonObjectsCount: 0,\n      polygonRingsCount: 0,\n      polygonFeaturesCount: 0\n    };\n\n    if (arrayBuffer.byteLength > 0) {\n      const tile = binary\n        ? new BinaryVectorTile(new Protobuf(arrayBuffer))\n        : new VectorTile(new Protobuf(arrayBuffer));\n      const loaderOptions = options.mvt;\n\n      const selectedLayers = Array.isArray(loaderOptions.layers)\n        ? loaderOptions.layers\n        : Object.keys(tile.layers);\n\n      selectedLayers.forEach((layerName: string) => {\n        const vectorTileLayer = tile.layers[layerName];\n        const featureOptions = {...loaderOptions, layerName};\n\n        if (!vectorTileLayer) {\n          return;\n        }\n\n        for (let i = 0; i < vectorTileLayer.length; i++) {\n          const vectorTileFeature = vectorTileLayer.feature(i, firstPassData);\n\n          const decodedFeature = binary\n            ? getDecodedFeatureBinary(vectorTileFeature as VectorTileFeatureBinary, featureOptions)\n            : getDecodedFeature(vectorTileFeature as VectorTileFeatureMapBox, featureOptions);\n          features.push(decodedFeature);\n        }\n      });\n    }\n\n    if (binary) {\n      const data = featuresToBinary(features as MvtBinaryCoordinates[], firstPassData);\n      // Add the original byteLength (as a reasonable approximation of the size of the binary data)\n      // TODO decide where to store extra fields like byteLength (header etc) and document\n      // @ts-ignore\n      data.byteLength = arrayBuffer.byteLength;\n      return data;\n    }\n  }\n  return features;\n}\n\n/**\n * @param options\n * @returns options\n */\nfunction normalizeOptions(options: LoaderOptions | undefined) {\n  if (options) {\n    options = {\n      ...options,\n      mvt: options.mvt || {},\n      gis: options.gis || {}\n    };\n\n    // Validate\n    const wgs84Coordinates = options.coordinates === 'wgs84';\n    const {tileIndex} = options;\n    const hasTileIndex =\n      tileIndex &&\n      Number.isFinite(tileIndex.x) &&\n      Number.isFinite(tileIndex.y) &&\n      Number.isFinite(tileIndex.z);\n\n    if (wgs84Coordinates && !hasTileIndex) {\n      throw new Error(\n        'MVT Loader: WGS84 coordinates need tileIndex property. Check documentation.'\n      );\n    }\n  }\n  return options;\n}\n\n/**\n * @param feature\n * @param options\n * @returns decoded feature\n */\nfunction getDecodedFeature(\n  feature: VectorTileFeatureMapBox,\n  options: MvtOptions\n): MvtMapboxCoordinates {\n  const decodedFeature = feature.toGeoJSON(\n    options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinates\n  );\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n\n/**\n * @param feature\n * @param options\n * @returns decoded binary feature\n */\nfunction getDecodedFeatureBinary(\n  feature: VectorTileFeatureBinary,\n  options: MvtOptions\n): MvtBinaryCoordinates {\n  const decodedFeature = feature.toBinaryCoordinates(\n    options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinatesBinary\n  );\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n\n/**\n * @param line\n * @param feature\n */\nfunction transformToLocalCoordinates(line: number[], feature: {extent: any}): void {\n  // This function transforms local coordinates in a\n  // [0 - bufferSize, this.extent + bufferSize] range to a\n  // [0 - (bufferSize / this.extent), 1 + (bufferSize / this.extent)] range.\n  // The resulting extent would be 1.\n  const {extent} = feature;\n  for (let i = 0; i < line.length; i++) {\n    const p = line[i];\n    p[0] /= extent;\n    p[1] /= extent;\n  }\n}\n\nfunction transformToLocalCoordinatesBinary(data: number[], feature: {extent: any}) {\n  // For the binary code path, the feature data is just\n  // one big flat array, so we just divide each value\n  const {extent} = feature;\n  for (let i = 0, il = data.length; i < il; ++i) {\n    data[i] /= extent;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}