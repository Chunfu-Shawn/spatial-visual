{"ast":null,"code":"import { selector as parseSelector } from 'vega-event-selector';\nimport { X, Y } from '../../../channel';\nimport { BRUSH as INTERVAL_BRUSH } from '../interval';\nimport scalesCompiler, { domain } from './scales';\nvar ANCHOR = '_translate_anchor';\nvar DELTA = '_translate_delta';\nvar translate = {\n  has: function has(selCmpt) {\n    return selCmpt.type === 'interval' && selCmpt.translate;\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    var name = selCmpt.name;\n    var hasScales = scalesCompiler.has(selCmpt);\n    var anchor = name + ANCHOR;\n    var _selCmpt$project$hasC = selCmpt.project.hasChannel,\n        x = _selCmpt$project$hasC.x,\n        y = _selCmpt$project$hasC.y;\n    var events = parseSelector(selCmpt.translate, 'scope');\n\n    if (!hasScales) {\n      events = events.map(function (e) {\n        return e.between[0].markname = name + INTERVAL_BRUSH, e;\n      });\n    }\n\n    _signals.push({\n      name: anchor,\n      value: {},\n      on: [{\n        events: events.map(function (e) {\n          return e.between[0];\n        }),\n        update: '{x: x(unit), y: y(unit)' + (x !== undefined ? ', extent_x: ' + (hasScales ? domain(model, X) : \"slice(\".concat(x.signals.visual, \")\")) : '') + (y !== undefined ? ', extent_y: ' + (hasScales ? domain(model, Y) : \"slice(\".concat(y.signals.visual, \")\")) : '') + '}'\n      }]\n    }, {\n      name: name + DELTA,\n      value: {},\n      on: [{\n        events: events,\n        update: \"{x: \".concat(anchor, \".x - x(unit), y: \").concat(anchor, \".y - y(unit)}\")\n      }]\n    });\n\n    if (x !== undefined) {\n      onDelta(model, selCmpt, x, 'width', _signals);\n    }\n\n    if (y !== undefined) {\n      onDelta(model, selCmpt, y, 'height', _signals);\n    }\n\n    return _signals;\n  }\n};\nexport default translate;\n\nfunction onDelta(model, selCmpt, proj, size, signals) {\n  var _a;\n\n  var name = selCmpt.name;\n  var anchor = name + ANCHOR;\n  var delta = name + DELTA;\n  var channel = proj.channel;\n  var hasScales = scalesCompiler.has(selCmpt);\n  var signal = signals.filter(function (s) {\n    return s.name === proj.signals[hasScales ? 'data' : 'visual'];\n  })[0];\n  var sizeSg = model.getSizeSignalRef(size).signal;\n  var scaleCmpt = model.getScaleComponent(channel);\n  var scaleType = scaleCmpt.get('type');\n  var sign = hasScales && channel === X ? '-' : ''; // Invert delta when panning x-scales.\n\n  var extent = \"\".concat(anchor, \".extent_\").concat(channel);\n  var offset = \"\".concat(sign).concat(delta, \".\").concat(channel, \" / \") + (hasScales ? \"\".concat(sizeSg) : \"span(\".concat(extent, \")\"));\n  var panFn = !hasScales ? 'panLinear' : scaleType === 'log' ? 'panLog' : scaleType === 'pow' ? 'panPow' : 'panLinear';\n  var update = \"\".concat(panFn, \"(\").concat(extent, \", \").concat(offset) + (hasScales && scaleType === 'pow' ? \", \".concat((_a = scaleCmpt.get('exponent')) !== null && _a !== void 0 ? _a : 1) : '') + ')';\n  signal.on.push({\n    events: {\n      signal: delta\n    },\n    update: hasScales ? update : \"clampRange(\".concat(update, \", 0, \").concat(sizeSg, \")\")\n  });\n}","map":{"version":3,"sources":["../../../../../src/compile/selection/transforms/translate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { selector as parseSelector } from 'vega-event-selector';\nimport { X, Y } from '../../../channel';\nimport { BRUSH as INTERVAL_BRUSH } from '../interval';\nimport scalesCompiler, { domain } from './scales';\nconst ANCHOR = '_translate_anchor';\nconst DELTA = '_translate_delta';\nconst translate = {\n    has: selCmpt => {\n        return selCmpt.type === 'interval' && selCmpt.translate;\n    },\n    signals: (model, selCmpt, signals) => {\n        const name = selCmpt.name;\n        const hasScales = scalesCompiler.has(selCmpt);\n        const anchor = name + ANCHOR;\n        const { x, y } = selCmpt.project.hasChannel;\n        let events = parseSelector(selCmpt.translate, 'scope');\n        if (!hasScales) {\n            events = events.map(e => ((e.between[0].markname = name + INTERVAL_BRUSH), e));\n        }\n        signals.push({\n            name: anchor,\n            value: {},\n            on: [\n                {\n                    events: events.map(e => e.between[0]),\n                    update: '{x: x(unit), y: y(unit)' +\n                        (x !== undefined ? ', extent_x: ' + (hasScales ? domain(model, X) : `slice(${x.signals.visual})`) : '') +\n                        (y !== undefined ? ', extent_y: ' + (hasScales ? domain(model, Y) : `slice(${y.signals.visual})`) : '') +\n                        '}'\n                }\n            ]\n        }, {\n            name: name + DELTA,\n            value: {},\n            on: [\n                {\n                    events: events,\n                    update: `{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`\n                }\n            ]\n        });\n        if (x !== undefined) {\n            onDelta(model, selCmpt, x, 'width', signals);\n        }\n        if (y !== undefined) {\n            onDelta(model, selCmpt, y, 'height', signals);\n        }\n        return signals;\n    }\n};\nexport default translate;\nfunction onDelta(model, selCmpt, proj, size, signals) {\n    var _a;\n    const name = selCmpt.name;\n    const anchor = name + ANCHOR;\n    const delta = name + DELTA;\n    const channel = proj.channel;\n    const hasScales = scalesCompiler.has(selCmpt);\n    const signal = signals.filter(s => s.name === proj.signals[hasScales ? 'data' : 'visual'])[0];\n    const sizeSg = model.getSizeSignalRef(size).signal;\n    const scaleCmpt = model.getScaleComponent(channel);\n    const scaleType = scaleCmpt.get('type');\n    const sign = hasScales && channel === X ? '-' : ''; // Invert delta when panning x-scales.\n    const extent = `${anchor}.extent_${channel}`;\n    const offset = `${sign}${delta}.${channel} / ` + (hasScales ? `${sizeSg}` : `span(${extent})`);\n    const panFn = !hasScales\n        ? 'panLinear'\n        : scaleType === 'log'\n            ? 'panLog'\n            : scaleType === 'pow'\n                ? 'panPow'\n                : 'panLinear';\n    const update = `${panFn}(${extent}, ${offset}` +\n        (hasScales && scaleType === 'pow' ? `, ${(_a = scaleCmpt.get('exponent')) !== null && _a !== void 0 ? _a : 1}` : '') +\n        ')';\n    signal.on.push({\n        events: { signal: delta },\n        update: hasScales ? update : `clampRange(${update}, 0, ${sizeSg})`\n    });\n}\n//# sourceMappingURL=translate.js.map"]},"metadata":{},"sourceType":"module"}