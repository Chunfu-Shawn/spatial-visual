{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { TUPLE } from '..';\nimport { varName } from '../../../util';\nimport { assembleInit } from '../assemble';\nimport nearest from './nearest';\nimport { TUPLE_FIELDS } from './project';\nimport { isLegendBinding } from '../../../selection';\nvar inputBindings = {\n  has: function has(selCmpt) {\n    return selCmpt.type === 'single' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind !== 'scales' && !isLegendBinding(selCmpt.bind);\n  },\n  parse: function parse(model, selCmpt, selDef, origDef) {\n    // Binding a selection to input widgets disables default direct manipulation interaction.\n    // A user can choose to re-enable it by explicitly specifying triggering input events.\n    if (!origDef.on) delete selCmpt.events;\n    if (!origDef.clear) delete selCmpt.clear;\n  },\n  topLevelSignals: function topLevelSignals(model, selCmpt, signals) {\n    var name = selCmpt.name;\n    var proj = selCmpt.project;\n    var bind = selCmpt.bind;\n    var init = selCmpt.init && selCmpt.init[0]; // Can only exist on single selections (one initial value).\n\n    var datum = nearest.has(selCmpt) ? '(item().isVoronoi ? datum.datum : datum)' : 'datum';\n    proj.items.forEach(function (p, i) {\n      var _a, _b;\n\n      var sgname = varName(\"\".concat(name, \"_\").concat(p.field));\n      var hasSignal = signals.filter(function (s) {\n        return s.name === sgname;\n      });\n\n      if (!hasSignal.length) {\n        signals.unshift(Object.assign(Object.assign({\n          name: sgname\n        }, init ? {\n          init: assembleInit(init[i])\n        } : {\n          value: null\n        }), {\n          on: selCmpt.events ? [{\n            events: selCmpt.events,\n            update: \"datum && item().mark.marktype !== 'group' ? \".concat(datum, \"[\").concat(stringValue(p.field), \"] : null\")\n          }] : [],\n          bind: (_b = (_a = bind[p.field]) !== null && _a !== void 0 ? _a : bind[p.channel]) !== null && _b !== void 0 ? _b : bind\n        }));\n      }\n    });\n    return signals;\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    var name = selCmpt.name;\n    var proj = selCmpt.project;\n\n    var signal = _signals.filter(function (s) {\n      return s.name === name + TUPLE;\n    })[0];\n\n    var fields = name + TUPLE_FIELDS;\n    var values = proj.items.map(function (p) {\n      return varName(\"\".concat(name, \"_\").concat(p.field));\n    });\n    var valid = values.map(function (v) {\n      return \"\".concat(v, \" !== null\");\n    }).join(' && ');\n\n    if (values.length) {\n      signal.update = \"\".concat(valid, \" ? {fields: \").concat(fields, \", values: [\").concat(values.join(', '), \"]} : null\");\n    }\n\n    delete signal.value;\n    delete signal.on;\n    return _signals;\n  }\n};\nexport default inputBindings;","map":{"version":3,"sources":["../../../../../src/compile/selection/transforms/inputs.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { stringValue } from 'vega-util';\nimport { TUPLE } from '..';\nimport { varName } from '../../../util';\nimport { assembleInit } from '../assemble';\nimport nearest from './nearest';\nimport { TUPLE_FIELDS } from './project';\nimport { isLegendBinding } from '../../../selection';\nconst inputBindings = {\n    has: selCmpt => {\n        return (selCmpt.type === 'single' &&\n            selCmpt.resolve === 'global' &&\n            selCmpt.bind &&\n            selCmpt.bind !== 'scales' &&\n            !isLegendBinding(selCmpt.bind));\n    },\n    parse: (model, selCmpt, selDef, origDef) => {\n        // Binding a selection to input widgets disables default direct manipulation interaction.\n        // A user can choose to re-enable it by explicitly specifying triggering input events.\n        if (!origDef.on)\n            delete selCmpt.events;\n        if (!origDef.clear)\n            delete selCmpt.clear;\n    },\n    topLevelSignals: (model, selCmpt, signals) => {\n        const name = selCmpt.name;\n        const proj = selCmpt.project;\n        const bind = selCmpt.bind;\n        const init = selCmpt.init && selCmpt.init[0]; // Can only exist on single selections (one initial value).\n        const datum = nearest.has(selCmpt) ? '(item().isVoronoi ? datum.datum : datum)' : 'datum';\n        proj.items.forEach((p, i) => {\n            var _a, _b;\n            const sgname = varName(`${name}_${p.field}`);\n            const hasSignal = signals.filter(s => s.name === sgname);\n            if (!hasSignal.length) {\n                signals.unshift(Object.assign(Object.assign({ name: sgname }, (init ? { init: assembleInit(init[i]) } : { value: null })), { on: selCmpt.events\n                        ? [\n                            {\n                                events: selCmpt.events,\n                                update: `datum && item().mark.marktype !== 'group' ? ${datum}[${stringValue(p.field)}] : null`\n                            }\n                        ]\n                        : [], bind: (_b = (_a = bind[p.field]) !== null && _a !== void 0 ? _a : bind[p.channel]) !== null && _b !== void 0 ? _b : bind }));\n            }\n        });\n        return signals;\n    },\n    signals: (model, selCmpt, signals) => {\n        const name = selCmpt.name;\n        const proj = selCmpt.project;\n        const signal = signals.filter(s => s.name === name + TUPLE)[0];\n        const fields = name + TUPLE_FIELDS;\n        const values = proj.items.map(p => varName(`${name}_${p.field}`));\n        const valid = values.map(v => `${v} !== null`).join(' && ');\n        if (values.length) {\n            signal.update = `${valid} ? {fields: ${fields}, values: [${values.join(', ')}]} : null`;\n        }\n        delete signal.value;\n        delete signal.on;\n        return signals;\n    }\n};\nexport default inputBindings;\n//# sourceMappingURL=inputs.js.map"]},"metadata":{},"sourceType":"module"}