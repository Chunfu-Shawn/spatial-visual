{"ast":null,"code":"import _regeneratorRuntime from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Tile3DSubtreeLoader } from '../../../tile-3d-subtree-loader';\nimport { load } from '@loaders.gl/core';\nvar QUADTREE_DEVISION_COUNT = 4;\nvar OCTREE_DEVISION_COUNT = 8;\nvar SUBDIVISION_COUNT_MAP = {\n  QUADTREE: QUADTREE_DEVISION_COUNT,\n  OCTREE: OCTREE_DEVISION_COUNT\n};\nexport function parseImplicitTiles(_x, _x2) {\n  return _parseImplicitTiles.apply(this, arguments);\n}\n\nfunction _parseImplicitTiles() {\n  _parseImplicitTiles = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(subtree, options) {\n    var parentData,\n        childIndex,\n        level,\n        globalData,\n        subdivisionScheme,\n        subtreeLevels,\n        maximumLevel,\n        contentUrlTemplate,\n        subtreesUriTemplate,\n        basePath,\n        tile,\n        childrenPerTile,\n        childX,\n        childY,\n        childZ,\n        levelOffset,\n        childTileMortonIndex,\n        tileAvailabilityIndex,\n        childTileX,\n        childTileY,\n        childTileZ,\n        isChildSubtreeAvailable,\n        x,\n        y,\n        z,\n        lev,\n        subtreePath,\n        childSubtreeUrl,\n        childSubtree,\n        isTileAvailable,\n        isContentAvailable,\n        childTileLevel,\n        pData,\n        index,\n        currentTile,\n        globalLevel,\n        formattedTile,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            parentData = _args.length > 2 && _args[2] !== undefined ? _args[2] : {\n              mortonIndex: 0,\n              x: 0,\n              y: 0,\n              z: 0\n            };\n            childIndex = _args.length > 3 && _args[3] !== undefined ? _args[3] : 0;\n            level = _args.length > 4 && _args[4] !== undefined ? _args[4] : 0;\n            globalData = _args.length > 5 && _args[5] !== undefined ? _args[5] : {\n              level: 0,\n              mortonIndex: 0,\n              x: 0,\n              y: 0,\n              z: 0\n            };\n            subdivisionScheme = options.subdivisionScheme, subtreeLevels = options.subtreeLevels, maximumLevel = options.maximumLevel, contentUrlTemplate = options.contentUrlTemplate, subtreesUriTemplate = options.subtreesUriTemplate, basePath = options.basePath;\n            tile = {\n              children: [],\n              lodMetricValue: 0,\n              contentUrl: ''\n            };\n            childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];\n            childX = childIndex & 1;\n            childY = childIndex >> 1 & 1;\n            childZ = childIndex >> 2 & 1;\n            levelOffset = (Math.pow(childrenPerTile, level) - 1) / (childrenPerTile - 1);\n            childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);\n            tileAvailabilityIndex = levelOffset + childTileMortonIndex;\n            childTileX = concatBits(parentData.x, childX);\n            childTileY = concatBits(parentData.y, childY);\n            childTileZ = concatBits(parentData.z, childZ);\n            isChildSubtreeAvailable = false;\n\n            if (level + 1 > subtreeLevels) {\n              isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);\n            }\n\n            x = concatBits(globalData.x, childTileX);\n            y = concatBits(globalData.y, childTileY);\n            z = concatBits(globalData.z, childTileZ);\n            lev = level + globalData.level;\n\n            if (!isChildSubtreeAvailable) {\n              _context.next = 40;\n              break;\n            }\n\n            subtreePath = \"\".concat(basePath, \"/\").concat(subtreesUriTemplate);\n            childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);\n            _context.next = 27;\n            return load(childSubtreeUrl, Tile3DSubtreeLoader);\n\n          case 27:\n            childSubtree = _context.sent;\n            subtree = childSubtree;\n            globalData.mortonIndex = childTileMortonIndex;\n            globalData.x = childTileX;\n            globalData.y = childTileY;\n            globalData.z = childTileZ;\n            globalData.level = level;\n            childTileMortonIndex = 0;\n            tileAvailabilityIndex = 0;\n            childTileX = 0;\n            childTileY = 0;\n            childTileZ = 0;\n            level = 0;\n\n          case 40:\n            isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);\n\n            if (!(!isTileAvailable || level > maximumLevel)) {\n              _context.next = 43;\n              break;\n            }\n\n            return _context.abrupt(\"return\", tile);\n\n          case 43:\n            isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);\n\n            if (isContentAvailable) {\n              tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);\n            }\n\n            childTileLevel = level + 1;\n            pData = {\n              mortonIndex: childTileMortonIndex,\n              x: childTileX,\n              y: childTileY,\n              z: childTileZ\n            };\n            index = 0;\n\n          case 48:\n            if (!(index < childrenPerTile)) {\n              _context.next = 56;\n              break;\n            }\n\n            _context.next = 51;\n            return parseImplicitTiles(subtree, options, pData, index, childTileLevel, globalData);\n\n          case 51:\n            currentTile = _context.sent;\n\n            if (currentTile.contentUrl || currentTile.children.length) {\n              globalLevel = lev + 1;\n              formattedTile = formatTileData(currentTile, globalLevel, options);\n              tile.children.push(formattedTile);\n            }\n\n          case 53:\n            index++;\n            _context.next = 48;\n            break;\n\n          case 56:\n            return _context.abrupt(\"return\", tile);\n\n          case 57:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseImplicitTiles.apply(this, arguments);\n}\n\nfunction getAvailabilityResult(availabilityData, index) {\n  if ('constant' in availabilityData) {\n    return Boolean(availabilityData.constant);\n  }\n\n  if (availabilityData.explicitBitstream) {\n    return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);\n  }\n\n  return false;\n}\n\nfunction formatTileData(tile, level, options) {\n  var basePath = options.basePath,\n      refine = options.refine,\n      getRefine = options.getRefine,\n      lodMetricType = options.lodMetricType,\n      getTileType = options.getTileType,\n      rootLodMetricValue = options.rootLodMetricValue;\n  var uri = tile.contentUrl && tile.contentUrl.replace(\"\".concat(basePath, \"/\"), '');\n  var lodMetricValue = rootLodMetricValue / Math.pow(2, level);\n  return {\n    children: tile.children,\n    contentUrl: tile.contentUrl,\n    content: {\n      uri: uri\n    },\n    id: tile.contentUrl,\n    refine: getRefine(refine),\n    type: getTileType(tile),\n    lodMetricType: lodMetricType,\n    lodMetricValue: lodMetricValue\n  };\n}\n\nfunction concatBits(first, second) {\n  return parseInt(first.toString(2) + second.toString(2), 2);\n}\n\nexport function replaceContentUrlTemplate(templateUrl, level, x, y, z) {\n  var mapUrl = generateMapUrl({\n    level: level,\n    x: x,\n    y: y,\n    z: z\n  });\n  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, function (matched) {\n    return mapUrl[matched];\n  });\n}\n\nfunction generateMapUrl(items) {\n  var mapUrl = {};\n\n  for (var key in items) {\n    mapUrl[\"{\".concat(key, \"}\")] = items[key];\n  }\n\n  return mapUrl;\n}\n\nfunction getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {\n  var byteIndex = Math.floor(availabilityIndex / 8);\n  var bitIndex = availabilityIndex % 8;\n  var bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;\n  return bitValue === 1;\n}","map":{"version":3,"sources":["../../../../../src/lib/parsers/helpers/parse-3d-implicit-tiles.ts"],"names":["QUADTREE_DEVISION_COUNT","OCTREE_DEVISION_COUNT","SUBDIVISION_COUNT_MAP","QUADTREE","OCTREE","parentData","mortonIndex","x","y","z","childIndex","level","globalData","basePath","tile","children","lodMetricValue","contentUrl","childrenPerTile","childX","childY","childZ","levelOffset","childTileMortonIndex","concatBits","tileAvailabilityIndex","childTileX","childTileY","childTileZ","isChildSubtreeAvailable","getAvailabilityResult","subtree","lev","subtreePath","childSubtreeUrl","replaceContentUrlTemplate","childSubtree","load","isTileAvailable","isContentAvailable","childTileLevel","pData","index","currentTile","parseImplicitTiles","globalLevel","formattedTile","formatTileData","Boolean","availabilityData","getBooleanValueFromBitstream","rootLodMetricValue","uri","content","id","refine","getRefine","type","getTileType","lodMetricType","parseInt","first","second","mapUrl","generateMapUrl","templateUrl","matched","items","byteIndex","Math","availabilityIndex","bitIndex","bitValue","availabilityBuffer"],"mappings":"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","sourcesContent":["import type {Availability, Subtree} from '../../../types';\nimport {Tile3DSubtreeLoader} from '../../../tile-3d-subtree-loader';\nimport {load} from '@loaders.gl/core';\n\nconst QUADTREE_DEVISION_COUNT = 4;\nconst OCTREE_DEVISION_COUNT = 8;\n\nconst SUBDIVISION_COUNT_MAP = {\n  QUADTREE: QUADTREE_DEVISION_COUNT,\n  OCTREE: OCTREE_DEVISION_COUNT\n};\n\n/**\n * Recursively parse implicit tiles tree\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling\n * TODO Check out do we able to use Tile3D class as return type here.\n * @param subtree\n * @param lodMetricValue\n * @param options\n * @param parentData\n * @param childIndex\n * @param level\n * @param globalData\n */\n// eslint-disable-next-line max-params\n// eslint-disable-next-line max-statements\nexport async function parseImplicitTiles(\n  subtree: Subtree,\n  options: any,\n  parentData: {mortonIndex: number; x: number; y: number; z: number} = {\n    mortonIndex: 0,\n    x: 0,\n    y: 0,\n    z: 0\n  },\n  childIndex: number = 0,\n  level: number = 0,\n  globalData: {level: number; mortonIndex: number; x: number; y: number; z: number} = {\n    level: 0,\n    mortonIndex: 0,\n    x: 0,\n    y: 0,\n    z: 0\n  }\n) {\n  const {\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    basePath\n  } = options;\n\n  const tile = {children: [], lodMetricValue: 0, contentUrl: ''};\n\n  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];\n\n  const childX = childIndex & 0b01;\n  const childY = (childIndex >> 1) & 0b01;\n  const childZ = (childIndex >> 2) & 0b01;\n\n  const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);\n  let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);\n  let tileAvailabilityIndex = levelOffset + childTileMortonIndex;\n\n  // Local tile coordinates\n  let childTileX = concatBits(parentData.x, childX);\n  let childTileY = concatBits(parentData.y, childY);\n  let childTileZ = concatBits(parentData.z, childZ);\n\n  // TODO Remove after real implicit tileset will be tested.\n  // Degug data\n  // tile.level = level + globalData.level;\n  // tile.x = concatBits(globalData.x, childTileX);\n  // tile.y = concatBits(globalData.y, childTileY);\n  // tile.z = concatBits(globalData.z, childTileZ);\n  // tile.mortonIndex = childTileMortonIndex;\n  // End of debug data\n\n  let isChildSubtreeAvailable = false;\n\n  if (level + 1 > subtreeLevels) {\n    isChildSubtreeAvailable = getAvailabilityResult(\n      subtree.childSubtreeAvailability,\n      childTileMortonIndex\n    );\n  }\n\n  const x = concatBits(globalData.x, childTileX);\n  const y = concatBits(globalData.y, childTileY);\n  const z = concatBits(globalData.z, childTileZ);\n  const lev = level + globalData.level;\n\n  if (isChildSubtreeAvailable) {\n    const subtreePath = `${basePath}/${subtreesUriTemplate}`;\n    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);\n    const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader);\n\n    subtree = childSubtree;\n\n    globalData.mortonIndex = childTileMortonIndex;\n    globalData.x = childTileX;\n    globalData.y = childTileY;\n    globalData.z = childTileZ;\n    globalData.level = level;\n\n    childTileMortonIndex = 0;\n    tileAvailabilityIndex = 0;\n    childTileX = 0;\n    childTileY = 0;\n    childTileZ = 0;\n    level = 0;\n  }\n\n  const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);\n\n  if (!isTileAvailable || level > maximumLevel) {\n    return tile;\n  }\n\n  const isContentAvailable = getAvailabilityResult(\n    subtree.contentAvailability,\n    tileAvailabilityIndex\n  );\n\n  if (isContentAvailable) {\n    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);\n  }\n\n  const childTileLevel = level + 1;\n  const pData = {mortonIndex: childTileMortonIndex, x: childTileX, y: childTileY, z: childTileZ};\n\n  for (let index = 0; index < childrenPerTile; index++) {\n    const currentTile = await parseImplicitTiles(\n      subtree,\n      options,\n      pData,\n      index,\n      childTileLevel,\n      globalData\n    );\n\n    if (currentTile.contentUrl || currentTile.children.length) {\n      const globalLevel = lev + 1;\n      const formattedTile = formatTileData(currentTile, globalLevel, options);\n      // @ts-ignore\n      tile.children.push(formattedTile);\n    }\n  }\n\n  return tile;\n}\n\nfunction getAvailabilityResult(availabilityData: Availability, index: number): boolean {\n  if ('constant' in availabilityData) {\n    return Boolean(availabilityData.constant);\n  }\n\n  if (availabilityData.explicitBitstream) {\n    return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);\n  }\n\n  return false;\n}\n\n/**\n * Do formatting of implicit tile data.\n * TODO Check out do we able to use Tile3D class as type here.\n * @param tile\n * @param lodMetricValue\n * @param options\n * @returns\n */\nfunction formatTileData(tile, level: number, options: any) {\n  const {basePath, refine, getRefine, lodMetricType, getTileType, rootLodMetricValue} = options;\n  const uri = tile.contentUrl && tile.contentUrl.replace(`${basePath}/`, '');\n  const lodMetricValue = rootLodMetricValue / 2 ** level;\n  // TODO handle bounding volume\n  return {\n    children: tile.children,\n    contentUrl: tile.contentUrl,\n    content: {uri},\n    id: tile.contentUrl,\n    refine: getRefine(refine),\n    type: getTileType(tile),\n    lodMetricType,\n    lodMetricValue\n    // Temp debug values. Remove when real implicit tileset will be tested.\n    // x: tile.x,\n    // y: tile.y,\n    // z: tile.z,\n    // level: tile.level\n  };\n}\n\n/**\n * Do binary concatenation\n * @param first\n * @param second\n */\nfunction concatBits(first: number, second: number): number {\n  return parseInt(first.toString(2) + second.toString(2), 2);\n}\n\n/**\n * Replace implicit tile content url with real coordinates.\n * @param templateUrl\n * @param level\n * @param x\n * @param y\n * @param z\n */\nexport function replaceContentUrlTemplate(\n  templateUrl: string,\n  level: number,\n  x: number,\n  y: number,\n  z: number\n): string {\n  const mapUrl = generateMapUrl({level, x, y, z});\n  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);\n}\n\n/**\n * Get Map object for content url generation\n * @param items\n */\nfunction generateMapUrl(items: {[key: string]: number}): {[key: string]: string} {\n  const mapUrl = {};\n\n  for (const key in items) {\n    mapUrl[`{${key}}`] = items[key];\n  }\n  return mapUrl;\n}\n\n/**\n * Get boolean value from bistream by index\n * A boolean value is encoded as a single bit, either 0 (false) or 1 (true).\n * Multiple boolean values are packed tightly in the same buffer.\n * These buffers of tightly-packed bits are sometimes referred to as bitstreams.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/implicit-revisions/specification/Metadata#booleans\n * @param availabilitiIndex\n */\nfunction getBooleanValueFromBitstream(\n  availabilityIndex: number,\n  availabilityBuffer: Uint8Array\n): boolean {\n  const byteIndex = Math.floor(availabilityIndex / 8);\n  const bitIndex = availabilityIndex % 8;\n  const bitValue = (availabilityBuffer[byteIndex] >> bitIndex) & 1;\n\n  return bitValue === 1;\n}\n"]},"metadata":{},"sourceType":"module"}