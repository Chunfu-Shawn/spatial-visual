{"ast":null,"code":"import _toConsumableArray from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { isFieldDef } from '../../channeldef';\nimport { pathGroupingFields } from '../../encoding';\nimport { isImputeSequence } from '../../transform';\nimport { duplicate, hash as _hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport var ImputeNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(ImputeNode, _DataFlowNode);\n\n  var _super = _createSuper(ImputeNode);\n\n  function ImputeNode(parent, transform) {\n    var _this;\n\n    _classCallCheck(this, ImputeNode);\n\n    _this = _super.call(this, parent);\n    _this.transform = transform;\n    return _this;\n  }\n\n  _createClass(ImputeNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new ImputeNode(null, duplicate(this.transform));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      var _a;\n\n      return new Set([this.transform.impute, this.transform.key].concat(_toConsumableArray((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : [])));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set([this.transform.impute]);\n    }\n  }, {\n    key: \"processSequence\",\n    value: function processSequence(keyvals) {\n      var _keyvals$start = keyvals.start,\n          start = _keyvals$start === void 0 ? 0 : _keyvals$start,\n          stop = keyvals.stop,\n          step = keyvals.step;\n      var result = [start, stop].concat(_toConsumableArray(step ? [step] : [])).join(',');\n      return {\n        signal: \"sequence(\".concat(result, \")\")\n      };\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Impute \".concat(_hash(this.transform));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var _this$transform = this.transform,\n          impute = _this$transform.impute,\n          key = _this$transform.key,\n          keyvals = _this$transform.keyvals,\n          method = _this$transform.method,\n          groupby = _this$transform.groupby,\n          value = _this$transform.value,\n          _this$transform$frame = _this$transform.frame,\n          frame = _this$transform$frame === void 0 ? [null, null] : _this$transform$frame;\n      var imputeTransform = Object.assign(Object.assign(Object.assign(Object.assign({\n        type: 'impute',\n        field: impute,\n        key: key\n      }, keyvals ? {\n        keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals\n      } : {}), {\n        method: 'value'\n      }), groupby ? {\n        groupby: groupby\n      } : {}), {\n        value: !method || method === 'value' ? value : null\n      });\n\n      if (method && method !== 'value') {\n        var deriveNewField = Object.assign({\n          type: 'window',\n          as: [\"imputed_\".concat(impute, \"_value\")],\n          ops: [method],\n          fields: [impute],\n          frame: frame,\n          ignorePeers: false\n        }, groupby ? {\n          groupby: groupby\n        } : {});\n        var replaceOriginal = {\n          type: 'formula',\n          expr: \"datum.\".concat(impute, \" === null ? datum.imputed_\").concat(impute, \"_value : datum.\").concat(impute),\n          as: impute\n        };\n        return [imputeTransform, deriveNewField, replaceOriginal];\n      } else {\n        return [imputeTransform];\n      }\n    }\n  }], [{\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, imputeTransform) {\n      return new ImputeNode(parent, imputeTransform);\n    }\n  }, {\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var encoding = model.encoding;\n      var xDef = encoding.x;\n      var yDef = encoding.y;\n\n      if (isFieldDef(xDef) && isFieldDef(yDef)) {\n        var imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n\n        if (imputedChannel === undefined) {\n          return undefined;\n        }\n\n        var keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n        var _imputedChannel$imput = imputedChannel.impute,\n            method = _imputedChannel$imput.method,\n            value = _imputedChannel$imput.value,\n            frame = _imputedChannel$imput.frame,\n            keyvals = _imputedChannel$imput.keyvals;\n        var groupbyFields = pathGroupingFields(model.mark, encoding);\n        return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n          impute: imputedChannel.field,\n          key: keyChannel.field\n        }, method ? {\n          method: method\n        } : {}), value !== undefined ? {\n          value: value\n        } : {}), frame ? {\n          frame: frame\n        } : {}), keyvals !== undefined ? {\n          keyvals: keyvals\n        } : {}), groupbyFields.length ? {\n          groupby: groupbyFields\n        } : {}));\n      }\n\n      return null;\n    }\n  }]);\n\n  return ImputeNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/impute.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isFieldDef } from '../../channeldef';\nimport { pathGroupingFields } from '../../encoding';\nimport { isImputeSequence } from '../../transform';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class ImputeNode extends DataFlowNode {\n    constructor(parent, transform) {\n        super(parent);\n        this.transform = transform;\n    }\n    clone() {\n        return new ImputeNode(null, duplicate(this.transform));\n    }\n    dependentFields() {\n        var _a;\n        return new Set([this.transform.impute, this.transform.key, ...((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : [])]);\n    }\n    producedFields() {\n        return new Set([this.transform.impute]);\n    }\n    processSequence(keyvals) {\n        const { start = 0, stop, step } = keyvals;\n        const result = [start, stop, ...(step ? [step] : [])].join(',');\n        return { signal: `sequence(${result})` };\n    }\n    static makeFromTransform(parent, imputeTransform) {\n        return new ImputeNode(parent, imputeTransform);\n    }\n    static makeFromEncoding(parent, model) {\n        const encoding = model.encoding;\n        const xDef = encoding.x;\n        const yDef = encoding.y;\n        if (isFieldDef(xDef) && isFieldDef(yDef)) {\n            const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n            if (imputedChannel === undefined) {\n                return undefined;\n            }\n            const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n            const { method, value, frame, keyvals } = imputedChannel.impute;\n            const groupbyFields = pathGroupingFields(model.mark, encoding);\n            return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ impute: imputedChannel.field, key: keyChannel.field }, (method ? { method } : {})), (value !== undefined ? { value } : {})), (frame ? { frame } : {})), (keyvals !== undefined ? { keyvals } : {})), (groupbyFields.length ? { groupby: groupbyFields } : {})));\n        }\n        return null;\n    }\n    hash() {\n        return `Impute ${hash(this.transform)}`;\n    }\n    assemble() {\n        const { impute, key, keyvals, method, groupby, value, frame = [null, null] } = this.transform;\n        const imputeTransform = Object.assign(Object.assign(Object.assign(Object.assign({ type: 'impute', field: impute, key }, (keyvals ? { keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals } : {})), { method: 'value' }), (groupby ? { groupby } : {})), { value: !method || method === 'value' ? value : null });\n        if (method && method !== 'value') {\n            const deriveNewField = Object.assign({ type: 'window', as: [`imputed_${impute}_value`], ops: [method], fields: [impute], frame, ignorePeers: false }, (groupby ? { groupby } : {}));\n            const replaceOriginal = {\n                type: 'formula',\n                expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,\n                as: impute\n            };\n            return [imputeTransform, deriveNewField, replaceOriginal];\n        }\n        else {\n            return [imputeTransform];\n        }\n    }\n}\n//# sourceMappingURL=impute.js.map"]},"metadata":{},"sourceType":"module"}