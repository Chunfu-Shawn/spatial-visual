{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { forEachSelection, MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE } from '.';\nimport { dateTimeToExpr, isDateTime, dateTimeToTimestamp } from '../../datetime';\nimport { keys, varName } from '../../util';\nimport { isUnitModel } from '../model';\nimport { forEachTransform } from './transforms/transforms';\nimport { parseSelectionBinExtent } from './parse';\nexport function assembleInit(init) {\n  var isExpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n\n  if (isArray(init)) {\n    var assembled = init.map(function (v) {\n      return assembleInit(v, isExpr, wrap);\n    });\n    return isExpr ? \"[\".concat(assembled.join(', '), \"]\") : assembled;\n  } else if (isDateTime(init)) {\n    if (isExpr) {\n      return wrap(dateTimeToExpr(init));\n    } else {\n      return wrap(dateTimeToTimestamp(init));\n    }\n  }\n\n  return isExpr ? wrap(JSON.stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n  forEachSelection(model, function (selCmpt, selCompiler) {\n    var _signals;\n\n    var name = selCmpt.name;\n    var modifyExpr = selCompiler.modifyExpr(model, selCmpt);\n\n    (_signals = signals).push.apply(_signals, _toConsumableArray(selCompiler.signals(model, selCmpt)));\n\n    forEachTransform(selCmpt, function (txCompiler) {\n      if (txCompiler.signals) {\n        signals = txCompiler.signals(model, selCmpt, signals);\n      }\n\n      if (txCompiler.modifyExpr) {\n        modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);\n      }\n    });\n    signals.push({\n      name: name + MODIFY,\n      on: [{\n        events: {\n          signal: selCmpt.name + TUPLE\n        },\n        update: \"modify(\".concat(stringValue(selCmpt.name + STORE), \", \").concat(modifyExpr, \")\")\n      }]\n    });\n  });\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    var name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [{\n        events: parseSelector('mousemove', 'scope'),\n        update: \"isTuple(facet) ? facet : group(\".concat(name, \").datum\")\n      }]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n  var hasSelections = false;\n  forEachSelection(model, function (selCmpt, selCompiler) {\n    var name = selCmpt.name;\n    var store = stringValue(name + STORE);\n    var hasSg = signals.filter(function (s) {\n      return s.name === name;\n    });\n\n    if (hasSg.length === 0) {\n      var resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n      var isMulti = selCmpt.type === 'multi' ? ', true)' : ')';\n      signals.push({\n        name: selCmpt.name,\n        update: \"\".concat(VL_SELECTION_RESOLVE, \"(\").concat(store, \", \").concat(stringValue(resolve)).concat(isMulti)\n      });\n    }\n\n    hasSelections = true;\n\n    if (selCompiler.topLevelSignals) {\n      signals = selCompiler.topLevelSignals(model, selCmpt, signals);\n    }\n\n    forEachTransform(selCmpt, function (txCompiler) {\n      if (txCompiler.topLevelSignals) {\n        signals = txCompiler.topLevelSignals(model, selCmpt, signals);\n      }\n    });\n  });\n\n  if (hasSelections) {\n    var hasUnit = signals.filter(function (s) {\n      return s.name === 'unit';\n    });\n\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{\n          events: 'mousemove',\n          update: 'isTuple(group()) ? group() : unit'\n        }]\n      });\n    }\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n  var dataCopy = _toConsumableArray(data);\n\n  forEachSelection(model, function (selCmpt) {\n    var init = {\n      name: selCmpt.name + STORE\n    };\n\n    if (selCmpt.init) {\n      var fields = selCmpt.project.items.map(function (proj) {\n        var signals = proj.signals,\n            rest = __rest(proj, [\"signals\"]);\n\n        return rest;\n      });\n      var insert = selCmpt.init.map(function (i) {\n        return assembleInit(i, false);\n      });\n      init.values = selCmpt.type === 'interval' ? [{\n        unit: unitName(model, {\n          escape: false\n        }),\n        fields: fields,\n        values: insert\n      }] : insert.map(function (i) {\n        return {\n          unit: unitName(model, {\n            escape: false\n          }),\n          fields: fields,\n          values: i\n        };\n      });\n    }\n\n    var contains = dataCopy.filter(function (d) {\n      return d.name === selCmpt.name + STORE;\n    });\n\n    if (!contains.length) {\n      dataCopy.push(init);\n    }\n  });\n  return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n  forEachSelection(model, function (selCmpt, selCompiler) {\n    marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;\n    forEachTransform(selCmpt, function (txCompiler) {\n      if (txCompiler.marks) {\n        marks = txCompiler.marks(model, selCmpt, marks);\n      }\n    });\n  });\n  return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n  var _iterator = _createForOfIteratorHelper(model.children),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n\n      if (isUnitModel(child)) {\n        marks = assembleUnitSelectionMarks(child, marks);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent) {\n  var name = extent.selection;\n  var selCmpt = model.getSelectionComponent(name, varName(name));\n  return {\n    signal: parseSelectionBinExtent(selCmpt, extent)\n  };\n}\n\nfunction cleanupEmptyOnArray(signals) {\n  return signals.map(function (s) {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}","map":{"version":3,"sources":["../../../../src/compile/selection/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { forEachSelection, MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE } from '.';\nimport { dateTimeToExpr, isDateTime, dateTimeToTimestamp } from '../../datetime';\nimport { keys, varName } from '../../util';\nimport { isUnitModel } from '../model';\nimport { forEachTransform } from './transforms/transforms';\nimport { parseSelectionBinExtent } from './parse';\nexport function assembleInit(init, isExpr = true, wrap = identity) {\n    if (isArray(init)) {\n        const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n        return isExpr ? `[${assembled.join(', ')}]` : assembled;\n    }\n    else if (isDateTime(init)) {\n        if (isExpr) {\n            return wrap(dateTimeToExpr(init));\n        }\n        else {\n            return wrap(dateTimeToTimestamp(init));\n        }\n    }\n    return isExpr ? wrap(JSON.stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n    forEachSelection(model, (selCmpt, selCompiler) => {\n        const name = selCmpt.name;\n        let modifyExpr = selCompiler.modifyExpr(model, selCmpt);\n        signals.push(...selCompiler.signals(model, selCmpt));\n        forEachTransform(selCmpt, txCompiler => {\n            if (txCompiler.signals) {\n                signals = txCompiler.signals(model, selCmpt, signals);\n            }\n            if (txCompiler.modifyExpr) {\n                modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);\n            }\n        });\n        signals.push({\n            name: name + MODIFY,\n            on: [\n                {\n                    events: { signal: selCmpt.name + TUPLE },\n                    update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n                }\n            ]\n        });\n    });\n    return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n    if (model.component.selection && keys(model.component.selection).length) {\n        const name = stringValue(model.getName('cell'));\n        signals.unshift({\n            name: 'facet',\n            value: {},\n            on: [\n                {\n                    events: parseSelector('mousemove', 'scope'),\n                    update: `isTuple(facet) ? facet : group(${name}).datum`\n                }\n            ]\n        });\n    }\n    return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n    let hasSelections = false;\n    forEachSelection(model, (selCmpt, selCompiler) => {\n        const name = selCmpt.name;\n        const store = stringValue(name + STORE);\n        const hasSg = signals.filter(s => s.name === name);\n        if (hasSg.length === 0) {\n            const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n            const isMulti = selCmpt.type === 'multi' ? ', true)' : ')';\n            signals.push({\n                name: selCmpt.name,\n                update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isMulti}`\n            });\n        }\n        hasSelections = true;\n        if (selCompiler.topLevelSignals) {\n            signals = selCompiler.topLevelSignals(model, selCmpt, signals);\n        }\n        forEachTransform(selCmpt, txCompiler => {\n            if (txCompiler.topLevelSignals) {\n                signals = txCompiler.topLevelSignals(model, selCmpt, signals);\n            }\n        });\n    });\n    if (hasSelections) {\n        const hasUnit = signals.filter(s => s.name === 'unit');\n        if (hasUnit.length === 0) {\n            signals.unshift({\n                name: 'unit',\n                value: {},\n                on: [{ events: 'mousemove', update: 'isTuple(group()) ? group() : unit' }]\n            });\n        }\n    }\n    return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n    const dataCopy = [...data];\n    forEachSelection(model, selCmpt => {\n        const init = { name: selCmpt.name + STORE };\n        if (selCmpt.init) {\n            const fields = selCmpt.project.items.map(proj => {\n                const { signals } = proj, rest = __rest(proj, [\"signals\"]);\n                return rest;\n            });\n            const insert = selCmpt.init.map(i => assembleInit(i, false));\n            init.values =\n                selCmpt.type === 'interval'\n                    ? [{ unit: unitName(model, { escape: false }), fields, values: insert }]\n                    : insert.map(i => ({ unit: unitName(model, { escape: false }), fields, values: i }));\n        }\n        const contains = dataCopy.filter(d => d.name === selCmpt.name + STORE);\n        if (!contains.length) {\n            dataCopy.push(init);\n        }\n    });\n    return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n    forEachSelection(model, (selCmpt, selCompiler) => {\n        marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;\n        forEachTransform(selCmpt, txCompiler => {\n            if (txCompiler.marks) {\n                marks = txCompiler.marks(model, selCmpt, marks);\n            }\n        });\n    });\n    return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n    for (const child of model.children) {\n        if (isUnitModel(child)) {\n            marks = assembleUnitSelectionMarks(child, marks);\n        }\n    }\n    return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent) {\n    const name = extent.selection;\n    const selCmpt = model.getSelectionComponent(name, varName(name));\n    return { signal: parseSelectionBinExtent(selCmpt, extent) };\n}\nfunction cleanupEmptyOnArray(signals) {\n    return signals.map(s => {\n        if (s.on && !s.on.length)\n            delete s.on;\n        return s;\n    });\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}