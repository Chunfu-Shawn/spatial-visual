{"ast":null,"code":"import calcBbox from \"@turf/bbox\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport isPointOnLine from \"@turf/boolean-point-on-line\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Boolean-contains returns True if the second geometry is completely contained by the first geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)\n * must not intersect the exterior of the primary (geometry a).\n * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.\n *\n * @name booleanContains\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanContains(line, point);\n * //=true\n */\n\nexport default function booleanContains(feature1, feature2) {\n  var geom1 = getGeom(feature1);\n  var geom2 = getGeom(feature2);\n  var type1 = geom1.type;\n  var type2 = geom2.type;\n  var coords1 = geom1.coordinates;\n  var coords2 = geom2.coordinates;\n\n  switch (type1) {\n    case \"Point\":\n      switch (type2) {\n        case \"Point\":\n          return compareCoords(coords1, coords2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"MultiPoint\":\n      switch (type2) {\n        case \"Point\":\n          return isPointInMultiPoint(geom1, geom2);\n\n        case \"MultiPoint\":\n          return isMultiPointInMultiPoint(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"LineString\":\n      switch (type2) {\n        case \"Point\":\n          return isPointOnLine(geom2, geom1, {\n            ignoreEndVertices: true\n          });\n\n        case \"LineString\":\n          return isLineOnLine(geom1, geom2);\n\n        case \"MultiPoint\":\n          return isMultiPointOnLine(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    case \"Polygon\":\n      switch (type2) {\n        case \"Point\":\n          return booleanPointInPolygon(geom2, geom1, {\n            ignoreBoundary: true\n          });\n\n        case \"LineString\":\n          return isLineInPoly(geom1, geom2);\n\n        case \"Polygon\":\n          return isPolyInPoly(geom1, geom2);\n\n        case \"MultiPoint\":\n          return isMultiPointInPoly(geom1, geom2);\n\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n\n    default:\n      throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n  }\n}\nexport function isPointInMultiPoint(multiPoint, pt) {\n  var i;\n  var output = false;\n\n  for (i = 0; i < multiPoint.coordinates.length; i++) {\n    if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {\n      output = true;\n      break;\n    }\n  }\n\n  return output;\n}\nexport function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n  for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {\n    var coord2 = _a[_i];\n    var matchFound = false;\n\n    for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {\n      var coord1 = _c[_b];\n\n      if (compareCoords(coord2, coord1)) {\n        matchFound = true;\n        break;\n      }\n    }\n\n    if (!matchFound) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function isMultiPointOnLine(lineString, multiPoint) {\n  var haveFoundInteriorPoint = false;\n\n  for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n    var coord = _a[_i];\n\n    if (isPointOnLine(coord, lineString, {\n      ignoreEndVertices: true\n    })) {\n      haveFoundInteriorPoint = true;\n    }\n\n    if (!isPointOnLine(coord, lineString)) {\n      return false;\n    }\n  }\n\n  if (haveFoundInteriorPoint) {\n    return true;\n  }\n\n  return false;\n}\nexport function isMultiPointInPoly(polygon, multiPoint) {\n  for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n    var coord = _a[_i];\n\n    if (!booleanPointInPolygon(coord, polygon, {\n      ignoreBoundary: true\n    })) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function isLineOnLine(lineString1, lineString2) {\n  var haveFoundInteriorPoint = false;\n\n  for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {\n    var coords = _a[_i];\n\n    if (isPointOnLine({\n      type: \"Point\",\n      coordinates: coords\n    }, lineString1, {\n      ignoreEndVertices: true\n    })) {\n      haveFoundInteriorPoint = true;\n    }\n\n    if (!isPointOnLine({\n      type: \"Point\",\n      coordinates: coords\n    }, lineString1, {\n      ignoreEndVertices: false\n    })) {\n      return false;\n    }\n  }\n\n  return haveFoundInteriorPoint;\n}\nexport function isLineInPoly(polygon, linestring) {\n  var output = false;\n  var i = 0;\n  var polyBbox = calcBbox(polygon);\n  var lineBbox = calcBbox(linestring);\n\n  if (!doBBoxOverlap(polyBbox, lineBbox)) {\n    return false;\n  }\n\n  for (i; i < linestring.coordinates.length - 1; i++) {\n    var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n\n    if (booleanPointInPolygon({\n      type: \"Point\",\n      coordinates: midPoint\n    }, polygon, {\n      ignoreBoundary: true\n    })) {\n      output = true;\n      break;\n    }\n  }\n\n  return output;\n}\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\n\nexport function isPolyInPoly(feature1, feature2) {\n  // Handle Nulls\n  if (feature1.type === \"Feature\" && feature1.geometry === null) {\n    return false;\n  }\n\n  if (feature2.type === \"Feature\" && feature2.geometry === null) {\n    return false;\n  }\n\n  var poly1Bbox = calcBbox(feature1);\n  var poly2Bbox = calcBbox(feature2);\n\n  if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {\n    return false;\n  }\n\n  var coords = getGeom(feature2).coordinates;\n\n  for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {\n    var ring = coords_1[_i];\n\n    for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {\n      var coord = ring_1[_a];\n\n      if (!booleanPointInPolygon(coord, feature1)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\nexport function doBBoxOverlap(bbox1, bbox2) {\n  if (bbox1[0] > bbox2[0]) {\n    return false;\n  }\n\n  if (bbox1[2] < bbox2[2]) {\n    return false;\n  }\n\n  if (bbox1[1] > bbox2[1]) {\n    return false;\n  }\n\n  if (bbox1[3] < bbox2[3]) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\n\nexport function compareCoords(pair1, pair2) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport function getMidpoint(pair1, pair2) {\n  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}","map":{"version":3,"sources":["/Users/chunfu/IdeaProjects/spatial-visual/node_modules/@turf/boolean-contains/dist/es/index.js"],"names":["calcBbox","booleanPointInPolygon","isPointOnLine","getGeom","booleanContains","feature1","feature2","geom1","geom2","type1","type","type2","coords1","coordinates","coords2","compareCoords","Error","isPointInMultiPoint","isMultiPointInMultiPoint","ignoreEndVertices","isLineOnLine","isMultiPointOnLine","ignoreBoundary","isLineInPoly","isPolyInPoly","isMultiPointInPoly","multiPoint","pt","i","output","length","multiPoint1","multiPoint2","_i","_a","coord2","matchFound","_b","_c","coord1","lineString","haveFoundInteriorPoint","coord","polygon","lineString1","lineString2","coords","linestring","polyBbox","lineBbox","doBBoxOverlap","midPoint","getMidpoint","geometry","poly1Bbox","poly2Bbox","coords_1","ring","ring_1","bbox1","bbox2","pair1","pair2"],"mappings":"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","sourcesContent":["import calcBbox from \"@turf/bbox\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport isPointOnLine from \"@turf/boolean-point-on-line\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Boolean-contains returns True if the second geometry is completely contained by the first geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)\n * must not intersect the exterior of the primary (geometry a).\n * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.\n *\n * @name booleanContains\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanContains(line, point);\n * //=true\n */\nexport default function booleanContains(feature1, feature2) {\n    var geom1 = getGeom(feature1);\n    var geom2 = getGeom(feature2);\n    var type1 = geom1.type;\n    var type2 = geom2.type;\n    var coords1 = geom1.coordinates;\n    var coords2 = geom2.coordinates;\n    switch (type1) {\n        case \"Point\":\n            switch (type2) {\n                case \"Point\":\n                    return compareCoords(coords1, coords2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"MultiPoint\":\n            switch (type2) {\n                case \"Point\":\n                    return isPointInMultiPoint(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInMultiPoint(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"LineString\":\n            switch (type2) {\n                case \"Point\":\n                    return isPointOnLine(geom2, geom1, { ignoreEndVertices: true });\n                case \"LineString\":\n                    return isLineOnLine(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointOnLine(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"Polygon\":\n            switch (type2) {\n                case \"Point\":\n                    return booleanPointInPolygon(geom2, geom1, { ignoreBoundary: true });\n                case \"LineString\":\n                    return isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return isPolyInPoly(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        default:\n            throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n    }\n}\nexport function isPointInMultiPoint(multiPoint, pt) {\n    var i;\n    var output = false;\n    for (i = 0; i < multiPoint.coordinates.length; i++) {\n        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nexport function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {\n        var coord2 = _a[_i];\n        var matchFound = false;\n        for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {\n            var coord1 = _c[_b];\n            if (compareCoords(coord2, coord1)) {\n                matchFound = true;\n                break;\n            }\n        }\n        if (!matchFound) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function isMultiPointOnLine(lineString, multiPoint) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (isPointOnLine(coord, lineString, { ignoreEndVertices: true })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!isPointOnLine(coord, lineString)) {\n            return false;\n        }\n    }\n    if (haveFoundInteriorPoint) {\n        return true;\n    }\n    return false;\n}\nexport function isMultiPointInPoly(polygon, multiPoint) {\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (!booleanPointInPolygon(coord, polygon, { ignoreBoundary: true })) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function isLineOnLine(lineString1, lineString2) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {\n        var coords = _a[_i];\n        if (isPointOnLine({ type: \"Point\", coordinates: coords }, lineString1, {\n            ignoreEndVertices: true,\n        })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!isPointOnLine({ type: \"Point\", coordinates: coords }, lineString1, {\n            ignoreEndVertices: false,\n        })) {\n            return false;\n        }\n    }\n    return haveFoundInteriorPoint;\n}\nexport function isLineInPoly(polygon, linestring) {\n    var output = false;\n    var i = 0;\n    var polyBbox = calcBbox(polygon);\n    var lineBbox = calcBbox(linestring);\n    if (!doBBoxOverlap(polyBbox, lineBbox)) {\n        return false;\n    }\n    for (i; i < linestring.coordinates.length - 1; i++) {\n        var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n        if (booleanPointInPolygon({ type: \"Point\", coordinates: midPoint }, polygon, {\n            ignoreBoundary: true,\n        })) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nexport function isPolyInPoly(feature1, feature2) {\n    // Handle Nulls\n    if (feature1.type === \"Feature\" && feature1.geometry === null) {\n        return false;\n    }\n    if (feature2.type === \"Feature\" && feature2.geometry === null) {\n        return false;\n    }\n    var poly1Bbox = calcBbox(feature1);\n    var poly2Bbox = calcBbox(feature2);\n    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {\n        return false;\n    }\n    var coords = getGeom(feature2).coordinates;\n    for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {\n        var ring = coords_1[_i];\n        for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {\n            var coord = ring_1[_a];\n            if (!booleanPointInPolygon(coord, feature1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexport function doBBoxOverlap(bbox1, bbox2) {\n    if (bbox1[0] > bbox2[0]) {\n        return false;\n    }\n    if (bbox1[2] < bbox2[2]) {\n        return false;\n    }\n    if (bbox1[1] > bbox2[1]) {\n        return false;\n    }\n    if (bbox1[3] < bbox2[3]) {\n        return false;\n    }\n    return true;\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nexport function compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport function getMidpoint(pair1, pair2) {\n    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\n"]},"metadata":{},"sourceType":"module"}