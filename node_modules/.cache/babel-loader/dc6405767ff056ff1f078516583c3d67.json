{"ast":null,"code":"import _defineProperty from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _createForOfIteratorHelper from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { title as fieldDefTitle } from '../../channeldef';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { assembleAxis } from '../axis/assemble';\nimport { parseGuideResolve } from '../resolve';\nimport { getHeaderProperty } from './common';\nexport function getHeaderType(orient) {\n  if (orient === 'top' || orient === 'left' || isSignalRef(orient)) {\n    // we always use header for orient signal since we can't dynamically make header becomes footer\n    return 'header';\n  }\n\n  return 'footer';\n}\nexport function parseFacetHeaders(model) {\n  var _iterator = _createForOfIteratorHelper(FACET_CHANNELS),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var channel = _step.value;\n      parseFacetHeader(model, channel);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  mergeChildAxis(model, 'x');\n  mergeChildAxis(model, 'y');\n}\n\nfunction parseFacetHeader(model, channel) {\n  var _a;\n\n  var facet = model.facet,\n      config = model.config,\n      child = model.child,\n      component = model.component;\n\n  if (model.channelHasField(channel)) {\n    var fieldDef = facet[channel];\n    var titleConfig = getHeaderProperty('title', null, config, channel);\n    var title = fieldDefTitle(fieldDef, config, {\n      allowDisabling: true,\n      includeDefault: titleConfig === undefined || !!titleConfig\n    });\n\n    if (child.component.layoutHeaders[channel].title) {\n      // TODO: better handle multiline titles\n      title = isArray(title) ? title.join(', ') : title; // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n\n      title += ' / ' + child.component.layoutHeaders[channel].title;\n      child.component.layoutHeaders[channel].title = null;\n    }\n\n    var labelOrient = getHeaderProperty('labelOrient', fieldDef, config, channel);\n    var header = (_a = fieldDef.header) !== null && _a !== void 0 ? _a : {};\n    var labels = getFirstDefined(header.labels, config.header.labels, true);\n    var headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n    component.layoutHeaders[channel] = _defineProperty({\n      title: title,\n      facetFieldDef: fieldDef\n    }, headerType, channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]);\n  }\n}\n\nfunction makeHeaderComponent(model, channel, labels) {\n  var sizeType = channel === 'row' ? 'height' : 'width';\n  return {\n    labels: labels,\n    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n    axes: []\n  };\n}\n\nfunction mergeChildAxis(model, channel) {\n  var _a;\n\n  var child = model.child;\n\n  if (child.component.axes[channel]) {\n    var _model$component = model.component,\n        layoutHeaders = _model$component.layoutHeaders,\n        resolve = _model$component.resolve;\n    resolve.axis[channel] = parseGuideResolve(resolve, channel);\n\n    if (resolve.axis[channel] === 'shared') {\n      // For shared axis, move the axes to facet's header or footer\n      var headerChannel = channel === 'x' ? 'column' : 'row';\n      var layoutHeader = layoutHeaders[headerChannel];\n\n      var _iterator2 = _createForOfIteratorHelper(child.component.axes[channel]),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var axisComponent = _step2.value;\n          var headerType = getHeaderType(axisComponent.get('orient'));\n          layoutHeader[headerType] = (_a = layoutHeader[headerType]) !== null && _a !== void 0 ? _a : [makeHeaderComponent(model, headerChannel, false)]; // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n\n          var mainAxis = assembleAxis(axisComponent, 'main', model.config, {\n            header: true\n          });\n\n          if (mainAxis) {\n            // LayoutHeader no longer keep track of property precedence, thus let's combine.\n            layoutHeader[headerType][0].axes.push(mainAxis);\n          }\n\n          axisComponent.mainExtracted = true;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else {// Otherwise do nothing for independent axes\n    }\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/header/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { title as fieldDefTitle } from '../../channeldef';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { assembleAxis } from '../axis/assemble';\nimport { parseGuideResolve } from '../resolve';\nimport { getHeaderProperty } from './common';\nexport function getHeaderType(orient) {\n    if (orient === 'top' || orient === 'left' || isSignalRef(orient)) {\n        // we always use header for orient signal since we can't dynamically make header becomes footer\n        return 'header';\n    }\n    return 'footer';\n}\nexport function parseFacetHeaders(model) {\n    for (const channel of FACET_CHANNELS) {\n        parseFacetHeader(model, channel);\n    }\n    mergeChildAxis(model, 'x');\n    mergeChildAxis(model, 'y');\n}\nfunction parseFacetHeader(model, channel) {\n    var _a;\n    const { facet, config, child, component } = model;\n    if (model.channelHasField(channel)) {\n        const fieldDef = facet[channel];\n        const titleConfig = getHeaderProperty('title', null, config, channel);\n        let title = fieldDefTitle(fieldDef, config, {\n            allowDisabling: true,\n            includeDefault: titleConfig === undefined || !!titleConfig\n        });\n        if (child.component.layoutHeaders[channel].title) {\n            // TODO: better handle multiline titles\n            title = isArray(title) ? title.join(', ') : title;\n            // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n            title += ' / ' + child.component.layoutHeaders[channel].title;\n            child.component.layoutHeaders[channel].title = null;\n        }\n        const labelOrient = getHeaderProperty('labelOrient', fieldDef, config, channel);\n        const header = (_a = fieldDef.header) !== null && _a !== void 0 ? _a : {};\n        const labels = getFirstDefined(header.labels, config.header.labels, true);\n        const headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n        component.layoutHeaders[channel] = {\n            title,\n            facetFieldDef: fieldDef,\n            [headerType]: channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]\n        };\n    }\n}\nfunction makeHeaderComponent(model, channel, labels) {\n    const sizeType = channel === 'row' ? 'height' : 'width';\n    return {\n        labels,\n        sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n        axes: []\n    };\n}\nfunction mergeChildAxis(model, channel) {\n    var _a;\n    const { child } = model;\n    if (child.component.axes[channel]) {\n        const { layoutHeaders, resolve } = model.component;\n        resolve.axis[channel] = parseGuideResolve(resolve, channel);\n        if (resolve.axis[channel] === 'shared') {\n            // For shared axis, move the axes to facet's header or footer\n            const headerChannel = channel === 'x' ? 'column' : 'row';\n            const layoutHeader = layoutHeaders[headerChannel];\n            for (const axisComponent of child.component.axes[channel]) {\n                const headerType = getHeaderType(axisComponent.get('orient'));\n                layoutHeader[headerType] = (_a = layoutHeader[headerType]) !== null && _a !== void 0 ? _a : [makeHeaderComponent(model, headerChannel, false)];\n                // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n                const mainAxis = assembleAxis(axisComponent, 'main', model.config, { header: true });\n                if (mainAxis) {\n                    // LayoutHeader no longer keep track of property precedence, thus let's combine.\n                    layoutHeader[headerType][0].axes.push(mainAxis);\n                }\n                axisComponent.mainExtracted = true;\n            }\n        }\n        else {\n            // Otherwise do nothing for independent axes\n        }\n    }\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}