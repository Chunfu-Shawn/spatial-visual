{"ast":null,"code":"import _objectSpread from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { log } from '@deck.gl/core';\nimport { ColumnLayer } from '@deck.gl/layers';\nimport { defaultColorRange } from '../utils/color-utils';\nimport { pointToHexbin } from './hexagon-aggregator';\nimport CPUAggregator from '../utils/cpu-aggregator';\nimport AggregationLayer from '../aggregation-layer';\n\nfunction nop() {}\n\nvar defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {\n    type: 'accessor',\n    value: null\n  },\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  lowerPercentile: {\n    type: 'number',\n    value: 0,\n    min: 0,\n    max: 100\n  },\n  upperPercentile: {\n    type: 'number',\n    value: 100,\n    min: 0,\n    max: 100\n  },\n  colorScaleType: 'quantize',\n  onSetColorDomain: nop,\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {\n    type: 'accessor',\n    value: null\n  },\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationLowerPercentile: {\n    type: 'number',\n    value: 0,\n    min: 0,\n    max: 100\n  },\n  elevationUpperPercentile: {\n    type: 'number',\n    value: 100,\n    min: 0,\n    max: 100\n  },\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  elevationScaleType: 'linear',\n  onSetElevationDomain: nop,\n  radius: {\n    type: 'number',\n    value: 1000,\n    min: 1\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  extruded: false,\n  hexagonAggregator: pointToHexbin,\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  material: true,\n  _filterData: {\n    type: 'function',\n    value: null,\n    optional: true\n  }\n};\n\nvar HexagonLayer = /*#__PURE__*/function (_AggregationLayer) {\n  _inherits(HexagonLayer, _AggregationLayer);\n\n  var _super = _createSuper(HexagonLayer);\n\n  function HexagonLayer() {\n    _classCallCheck(this, HexagonLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(HexagonLayer, [{\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var cpuAggregator = new CPUAggregator({\n        getAggregator: function getAggregator(props) {\n          return props.hexagonAggregator;\n        },\n        getCellSize: function getCellSize(props) {\n          return props.radius;\n        }\n      });\n      this.state = {\n        cpuAggregator: cpuAggregator,\n        aggregatorState: cpuAggregator.state,\n        hexagonVertices: null\n      };\n      var attributeManager = this.getAttributeManager();\n      attributeManager.add({\n        positions: {\n          size: 3,\n          accessor: 'getPosition'\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      _get(_getPrototypeOf(HexagonLayer.prototype), \"updateState\", this).call(this, opts);\n\n      var _this$state = this.state,\n          cpuAggregator = _this$state.cpuAggregator,\n          oldVertices = _this$state.hexagonVertices;\n\n      if (opts.changeFlags.propsOrDataChanged) {\n        this.setState({\n          aggregatorState: cpuAggregator.updateState(opts, {\n            viewport: this.context.viewport,\n            attributes: this.getAttributes()\n          })\n        });\n      }\n\n      var _ref2 = cpuAggregator.state.layerData || {},\n          hexagonVertices = _ref2.hexagonVertices;\n\n      if (hexagonVertices && oldVertices !== hexagonVertices) {\n        var vertices = this.convertLatLngToMeterOffset(hexagonVertices);\n\n        if (vertices) {\n          this.setState({\n            hexagonVertices: hexagonVertices,\n            vertices: vertices\n          });\n        }\n      } else {\n        this.updateRadiusAngle();\n      }\n    }\n  }, {\n    key: \"updateRadiusAngle\",\n    value: function updateRadiusAngle(vertices) {\n      var viewport = this.context.viewport;\n\n      var _viewport$getDistance = viewport.getDistanceScales(),\n          unitsPerMeter = _viewport$getDistance.unitsPerMeter;\n\n      var cpuAggregator = this.state.cpuAggregator;\n\n      if (cpuAggregator.state.layerData && cpuAggregator.state.layerData.radiusCommon) {\n        var radiusCommon = cpuAggregator.state.layerData.radiusCommon;\n        var radius = radiusCommon / unitsPerMeter[0];\n        this.setState({\n          angle: 90,\n          radius: radius\n        });\n      }\n    }\n  }, {\n    key: \"convertLatLngToMeterOffset\",\n    value: function convertLatLngToMeterOffset(hexagonVertices) {\n      var viewport = this.context.viewport;\n\n      if (Array.isArray(hexagonVertices) && hexagonVertices.length === 6) {\n        var vertex0 = hexagonVertices[0];\n        var vertex3 = hexagonVertices[3];\n        var centroid = [(vertex0[0] + vertex3[0]) / 2, (vertex0[1] + vertex3[1]) / 2];\n        var centroidFlat = viewport.projectFlat(centroid);\n\n        var _viewport$getDistance2 = viewport.getDistanceScales(centroid),\n            metersPerUnit = _viewport$getDistance2.metersPerUnit;\n\n        var vertices = hexagonVertices.map(function (vt) {\n          var vtFlat = viewport.projectFlat(vt);\n          return [(vtFlat[0] - centroidFlat[0]) * metersPerUnit[0], (vtFlat[1] - centroidFlat[1]) * metersPerUnit[1]];\n        });\n        return vertices;\n      }\n\n      log.error('HexagonLayer: hexagonVertices needs to be an array of 6 points')();\n      return null;\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info;\n      return this.state.cpuAggregator.getPickingInfo({\n        info: info\n      });\n    }\n  }, {\n    key: \"_onGetSublayerColor\",\n    value: function _onGetSublayerColor(cell) {\n      return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n    }\n  }, {\n    key: \"_onGetSublayerElevation\",\n    value: function _onGetSublayerElevation(cell) {\n      return this.state.cpuAggregator.getAccessor('elevation')(cell);\n    }\n  }, {\n    key: \"_getSublayerUpdateTriggers\",\n    value: function _getSublayerUpdateTriggers() {\n      return this.state.cpuAggregator.getUpdateTriggers(this.props);\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$props = this.props,\n          elevationScale = _this$props.elevationScale,\n          extruded = _this$props.extruded,\n          coverage = _this$props.coverage,\n          material = _this$props.material,\n          transitions = _this$props.transitions;\n      var _this$state2 = this.state,\n          angle = _this$state2.angle,\n          radius = _this$state2.radius,\n          cpuAggregator = _this$state2.cpuAggregator,\n          vertices = _this$state2.vertices;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n\n      var updateTriggers = this._getSublayerUpdateTriggers();\n\n      var geometry = vertices && vertices.length ? {\n        vertices: vertices,\n        radius: 1\n      } : {\n        radius: radius,\n        angle: angle\n      };\n      return new SubLayerClass(_objectSpread(_objectSpread({}, geometry), {}, {\n        diskResolution: 6,\n        elevationScale: elevationScale,\n        extruded: extruded,\n        coverage: coverage,\n        material: material,\n        getFillColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        }\n      }), this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers: updateTriggers\n      }), {\n        data: cpuAggregator.state.layerData.data\n      });\n    }\n  }]);\n\n  return HexagonLayer;\n}(AggregationLayer);\n\nexport { HexagonLayer as default };\nHexagonLayer.layerName = 'HexagonLayer';\nHexagonLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/hexagon-layer/hexagon-layer.js"],"names":["defaultProps","colorDomain","colorRange","getColorValue","type","value","getColorWeight","colorAggregation","lowerPercentile","min","max","upperPercentile","colorScaleType","onSetColorDomain","elevationDomain","elevationRange","getElevationValue","getElevationWeight","elevationAggregation","elevationLowerPercentile","elevationUpperPercentile","elevationScale","elevationScaleType","onSetElevationDomain","radius","coverage","extruded","hexagonAggregator","getPosition","x","position","material","_filterData","optional","shouldUpdateState","changeFlags","initializeState","cpuAggregator","getAggregator","props","getCellSize","aggregatorState","hexagonVertices","attributeManager","positions","size","accessor","updateState","oldVertices","opts","viewport","attributes","vertices","updateRadiusAngle","unitsPerMeter","radiusCommon","angle","convertLatLngToMeterOffset","Array","vertex0","vertex3","centroid","centroidFlat","metersPerUnit","vt","vtFlat","log","getPickingInfo","info","_onGetSublayerColor","_onGetSublayerElevation","_getSublayerUpdateTriggers","renderLayers","transitions","SubLayerClass","updateTriggers","geometry","diskResolution","getFillColor","getElevation","id","data","HexagonLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {log} from '@deck.gl/core';\nimport {ColumnLayer} from '@deck.gl/layers';\n\nimport {defaultColorRange} from '../utils/color-utils';\n\nimport {pointToHexbin} from './hexagon-aggregator';\nimport CPUAggregator from '../utils/cpu-aggregator';\nimport AggregationLayer from '../aggregation-layer';\n\nfunction nop() {}\n\nconst defaultProps = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {type: 'accessor', value: null}, // default value is calcuated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n  lowerPercentile: {type: 'number', value: 0, min: 0, max: 100},\n  upperPercentile: {type: 'number', value: 100, min: 0, max: 100},\n  colorScaleType: 'quantize',\n  onSetColorDomain: nop,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {type: 'accessor', value: null}, // default value is calcuated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationLowerPercentile: {type: 'number', value: 0, min: 0, max: 100},\n  elevationUpperPercentile: {type: 'number', value: 100, min: 0, max: 100},\n  elevationScale: {type: 'number', min: 0, value: 1},\n  elevationScaleType: 'linear',\n  onSetElevationDomain: nop,\n\n  radius: {type: 'number', value: 1000, min: 1},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  extruded: false,\n  hexagonAggregator: pointToHexbin,\n  getPosition: {type: 'accessor', value: x => x.position},\n  // Optional material for 'lighting' shader module\n  material: true,\n\n  // data filter\n  _filterData: {type: 'function', value: null, optional: true}\n};\n\nexport default class HexagonLayer extends AggregationLayer {\n  shouldUpdateState({changeFlags}) {\n    return changeFlags.somethingChanged;\n  }\n  initializeState() {\n    const cpuAggregator = new CPUAggregator({\n      getAggregator: props => props.hexagonAggregator,\n      getCellSize: props => props.radius\n    });\n\n    this.state = {\n      cpuAggregator,\n      aggregatorState: cpuAggregator.state,\n      hexagonVertices: null\n    };\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {size: 3, accessor: 'getPosition'}\n    });\n    // color and elevation attributes can't be added as attributes\n    // they are calculated using 'getValue' accessor that takes an array of pints.\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n    const {cpuAggregator, hexagonVertices: oldVertices} = this.state;\n\n    if (opts.changeFlags.propsOrDataChanged) {\n      this.setState({\n        // make a copy of the internal state of cpuAggregator for testing\n        aggregatorState: cpuAggregator.updateState(opts, {\n          viewport: this.context.viewport,\n          attributes: this.getAttributes()\n        })\n      });\n    }\n\n    // if user provided custom aggregator and returns hexagonVertices,\n    // Need to recalculate radius and angle based on vertices\n    const {hexagonVertices} = cpuAggregator.state.layerData || {};\n\n    if (hexagonVertices && oldVertices !== hexagonVertices) {\n      const vertices = this.convertLatLngToMeterOffset(hexagonVertices);\n      if (vertices) {\n        this.setState({\n          hexagonVertices,\n          vertices\n        });\n      }\n    } else {\n      // update radius angle by viewport\n      this.updateRadiusAngle();\n    }\n  }\n\n  updateRadiusAngle(vertices) {\n    const {viewport} = this.context;\n    const {unitsPerMeter} = viewport.getDistanceScales();\n    const {cpuAggregator} = this.state;\n\n    if (cpuAggregator.state.layerData && cpuAggregator.state.layerData.radiusCommon) {\n      const {radiusCommon} = cpuAggregator.state.layerData;\n      const radius = radiusCommon / unitsPerMeter[0];\n\n      // convert radius in common to meter\n      this.setState({angle: 90, radius});\n    }\n  }\n\n  convertLatLngToMeterOffset(hexagonVertices) {\n    const {viewport} = this.context;\n    if (Array.isArray(hexagonVertices) && hexagonVertices.length === 6) {\n      // get centroid of hexagons\n      const vertex0 = hexagonVertices[0];\n      const vertex3 = hexagonVertices[3];\n\n      const centroid = [(vertex0[0] + vertex3[0]) / 2, (vertex0[1] + vertex3[1]) / 2];\n      const centroidFlat = viewport.projectFlat(centroid);\n\n      const {metersPerUnit} = viewport.getDistanceScales(centroid);\n\n      // offset all points by centroid to meter offset\n      const vertices = hexagonVertices.map(vt => {\n        const vtFlat = viewport.projectFlat(vt);\n\n        return [\n          (vtFlat[0] - centroidFlat[0]) * metersPerUnit[0],\n          (vtFlat[1] - centroidFlat[1]) * metersPerUnit[1]\n        ];\n      });\n\n      return vertices;\n    }\n\n    log.error('HexagonLayer: hexagonVertices needs to be an array of 6 points')();\n    return null;\n  }\n\n  getPickingInfo({info}) {\n    return this.state.cpuAggregator.getPickingInfo({info});\n  }\n\n  // create a method for testing\n  _onGetSublayerColor(cell) {\n    return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n  }\n\n  // create a method for testing\n  _onGetSublayerElevation(cell) {\n    return this.state.cpuAggregator.getAccessor('elevation')(cell);\n  }\n\n  _getSublayerUpdateTriggers() {\n    return this.state.cpuAggregator.getUpdateTriggers(this.props);\n  }\n\n  renderLayers() {\n    const {elevationScale, extruded, coverage, material, transitions} = this.props;\n    const {angle, radius, cpuAggregator, vertices} = this.state;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const updateTriggers = this._getSublayerUpdateTriggers();\n\n    const geometry = vertices && vertices.length ? {vertices, radius: 1} : {radius, angle};\n    return new SubLayerClass(\n      {\n        ...geometry,\n        diskResolution: 6,\n        elevationScale,\n        extruded,\n        coverage,\n        material,\n\n        getFillColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        }\n      },\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers\n      }),\n      {\n        data: cpuAggregator.state.layerData.data\n      }\n    );\n  }\n}\n\nHexagonLayer.layerName = 'HexagonLayer';\nHexagonLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}