{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { classifyRings, project, readFeature } from '../../helpers/binary-util-functions';\nlet endPos;\nlet cmd;\nlet cmdLen;\nlet length;\nlet x;\nlet y;\nlet i;\nexport const TEST_EXPORTS = {\n  classifyRings\n};\nexport default class VectorTileFeature {\n  static get types() {\n    return ['Unknown', 'Point', 'LineString', 'Polygon'];\n  }\n\n  constructor(pbf, end, extent, keys, values, firstPassData) {\n    _defineProperty(this, \"properties\", void 0);\n\n    _defineProperty(this, \"extent\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"_pbf\", void 0);\n\n    _defineProperty(this, \"_geometry\", void 0);\n\n    _defineProperty(this, \"_keys\", void 0);\n\n    _defineProperty(this, \"_values\", void 0);\n\n    _defineProperty(this, \"_firstPassData\", void 0);\n\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n    this.id = null;\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n    this._firstPassData = firstPassData;\n    pbf.readFields(readFeature, this, end);\n  }\n\n  loadGeometry() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n    endPos = pbf.readVarint() + pbf.pos;\n    cmd = 1;\n    length = 0;\n    x = 0;\n    y = 0;\n    i = 0;\n    const lines = [];\n    const data = [];\n\n    while (pbf.pos < endPos) {\n      if (length <= 0) {\n        cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) {\n          lines.push(i);\n        }\n\n        data.push(x, y);\n        i += 2;\n      } else if (cmd === 7) {\n        if (i > 0) {\n          const start = lines[lines.length - 1];\n          data.push(data[start], data[start + 1]);\n          i += 2;\n        }\n      } else {\n        throw new Error(\"unknown command \".concat(cmd));\n      }\n    }\n\n    return {\n      data,\n      lines\n    };\n  }\n\n  _toBinaryCoordinates(transform) {\n    let geom = this.loadGeometry();\n    transform(geom.data, this);\n    const coordLength = 2;\n\n    switch (this.type) {\n      case 1:\n        this._firstPassData.pointFeaturesCount++;\n        this._firstPassData.pointPositionsCount += geom.lines.length;\n        break;\n\n      case 2:\n        this._firstPassData.lineFeaturesCount++;\n        this._firstPassData.linePathsCount += geom.lines.length;\n        this._firstPassData.linePositionsCount += geom.data.length / coordLength;\n        break;\n\n      case 3:\n        const classified = classifyRings(geom);\n        this._firstPassData.polygonFeaturesCount++;\n        this._firstPassData.polygonObjectsCount += classified.lines.length;\n\n        for (const lines of classified.lines) {\n          this._firstPassData.polygonRingsCount += lines.length;\n        }\n\n        this._firstPassData.polygonPositionsCount += classified.data.length / coordLength;\n        geom = classified;\n        break;\n    }\n\n    geom.type = VectorTileFeature.types[this.type];\n\n    if (geom.lines.length > 1) {\n      geom.type = \"Multi\".concat(geom.type);\n    }\n\n    const result = {\n      type: 'Feature',\n      geometry: geom,\n      properties: this.properties\n    };\n\n    if (this.id !== null) {\n      result.id = this.id;\n    }\n\n    return result;\n  }\n\n  toBinaryCoordinates(options) {\n    if (typeof options === 'function') {\n      return this._toBinaryCoordinates(options);\n    }\n\n    return this._toBinaryCoordinates(project);\n  }\n\n}","map":{"version":3,"sources":["../../../../src/lib/binary-vector-tile/vector-tile-feature.ts"],"names":["TEST_EXPORTS","classifyRings","types","constructor","pbf","loadGeometry","endPos","cmd","length","x","y","i","lines","data","cmdLen","start","_toBinaryCoordinates","geom","transform","coordLength","classified","VectorTileFeature","result","type","geometry","properties","toBinaryCoordinates"],"mappings":"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","sourcesContent":["// This code is forked from https://github.com/mapbox/vector-tile-js under BSD 3-clause license.\n\nimport Protobuf from 'pbf';\nimport {MvtBinaryCoordinates, MvtBinaryGeometry, MvtFirstPassedData} from '../types';\nimport {classifyRings, project, readFeature} from '../../helpers/binary-util-functions';\n\n// Reduce GC by reusing variables\nlet endPos: number;\nlet cmd: number;\nlet cmdLen: number;\nlet length: number;\nlet x: number;\nlet y: number;\nlet i: number;\n\nexport const TEST_EXPORTS = {\n  classifyRings\n};\n\nexport default class VectorTileFeature {\n  properties: {[x: string]: string | number | boolean | null};\n  extent: any;\n  type: number;\n  id: number | null;\n  _pbf: Protobuf;\n  _geometry: number;\n  _keys: string[];\n  _values: (string | number | boolean | null)[];\n  _firstPassData: MvtFirstPassedData;\n  static get types() {\n    return ['Unknown', 'Point', 'LineString', 'Polygon'];\n  }\n\n  // eslint-disable-next-line max-params\n  constructor(\n    pbf: Protobuf,\n    end: number,\n    extent: any,\n    keys: string[],\n    values: (string | number | boolean | null)[],\n    firstPassData: MvtFirstPassedData\n  ) {\n    // Public\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n    this.id = null;\n\n    // Private\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n    this._firstPassData = firstPassData;\n\n    pbf.readFields(readFeature, this, end);\n  }\n\n  // eslint-disable-next-line complexity, max-statements\n  loadGeometry(): MvtBinaryGeometry {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    endPos = pbf.readVarint() + pbf.pos;\n    cmd = 1;\n    length = 0;\n    x = 0;\n    y = 0;\n    i = 0;\n\n    // Note: I attempted to replace the `data` array with a\n    // Float32Array, but performance was worse, both using\n    // `set()` and direct index access. Also, we cannot\n    // know how large the buffer should be, so it would\n    // increase memory usage\n    const lines: number[] = []; // Indices where lines start\n    const data: number[] = []; // Flat array of coordinate data\n\n    while (pbf.pos < endPos) {\n      if (length <= 0) {\n        cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) {\n          // New line\n          lines.push(i);\n        }\n        data.push(x, y);\n        i += 2;\n      } else if (cmd === 7) {\n        // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n        if (i > 0) {\n          const start = lines[lines.length - 1]; // start index of polygon\n          data.push(data[start], data[start + 1]); // closePolygon\n          i += 2;\n        }\n      } else {\n        throw new Error(`unknown command ${cmd}`);\n      }\n    }\n\n    return {data, lines};\n  }\n\n  /**\n   *\n   * @param transform\n   * @returns result\n   */\n  _toBinaryCoordinates(transform) {\n    // Expands the protobuf data to an intermediate `lines`\n    // data format, which maps closely to the binary data buffers.\n    // It is similar to GeoJSON, but rather than storing the coordinates\n    // in multidimensional arrays, we have a 1D `data` with all the\n    // coordinates, and then index into this using the `lines`\n    // parameter, e.g.\n    //\n    // geometry: {\n    //   type: 'Point', data: [1,2], lines: [0]\n    // }\n    // geometry: {\n    //   type: 'LineString', data: [1,2,3,4,...], lines: [0]\n    // }\n    // geometry: {\n    //   type: 'Polygon', data: [1,2,3,4,...], lines: [[0, 2]]\n    // }\n    // Thus the lines member lets us look up the relevant range\n    // from the data array.\n    // The Multi* versions of the above types share the same data\n    // structure, just with multiple elements in the lines array\n    let geom = this.loadGeometry();\n\n    // Apply the supplied transformation to data\n    transform(geom.data, this);\n\n    const coordLength = 2;\n\n    // eslint-disable-next-line default-case\n    switch (this.type) {\n      case 1: // Point\n        this._firstPassData.pointFeaturesCount++;\n        this._firstPassData.pointPositionsCount += geom.lines.length;\n        break;\n\n      case 2: // LineString\n        this._firstPassData.lineFeaturesCount++;\n        this._firstPassData.linePathsCount += geom.lines.length;\n        this._firstPassData.linePositionsCount += geom.data.length / coordLength;\n        break;\n\n      case 3: // Polygon\n        const classified = classifyRings(geom);\n\n        // Unlike Point & LineString geom.lines is a 2D array, thanks\n        // to the classifyRings method\n        this._firstPassData.polygonFeaturesCount++;\n        this._firstPassData.polygonObjectsCount += classified.lines.length;\n\n        for (const lines of classified.lines) {\n          this._firstPassData.polygonRingsCount += lines.length;\n        }\n        this._firstPassData.polygonPositionsCount += classified.data.length / coordLength;\n\n        geom = classified;\n        break;\n    }\n\n    geom.type = VectorTileFeature.types[this.type];\n    if (geom.lines.length > 1) {\n      geom.type = `Multi${geom.type}`;\n    }\n\n    const result: MvtBinaryCoordinates = {\n      type: 'Feature',\n      geometry: geom,\n      properties: this.properties\n    };\n\n    if (this.id !== null) {\n      result.id = this.id;\n    }\n\n    return result;\n  }\n\n  toBinaryCoordinates(\n    options: {x: number; y: number; z: number} | ((data: number[], feature: {extent: any}) => void)\n  ): MvtBinaryCoordinates {\n    if (typeof options === 'function') {\n      return this._toBinaryCoordinates(options);\n    }\n    return this._toBinaryCoordinates(project);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}