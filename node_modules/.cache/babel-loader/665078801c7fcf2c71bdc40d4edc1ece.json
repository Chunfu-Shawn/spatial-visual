{"ast":null,"code":"import _classCallCheck from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/chunfu/IdeaProjects/spatial-visual/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { isGenerator, isInlineData, isNamedData, isSphereGenerator, isUrlData } from '../../data';\nimport { contains, isEmpty, omit } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport var SourceNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(SourceNode, _DataFlowNode);\n\n  var _super = _createSuper(SourceNode);\n\n  function SourceNode(data) {\n    var _this;\n\n    _classCallCheck(this, SourceNode);\n\n    _this = _super.call(this, null); // source cannot have parent\n\n    data = data !== null && data !== void 0 ? data : {\n      name: 'source'\n    };\n    var format;\n\n    if (!isGenerator(data)) {\n      format = data.format ? Object.assign({}, omit(data.format, ['parse'])) : {};\n    }\n\n    if (isInlineData(data)) {\n      _this._data = {\n        values: data.values\n      };\n    } else if (isUrlData(data)) {\n      _this._data = {\n        url: data.url\n      };\n\n      if (!format.type) {\n        // Extract extension from URL using snippet from\n        // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n        var defaultExtension = /(?:\\.([^.]+))?$/.exec(data.url)[1];\n\n        if (!contains(['json', 'csv', 'tsv', 'dsv', 'topojson'], defaultExtension)) {\n          defaultExtension = 'json';\n        } // defaultExtension has type string but we ensure that it is DataFormatType above\n\n\n        format.type = defaultExtension;\n      }\n    } else if (isSphereGenerator(data)) {\n      // hardwire GeoJSON sphere data into output specification\n      _this._data = {\n        values: [{\n          type: 'Sphere'\n        }]\n      };\n    } else if (isNamedData(data) || isGenerator(data)) {\n      _this._data = {};\n    } // set flag to check if generator\n\n\n    _this._generator = isGenerator(data); // any dataset can be named\n\n    if (data.name) {\n      _this._name = data.name;\n    }\n\n    if (format && !isEmpty(format)) {\n      _this._data.format = format;\n    }\n\n    return _this;\n  }\n\n  _createClass(SourceNode, [{\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set();\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return undefined; // we don't know what this source produces\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._data;\n    }\n  }, {\n    key: \"hasName\",\n    value: function hasName() {\n      return !!this._name;\n    }\n  }, {\n    key: \"isGenerator\",\n    get: function get() {\n      return this._generator;\n    }\n  }, {\n    key: \"dataName\",\n    get: function get() {\n      return this._name;\n    },\n    set: function set(name) {\n      this._name = name;\n    }\n  }, {\n    key: \"parent\",\n    set: function set(parent) {\n      throw new Error('Source nodes have to be roots.');\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      throw new Error('Source nodes are roots and cannot be removed.');\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      throw new Error('Cannot hash sources');\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      return Object.assign(Object.assign({\n        name: this._name\n      }, this._data), {\n        transform: []\n      });\n    }\n  }]);\n\n  return SourceNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/source.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isGenerator, isInlineData, isNamedData, isSphereGenerator, isUrlData } from '../../data';\nimport { contains, isEmpty, omit } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class SourceNode extends DataFlowNode {\n    constructor(data) {\n        super(null); // source cannot have parent\n        data = data !== null && data !== void 0 ? data : { name: 'source' };\n        let format;\n        if (!isGenerator(data)) {\n            format = data.format ? Object.assign({}, omit(data.format, ['parse'])) : {};\n        }\n        if (isInlineData(data)) {\n            this._data = { values: data.values };\n        }\n        else if (isUrlData(data)) {\n            this._data = { url: data.url };\n            if (!format.type) {\n                // Extract extension from URL using snippet from\n                // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n                let defaultExtension = /(?:\\.([^.]+))?$/.exec(data.url)[1];\n                if (!contains(['json', 'csv', 'tsv', 'dsv', 'topojson'], defaultExtension)) {\n                    defaultExtension = 'json';\n                }\n                // defaultExtension has type string but we ensure that it is DataFormatType above\n                format.type = defaultExtension;\n            }\n        }\n        else if (isSphereGenerator(data)) {\n            // hardwire GeoJSON sphere data into output specification\n            this._data = { values: [{ type: 'Sphere' }] };\n        }\n        else if (isNamedData(data) || isGenerator(data)) {\n            this._data = {};\n        }\n        // set flag to check if generator\n        this._generator = isGenerator(data);\n        // any dataset can be named\n        if (data.name) {\n            this._name = data.name;\n        }\n        if (format && !isEmpty(format)) {\n            this._data.format = format;\n        }\n    }\n    dependentFields() {\n        return new Set();\n    }\n    producedFields() {\n        return undefined; // we don't know what this source produces\n    }\n    get data() {\n        return this._data;\n    }\n    hasName() {\n        return !!this._name;\n    }\n    get isGenerator() {\n        return this._generator;\n    }\n    get dataName() {\n        return this._name;\n    }\n    set dataName(name) {\n        this._name = name;\n    }\n    set parent(parent) {\n        throw new Error('Source nodes have to be roots.');\n    }\n    remove() {\n        throw new Error('Source nodes are roots and cannot be removed.');\n    }\n    hash() {\n        throw new Error('Cannot hash sources');\n    }\n    assemble() {\n        return Object.assign(Object.assign({ name: this._name }, this._data), { transform: [] });\n    }\n}\n//# sourceMappingURL=source.js.map"]},"metadata":{},"sourceType":"module"}