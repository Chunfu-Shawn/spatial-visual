var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __require = typeof require !== "undefined" ? require : (x) => {
  throw new Error('Dynamic require of "' + x + '" is not supported');
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/components/heatmap/HeatmapSubscriber.js
import React14, {
  useEffect as useEffect5,
  useState as useState7,
  useCallback as useCallback5,
  useMemo as useMemo5
} from "react";

// src/components/TitleInfo.js
import React3, { useState as useState2 } from "react";
import { makeStyles as makeStyles2 } from "@material-ui/core/styles";
import CloudDownloadIcon from "@material-ui/icons/CloudDownload";
import MenuItem from "@material-ui/core/MenuItem";
import IconButton2 from "@material-ui/core/IconButton";
import Link from "@material-ui/core/Link";
import ArrowDropDownIcon from "@material-ui/icons/ArrowDropDown";
import ArrowDropUpIcon from "@material-ui/icons/ArrowDropUp";
import SettingsIcon from "@material-ui/icons/Settings";
import CloseIcon from "@material-ui/icons/Close";

// src/components/classNames.js
var TOOLTIP_ANCESTOR = "tooltip-ancestor";
var CARD = `card card-body my-2 ${TOOLTIP_ANCESTOR}`;
var PRIMARY_CARD = `${CARD} bg-primary`;
var SECONDARY_CARD = `${CARD} bg-secondary`;
var BLACK_CARD = `${CARD} bg-black`;
var SCROLL_CARD = `${PRIMARY_CARD} scroll`;
var VITESSCE_CONTAINER = "vitessce-container";

// src/components/LoadingIndicator.js
import React from "react";
import CircularProgress from "@material-ui/core/CircularProgress";
function LoadingIndicator() {
  return /* @__PURE__ */ React.createElement("div", {
    className: "loading-indicator-backdrop"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "loading-indicator-container"
  }, /* @__PURE__ */ React.createElement(CircularProgress, null)));
}

// src/components/shared-mui/components.js
import React2, { useRef as useRef3 } from "react";
import Paper from "@material-ui/core/Paper";
import Popper from "@material-ui/core/Popper";
import IconButton from "@material-ui/core/IconButton";
import MenuList from "@material-ui/core/MenuList";
import ClickAwayListener from "@material-ui/core/ClickAwayListener";
import Fade from "@material-ui/core/Fade";

// src/components/hooks.js
import {
  useRef as useRef2,
  useState,
  useEffect,
  useCallback as useCallback2,
  useMemo as useMemo2
} from "react";
import debounce from "lodash/debounce";

// src/app/state/hooks.js
import { useRef, useCallback, useMemo } from "react";
import create from "zustand";
import createContext from "zustand/context";
import shallow from "zustand/shallow";

// src/utils.js
function fromEntries(iterable) {
  return [...iterable].reduce((obj, { 0: key, 1: val }) => Object.assign(obj, { [key]: val }), {});
}
function range(length) {
  return [...Array(length).keys()];
}
function pluralize(singular, plural, count) {
  return count === 1 ? singular : plural;
}
function capitalize(word) {
  return word.charAt(0).toUpperCase() + word.slice(1);
}
function getNextScope(prevScopes) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const nextCharIndices = [0];
  function next() {
    const r = [];
    nextCharIndices.forEach((charIndex) => {
      r.unshift(chars[charIndex]);
    });
    let increment = true;
    for (let i = 0; i < nextCharIndices.length; i++) {
      const val = ++nextCharIndices[i];
      if (val >= chars.length) {
        nextCharIndices[i] = 0;
      } else {
        increment = false;
        break;
      }
    }
    if (increment) {
      nextCharIndices.push(0);
    }
    return r.join("");
  }
  let nextScope;
  do {
    nextScope = next();
  } while (prevScopes.includes(nextScope));
  return nextScope;
}
function getSourceFromLoader(loader, level) {
  const { data } = loader;
  const source = Array.isArray(data) ? data[level || data.length - 1] : data;
  return source;
}
function isRgb(loader) {
  const source = getSourceFromLoader(loader);
  const { shape, dtype, labels } = source;
  const channelSize = shape[labels.indexOf("c")];
  return channelSize === 3 && dtype === "Uint8";
}

// src/app/state/hooks.js
var {
  Provider: ViewConfigProviderLocal,
  useStore: useViewConfigStoreLocal,
  useStoreApi: useViewConfigStoreApiLocal
} = createContext();
var ViewConfigProvider = ViewConfigProviderLocal;
var useViewConfigStore = useViewConfigStoreLocal;
var useViewConfigStoreApi = useViewConfigStoreApiLocal;
var {
  Provider: AuxiliaryProviderLocal,
  useStore: useAuxiliaryStoreLocal
} = createContext();
var AuxiliaryProvider = AuxiliaryProviderLocal;
var useAuxiliaryStore = useAuxiliaryStoreLocal;
var createViewConfigStore = () => create((set) => ({
  viewConfig: null,
  loaders: null,
  setViewConfig: (viewConfig) => set({ viewConfig }),
  setLoaders: (loaders) => set({ loaders }),
  setCoordinationValue: ({ parameter, scope, value }) => set((state) => ({
    viewConfig: __spreadProps(__spreadValues({}, state.viewConfig), {
      coordinationSpace: __spreadProps(__spreadValues({}, state.viewConfig.coordinationSpace), {
        [parameter]: __spreadProps(__spreadValues({}, state.viewConfig.coordinationSpace[parameter]), {
          [scope]: value
        })
      })
    })
  })),
  removeComponent: (i) => set((state) => {
    const newLayout = state.viewConfig.layout.slice();
    newLayout.splice(i, 1);
    return {
      viewConfig: __spreadProps(__spreadValues({}, state.viewConfig), {
        layout: newLayout
      })
    };
  }),
  changeLayout: (newComponentProps) => set((state) => {
    const newLayout = state.viewConfig.layout.slice();
    newComponentProps.forEach(([i, newProps]) => {
      newLayout[i] = __spreadValues(__spreadValues({}, newLayout[i]), newProps);
    });
    return {
      viewConfig: __spreadProps(__spreadValues({}, state.viewConfig), {
        layout: newLayout
      })
    };
  })
}));
var useComponentLayout = (component, scopes, coordinationScopes) => useViewConfigStore((state) => state.viewConfig.layout.filter((l) => l.component === component).filter((l) => scopes.every((scope) => l.coordinationScopes[scope] === coordinationScopes[scope])));
var createAuxiliaryStore = () => create((set) => ({
  auxiliaryStore: null,
  setCoordinationValue: ({ parameter, scope, value }) => set((state) => ({
    auxiliaryStore: __spreadProps(__spreadValues({}, state.auxiliaryStore), {
      [parameter]: {
        [scope]: value
      }
    })
  }))
}));
var useHoverStore = create((set) => ({
  componentHover: null,
  setComponentHover: (componentHover) => set({ componentHover })
}));
var useWarnStore = create((set) => ({
  warning: null,
  setWarning: (warning) => set({ warning })
}));
var useViewInfoStore = create((set) => ({
  viewInfo: {},
  setComponentViewInfo: (uuid, viewInfo) => set((state) => ({
    viewInfo: __spreadProps(__spreadValues({}, state.viewInfo), {
      [uuid]: viewInfo
    })
  }))
}));
var useGridSizeStore = create((set) => ({
  resizeCount: {},
  incrementResizeCount: () => set((state) => ({
    resizeCount: state.resizeCount + 1
  }))
}));
function useCoordination(parameters, coordinationScopes) {
  const setCoordinationValue = useViewConfigStore((state) => state.setCoordinationValue);
  const values = useViewConfigStore((state) => {
    const { coordinationSpace } = state.viewConfig;
    return fromEntries(parameters.map((parameter) => {
      if (coordinationSpace && coordinationSpace[parameter]) {
        const value = coordinationSpace[parameter][coordinationScopes[parameter]];
        return [parameter, value];
      }
      return [parameter, void 0];
    }));
  }, shallow);
  const setters = useMemo(() => fromEntries(parameters.map((parameter) => {
    const setterName = `set${capitalize(parameter)}`;
    const setterFunc = (value) => setCoordinationValue({
      parameter,
      scope: coordinationScopes[parameter],
      value
    });
    return [setterName, setterFunc];
  })), [parameters, coordinationScopes]);
  return [values, setters];
}
var AUXILIARY_COORDINATION_TYPES_MAP = {
  spatialRasterLayers: ["rasterLayersCallbacks", "areLoadingRasterChannnels"]
};
var mapCoordinationScopes = (coordinationScopes) => {
  const newCoordinationScopes = {};
  Object.keys(coordinationScopes).forEach((key) => {
    const newCoordinationTypes = AUXILIARY_COORDINATION_TYPES_MAP[key] || [];
    newCoordinationTypes.forEach((coordinationType) => {
      newCoordinationScopes[coordinationType || key] = coordinationScopes[key];
    });
  });
  return newCoordinationScopes;
};
var mapParameters = (parameters) => parameters.map((parameter) => AUXILIARY_COORDINATION_TYPES_MAP[parameter]).filter(Boolean).flat();
function useAuxiliaryCoordination(parameters, coordinationScopes) {
  const setCoordinationValue = useAuxiliaryStore((state) => state.setCoordinationValue);
  const mappedCoordinationScopes = mapCoordinationScopes(coordinationScopes);
  const mappedParameters = mapParameters(parameters);
  const values = useAuxiliaryStore((state) => {
    const { auxiliaryStore } = state;
    return fromEntries(mappedParameters.map((parameter) => {
      if (auxiliaryStore && auxiliaryStore[parameter]) {
        const value = auxiliaryStore[parameter][mappedCoordinationScopes[parameter]];
        return [parameter, value];
      }
      return [parameter, void 0];
    }));
  }, shallow);
  const setters = useMemo(() => fromEntries(mappedParameters.map((parameter) => {
    const setterName = `set${capitalize(parameter)}`;
    const setterFunc = (value) => setCoordinationValue({
      parameter,
      scope: mappedCoordinationScopes[parameter],
      value
    });
    return [setterName, setterFunc];
  })), [parameters, coordinationScopes]);
  return [values, setters];
}
function useLoaders() {
  return useViewConfigStore((state) => state.loaders);
}
function useLayout() {
  return useViewConfigStore((state) => {
    var _a2;
    return (_a2 = state.viewConfig) == null ? void 0 : _a2.layout;
  });
}
function useRemoveComponent() {
  return useViewConfigStore((state) => state.removeComponent);
}
function useChangeLayout() {
  return useViewConfigStore((state) => state.changeLayout);
}
function useSetLoaders() {
  return useViewConfigStore((state) => state.setLoaders);
}
function useSetViewConfig(viewConfigStoreApi) {
  const setViewConfigRef = useRef(viewConfigStoreApi.getState().setViewConfig);
  const setViewConfig = setViewConfigRef.current;
  return setViewConfig;
}
function useComponentHover() {
  return useHoverStore((state) => state.componentHover);
}
function useSetComponentHover() {
  return useHoverStore((state) => state.setComponentHover);
}
function useWarning() {
  return useWarnStore((state) => state.warning);
}
function useSetWarning() {
  return useWarnStore((state) => state.setWarning);
}
function useComponentViewInfo(uuid) {
  return useViewInfoStore(useCallback((state) => state.viewInfo[uuid], [uuid]));
}
function useSetComponentViewInfo(uuid) {
  const setViewInfoRef = useRef(useViewInfoStore.getState().setComponentViewInfo);
  const setComponentViewInfo = (viewInfo) => setViewInfoRef.current(uuid, viewInfo);
  return setComponentViewInfo;
}
function useGridResize() {
  return useGridSizeStore((state) => state.resizeCount);
}
function useEmitGridResize() {
  return useGridSizeStore((state) => state.incrementResizeCount);
}

// src/components/hooks.js
function getWindowDimensions() {
  const { innerWidth: width, innerHeight: height } = window;
  return {
    width,
    height
  };
}
function useVitessceContainer(ref) {
  return useCallback2(() => {
    if (ref.current) {
      return ref.current.closest(`.${VITESSCE_CONTAINER}`);
    }
    return null;
  }, [ref]);
}
function useWindowDimensions() {
  const [windowDimensions, setWindowDimensions] = useState(getWindowDimensions());
  useEffect(() => {
    function handleResize() {
      setWindowDimensions(getWindowDimensions());
    }
    const onResizeDebounced = debounce(handleResize, 100, { trailing: true });
    window.addEventListener("resize", onResizeDebounced);
    return () => window.removeEventListener("resize", onResizeDebounced);
  }, []);
  return windowDimensions;
}
function useGridItemSize() {
  const containerRef = useRef2();
  const [height, setHeight] = useState();
  const [width, setWidth] = useState();
  const resizeCount = useGridResize();
  const incrementResizeCount = useEmitGridResize();
  useEffect(() => {
    function onWindowResize() {
      incrementResizeCount();
    }
    const onResizeDebounced = debounce(onWindowResize, 100, { trailing: true });
    window.addEventListener("resize", onResizeDebounced);
    onWindowResize();
    return () => {
      window.removeEventListener("resize", onResizeDebounced);
    };
  }, [incrementResizeCount]);
  useEffect(() => {
    if (!containerRef.current)
      return;
    const container = containerRef.current;
    const containerRect = container.getBoundingClientRect();
    setHeight(containerRect.height);
    setWidth(containerRect.width);
  }, [resizeCount]);
  return [width, height, containerRef];
}
function useDeckCanvasSize() {
  const deckRef = useRef2();
  const [height, setHeight] = useState();
  const [width, setWidth] = useState();
  const resizeCount = useGridResize();
  const incrementResizeCount = useEmitGridResize();
  useEffect(() => {
    function onWindowResize() {
      incrementResizeCount();
    }
    const onResizeDebounced = debounce(onWindowResize, 100, { trailing: true });
    window.addEventListener("resize", onResizeDebounced);
    onWindowResize();
    return () => {
      window.removeEventListener("resize", onResizeDebounced);
    };
  }, [incrementResizeCount]);
  useEffect(() => {
    if (!deckRef.current)
      return;
    const { canvas } = deckRef.current.deck;
    const canvasRect = canvas.getBoundingClientRect();
    setHeight(canvasRect.height);
    setWidth(canvasRect.width);
  }, [resizeCount]);
  return [width, height, deckRef];
}
function useReady(supportedItems) {
  const items2 = supportedItems;
  const [waiting, setWaiting] = useState(items2);
  const setItemIsReady = useCallback2((readyItem) => {
    setWaiting((waitingItems) => {
      const nextWaitingItems = waitingItems.filter((item) => item !== readyItem);
      console.log(`cleared ${readyItem}; waiting on ${nextWaitingItems.length}: ${JSON.stringify(nextWaitingItems)}`);
      return nextWaitingItems;
    });
  }, [setWaiting]);
  const setItemIsNotReady = useCallback2((notReadyItem) => {
    setWaiting((waitingItems) => {
      const nextWaitingItems = [...waitingItems, notReadyItem];
      console.log(`waiting on ${nextWaitingItems.length}: ${JSON.stringify(nextWaitingItems)}`);
      return nextWaitingItems;
    });
  }, [setWaiting]);
  const resetReadyItems = useCallback2(() => {
    setWaiting(items2);
    console.log(`waiting on ${items2.length}: ${JSON.stringify(items2)}`);
  }, [setWaiting, items2]);
  const isReady = waiting.length === 0;
  return [isReady, setItemIsReady, setItemIsNotReady, resetReadyItems];
}
function useUrls() {
  const [urls, setUrls] = useState([]);
  const addUrl = useCallback2((url, name2) => {
    if (url) {
      setUrls((prev) => [...prev, { url, name: name2 }]);
    }
  }, [setUrls]);
  const resetUrls = useCallback2(() => {
    setUrls([]);
  }, [setUrls]);
  return [urls, addUrl, resetUrls];
}
function useClosestVitessceContainerSize(ref) {
  const [height, setHeight] = useState();
  const [width, setWidth] = useState();
  useEffect(() => {
    function onWindowResize() {
      if (ref.current) {
        const {
          clientHeight: componentHeight,
          clientWidth: componentWidth
        } = ref.current.closest(".vitessce-container");
        setWidth(componentWidth);
        setHeight(componentHeight);
      }
    }
    const onResizeDebounced = debounce(onWindowResize, 100, { trailing: true });
    window.addEventListener("resize", onResizeDebounced);
    onWindowResize();
    return () => {
      window.removeEventListener("resize", onResizeDebounced);
    };
  }, [ref]);
  return [width, height];
}
function useExpressionValueGetter({ attrs, expressionData }) {
  const cellIdMap = useMemo2(() => {
    const result = {};
    if (attrs && attrs.rows) {
      for (let i = 0; i < attrs.rows.length; i++) {
        result[attrs.rows[i]] = i;
      }
    }
    return result;
  }, [attrs]);
  const getExpressionValue = useCallback2((entry) => {
    const cellId = entry[0];
    if (cellIdMap && expressionData && expressionData[0]) {
      const cellIndex = cellIdMap[cellId];
      const val = expressionData[0][cellIndex];
      return val;
    }
    return 0;
  }, [cellIdMap, expressionData]);
  return getExpressionValue;
}

// src/components/shared-mui/styles.js
import { makeStyles, createMuiTheme } from "@material-ui/core/styles";
import { grey } from "@material-ui/core/colors";
var styles = makeStyles(() => ({
  paper: {
    maxHeight: 200,
    overflow: "auto"
  },
  container: {
    position: "relative",
    left: 0,
    top: 0
  },
  span: {
    width: "70px",
    textAlign: "center",
    paddingLeft: "2px",
    paddingRight: "2px"
  }
}));
var muiTheme = {
  dark: createMuiTheme({
    palette: {
      type: "dark",
      primary: grey,
      secondary: grey,
      primaryBackground: "#222222",
      primaryBackgroundHighlight: "#000000",
      primaryBackgroundInput: "#D3D3D3",
      primaryBackgroundDim: "#333333",
      primaryBackgroundLight: "#757575",
      primaryForeground: "#D3D3D3",
      primaryForegroundDim: "#000000",
      primaryForegroundActive: "#9bb7d6",
      secondaryBackground: "#000000",
      secondaryBackgroundDim: "#444444",
      secondaryForeground: "#D3D3D3"
    },
    props: {
      MuiButtonBase: {
        disableRipple: true
      }
    }
  }),
  light: createMuiTheme({
    palette: {
      type: "light",
      primary: grey,
      secondary: grey,
      primaryBackground: "#F1F1F1",
      primaryBackgroundHighlight: "#FFFFFF",
      primaryBackgroundInput: "#FFFFFF",
      primaryBackgroundDim: "#8A8A8A",
      primaryBackgroundLight: "#e0e0e0",
      primaryForeground: "#333333",
      primaryForegroundDim: "#808080",
      primaryForegroundActive: "#0074D9",
      secondaryBackground: "#F1F1F1",
      secondaryBackgroundDim: "#C0C0C0",
      secondaryForeground: "#222222"
    },
    props: {
      MuiButtonBase: {
        disableRipple: true
      }
    }
  })
};

// src/components/shared-mui/components.js
function MuiSpan(props) {
  const { children } = props;
  const classes = styles();
  return /* @__PURE__ */ React2.createElement("span", {
    className: classes.span
  }, children);
}
function PopperMenu(props) {
  const {
    buttonIcon,
    open,
    setOpen,
    children,
    buttonClassName
  } = props;
  const classes = styles();
  const anchorRef = useRef3();
  const handleClick = () => {
    setOpen((prev) => !prev);
  };
  const handleClose = () => {
    setOpen(false);
  };
  const id = open ? "v-popover-menu" : void 0;
  const getTooltipContainer = useVitessceContainer(anchorRef);
  return /* @__PURE__ */ React2.createElement("div", {
    ref: anchorRef,
    className: classes.container
  }, /* @__PURE__ */ React2.createElement(IconButton, {
    "aria-describedby": id,
    onClick: handleClick,
    size: "small",
    className: buttonClassName
  }, buttonIcon), /* @__PURE__ */ React2.createElement(Popper, {
    id,
    open,
    anchorEl: anchorRef && anchorRef.current,
    container: getTooltipContainer,
    onClose: handleClose,
    placement: "bottom-end",
    transition: true
  }, ({ TransitionProps }) => /* @__PURE__ */ React2.createElement(ClickAwayListener, {
    onClickAway: handleClose
  }, /* @__PURE__ */ React2.createElement(Fade, __spreadProps(__spreadValues({}, TransitionProps), {
    timeout: 100
  }), /* @__PURE__ */ React2.createElement(Paper, {
    elevation: 4,
    className: classes.paper
  }, /* @__PURE__ */ React2.createElement(MenuList, null, children))))));
}

// src/components/TitleInfo.js
var useStyles = makeStyles2((theme) => ({
  iconButton: {
    border: "none",
    marginLeft: 0,
    background: "none",
    color: theme.palette.primaryForeground,
    paddingLeft: "0.25em",
    paddingRight: "0.25em",
    borderRadius: "2px",
    "&:hover": {
      backgroundColor: theme.palette.primaryBackgroundLight
    },
    "&:first-child": {
      marginLeft: "0.25em"
    },
    "&:last-child": {
      marginRight: "0.25em"
    },
    "& svg": {
      width: "0.7em",
      height: "0.7em",
      verticalAlign: "middle",
      overflow: "visible"
    }
  },
  downloadLink: {
    color: theme.palette.primaryForeground
  }
}));
function SettingsIconWithArrow({ open }) {
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(SettingsIcon, null), open ? /* @__PURE__ */ React3.createElement(ArrowDropUpIcon, null) : /* @__PURE__ */ React3.createElement(ArrowDropDownIcon, null));
}
function PlotOptions(props) {
  const { options } = props;
  const [open, setOpen] = useState2(false);
  const classes = useStyles();
  return /* @__PURE__ */ React3.createElement(PopperMenu, {
    open,
    setOpen,
    buttonIcon: /* @__PURE__ */ React3.createElement(SettingsIconWithArrow, {
      open
    }),
    buttonClassName: classes.iconButton,
    placement: "bottom-end"
  }, options);
}
function CloudDownloadIconWithArrow({ open }) {
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(CloudDownloadIcon, null), open ? /* @__PURE__ */ React3.createElement(ArrowDropUpIcon, null) : /* @__PURE__ */ React3.createElement(ArrowDropDownIcon, null));
}
function DownloadOptions(props) {
  const { urls } = props;
  const [open, setOpen] = useState2(false);
  const classes = useStyles();
  return /* @__PURE__ */ React3.createElement(PopperMenu, {
    open,
    setOpen,
    buttonIcon: /* @__PURE__ */ React3.createElement(CloudDownloadIconWithArrow, {
      open
    }),
    buttonClassName: classes.iconButton,
    placement: "bottom-end"
  }, urls.map(({ url, name: name2 }) => /* @__PURE__ */ React3.createElement(MenuItem, {
    dense: true,
    key: url
  }, /* @__PURE__ */ React3.createElement(Link, {
    underline: "none",
    href: url,
    target: "_blank",
    rel: "noopener",
    className: classes.downloadLink
  }, "Download ", name2))));
}
function ClosePaneButton(props) {
  const { removeGridComponent } = props;
  const classes = useStyles();
  return /* @__PURE__ */ React3.createElement(IconButton2, {
    onClick: removeGridComponent,
    size: "small",
    className: classes.iconButton,
    title: "close"
  }, /* @__PURE__ */ React3.createElement(CloseIcon, null));
}
function TitleInfo(props) {
  const {
    title: title16,
    info,
    children,
    isScroll,
    isSpatial,
    removeGridComponent,
    urls,
    isReady,
    options
  } = props;
  const childClassName = isScroll ? SCROLL_CARD : isSpatial ? BLACK_CARD : SECONDARY_CARD;
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement("div", {
    className: "title"
  }, /* @__PURE__ */ React3.createElement("div", {
    className: "title-left"
  }, title16), /* @__PURE__ */ React3.createElement("div", {
    className: "title-info",
    title: info
  }, info), /* @__PURE__ */ React3.createElement("div", {
    className: "title-buttons"
  }, options && /* @__PURE__ */ React3.createElement(PlotOptions, {
    options
  }), urls && urls.length > 0 && /* @__PURE__ */ React3.createElement(DownloadOptions, {
    urls
  }), /* @__PURE__ */ React3.createElement(ClosePaneButton, {
    removeGridComponent
  }))), /* @__PURE__ */ React3.createElement("div", {
    className: childClassName
  }, !isReady && /* @__PURE__ */ React3.createElement(LoadingIndicator, null), children));
}

// src/components/utils.js
import React4 from "react";
import { COORDINATE_SYSTEM } from "@deck.gl/core";

// src/schemas/cell-sets.schema.json
var $schema = "http://json-schema.org/draft-07/schema#";
var $id = "https://github.com/vitessce/vitessce/#cell-sets";
var title = "Vitessce cell sets data";
var type = "object";
var definitions = {
  stringArray: {
    type: "array",
    items: {
      type: "string"
    }
  },
  stringProbabilityTupleArray: {
    type: "array",
    items: {
      type: "array",
      additionalItems: false,
      items: [
        {
          type: "string"
        },
        {
          oneOf: [
            {
              type: "number",
              minimum: 0,
              maximum: 1
            },
            {
              type: "null"
            }
          ]
        }
      ]
    }
  },
  colorArray: {
    type: "array",
    items: {
      type: "integer",
      minimum: 0,
      maximum: 255
    },
    minItems: 3,
    maxItems: 3
  },
  treeNodeLeaf: {
    type: "object",
    additionalProperties: false,
    required: ["name"],
    properties: {
      name: {
        type: "string"
      },
      color: {
        $ref: "#/definitions/colorArray"
      },
      set: {
        $ref: "#/definitions/stringArray"
      }
    }
  },
  treeNodeNonLeaf: {
    type: "object",
    additionalProperties: false,
    required: ["name"],
    properties: {
      name: {
        type: "string"
      },
      color: {
        $ref: "#/definitions/colorArray"
      },
      children: {
        type: "array",
        items: {
          $ref: "#/definitions/treeNode"
        }
      }
    }
  },
  treeNode: {
    oneOf: [
      {
        $ref: "#/definitions/treeNodeNonLeaf"
      },
      {
        $ref: "#/definitions/treeNodeLeaf"
      }
    ]
  },
  "version0.1.2": {
    type: "object",
    additionalProperties: false,
    required: ["version", "datatype", "tree"],
    properties: {
      dataset: {
        type: "string"
      },
      version: {
        type: "string",
        enum: ["0.1.2"]
      },
      datatype: {
        type: "string",
        enum: ["cell"]
      },
      tree: {
        type: "array",
        items: {
          $ref: "#/definitions/treeNodeNonLeaf"
        }
      }
    }
  },
  treeNodeLeafProbabilistic: {
    type: "object",
    additionalProperties: false,
    required: ["name"],
    properties: {
      name: {
        type: "string"
      },
      color: {
        $ref: "#/definitions/colorArray"
      },
      set: {
        $ref: "#/definitions/stringProbabilityTupleArray"
      }
    }
  },
  treeNodeNonLeafProbabilistic: {
    type: "object",
    additionalProperties: false,
    required: ["name"],
    properties: {
      name: {
        type: "string"
      },
      color: {
        $ref: "#/definitions/colorArray"
      },
      children: {
        type: "array",
        items: {
          $ref: "#/definitions/treeNodeProbabilistic"
        }
      }
    }
  },
  treeNodeProbabilistic: {
    oneOf: [
      {
        $ref: "#/definitions/treeNodeNonLeafProbabilistic"
      },
      {
        $ref: "#/definitions/treeNodeLeafProbabilistic"
      }
    ]
  },
  "version0.1.3": {
    type: "object",
    additionalProperties: false,
    required: ["version", "datatype", "tree"],
    properties: {
      dataset: {
        type: "string"
      },
      version: {
        type: "string",
        enum: ["0.1.3"]
      },
      datatype: {
        type: "string",
        enum: ["cell"]
      },
      tree: {
        type: "array",
        items: {
          $ref: "#/definitions/treeNodeNonLeafProbabilistic"
        }
      }
    }
  }
};
var oneOf = [
  {
    $ref: "#/definitions/version0.1.2"
  },
  {
    $ref: "#/definitions/version0.1.3"
  }
];
var cell_sets_schema_default = {
  $schema,
  $id,
  title,
  type,
  definitions,
  oneOf
};

// src/schemas/cell-sets-tabular.schema.json
var $schema2 = "http://json-schema.org/draft-07/schema#";
var $id2 = "https://github.com/vitessce/vitessce/#cell-sets-tabular";
var title2 = "Vitessce cell sets data, tabular format";
var definitions2 = {
  colorArray: {
    type: "array",
    items: { type: "integer", minimum: 0, maximum: 255 },
    minItems: 3,
    maxItems: 3
  }
};
var type2 = "array";
var items = {
  type: "object",
  additionalProperties: false,
  required: ["groupName", "setName", "obsId"],
  properties: {
    groupName: { type: "string" },
    setName: { type: "string" },
    setColor: { $ref: "#/definitions/colorArray" },
    obsId: { type: "string" },
    predictionScore: {
      oneOf: [
        {
          type: "number",
          minimum: 0,
          maximum: 1
        },
        {
          type: "null"
        }
      ]
    }
  }
};
var cell_sets_tabular_schema_default = {
  $schema: $schema2,
  $id: $id2,
  title: title2,
  definitions: definitions2,
  type: type2,
  items
};

// src/components/sets/constants.js
var FILE_EXTENSION_JSON = "json";
var MIME_TYPE_JSON = "application/json";
var FILE_EXTENSION_TABULAR = "csv";
var MIME_TYPE_TABULAR = "text/csv";
var SEPARATOR_TABULAR = ",";
var NA_VALUE_TABULAR = "NA";
var SETS_DATATYPE_CELL = "cell";
var HIERARCHICAL_SCHEMAS = {
  cell: {
    latestVersion: "0.1.3",
    schema: cell_sets_schema_default
  }
};
var TABULAR_SCHEMAS = {
  cell: {
    schema: cell_sets_tabular_schema_default
  }
};

// src/components/utils.js
function makeCellStatusMessage(cellInfoFactors) {
  return Object.entries(cellInfoFactors).map(([factor, value]) => `${factor}: ${value}`).join("; ");
}
function cellLayerDefaultProps(cells, updateStatus, setCellHighlight, setComponentHover) {
  return {
    coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
    data: cells,
    pickable: true,
    autoHighlight: true,
    stroked: true,
    filled: true,
    getElevation: 0,
    onHover: (info) => {
      if (setComponentHover) {
        setComponentHover();
      }
      if (info.object) {
        const [cellId, cellInfo] = info.object;
        const { factors = {} } = cellInfo;
        if (updateStatus) {
          updateStatus(makeCellStatusMessage(factors));
        }
        if (setCellHighlight) {
          setCellHighlight(cellId);
        }
      } else if (setCellHighlight) {
        setCellHighlight("");
      }
    }
  };
}
var DEFAULT_DARK_COLOR = [50, 50, 50];
var DEFAULT_LIGHT_COLOR = [200, 200, 200];
function getDefaultColor(theme) {
  return theme === "dark" ? DEFAULT_DARK_COLOR : DEFAULT_LIGHT_COLOR;
}
var PALETTE = [
  [68, 119, 170],
  [136, 204, 238],
  [68, 170, 153],
  [17, 119, 51],
  [153, 153, 51],
  [221, 204, 119],
  [204, 102, 119],
  [136, 34, 85],
  [170, 68, 153]
];
var VIEWER_PALETTE = [
  [0, 0, 255],
  [0, 255, 0],
  [255, 0, 255],
  [255, 255, 0],
  [0, 255, 255],
  [255, 255, 255],
  [255, 128, 0],
  [255, 0, 0]
];
var COLORMAP_OPTIONS = [
  "viridis",
  "greys",
  "magma",
  "jet",
  "hot",
  "bone",
  "copper",
  "summer",
  "density",
  "inferno"
];
var DEFAULT_GL_OPTIONS = { webgl2: true };
function createDefaultUpdateCellsHover(componentName) {
  return (hoverInfo) => console.warn(`${componentName} updateCellsHover: ${hoverInfo.cellId}`);
}
function createDefaultUpdateGenesHover(componentName) {
  return (hoverInfo) => console.warn(`${componentName} updateGenesHover: ${hoverInfo.geneId}`);
}
function createDefaultUpdateViewInfo(componentName) {
  return (viewInfo) => console.warn(`${componentName} updateViewInfo: ${viewInfo}`);
}
function copyUint8Array(arr) {
  const newBuffer = new ArrayBuffer(arr.buffer.byteLength);
  const newArr = new Uint8Array(newBuffer);
  newArr.set(arr);
  return newArr;
}
function getNextNumberedNodeName(nodes, prefix) {
  let i = 1;
  if (nodes) {
    while (nodes.find((n) => n.name === `${prefix}${i}`)) {
      i++;
    }
  }
  return `${prefix}${i}`;
}
function setCellSelection(cellSelection, additionalCellSets, cellSetColor, setCellSetSelection, setAdditionalCellSets, setCellSetColor, setCellColorEncoding, prefix = "Selection ") {
  const CELL_SELECTIONS_LEVEL_ZERO_NAME = "My Selections";
  const selectionsLevelZeroNode = additionalCellSets == null ? void 0 : additionalCellSets.tree.find((n) => n.name === CELL_SELECTIONS_LEVEL_ZERO_NAME);
  const nextAdditionalCellSets = {
    version: HIERARCHICAL_SCHEMAS[SETS_DATATYPE_CELL].latestVersion,
    datatype: SETS_DATATYPE_CELL,
    tree: [...additionalCellSets ? additionalCellSets.tree : []]
  };
  const nextName = getNextNumberedNodeName(selectionsLevelZeroNode == null ? void 0 : selectionsLevelZeroNode.children, prefix);
  let colorIndex = 0;
  if (selectionsLevelZeroNode) {
    colorIndex = selectionsLevelZeroNode.children.length;
    selectionsLevelZeroNode.children.push({
      name: nextName,
      set: cellSelection.map((d) => [d, null])
    });
  } else {
    nextAdditionalCellSets.tree.push({
      name: CELL_SELECTIONS_LEVEL_ZERO_NAME,
      children: [
        {
          name: nextName,
          set: cellSelection.map((d) => [d, null])
        }
      ]
    });
  }
  setAdditionalCellSets(nextAdditionalCellSets);
  const nextPath = ["My Selections", nextName];
  setCellSetColor([
    ...cellSetColor || [],
    {
      path: nextPath,
      color: PALETTE[colorIndex % PALETTE.length]
    }
  ]);
  setCellSetSelection([nextPath]);
  setCellColorEncoding("cellSetSelection");
}
function mergeCellSets(cellSets, additionalCellSets) {
  return {
    version: HIERARCHICAL_SCHEMAS[SETS_DATATYPE_CELL].latestVersion,
    datatype: SETS_DATATYPE_CELL,
    tree: [
      ...cellSets ? cellSets.tree : [],
      ...additionalCellSets ? additionalCellSets.tree : []
    ]
  };
}
function createWarningComponent(props) {
  return () => {
    const {
      title: title16,
      message
    } = props;
    return /* @__PURE__ */ React4.createElement("div", {
      className: PRIMARY_CARD
    }, /* @__PURE__ */ React4.createElement("h1", null, title16), /* @__PURE__ */ React4.createElement("div", null, message));
  };
}
function asEsModule(component) {
  return {
    __esModule: true,
    default: component
  };
}
function formatBytes(bytes, decimals = 2) {
  if (bytes === 0)
    return "0 Bytes";
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ["Bytes", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}
var getStatsForResolution = (loader, resolution) => {
  const { shape, labels } = loader[resolution];
  const height = shape[labels.indexOf("y")];
  const width = shape[labels.indexOf("x")];
  const depth = shape[labels.indexOf("z")];
  const depthDownsampled = Math.max(1, depth >> resolution);
  const totalBytes = 4 * height * width * depthDownsampled;
  return {
    height,
    width,
    depthDownsampled,
    totalBytes
  };
};
var canLoadResolution = (loader, resolution) => {
  var _a2, _b2, _c;
  const {
    totalBytes,
    height,
    width,
    depthDownsampled
  } = getStatsForResolution(loader, resolution);
  const maxHeapSize = ((_a2 = window.performance) == null ? void 0 : _a2.memory) && ((_c = (_b2 = window.performance) == null ? void 0 : _b2.memory) == null ? void 0 : _c.jsHeapSizeLimit) / 2;
  const maxSize = maxHeapSize || __pow(2, 31) - 1;
  return totalBytes < maxSize && height <= 2048 && depthDownsampled <= 2048 && width <= 2048 && depthDownsampled > 1;
};

// src/components/data-hooks.js
import { useState as useState4, useEffect as useEffect2 } from "react";
import equal2 from "fast-deep-equal";

// src/loaders/errors/AbstractLoaderError.js
var AbstractLoaderError = class {
  constructor(message) {
    this.message = message;
  }
  warnInConsole() {
    throw new Error("The warnInConsole() method has not been implemented.");
  }
};

// src/loaders/errors/LoaderValidationError.js
var LoaderValidationError = class extends AbstractLoaderError {
  constructor(datasetType, datasetFileType, datasetUrl, reason) {
    super(`Error while validating ${datasetType}.`);
    this.name = "LoaderValidationError";
    this.datasetType = datasetType;
    this.datasetFileType = datasetFileType;
    this.datasetUrl = datasetUrl;
    this.reason = reason;
  }
  warnInConsole() {
    const {
      datasetType,
      datasetUrl,
      reason
    } = this;
    console.warn(`${datasetType} from ${datasetUrl}: validation failed`, JSON.stringify(reason, null, 2));
  }
};

// src/loaders/errors/LoaderNotFoundError.js
var LoaderNotFoundError = class extends AbstractLoaderError {
  constructor(datasetType, datasetFileType, datasetUrl) {
    super(`Error finding loader for ${datasetType}.`);
    this.name = "LoaderNotFoundError";
    this.datasetType = datasetType;
    this.datasetFileType = datasetFileType;
    this.datasetUrl = datasetUrl;
  }
  warnInConsole() {
    const {
      datasetType,
      datasetFileType,
      datasetUrl
    } = this;
    if (datasetFileType && datasetUrl) {
      console.warn(`${datasetType} from ${datasetUrl}: unable to find loader for fileType ${datasetFileType}`);
    } else {
      console.warn(`${datasetType}: unable to find loader`);
    }
  }
};

// node_modules/@hms-dbmi/viv/dist/viv.es.js
import { COORDINATE_SYSTEM as COORDINATE_SYSTEM2, Layer, project32, picking, CompositeLayer, OrthographicView, Controller, OrbitView } from "@deck.gl/core";
import { Matrix4 } from "math.gl";
import GL from "@luma.gl/constants";
import { TileLayer } from "@deck.gl/geo-layers";
import { Model, Geometry, Texture2D, isWebGL2, Texture3D } from "@luma.gl/core";
import { hasFeature, FEATURES } from "@luma.gl/webgl";
import { BitmapLayer as BitmapLayer$1, PolygonLayer, LineLayer, TextLayer } from "@deck.gl/layers";
import quickselect from "quickselect";
import { Plane } from "@math.gl/culling";
import React5, { PureComponent, useState as useState3, useMemo as useMemo3 } from "react";
import DeckGL from "@deck.gl/react";
import equal from "fast-deep-equal";
import { fromUrl, fromBlob } from "geotiff";
import parser from "fast-xml-parser";
import { KeyError, openGroup, BoundsCheckError, slice, HTTPStore } from "zarr";
var fsColormap1 = "#define SHADER_NAME xr-layer-fragment-shader-colormap\nprecision highp float;\n#define GLSLIFY 1\nuniform sampler2D channel0;uniform sampler2D channel1;uniform sampler2D channel2;uniform sampler2D channel3;uniform sampler2D channel4;uniform sampler2D channel5;uniform vec2 contrastLimits[6];uniform float opacity;uniform float divisor;uniform bool useTransparentColor;varying vec2 vTexCoord;void main(){float intensityValue0=sample_and_apply_contrast_limits(channel0,vTexCoord,contrastLimits[0]);float intensityValue1=sample_and_apply_contrast_limits(channel1,vTexCoord,contrastLimits[1]);float intensityValue2=sample_and_apply_contrast_limits(channel2,vTexCoord,contrastLimits[2]);float intensityValue3=sample_and_apply_contrast_limits(channel3,vTexCoord,contrastLimits[3]);float intensityValue4=sample_and_apply_contrast_limits(channel4,vTexCoord,contrastLimits[4]);float intensityValue5=sample_and_apply_contrast_limits(channel5,vTexCoord,contrastLimits[5]);float intensityCombo=0.;intensityCombo+=max(0.,intensityValue0);intensityCombo+=max(0.,intensityValue1);intensityCombo+=max(0.,intensityValue2);intensityCombo+=max(0.,intensityValue3);intensityCombo+=max(0.,intensityValue4);intensityCombo+=max(0.,intensityValue5);gl_FragColor=colormap(intensityCombo,opacity,useTransparentColor);geometry.uv=vTexCoord;DECKGL_FILTER_COLOR(gl_FragColor,geometry);}";
var fsColormap2 = "#version 300 es\n#define SHADER_NAME xr-layer-fragment-shader\nprecision highp float;precision highp int;precision highp SAMPLER_TYPE;\n#define GLSLIFY 1\nuniform SAMPLER_TYPE channel0;uniform SAMPLER_TYPE channel1;uniform SAMPLER_TYPE channel2;uniform SAMPLER_TYPE channel3;uniform SAMPLER_TYPE channel4;uniform SAMPLER_TYPE channel5;uniform vec2 contrastLimits[6];uniform float opacity;uniform bool useTransparentColor;in vec2 vTexCoord;out vec4 color;void main(){float intensityValue0=sample_and_apply_contrast_limits(channel0,vTexCoord,contrastLimits[0]);float intensityValue1=sample_and_apply_contrast_limits(channel1,vTexCoord,contrastLimits[1]);float intensityValue2=sample_and_apply_contrast_limits(channel2,vTexCoord,contrastLimits[2]);float intensityValue3=sample_and_apply_contrast_limits(channel3,vTexCoord,contrastLimits[3]);float intensityValue4=sample_and_apply_contrast_limits(channel4,vTexCoord,contrastLimits[4]);float intensityValue5=sample_and_apply_contrast_limits(channel5,vTexCoord,contrastLimits[5]);float intensityArray[6]=float[6](intensityValue0,intensityValue1,intensityValue2,intensityValue3,intensityValue4,intensityValue5);float intensityCombo=0.;for(int i=0;i<6;i++){intensityCombo+=max(0.,intensityArray[i]);}color=colormap(intensityCombo,opacity,useTransparentColor);geometry.uv=vTexCoord;DECKGL_FILTER_COLOR(color,geometry);}";
var fs1 = "#define SHADER_NAME xr-layer-fragment-shader\nprecision highp float;\n#define GLSLIFY 1\nuniform sampler2D channel0;uniform sampler2D channel1;uniform sampler2D channel2;uniform sampler2D channel3;uniform sampler2D channel4;uniform sampler2D channel5;uniform vec2 contrastLimits[6];uniform vec3 colors[6];uniform float intensityArray[6];uniform float opacity;uniform float majorLensAxis;uniform float minorLensAxis;uniform vec2 lensCenter;uniform bool isLensOn;uniform int lensSelection;uniform vec3 lensBorderColor;uniform float lensBorderRadius;uniform vec3 transparentColor;uniform bool useTransparentColor;varying vec2 vTexCoord;void main(){float intensityValue0=sample_and_apply_contrast_limits(channel0,vTexCoord,contrastLimits[0]);float intensityValue1=sample_and_apply_contrast_limits(channel1,vTexCoord,contrastLimits[1]);float intensityValue2=sample_and_apply_contrast_limits(channel2,vTexCoord,contrastLimits[2]);float intensityValue3=sample_and_apply_contrast_limits(channel3,vTexCoord,contrastLimits[3]);float intensityValue4=sample_and_apply_contrast_limits(channel4,vTexCoord,contrastLimits[4]);float intensityValue5=sample_and_apply_contrast_limits(channel5,vTexCoord,contrastLimits[5]);bool isFragInLensBounds=frag_in_lens_bounds(lensCenter,vTexCoord,majorLensAxis,minorLensAxis,lensBorderRadius);bool isFragOnLensBounds=frag_on_lens_bounds(lensCenter,vTexCoord,majorLensAxis,minorLensAxis,lensBorderRadius);bool inLensAndUseLens=isLensOn&&isFragInLensBounds;vec3 rgbCombo=process_channel_intensity(intensityValue0,colors[0],0,inLensAndUseLens,lensSelection);rgbCombo+=process_channel_intensity(intensityValue1,colors[1],1,inLensAndUseLens,lensSelection);rgbCombo+=process_channel_intensity(intensityValue2,colors[2],2,inLensAndUseLens,lensSelection);rgbCombo+=process_channel_intensity(intensityValue3,colors[3],3,inLensAndUseLens,lensSelection);rgbCombo+=process_channel_intensity(intensityValue4,colors[4],4,inLensAndUseLens,lensSelection);rgbCombo+=process_channel_intensity(intensityValue5,colors[5],5,inLensAndUseLens,lensSelection);rgbCombo=(isLensOn&&isFragOnLensBounds)? lensBorderColor : rgbCombo;gl_FragColor=apply_opacity(rgbCombo,useTransparentColor,transparentColor,opacity);geometry.uv=vTexCoord;DECKGL_FILTER_COLOR(gl_FragColor,geometry);}";
var fs2 = "#version 300 es\n#define SHADER_NAME xr-layer-fragment-shader\nprecision highp float;precision highp int;precision highp SAMPLER_TYPE;\n#define GLSLIFY 1\nuniform SAMPLER_TYPE channel0;uniform SAMPLER_TYPE channel1;uniform SAMPLER_TYPE channel2;uniform SAMPLER_TYPE channel3;uniform SAMPLER_TYPE channel4;uniform SAMPLER_TYPE channel5;uniform vec2 contrastLimits[6];uniform vec3 colors[6];uniform float opacity;uniform float majorLensAxis;uniform float minorLensAxis;uniform vec2 lensCenter;uniform bool isLensOn;uniform int lensSelection;uniform vec3 lensBorderColor;uniform float lensBorderRadius;uniform vec3 transparentColor;uniform bool useTransparentColor;in vec2 vTexCoord;out vec4 color;void main(){float intensityValue0=sample_and_apply_contrast_limits(channel0,vTexCoord,contrastLimits[0]);float intensityValue1=sample_and_apply_contrast_limits(channel1,vTexCoord,contrastLimits[1]);float intensityValue2=sample_and_apply_contrast_limits(channel2,vTexCoord,contrastLimits[2]);float intensityValue3=sample_and_apply_contrast_limits(channel3,vTexCoord,contrastLimits[3]);float intensityValue4=sample_and_apply_contrast_limits(channel4,vTexCoord,contrastLimits[4]);float intensityValue5=sample_and_apply_contrast_limits(channel5,vTexCoord,contrastLimits[5]);float intensityArray[6]=float[6](intensityValue0,intensityValue1,intensityValue2,intensityValue3,intensityValue4,intensityValue5);bool isFragInLensBounds=frag_in_lens_bounds(lensCenter,vTexCoord,majorLensAxis,minorLensAxis,lensBorderRadius);bool isFragOnLensBounds=frag_on_lens_bounds(lensCenter,vTexCoord,majorLensAxis,minorLensAxis,lensBorderRadius);bool inLensAndUseLens=isLensOn&&isFragInLensBounds;vec3 rgbCombo=vec3(0.);for(int i=0;i<6;i++){rgbCombo+=process_channel_intensity(intensityArray[i],colors[i],i,inLensAndUseLens,lensSelection);}rgbCombo=(isLensOn&&isFragOnLensBounds)? lensBorderColor : rgbCombo;color=apply_opacity(rgbCombo,useTransparentColor,transparentColor,opacity);geometry.uv=vTexCoord;DECKGL_FILTER_COLOR(color,geometry);}";
var vs1 = "#define GLSLIFY 1\n#define SHADER_NAME xr-layer-vertex-shader\nattribute vec2 texCoords;attribute vec3 positions;attribute vec3 positions64Low;attribute vec3 instancePickingColors;varying vec2 vTexCoord;void main(void){geometry.worldPosition=positions;geometry.uv=texCoords;geometry.pickingColor=instancePickingColors;gl_Position=project_position_to_clipspace(positions,positions64Low,vec3(0.),geometry.position);DECKGL_FILTER_GL_POSITION(gl_Position,geometry);vTexCoord=texCoords;vec4 color=vec4(0.);DECKGL_FILTER_COLOR(color,geometry);}";
var vs2 = "#version 300 es\n#define GLSLIFY 1\n#define SHADER_NAME xr-layer-vertex-shader\nin vec2 texCoords;in vec3 positions;in vec3 positions64Low;in vec3 instancePickingColors;out vec2 vTexCoord;void main(void){geometry.worldPosition=positions;geometry.uv=texCoords;geometry.pickingColor=instancePickingColors;gl_Position=project_position_to_clipspace(positions,positions64Low,vec3(0.),geometry.position);DECKGL_FILTER_GL_POSITION(gl_Position,geometry);vTexCoord=texCoords;vec4 color=vec4(0.);DECKGL_FILTER_COLOR(color,geometry);}";
var fs$3 = "#define GLSLIFY 1\nvec4 jet(float x_17){const float e0=0.0;const vec4 v0=vec4(0,0,0.5137254901960784,1);const float e1=0.125;const vec4 v1=vec4(0,0.23529411764705882,0.6666666666666666,1);const float e2=0.375;const vec4 v2=vec4(0.0196078431372549,1,1,1);const float e3=0.625;const vec4 v3=vec4(1,1,0,1);const float e4=0.875;const vec4 v4=vec4(0.9803921568627451,0,0,1);const float e5=1.0;const vec4 v5=vec4(0.5019607843137255,0,0,1);float a0=smoothstep(e0,e1,x_17);float a1=smoothstep(e1,e2,x_17);float a2=smoothstep(e2,e3,x_17);float a3=smoothstep(e3,e4,x_17);float a4=smoothstep(e4,e5,x_17);return max(mix(v0,v1,a0)*step(e0,x_17)*step(x_17,e1),max(mix(v1,v2,a1)*step(e1,x_17)*step(x_17,e2),max(mix(v2,v3,a2)*step(e2,x_17)*step(x_17,e3),max(mix(v3,v4,a3)*step(e3,x_17)*step(x_17,e4),mix(v4,v5,a4)*step(e4,x_17)*step(x_17,e5)))));}vec4 hsv(float x_18){const float e0=0.0;const vec4 v0=vec4(1,0,0,1);const float e1=0.169;const vec4 v1=vec4(0.9921568627450981,1,0.00784313725490196,1);const float e2=0.173;const vec4 v2=vec4(0.9686274509803922,1,0.00784313725490196,1);const float e3=0.337;const vec4 v3=vec4(0,0.9882352941176471,0.01568627450980392,1);const float e4=0.341;const vec4 v4=vec4(0,0.9882352941176471,0.0392156862745098,1);const float e5=0.506;const vec4 v5=vec4(0.00392156862745098,0.9764705882352941,1,1);const float e6=0.671;const vec4 v6=vec4(0.00784313725490196,0,0.9921568627450981,1);const float e7=0.675;const vec4 v7=vec4(0.03137254901960784,0,0.9921568627450981,1);const float e8=0.839;const vec4 v8=vec4(1,0,0.984313725490196,1);const float e9=0.843;const vec4 v9=vec4(1,0,0.9607843137254902,1);const float e10=1.0;const vec4 v10=vec4(1,0,0.023529411764705882,1);float a0=smoothstep(e0,e1,x_18);float a1=smoothstep(e1,e2,x_18);float a2=smoothstep(e2,e3,x_18);float a3=smoothstep(e3,e4,x_18);float a4=smoothstep(e4,e5,x_18);float a5=smoothstep(e5,e6,x_18);float a6=smoothstep(e6,e7,x_18);float a7=smoothstep(e7,e8,x_18);float a8=smoothstep(e8,e9,x_18);float a9=smoothstep(e9,e10,x_18);return max(mix(v0,v1,a0)*step(e0,x_18)*step(x_18,e1),max(mix(v1,v2,a1)*step(e1,x_18)*step(x_18,e2),max(mix(v2,v3,a2)*step(e2,x_18)*step(x_18,e3),max(mix(v3,v4,a3)*step(e3,x_18)*step(x_18,e4),max(mix(v4,v5,a4)*step(e4,x_18)*step(x_18,e5),max(mix(v5,v6,a5)*step(e5,x_18)*step(x_18,e6),max(mix(v6,v7,a6)*step(e6,x_18)*step(x_18,e7),max(mix(v7,v8,a7)*step(e7,x_18)*step(x_18,e8),max(mix(v8,v9,a8)*step(e8,x_18)*step(x_18,e9),mix(v9,v10,a9)*step(e9,x_18)*step(x_18,e10))))))))));}vec4 hot(float x_13){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.3;const vec4 v1=vec4(0.9019607843137255,0,0,1);const float e2=0.6;const vec4 v2=vec4(1,0.8235294117647058,0,1);const float e3=1.0;const vec4 v3=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_13);float a1=smoothstep(e1,e2,x_13);float a2=smoothstep(e2,e3,x_13);return max(mix(v0,v1,a0)*step(e0,x_13)*step(x_13,e1),max(mix(v1,v2,a1)*step(e1,x_13)*step(x_13,e2),mix(v2,v3,a2)*step(e2,x_13)*step(x_13,e3)));}vec4 cool(float x_24){const float e0=0.0;const vec4 v0=vec4(0.49019607843137253,0,0.7019607843137254,1);const float e1=0.13;const vec4 v1=vec4(0.4549019607843137,0,0.8549019607843137,1);const float e2=0.25;const vec4 v2=vec4(0.3843137254901961,0.2901960784313726,0.9294117647058824,1);const float e3=0.38;const vec4 v3=vec4(0.26666666666666666,0.5725490196078431,0.9058823529411765,1);const float e4=0.5;const vec4 v4=vec4(0,0.8,0.7725490196078432,1);const float e5=0.63;const vec4 v5=vec4(0,0.9686274509803922,0.5725490196078431,1);const float e6=0.75;const vec4 v6=vec4(0,1,0.34509803921568627,1);const float e7=0.88;const vec4 v7=vec4(0.1568627450980392,1,0.03137254901960784,1);const float e8=1.0;const vec4 v8=vec4(0.5764705882352941,1,0,1);float a0=smoothstep(e0,e1,x_24);float a1=smoothstep(e1,e2,x_24);float a2=smoothstep(e2,e3,x_24);float a3=smoothstep(e3,e4,x_24);float a4=smoothstep(e4,e5,x_24);float a5=smoothstep(e5,e6,x_24);float a6=smoothstep(e6,e7,x_24);float a7=smoothstep(e7,e8,x_24);return max(mix(v0,v1,a0)*step(e0,x_24)*step(x_24,e1),max(mix(v1,v2,a1)*step(e1,x_24)*step(x_24,e2),max(mix(v2,v3,a2)*step(e2,x_24)*step(x_24,e3),max(mix(v3,v4,a3)*step(e3,x_24)*step(x_24,e4),max(mix(v4,v5,a4)*step(e4,x_24)*step(x_24,e5),max(mix(v5,v6,a5)*step(e5,x_24)*step(x_24,e6),max(mix(v6,v7,a6)*step(e6,x_24)*step(x_24,e7),mix(v7,v8,a7)*step(e7,x_24)*step(x_24,e8))))))));}vec4 spring(float x_5){const float e0=0.0;const vec4 v0=vec4(1,0,1,1);const float e1=1.0;const vec4 v1=vec4(1,1,0,1);float a0=smoothstep(e0,e1,x_5);return mix(v0,v1,a0)*step(e0,x_5)*step(x_5,e1);}vec4 summer(float x_12){const float e0=0.0;const vec4 v0=vec4(0,0.5019607843137255,0.4,1);const float e1=1.0;const vec4 v1=vec4(1,1,0.4,1);float a0=smoothstep(e0,e1,x_12);return mix(v0,v1,a0)*step(e0,x_12)*step(x_12,e1);}vec4 autumn(float x_25){const float e0=0.0;const vec4 v0=vec4(1,0,0,1);const float e1=1.0;const vec4 v1=vec4(1,1,0,1);float a0=smoothstep(e0,e1,x_25);return mix(v0,v1,a0)*step(e0,x_25)*step(x_25,e1);}vec4 winter(float x_16){const float e0=0.0;const vec4 v0=vec4(0,0,1,1);const float e1=1.0;const vec4 v1=vec4(0,1,0.5019607843137255,1);float a0=smoothstep(e0,e1,x_16);return mix(v0,v1,a0)*step(e0,x_16)*step(x_16,e1);}vec4 bone(float x_15){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.376;const vec4 v1=vec4(0.32941176470588235,0.32941176470588235,0.4549019607843137,1);const float e2=0.753;const vec4 v2=vec4(0.6627450980392157,0.7843137254901961,0.7843137254901961,1);const float e3=1.0;const vec4 v3=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_15);float a1=smoothstep(e1,e2,x_15);float a2=smoothstep(e2,e3,x_15);return max(mix(v0,v1,a0)*step(e0,x_15)*step(x_15,e1),max(mix(v1,v2,a1)*step(e1,x_15)*step(x_15,e2),mix(v2,v3,a2)*step(e2,x_15)*step(x_15,e3)));}vec4 copper(float x_10){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.804;const vec4 v1=vec4(1,0.6274509803921569,0.4,1);const float e2=1.0;const vec4 v2=vec4(1,0.7803921568627451,0.4980392156862745,1);float a0=smoothstep(e0,e1,x_10);float a1=smoothstep(e1,e2,x_10);return max(mix(v0,v1,a0)*step(e0,x_10)*step(x_10,e1),mix(v1,v2,a1)*step(e1,x_10)*step(x_10,e2));}vec4 greys(float x_4){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=1.0;const vec4 v1=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_4);return mix(v0,v1,a0)*step(e0,x_4)*step(x_4,e1);}vec4 yignbu(float x_32){const float e0=0.0;const vec4 v0=vec4(0.03137254901960784,0.11372549019607843,0.34509803921568627,1);const float e1=0.125;const vec4 v1=vec4(0.1450980392156863,0.20392156862745098,0.5803921568627451,1);const float e2=0.25;const vec4 v2=vec4(0.13333333333333333,0.3686274509803922,0.6588235294117647,1);const float e3=0.375;const vec4 v3=vec4(0.11372549019607843,0.5686274509803921,0.7529411764705882,1);const float e4=0.5;const vec4 v4=vec4(0.2549019607843137,0.7137254901960784,0.7686274509803922,1);const float e5=0.625;const vec4 v5=vec4(0.4980392156862745,0.803921568627451,0.7333333333333333,1);const float e6=0.75;const vec4 v6=vec4(0.7803921568627451,0.9137254901960784,0.7058823529411765,1);const float e7=0.875;const vec4 v7=vec4(0.9294117647058824,0.9725490196078431,0.8509803921568627,1);const float e8=1.0;const vec4 v8=vec4(1,1,0.8509803921568627,1);float a0=smoothstep(e0,e1,x_32);float a1=smoothstep(e1,e2,x_32);float a2=smoothstep(e2,e3,x_32);float a3=smoothstep(e3,e4,x_32);float a4=smoothstep(e4,e5,x_32);float a5=smoothstep(e5,e6,x_32);float a6=smoothstep(e6,e7,x_32);float a7=smoothstep(e7,e8,x_32);return max(mix(v0,v1,a0)*step(e0,x_32)*step(x_32,e1),max(mix(v1,v2,a1)*step(e1,x_32)*step(x_32,e2),max(mix(v2,v3,a2)*step(e2,x_32)*step(x_32,e3),max(mix(v3,v4,a3)*step(e3,x_32)*step(x_32,e4),max(mix(v4,v5,a4)*step(e4,x_32)*step(x_32,e5),max(mix(v5,v6,a5)*step(e5,x_32)*step(x_32,e6),max(mix(v6,v7,a6)*step(e6,x_32)*step(x_32,e7),mix(v7,v8,a7)*step(e7,x_32)*step(x_32,e8))))))));}vec4 greens(float x_34){const float e0=0.0;const vec4 v0=vec4(0,0.26666666666666666,0.10588235294117647,1);const float e1=0.125;const vec4 v1=vec4(0,0.42745098039215684,0.17254901960784313,1);const float e2=0.25;const vec4 v2=vec4(0.13725490196078433,0.5450980392156862,0.27058823529411763,1);const float e3=0.375;const vec4 v3=vec4(0.2549019607843137,0.6705882352941176,0.36470588235294116,1);const float e4=0.5;const vec4 v4=vec4(0.4549019607843137,0.7686274509803922,0.4627450980392157,1);const float e5=0.625;const vec4 v5=vec4(0.6313725490196078,0.8509803921568627,0.6078431372549019,1);const float e6=0.75;const vec4 v6=vec4(0.7803921568627451,0.9137254901960784,0.7529411764705882,1);const float e7=0.875;const vec4 v7=vec4(0.8980392156862745,0.9607843137254902,0.8784313725490196,1);const float e8=1.0;const vec4 v8=vec4(0.9686274509803922,0.9882352941176471,0.9607843137254902,1);float a0=smoothstep(e0,e1,x_34);float a1=smoothstep(e1,e2,x_34);float a2=smoothstep(e2,e3,x_34);float a3=smoothstep(e3,e4,x_34);float a4=smoothstep(e4,e5,x_34);float a5=smoothstep(e5,e6,x_34);float a6=smoothstep(e6,e7,x_34);float a7=smoothstep(e7,e8,x_34);return max(mix(v0,v1,a0)*step(e0,x_34)*step(x_34,e1),max(mix(v1,v2,a1)*step(e1,x_34)*step(x_34,e2),max(mix(v2,v3,a2)*step(e2,x_34)*step(x_34,e3),max(mix(v3,v4,a3)*step(e3,x_34)*step(x_34,e4),max(mix(v4,v5,a4)*step(e4,x_34)*step(x_34,e5),max(mix(v5,v6,a5)*step(e5,x_34)*step(x_34,e6),max(mix(v6,v7,a6)*step(e6,x_34)*step(x_34,e7),mix(v7,v8,a7)*step(e7,x_34)*step(x_34,e8))))))));}vec4 yiorrd(float x_41){const float e0=0.0;const vec4 v0=vec4(0.5019607843137255,0,0.14901960784313725,1);const float e1=0.125;const vec4 v1=vec4(0.7411764705882353,0,0.14901960784313725,1);const float e2=0.25;const vec4 v2=vec4(0.8901960784313725,0.10196078431372549,0.10980392156862745,1);const float e3=0.375;const vec4 v3=vec4(0.9882352941176471,0.3058823529411765,0.16470588235294117,1);const float e4=0.5;const vec4 v4=vec4(0.9921568627450981,0.5529411764705883,0.23529411764705882,1);const float e5=0.625;const vec4 v5=vec4(0.996078431372549,0.6980392156862745,0.2980392156862745,1);const float e6=0.75;const vec4 v6=vec4(0.996078431372549,0.8509803921568627,0.4627450980392157,1);const float e7=0.875;const vec4 v7=vec4(1,0.9294117647058824,0.6274509803921569,1);const float e8=1.0;const vec4 v8=vec4(1,1,0.8,1);float a0=smoothstep(e0,e1,x_41);float a1=smoothstep(e1,e2,x_41);float a2=smoothstep(e2,e3,x_41);float a3=smoothstep(e3,e4,x_41);float a4=smoothstep(e4,e5,x_41);float a5=smoothstep(e5,e6,x_41);float a6=smoothstep(e6,e7,x_41);float a7=smoothstep(e7,e8,x_41);return max(mix(v0,v1,a0)*step(e0,x_41)*step(x_41,e1),max(mix(v1,v2,a1)*step(e1,x_41)*step(x_41,e2),max(mix(v2,v3,a2)*step(e2,x_41)*step(x_41,e3),max(mix(v3,v4,a3)*step(e3,x_41)*step(x_41,e4),max(mix(v4,v5,a4)*step(e4,x_41)*step(x_41,e5),max(mix(v5,v6,a5)*step(e5,x_41)*step(x_41,e6),max(mix(v6,v7,a6)*step(e6,x_41)*step(x_41,e7),mix(v7,v8,a7)*step(e7,x_41)*step(x_41,e8))))))));}vec4 bluered(float x_23){const float e0=0.0;const vec4 v0=vec4(0,0,1,1);const float e1=1.0;const vec4 v1=vec4(1,0,0,1);float a0=smoothstep(e0,e1,x_23);return mix(v0,v1,a0)*step(e0,x_23)*step(x_23,e1);}vec4 rdbu(float x_1){const float e0=0.0;const vec4 v0=vec4(0.0196078431372549,0.0392156862745098,0.6745098039215687,1);const float e1=0.35;const vec4 v1=vec4(0.41568627450980394,0.5372549019607843,0.9686274509803922,1);const float e2=0.5;const vec4 v2=vec4(0.7450980392156863,0.7450980392156863,0.7450980392156863,1);const float e3=0.6;const vec4 v3=vec4(0.8627450980392157,0.6666666666666666,0.5176470588235295,1);const float e4=0.7;const vec4 v4=vec4(0.9019607843137255,0.5686274509803921,0.35294117647058826,1);const float e5=1.0;const vec4 v5=vec4(0.6980392156862745,0.0392156862745098,0.10980392156862745,1);float a0=smoothstep(e0,e1,x_1);float a1=smoothstep(e1,e2,x_1);float a2=smoothstep(e2,e3,x_1);float a3=smoothstep(e3,e4,x_1);float a4=smoothstep(e4,e5,x_1);return max(mix(v0,v1,a0)*step(e0,x_1)*step(x_1,e1),max(mix(v1,v2,a1)*step(e1,x_1)*step(x_1,e2),max(mix(v2,v3,a2)*step(e2,x_1)*step(x_1,e3),max(mix(v3,v4,a3)*step(e3,x_1)*step(x_1,e4),mix(v4,v5,a4)*step(e4,x_1)*step(x_1,e5)))));}vec4 picnic(float x_42){const float e0=0.0;const vec4 v0=vec4(0,0,1,1);const float e1=0.1;const vec4 v1=vec4(0.2,0.6,1,1);const float e2=0.2;const vec4 v2=vec4(0.4,0.8,1,1);const float e3=0.3;const vec4 v3=vec4(0.6,0.8,1,1);const float e4=0.4;const vec4 v4=vec4(0.8,0.8,1,1);const float e5=0.5;const vec4 v5=vec4(1,1,1,1);const float e6=0.6;const vec4 v6=vec4(1,0.8,1,1);const float e7=0.7;const vec4 v7=vec4(1,0.6,1,1);const float e8=0.8;const vec4 v8=vec4(1,0.4,0.8,1);const float e9=0.9;const vec4 v9=vec4(1,0.4,0.4,1);const float e10=1.0;const vec4 v10=vec4(1,0,0,1);float a0=smoothstep(e0,e1,x_42);float a1=smoothstep(e1,e2,x_42);float a2=smoothstep(e2,e3,x_42);float a3=smoothstep(e3,e4,x_42);float a4=smoothstep(e4,e5,x_42);float a5=smoothstep(e5,e6,x_42);float a6=smoothstep(e6,e7,x_42);float a7=smoothstep(e7,e8,x_42);float a8=smoothstep(e8,e9,x_42);float a9=smoothstep(e9,e10,x_42);return max(mix(v0,v1,a0)*step(e0,x_42)*step(x_42,e1),max(mix(v1,v2,a1)*step(e1,x_42)*step(x_42,e2),max(mix(v2,v3,a2)*step(e2,x_42)*step(x_42,e3),max(mix(v3,v4,a3)*step(e3,x_42)*step(x_42,e4),max(mix(v4,v5,a4)*step(e4,x_42)*step(x_42,e5),max(mix(v5,v6,a5)*step(e5,x_42)*step(x_42,e6),max(mix(v6,v7,a6)*step(e6,x_42)*step(x_42,e7),max(mix(v7,v8,a7)*step(e7,x_42)*step(x_42,e8),max(mix(v8,v9,a8)*step(e8,x_42)*step(x_42,e9),mix(v9,v10,a9)*step(e9,x_42)*step(x_42,e10))))))))));}vec4 rainbow(float x_31){const float e0=0.0;const vec4 v0=vec4(0.5882352941176471,0,0.35294117647058826,1);const float e1=0.125;const vec4 v1=vec4(0,0,0.7843137254901961,1);const float e2=0.25;const vec4 v2=vec4(0,0.09803921568627451,1,1);const float e3=0.375;const vec4 v3=vec4(0,0.596078431372549,1,1);const float e4=0.5;const vec4 v4=vec4(0.17254901960784313,1,0.5882352941176471,1);const float e5=0.625;const vec4 v5=vec4(0.592156862745098,1,0,1);const float e6=0.75;const vec4 v6=vec4(1,0.9176470588235294,0,1);const float e7=0.875;const vec4 v7=vec4(1,0.43529411764705883,0,1);const float e8=1.0;const vec4 v8=vec4(1,0,0,1);float a0=smoothstep(e0,e1,x_31);float a1=smoothstep(e1,e2,x_31);float a2=smoothstep(e2,e3,x_31);float a3=smoothstep(e3,e4,x_31);float a4=smoothstep(e4,e5,x_31);float a5=smoothstep(e5,e6,x_31);float a6=smoothstep(e6,e7,x_31);float a7=smoothstep(e7,e8,x_31);return max(mix(v0,v1,a0)*step(e0,x_31)*step(x_31,e1),max(mix(v1,v2,a1)*step(e1,x_31)*step(x_31,e2),max(mix(v2,v3,a2)*step(e2,x_31)*step(x_31,e3),max(mix(v3,v4,a3)*step(e3,x_31)*step(x_31,e4),max(mix(v4,v5,a4)*step(e4,x_31)*step(x_31,e5),max(mix(v5,v6,a5)*step(e5,x_31)*step(x_31,e6),max(mix(v6,v7,a6)*step(e6,x_31)*step(x_31,e7),mix(v7,v8,a7)*step(e7,x_31)*step(x_31,e8))))))));}vec4 portland(float x_21){const float e0=0.0;const vec4 v0=vec4(0.047058823529411764,0.2,0.5137254901960784,1);const float e1=0.25;const vec4 v1=vec4(0.0392156862745098,0.5333333333333333,0.7294117647058823,1);const float e2=0.5;const vec4 v2=vec4(0.9490196078431372,0.8274509803921568,0.2196078431372549,1);const float e3=0.75;const vec4 v3=vec4(0.9490196078431372,0.5607843137254902,0.2196078431372549,1);const float e4=1.0;const vec4 v4=vec4(0.8509803921568627,0.11764705882352941,0.11764705882352941,1);float a0=smoothstep(e0,e1,x_21);float a1=smoothstep(e1,e2,x_21);float a2=smoothstep(e2,e3,x_21);float a3=smoothstep(e3,e4,x_21);return max(mix(v0,v1,a0)*step(e0,x_21)*step(x_21,e1),max(mix(v1,v2,a1)*step(e1,x_21)*step(x_21,e2),max(mix(v2,v3,a2)*step(e2,x_21)*step(x_21,e3),mix(v3,v4,a3)*step(e3,x_21)*step(x_21,e4))));}vec4 blackbody(float x_38){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.2;const vec4 v1=vec4(0.9019607843137255,0,0,1);const float e2=0.4;const vec4 v2=vec4(0.9019607843137255,0.8235294117647058,0,1);const float e3=0.7;const vec4 v3=vec4(1,1,1,1);const float e4=1.0;const vec4 v4=vec4(0.6274509803921569,0.7843137254901961,1,1);float a0=smoothstep(e0,e1,x_38);float a1=smoothstep(e1,e2,x_38);float a2=smoothstep(e2,e3,x_38);float a3=smoothstep(e3,e4,x_38);return max(mix(v0,v1,a0)*step(e0,x_38)*step(x_38,e1),max(mix(v1,v2,a1)*step(e1,x_38)*step(x_38,e2),max(mix(v2,v3,a2)*step(e2,x_38)*step(x_38,e3),mix(v3,v4,a3)*step(e3,x_38)*step(x_38,e4))));}vec4 earth(float x_29){const float e0=0.0;const vec4 v0=vec4(0,0,0.5098039215686274,1);const float e1=0.1;const vec4 v1=vec4(0,0.7058823529411765,0.7058823529411765,1);const float e2=0.2;const vec4 v2=vec4(0.1568627450980392,0.8235294117647058,0.1568627450980392,1);const float e3=0.4;const vec4 v3=vec4(0.9019607843137255,0.9019607843137255,0.19607843137254902,1);const float e4=0.6;const vec4 v4=vec4(0.47058823529411764,0.27450980392156865,0.0784313725490196,1);const float e5=1.0;const vec4 v5=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_29);float a1=smoothstep(e1,e2,x_29);float a2=smoothstep(e2,e3,x_29);float a3=smoothstep(e3,e4,x_29);float a4=smoothstep(e4,e5,x_29);return max(mix(v0,v1,a0)*step(e0,x_29)*step(x_29,e1),max(mix(v1,v2,a1)*step(e1,x_29)*step(x_29,e2),max(mix(v2,v3,a2)*step(e2,x_29)*step(x_29,e3),max(mix(v3,v4,a3)*step(e3,x_29)*step(x_29,e4),mix(v4,v5,a4)*step(e4,x_29)*step(x_29,e5)))));}vec4 electric(float x_9){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.15;const vec4 v1=vec4(0.11764705882352941,0,0.39215686274509803,1);const float e2=0.4;const vec4 v2=vec4(0.47058823529411764,0,0.39215686274509803,1);const float e3=0.6;const vec4 v3=vec4(0.6274509803921569,0.35294117647058826,0,1);const float e4=0.8;const vec4 v4=vec4(0.9019607843137255,0.7843137254901961,0,1);const float e5=1.0;const vec4 v5=vec4(1,0.9803921568627451,0.8627450980392157,1);float a0=smoothstep(e0,e1,x_9);float a1=smoothstep(e1,e2,x_9);float a2=smoothstep(e2,e3,x_9);float a3=smoothstep(e3,e4,x_9);float a4=smoothstep(e4,e5,x_9);return max(mix(v0,v1,a0)*step(e0,x_9)*step(x_9,e1),max(mix(v1,v2,a1)*step(e1,x_9)*step(x_9,e2),max(mix(v2,v3,a2)*step(e2,x_9)*step(x_9,e3),max(mix(v3,v4,a3)*step(e3,x_9)*step(x_9,e4),mix(v4,v5,a4)*step(e4,x_9)*step(x_9,e5)))));}vec4 alpha(float x_0){const float e0=0.0;const vec4 v0=vec4(1,1,1,0);const float e1=1.0;const vec4 v1=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_0);return mix(v0,v1,a0)*step(e0,x_0)*step(x_0,e1);}vec4 viridis(float x_22){const float e0=0.0;const vec4 v0=vec4(0.26666666666666666,0.00392156862745098,0.32941176470588235,1);const float e1=0.13;const vec4 v1=vec4(0.2784313725490196,0.17254901960784313,0.47843137254901963,1);const float e2=0.25;const vec4 v2=vec4(0.23137254901960785,0.3176470588235294,0.5450980392156862,1);const float e3=0.38;const vec4 v3=vec4(0.17254901960784313,0.44313725490196076,0.5568627450980392,1);const float e4=0.5;const vec4 v4=vec4(0.12941176470588237,0.5647058823529412,0.5529411764705883,1);const float e5=0.63;const vec4 v5=vec4(0.15294117647058825,0.6784313725490196,0.5058823529411764,1);const float e6=0.75;const vec4 v6=vec4(0.3607843137254902,0.7843137254901961,0.38823529411764707,1);const float e7=0.88;const vec4 v7=vec4(0.6666666666666666,0.8627450980392157,0.19607843137254902,1);const float e8=1.0;const vec4 v8=vec4(0.9921568627450981,0.9058823529411765,0.1450980392156863,1);float a0=smoothstep(e0,e1,x_22);float a1=smoothstep(e1,e2,x_22);float a2=smoothstep(e2,e3,x_22);float a3=smoothstep(e3,e4,x_22);float a4=smoothstep(e4,e5,x_22);float a5=smoothstep(e5,e6,x_22);float a6=smoothstep(e6,e7,x_22);float a7=smoothstep(e7,e8,x_22);return max(mix(v0,v1,a0)*step(e0,x_22)*step(x_22,e1),max(mix(v1,v2,a1)*step(e1,x_22)*step(x_22,e2),max(mix(v2,v3,a2)*step(e2,x_22)*step(x_22,e3),max(mix(v3,v4,a3)*step(e3,x_22)*step(x_22,e4),max(mix(v4,v5,a4)*step(e4,x_22)*step(x_22,e5),max(mix(v5,v6,a5)*step(e5,x_22)*step(x_22,e6),max(mix(v6,v7,a6)*step(e6,x_22)*step(x_22,e7),mix(v7,v8,a7)*step(e7,x_22)*step(x_22,e8))))))));}vec4 inferno(float x_30){const float e0=0.0;const vec4 v0=vec4(0,0,0.01568627450980392,1);const float e1=0.13;const vec4 v1=vec4(0.12156862745098039,0.047058823529411764,0.2823529411764706,1);const float e2=0.25;const vec4 v2=vec4(0.3333333333333333,0.058823529411764705,0.42745098039215684,1);const float e3=0.38;const vec4 v3=vec4(0.5333333333333333,0.13333333333333333,0.41568627450980394,1);const float e4=0.5;const vec4 v4=vec4(0.7294117647058823,0.21176470588235294,0.3333333333333333,1);const float e5=0.63;const vec4 v5=vec4(0.8901960784313725,0.34901960784313724,0.2,1);const float e6=0.75;const vec4 v6=vec4(0.9764705882352941,0.5490196078431373,0.0392156862745098,1);const float e7=0.88;const vec4 v7=vec4(0.9764705882352941,0.788235294117647,0.19607843137254902,1);const float e8=1.0;const vec4 v8=vec4(0.9882352941176471,1,0.6431372549019608,1);float a0=smoothstep(e0,e1,x_30);float a1=smoothstep(e1,e2,x_30);float a2=smoothstep(e2,e3,x_30);float a3=smoothstep(e3,e4,x_30);float a4=smoothstep(e4,e5,x_30);float a5=smoothstep(e5,e6,x_30);float a6=smoothstep(e6,e7,x_30);float a7=smoothstep(e7,e8,x_30);return max(mix(v0,v1,a0)*step(e0,x_30)*step(x_30,e1),max(mix(v1,v2,a1)*step(e1,x_30)*step(x_30,e2),max(mix(v2,v3,a2)*step(e2,x_30)*step(x_30,e3),max(mix(v3,v4,a3)*step(e3,x_30)*step(x_30,e4),max(mix(v4,v5,a4)*step(e4,x_30)*step(x_30,e5),max(mix(v5,v6,a5)*step(e5,x_30)*step(x_30,e6),max(mix(v6,v7,a6)*step(e6,x_30)*step(x_30,e7),mix(v7,v8,a7)*step(e7,x_30)*step(x_30,e8))))))));}vec4 magma(float x_33){const float e0=0.0;const vec4 v0=vec4(0,0,0.01568627450980392,1);const float e1=0.13;const vec4 v1=vec4(0.10980392156862745,0.06274509803921569,0.26666666666666666,1);const float e2=0.25;const vec4 v2=vec4(0.30980392156862746,0.07058823529411765,0.4823529411764706,1);const float e3=0.38;const vec4 v3=vec4(0.5058823529411764,0.1450980392156863,0.5058823529411764,1);const float e4=0.5;const vec4 v4=vec4(0.7098039215686275,0.21176470588235294,0.47843137254901963,1);const float e5=0.63;const vec4 v5=vec4(0.8980392156862745,0.3137254901960784,0.39215686274509803,1);const float e6=0.75;const vec4 v6=vec4(0.984313725490196,0.5294117647058824,0.3803921568627451,1);const float e7=0.88;const vec4 v7=vec4(0.996078431372549,0.7607843137254902,0.5294117647058824,1);const float e8=1.0;const vec4 v8=vec4(0.9882352941176471,0.9921568627450981,0.7490196078431373,1);float a0=smoothstep(e0,e1,x_33);float a1=smoothstep(e1,e2,x_33);float a2=smoothstep(e2,e3,x_33);float a3=smoothstep(e3,e4,x_33);float a4=smoothstep(e4,e5,x_33);float a5=smoothstep(e5,e6,x_33);float a6=smoothstep(e6,e7,x_33);float a7=smoothstep(e7,e8,x_33);return max(mix(v0,v1,a0)*step(e0,x_33)*step(x_33,e1),max(mix(v1,v2,a1)*step(e1,x_33)*step(x_33,e2),max(mix(v2,v3,a2)*step(e2,x_33)*step(x_33,e3),max(mix(v3,v4,a3)*step(e3,x_33)*step(x_33,e4),max(mix(v4,v5,a4)*step(e4,x_33)*step(x_33,e5),max(mix(v5,v6,a5)*step(e5,x_33)*step(x_33,e6),max(mix(v6,v7,a6)*step(e6,x_33)*step(x_33,e7),mix(v7,v8,a7)*step(e7,x_33)*step(x_33,e8))))))));}vec4 plasma(float x_3){const float e0=0.0;const vec4 v0=vec4(0.050980392156862744,0.03137254901960784,0.5294117647058824,1);const float e1=0.13;const vec4 v1=vec4(0.29411764705882354,0.011764705882352941,0.6313725490196078,1);const float e2=0.25;const vec4 v2=vec4(0.49019607843137253,0.011764705882352941,0.6588235294117647,1);const float e3=0.38;const vec4 v3=vec4(0.6588235294117647,0.13333333333333333,0.5882352941176471,1);const float e4=0.5;const vec4 v4=vec4(0.796078431372549,0.27450980392156865,0.4745098039215686,1);const float e5=0.63;const vec4 v5=vec4(0.8980392156862745,0.4196078431372549,0.36470588235294116,1);const float e6=0.75;const vec4 v6=vec4(0.9725490196078431,0.5803921568627451,0.2549019607843137,1);const float e7=0.88;const vec4 v7=vec4(0.9921568627450981,0.7647058823529411,0.1568627450980392,1);const float e8=1.0;const vec4 v8=vec4(0.9411764705882353,0.9764705882352941,0.12941176470588237,1);float a0=smoothstep(e0,e1,x_3);float a1=smoothstep(e1,e2,x_3);float a2=smoothstep(e2,e3,x_3);float a3=smoothstep(e3,e4,x_3);float a4=smoothstep(e4,e5,x_3);float a5=smoothstep(e5,e6,x_3);float a6=smoothstep(e6,e7,x_3);float a7=smoothstep(e7,e8,x_3);return max(mix(v0,v1,a0)*step(e0,x_3)*step(x_3,e1),max(mix(v1,v2,a1)*step(e1,x_3)*step(x_3,e2),max(mix(v2,v3,a2)*step(e2,x_3)*step(x_3,e3),max(mix(v3,v4,a3)*step(e3,x_3)*step(x_3,e4),max(mix(v4,v5,a4)*step(e4,x_3)*step(x_3,e5),max(mix(v5,v6,a5)*step(e5,x_3)*step(x_3,e6),max(mix(v6,v7,a6)*step(e6,x_3)*step(x_3,e7),mix(v7,v8,a7)*step(e7,x_3)*step(x_3,e8))))))));}vec4 warm(float x_43){const float e0=0.0;const vec4 v0=vec4(0.49019607843137253,0,0.7019607843137254,1);const float e1=0.13;const vec4 v1=vec4(0.6745098039215687,0,0.7333333333333333,1);const float e2=0.25;const vec4 v2=vec4(0.8588235294117647,0,0.6666666666666666,1);const float e3=0.38;const vec4 v3=vec4(1,0,0.5098039215686274,1);const float e4=0.5;const vec4 v4=vec4(1,0.24705882352941178,0.2901960784313726,1);const float e5=0.63;const vec4 v5=vec4(1,0.4823529411764706,0,1);const float e6=0.75;const vec4 v6=vec4(0.9176470588235294,0.6901960784313725,0,1);const float e7=0.88;const vec4 v7=vec4(0.7450980392156863,0.8941176470588236,0,1);const float e8=1.0;const vec4 v8=vec4(0.5764705882352941,1,0,1);float a0=smoothstep(e0,e1,x_43);float a1=smoothstep(e1,e2,x_43);float a2=smoothstep(e2,e3,x_43);float a3=smoothstep(e3,e4,x_43);float a4=smoothstep(e4,e5,x_43);float a5=smoothstep(e5,e6,x_43);float a6=smoothstep(e6,e7,x_43);float a7=smoothstep(e7,e8,x_43);return max(mix(v0,v1,a0)*step(e0,x_43)*step(x_43,e1),max(mix(v1,v2,a1)*step(e1,x_43)*step(x_43,e2),max(mix(v2,v3,a2)*step(e2,x_43)*step(x_43,e3),max(mix(v3,v4,a3)*step(e3,x_43)*step(x_43,e4),max(mix(v4,v5,a4)*step(e4,x_43)*step(x_43,e5),max(mix(v5,v6,a5)*step(e5,x_43)*step(x_43,e6),max(mix(v6,v7,a6)*step(e6,x_43)*step(x_43,e7),mix(v7,v8,a7)*step(e7,x_43)*step(x_43,e8))))))));}vec4 rainbow_soft_1310269270(float x_14){const float e0=0.0;const vec4 v0=vec4(0.49019607843137253,0,0.7019607843137254,1);const float e1=0.1;const vec4 v1=vec4(0.7803921568627451,0,0.7058823529411765,1);const float e2=0.2;const vec4 v2=vec4(1,0,0.4745098039215686,1);const float e3=0.3;const vec4 v3=vec4(1,0.4235294117647059,0,1);const float e4=0.4;const vec4 v4=vec4(0.8705882352941177,0.7607843137254902,0,1);const float e5=0.5;const vec4 v5=vec4(0.5882352941176471,1,0,1);const float e6=0.6;const vec4 v6=vec4(0,1,0.21568627450980393,1);const float e7=0.7;const vec4 v7=vec4(0,0.9647058823529412,0.5882352941176471,1);const float e8=0.8;const vec4 v8=vec4(0.19607843137254902,0.6549019607843137,0.8705882352941177,1);const float e9=0.9;const vec4 v9=vec4(0.403921568627451,0.2,0.9215686274509803,1);const float e10=1.0;const vec4 v10=vec4(0.48627450980392156,0,0.7294117647058823,1);float a0=smoothstep(e0,e1,x_14);float a1=smoothstep(e1,e2,x_14);float a2=smoothstep(e2,e3,x_14);float a3=smoothstep(e3,e4,x_14);float a4=smoothstep(e4,e5,x_14);float a5=smoothstep(e5,e6,x_14);float a6=smoothstep(e6,e7,x_14);float a7=smoothstep(e7,e8,x_14);float a8=smoothstep(e8,e9,x_14);float a9=smoothstep(e9,e10,x_14);return max(mix(v0,v1,a0)*step(e0,x_14)*step(x_14,e1),max(mix(v1,v2,a1)*step(e1,x_14)*step(x_14,e2),max(mix(v2,v3,a2)*step(e2,x_14)*step(x_14,e3),max(mix(v3,v4,a3)*step(e3,x_14)*step(x_14,e4),max(mix(v4,v5,a4)*step(e4,x_14)*step(x_14,e5),max(mix(v5,v6,a5)*step(e5,x_14)*step(x_14,e6),max(mix(v6,v7,a6)*step(e6,x_14)*step(x_14,e7),max(mix(v7,v8,a7)*step(e7,x_14)*step(x_14,e8),max(mix(v8,v9,a8)*step(e8,x_14)*step(x_14,e9),mix(v9,v10,a9)*step(e9,x_14)*step(x_14,e10))))))))));}vec4 bathymetry(float x_36){const float e0=0.0;const vec4 v0=vec4(0.1568627450980392,0.10196078431372549,0.17254901960784313,1);const float e1=0.13;const vec4 v1=vec4(0.23137254901960785,0.19215686274509805,0.35294117647058826,1);const float e2=0.25;const vec4 v2=vec4(0.25098039215686274,0.2980392156862745,0.5450980392156862,1);const float e3=0.38;const vec4 v3=vec4(0.24705882352941178,0.43137254901960786,0.592156862745098,1);const float e4=0.5;const vec4 v4=vec4(0.2823529411764706,0.5568627450980392,0.6196078431372549,1);const float e5=0.63;const vec4 v5=vec4(0.3333333333333333,0.6823529411764706,0.6392156862745098,1);const float e6=0.75;const vec4 v6=vec4(0.47058823529411764,0.807843137254902,0.6392156862745098,1);const float e7=0.88;const vec4 v7=vec4(0.7333333333333333,0.9019607843137255,0.6745098039215687,1);const float e8=1.0;const vec4 v8=vec4(0.9921568627450981,0.996078431372549,0.8,1);float a0=smoothstep(e0,e1,x_36);float a1=smoothstep(e1,e2,x_36);float a2=smoothstep(e2,e3,x_36);float a3=smoothstep(e3,e4,x_36);float a4=smoothstep(e4,e5,x_36);float a5=smoothstep(e5,e6,x_36);float a6=smoothstep(e6,e7,x_36);float a7=smoothstep(e7,e8,x_36);return max(mix(v0,v1,a0)*step(e0,x_36)*step(x_36,e1),max(mix(v1,v2,a1)*step(e1,x_36)*step(x_36,e2),max(mix(v2,v3,a2)*step(e2,x_36)*step(x_36,e3),max(mix(v3,v4,a3)*step(e3,x_36)*step(x_36,e4),max(mix(v4,v5,a4)*step(e4,x_36)*step(x_36,e5),max(mix(v5,v6,a5)*step(e5,x_36)*step(x_36,e6),max(mix(v6,v7,a6)*step(e6,x_36)*step(x_36,e7),mix(v7,v8,a7)*step(e7,x_36)*step(x_36,e8))))))));}vec4 cdom(float x_7){const float e0=0.0;const vec4 v0=vec4(0.1843137254901961,0.058823529411764705,0.24313725490196078,1);const float e1=0.13;const vec4 v1=vec4(0.3411764705882353,0.09019607843137255,0.33725490196078434,1);const float e2=0.25;const vec4 v2=vec4(0.5098039215686274,0.10980392156862745,0.38823529411764707,1);const float e3=0.38;const vec4 v3=vec4(0.6705882352941176,0.1607843137254902,0.3764705882352941,1);const float e4=0.5;const vec4 v4=vec4(0.807843137254902,0.2627450980392157,0.33725490196078434,1);const float e5=0.63;const vec4 v5=vec4(0.9019607843137255,0.41568627450980394,0.32941176470588235,1);const float e6=0.75;const vec4 v6=vec4(0.9490196078431372,0.5843137254901961,0.403921568627451,1);const float e7=0.88;const vec4 v7=vec4(0.9764705882352941,0.7568627450980392,0.5294117647058824,1);const float e8=1.0;const vec4 v8=vec4(0.996078431372549,0.9294117647058824,0.6901960784313725,1);float a0=smoothstep(e0,e1,x_7);float a1=smoothstep(e1,e2,x_7);float a2=smoothstep(e2,e3,x_7);float a3=smoothstep(e3,e4,x_7);float a4=smoothstep(e4,e5,x_7);float a5=smoothstep(e5,e6,x_7);float a6=smoothstep(e6,e7,x_7);float a7=smoothstep(e7,e8,x_7);return max(mix(v0,v1,a0)*step(e0,x_7)*step(x_7,e1),max(mix(v1,v2,a1)*step(e1,x_7)*step(x_7,e2),max(mix(v2,v3,a2)*step(e2,x_7)*step(x_7,e3),max(mix(v3,v4,a3)*step(e3,x_7)*step(x_7,e4),max(mix(v4,v5,a4)*step(e4,x_7)*step(x_7,e5),max(mix(v5,v6,a5)*step(e5,x_7)*step(x_7,e6),max(mix(v6,v7,a6)*step(e6,x_7)*step(x_7,e7),mix(v7,v8,a7)*step(e7,x_7)*step(x_7,e8))))))));}vec4 chlorophyll(float x_6){const float e0=0.0;const vec4 v0=vec4(0.07058823529411765,0.1411764705882353,0.0784313725490196,1);const float e1=0.13;const vec4 v1=vec4(0.09803921568627451,0.24705882352941178,0.1607843137254902,1);const float e2=0.25;const vec4 v2=vec4(0.09411764705882353,0.3568627450980392,0.23137254901960785,1);const float e3=0.38;const vec4 v3=vec4(0.050980392156862744,0.4666666666666667,0.2823529411764706,1);const float e4=0.5;const vec4 v4=vec4(0.07058823529411765,0.5803921568627451,0.3137254901960784,1);const float e5=0.63;const vec4 v5=vec4(0.3137254901960784,0.6784313725490196,0.34901960784313724,1);const float e6=0.75;const vec4 v6=vec4(0.5176470588235295,0.7686274509803922,0.47843137254901963,1);const float e7=0.88;const vec4 v7=vec4(0.6862745098039216,0.8666666666666667,0.6352941176470588,1);const float e8=1.0;const vec4 v8=vec4(0.8431372549019608,0.9764705882352941,0.8156862745098039,1);float a0=smoothstep(e0,e1,x_6);float a1=smoothstep(e1,e2,x_6);float a2=smoothstep(e2,e3,x_6);float a3=smoothstep(e3,e4,x_6);float a4=smoothstep(e4,e5,x_6);float a5=smoothstep(e5,e6,x_6);float a6=smoothstep(e6,e7,x_6);float a7=smoothstep(e7,e8,x_6);return max(mix(v0,v1,a0)*step(e0,x_6)*step(x_6,e1),max(mix(v1,v2,a1)*step(e1,x_6)*step(x_6,e2),max(mix(v2,v3,a2)*step(e2,x_6)*step(x_6,e3),max(mix(v3,v4,a3)*step(e3,x_6)*step(x_6,e4),max(mix(v4,v5,a4)*step(e4,x_6)*step(x_6,e5),max(mix(v5,v6,a5)*step(e5,x_6)*step(x_6,e6),max(mix(v6,v7,a6)*step(e6,x_6)*step(x_6,e7),mix(v7,v8,a7)*step(e7,x_6)*step(x_6,e8))))))));}vec4 density(float x_19){const float e0=0.0;const vec4 v0=vec4(0.21176470588235294,0.054901960784313725,0.1411764705882353,1);const float e1=0.13;const vec4 v1=vec4(0.34901960784313724,0.09019607843137255,0.3137254901960784,1);const float e2=0.25;const vec4 v2=vec4(0.43137254901960786,0.17647058823529413,0.5176470588235295,1);const float e3=0.38;const vec4 v3=vec4(0.47058823529411764,0.30196078431372547,0.6980392156862745,1);const float e4=0.5;const vec4 v4=vec4(0.47058823529411764,0.44313725490196076,0.8352941176470589,1);const float e5=0.63;const vec4 v5=vec4(0.45098039215686275,0.592156862745098,0.8941176470588236,1);const float e6=0.75;const vec4 v6=vec4(0.5254901960784314,0.7254901960784313,0.8901960784313725,1);const float e7=0.88;const vec4 v7=vec4(0.6941176470588235,0.8392156862745098,0.8901960784313725,1);const float e8=1.0;const vec4 v8=vec4(0.9019607843137255,0.9450980392156862,0.9450980392156862,1);float a0=smoothstep(e0,e1,x_19);float a1=smoothstep(e1,e2,x_19);float a2=smoothstep(e2,e3,x_19);float a3=smoothstep(e3,e4,x_19);float a4=smoothstep(e4,e5,x_19);float a5=smoothstep(e5,e6,x_19);float a6=smoothstep(e6,e7,x_19);float a7=smoothstep(e7,e8,x_19);return max(mix(v0,v1,a0)*step(e0,x_19)*step(x_19,e1),max(mix(v1,v2,a1)*step(e1,x_19)*step(x_19,e2),max(mix(v2,v3,a2)*step(e2,x_19)*step(x_19,e3),max(mix(v3,v4,a3)*step(e3,x_19)*step(x_19,e4),max(mix(v4,v5,a4)*step(e4,x_19)*step(x_19,e5),max(mix(v5,v6,a5)*step(e5,x_19)*step(x_19,e6),max(mix(v6,v7,a6)*step(e6,x_19)*step(x_19,e7),mix(v7,v8,a7)*step(e7,x_19)*step(x_19,e8))))))));}vec4 freesurface_blue_3154355989(float x_35){const float e0=0.0;const vec4 v0=vec4(0.11764705882352941,0.01568627450980392,0.43137254901960786,1);const float e1=0.13;const vec4 v1=vec4(0.1843137254901961,0.054901960784313725,0.6901960784313725,1);const float e2=0.25;const vec4 v2=vec4(0.1607843137254902,0.17647058823529413,0.9254901960784314,1);const float e3=0.38;const vec4 v3=vec4(0.09803921568627451,0.38823529411764707,0.8313725490196079,1);const float e4=0.5;const vec4 v4=vec4(0.26666666666666666,0.5137254901960784,0.7843137254901961,1);const float e5=0.63;const vec4 v5=vec4(0.4470588235294118,0.611764705882353,0.7725490196078432,1);const float e6=0.75;const vec4 v6=vec4(0.615686274509804,0.7098039215686275,0.796078431372549,1);const float e7=0.88;const vec4 v7=vec4(0.7843137254901961,0.8156862745098039,0.8470588235294118,1);const float e8=1.0;const vec4 v8=vec4(0.9450980392156862,0.9294117647058824,0.9254901960784314,1);float a0=smoothstep(e0,e1,x_35);float a1=smoothstep(e1,e2,x_35);float a2=smoothstep(e2,e3,x_35);float a3=smoothstep(e3,e4,x_35);float a4=smoothstep(e4,e5,x_35);float a5=smoothstep(e5,e6,x_35);float a6=smoothstep(e6,e7,x_35);float a7=smoothstep(e7,e8,x_35);return max(mix(v0,v1,a0)*step(e0,x_35)*step(x_35,e1),max(mix(v1,v2,a1)*step(e1,x_35)*step(x_35,e2),max(mix(v2,v3,a2)*step(e2,x_35)*step(x_35,e3),max(mix(v3,v4,a3)*step(e3,x_35)*step(x_35,e4),max(mix(v4,v5,a4)*step(e4,x_35)*step(x_35,e5),max(mix(v5,v6,a5)*step(e5,x_35)*step(x_35,e6),max(mix(v6,v7,a6)*step(e6,x_35)*step(x_35,e7),mix(v7,v8,a7)*step(e7,x_35)*step(x_35,e8))))))));}vec4 freesurface_red_1679163293(float x_20){const float e0=0.0;const vec4 v0=vec4(0.23529411764705882,0.03529411764705882,0.07058823529411765,1);const float e1=0.13;const vec4 v1=vec4(0.39215686274509803,0.06666666666666667,0.10588235294117647,1);const float e2=0.25;const vec4 v2=vec4(0.5568627450980392,0.0784313725490196,0.11372549019607843,1);const float e3=0.38;const vec4 v3=vec4(0.6941176470588235,0.16862745098039217,0.10588235294117647,1);const float e4=0.5;const vec4 v4=vec4(0.7529411764705882,0.3411764705882353,0.24705882352941178,1);const float e5=0.63;const vec4 v5=vec4(0.803921568627451,0.49019607843137253,0.4117647058823529,1);const float e6=0.75;const vec4 v6=vec4(0.8470588235294118,0.6352941176470588,0.5803921568627451,1);const float e7=0.88;const vec4 v7=vec4(0.8901960784313725,0.7803921568627451,0.7568627450980392,1);const float e8=1.0;const vec4 v8=vec4(0.9450980392156862,0.9294117647058824,0.9254901960784314,1);float a0=smoothstep(e0,e1,x_20);float a1=smoothstep(e1,e2,x_20);float a2=smoothstep(e2,e3,x_20);float a3=smoothstep(e3,e4,x_20);float a4=smoothstep(e4,e5,x_20);float a5=smoothstep(e5,e6,x_20);float a6=smoothstep(e6,e7,x_20);float a7=smoothstep(e7,e8,x_20);return max(mix(v0,v1,a0)*step(e0,x_20)*step(x_20,e1),max(mix(v1,v2,a1)*step(e1,x_20)*step(x_20,e2),max(mix(v2,v3,a2)*step(e2,x_20)*step(x_20,e3),max(mix(v3,v4,a3)*step(e3,x_20)*step(x_20,e4),max(mix(v4,v5,a4)*step(e4,x_20)*step(x_20,e5),max(mix(v5,v6,a5)*step(e5,x_20)*step(x_20,e6),max(mix(v6,v7,a6)*step(e6,x_20)*step(x_20,e7),mix(v7,v8,a7)*step(e7,x_20)*step(x_20,e8))))))));}vec4 oxygen(float x_11){const float e0=0.0;const vec4 v0=vec4(0.25098039215686274,0.0196078431372549,0.0196078431372549,1);const float e1=0.13;const vec4 v1=vec4(0.41568627450980394,0.023529411764705882,0.058823529411764705,1);const float e2=0.25;const vec4 v2=vec4(0.5647058823529412,0.10196078431372549,0.027450980392156862,1);const float e3=0.38;const vec4 v3=vec4(0.6588235294117647,0.25098039215686274,0.011764705882352941,1);const float e4=0.5;const vec4 v4=vec4(0.7372549019607844,0.39215686274509803,0.01568627450980392,1);const float e5=0.63;const vec4 v5=vec4(0.807843137254902,0.5333333333333333,0.043137254901960784,1);const float e6=0.75;const vec4 v6=vec4(0.8627450980392157,0.6823529411764706,0.09803921568627451,1);const float e7=0.88;const vec4 v7=vec4(0.9058823529411765,0.8431372549019608,0.17254901960784313,1);const float e8=1.0;const vec4 v8=vec4(0.9725490196078431,0.996078431372549,0.4117647058823529,1);float a0=smoothstep(e0,e1,x_11);float a1=smoothstep(e1,e2,x_11);float a2=smoothstep(e2,e3,x_11);float a3=smoothstep(e3,e4,x_11);float a4=smoothstep(e4,e5,x_11);float a5=smoothstep(e5,e6,x_11);float a6=smoothstep(e6,e7,x_11);float a7=smoothstep(e7,e8,x_11);return max(mix(v0,v1,a0)*step(e0,x_11)*step(x_11,e1),max(mix(v1,v2,a1)*step(e1,x_11)*step(x_11,e2),max(mix(v2,v3,a2)*step(e2,x_11)*step(x_11,e3),max(mix(v3,v4,a3)*step(e3,x_11)*step(x_11,e4),max(mix(v4,v5,a4)*step(e4,x_11)*step(x_11,e5),max(mix(v5,v6,a5)*step(e5,x_11)*step(x_11,e6),max(mix(v6,v7,a6)*step(e6,x_11)*step(x_11,e7),mix(v7,v8,a7)*step(e7,x_11)*step(x_11,e8))))))));}vec4 par(float x_28){const float e0=0.0;const vec4 v0=vec4(0.2,0.0784313725490196,0.09411764705882353,1);const float e1=0.13;const vec4 v1=vec4(0.35294117647058826,0.12549019607843137,0.13725490196078433,1);const float e2=0.25;const vec4 v2=vec4(0.5058823529411764,0.17254901960784313,0.13333333333333333,1);const float e3=0.38;const vec4 v3=vec4(0.6235294117647059,0.26666666666666666,0.09803921568627451,1);const float e4=0.5;const vec4 v4=vec4(0.7137254901960784,0.38823529411764707,0.07450980392156863,1);const float e5=0.63;const vec4 v5=vec4(0.7803921568627451,0.5254901960784314,0.08627450980392157,1);const float e6=0.75;const vec4 v6=vec4(0.8313725490196079,0.6705882352941176,0.13725490196078433,1);const float e7=0.88;const vec4 v7=vec4(0.8666666666666667,0.8235294117647058,0.21176470588235294,1);const float e8=1.0;const vec4 v8=vec4(0.8823529411764706,0.9921568627450981,0.29411764705882354,1);float a0=smoothstep(e0,e1,x_28);float a1=smoothstep(e1,e2,x_28);float a2=smoothstep(e2,e3,x_28);float a3=smoothstep(e3,e4,x_28);float a4=smoothstep(e4,e5,x_28);float a5=smoothstep(e5,e6,x_28);float a6=smoothstep(e6,e7,x_28);float a7=smoothstep(e7,e8,x_28);return max(mix(v0,v1,a0)*step(e0,x_28)*step(x_28,e1),max(mix(v1,v2,a1)*step(e1,x_28)*step(x_28,e2),max(mix(v2,v3,a2)*step(e2,x_28)*step(x_28,e3),max(mix(v3,v4,a3)*step(e3,x_28)*step(x_28,e4),max(mix(v4,v5,a4)*step(e4,x_28)*step(x_28,e5),max(mix(v5,v6,a5)*step(e5,x_28)*step(x_28,e6),max(mix(v6,v7,a6)*step(e6,x_28)*step(x_28,e7),mix(v7,v8,a7)*step(e7,x_28)*step(x_28,e8))))))));}vec4 phase(float x_39){const float e0=0.0;const vec4 v0=vec4(0.5686274509803921,0.4117647058823529,0.07058823529411765,1);const float e1=0.13;const vec4 v1=vec4(0.7215686274509804,0.2784313725490196,0.14901960784313725,1);const float e2=0.25;const vec4 v2=vec4(0.7294117647058823,0.22745098039215686,0.45098039215686275,1);const float e3=0.38;const vec4 v3=vec4(0.6274509803921569,0.2784313725490196,0.7254901960784313,1);const float e4=0.5;const vec4 v4=vec4(0.43137254901960786,0.3803921568627451,0.8549019607843137,1);const float e5=0.63;const vec4 v5=vec4(0.19607843137254902,0.4823529411764706,0.6431372549019608,1);const float e6=0.75;const vec4 v6=vec4(0.12156862745098039,0.5137254901960784,0.43137254901960786,1);const float e7=0.88;const vec4 v7=vec4(0.30196078431372547,0.5058823529411764,0.13333333333333333,1);const float e8=1.0;const vec4 v8=vec4(0.5686274509803921,0.4117647058823529,0.07058823529411765,1);float a0=smoothstep(e0,e1,x_39);float a1=smoothstep(e1,e2,x_39);float a2=smoothstep(e2,e3,x_39);float a3=smoothstep(e3,e4,x_39);float a4=smoothstep(e4,e5,x_39);float a5=smoothstep(e5,e6,x_39);float a6=smoothstep(e6,e7,x_39);float a7=smoothstep(e7,e8,x_39);return max(mix(v0,v1,a0)*step(e0,x_39)*step(x_39,e1),max(mix(v1,v2,a1)*step(e1,x_39)*step(x_39,e2),max(mix(v2,v3,a2)*step(e2,x_39)*step(x_39,e3),max(mix(v3,v4,a3)*step(e3,x_39)*step(x_39,e4),max(mix(v4,v5,a4)*step(e4,x_39)*step(x_39,e5),max(mix(v5,v6,a5)*step(e5,x_39)*step(x_39,e6),max(mix(v6,v7,a6)*step(e6,x_39)*step(x_39,e7),mix(v7,v8,a7)*step(e7,x_39)*step(x_39,e8))))))));}vec4 salinity(float x_26){const float e0=0.0;const vec4 v0=vec4(0.16470588235294117,0.09411764705882353,0.4235294117647059,1);const float e1=0.13;const vec4 v1=vec4(0.12941176470588237,0.19607843137254902,0.6352941176470588,1);const float e2=0.25;const vec4 v2=vec4(0.058823529411764705,0.35294117647058826,0.5686274509803921,1);const float e3=0.38;const vec4 v3=vec4(0.1568627450980392,0.4627450980392157,0.5372549019607843,1);const float e4=0.5;const vec4 v4=vec4(0.23137254901960785,0.5725490196078431,0.5294117647058824,1);const float e5=0.63;const vec4 v5=vec4(0.30980392156862746,0.6862745098039216,0.49411764705882355,1);const float e6=0.75;const vec4 v6=vec4(0.47058823529411764,0.796078431372549,0.40784313725490196,1);const float e7=0.88;const vec4 v7=vec4(0.7568627450980392,0.8666666666666667,0.39215686274509803,1);const float e8=1.0;const vec4 v8=vec4(0.9921568627450981,0.9372549019607843,0.6039215686274509,1);float a0=smoothstep(e0,e1,x_26);float a1=smoothstep(e1,e2,x_26);float a2=smoothstep(e2,e3,x_26);float a3=smoothstep(e3,e4,x_26);float a4=smoothstep(e4,e5,x_26);float a5=smoothstep(e5,e6,x_26);float a6=smoothstep(e6,e7,x_26);float a7=smoothstep(e7,e8,x_26);return max(mix(v0,v1,a0)*step(e0,x_26)*step(x_26,e1),max(mix(v1,v2,a1)*step(e1,x_26)*step(x_26,e2),max(mix(v2,v3,a2)*step(e2,x_26)*step(x_26,e3),max(mix(v3,v4,a3)*step(e3,x_26)*step(x_26,e4),max(mix(v4,v5,a4)*step(e4,x_26)*step(x_26,e5),max(mix(v5,v6,a5)*step(e5,x_26)*step(x_26,e6),max(mix(v6,v7,a6)*step(e6,x_26)*step(x_26,e7),mix(v7,v8,a7)*step(e7,x_26)*step(x_26,e8))))))));}vec4 temperature(float x_8){const float e0=0.0;const vec4 v0=vec4(0.01568627450980392,0.13725490196078433,0.2,1);const float e1=0.13;const vec4 v1=vec4(0.09019607843137255,0.2,0.47843137254901963,1);const float e2=0.25;const vec4 v2=vec4(0.3333333333333333,0.23137254901960785,0.615686274509804,1);const float e3=0.38;const vec4 v3=vec4(0.5058823529411764,0.30980392156862746,0.5607843137254902,1);const float e4=0.5;const vec4 v4=vec4(0.6862745098039216,0.37254901960784315,0.5098039215686274,1);const float e5=0.63;const vec4 v5=vec4(0.8705882352941177,0.4392156862745098,0.396078431372549,1);const float e6=0.75;const vec4 v6=vec4(0.9764705882352941,0.5725490196078431,0.25882352941176473,1);const float e7=0.88;const vec4 v7=vec4(0.9764705882352941,0.7686274509803922,0.2549019607843137,1);const float e8=1.0;const vec4 v8=vec4(0.9098039215686274,0.9803921568627451,0.3568627450980392,1);float a0=smoothstep(e0,e1,x_8);float a1=smoothstep(e1,e2,x_8);float a2=smoothstep(e2,e3,x_8);float a3=smoothstep(e3,e4,x_8);float a4=smoothstep(e4,e5,x_8);float a5=smoothstep(e5,e6,x_8);float a6=smoothstep(e6,e7,x_8);float a7=smoothstep(e7,e8,x_8);return max(mix(v0,v1,a0)*step(e0,x_8)*step(x_8,e1),max(mix(v1,v2,a1)*step(e1,x_8)*step(x_8,e2),max(mix(v2,v3,a2)*step(e2,x_8)*step(x_8,e3),max(mix(v3,v4,a3)*step(e3,x_8)*step(x_8,e4),max(mix(v4,v5,a4)*step(e4,x_8)*step(x_8,e5),max(mix(v5,v6,a5)*step(e5,x_8)*step(x_8,e6),max(mix(v6,v7,a6)*step(e6,x_8)*step(x_8,e7),mix(v7,v8,a7)*step(e7,x_8)*step(x_8,e8))))))));}vec4 turbidity(float x_40){const float e0=0.0;const vec4 v0=vec4(0.13333333333333333,0.12156862745098039,0.10588235294117647,1);const float e1=0.13;const vec4 v1=vec4(0.2549019607843137,0.19607843137254902,0.1607843137254902,1);const float e2=0.25;const vec4 v2=vec4(0.3843137254901961,0.27058823529411763,0.20392156862745098,1);const float e3=0.38;const vec4 v3=vec4(0.5137254901960784,0.34901960784313724,0.2235294117647059,1);const float e4=0.5;const vec4 v4=vec4(0.6313725490196078,0.4392156862745098,0.23137254901960785,1);const float e5=0.63;const vec4 v5=vec4(0.7254901960784313,0.5490196078431373,0.25882352941176473,1);const float e6=0.75;const vec4 v6=vec4(0.792156862745098,0.6823529411764706,0.34509803921568627,1);const float e7=0.88;const vec4 v7=vec4(0.8470588235294118,0.8196078431372549,0.49411764705882355,1);const float e8=1.0;const vec4 v8=vec4(0.9137254901960784,0.9647058823529412,0.6705882352941176,1);float a0=smoothstep(e0,e1,x_40);float a1=smoothstep(e1,e2,x_40);float a2=smoothstep(e2,e3,x_40);float a3=smoothstep(e3,e4,x_40);float a4=smoothstep(e4,e5,x_40);float a5=smoothstep(e5,e6,x_40);float a6=smoothstep(e6,e7,x_40);float a7=smoothstep(e7,e8,x_40);return max(mix(v0,v1,a0)*step(e0,x_40)*step(x_40,e1),max(mix(v1,v2,a1)*step(e1,x_40)*step(x_40,e2),max(mix(v2,v3,a2)*step(e2,x_40)*step(x_40,e3),max(mix(v3,v4,a3)*step(e3,x_40)*step(x_40,e4),max(mix(v4,v5,a4)*step(e4,x_40)*step(x_40,e5),max(mix(v5,v6,a5)*step(e5,x_40)*step(x_40,e6),max(mix(v6,v7,a6)*step(e6,x_40)*step(x_40,e7),mix(v7,v8,a7)*step(e7,x_40)*step(x_40,e8))))))));}vec4 velocity_blue_297387650(float x_2){const float e0=0.0;const vec4 v0=vec4(0.06666666666666667,0.12549019607843137,0.25098039215686274,1);const float e1=0.13;const vec4 v1=vec4(0.13725490196078433,0.20392156862745098,0.4549019607843137,1);const float e2=0.25;const vec4 v2=vec4(0.11372549019607843,0.3176470588235294,0.611764705882353,1);const float e3=0.38;const vec4 v3=vec4(0.12156862745098039,0.44313725490196076,0.6352941176470588,1);const float e4=0.5;const vec4 v4=vec4(0.19607843137254902,0.5647058823529412,0.6627450980392157,1);const float e5=0.63;const vec4 v5=vec4(0.3411764705882353,0.6784313725490196,0.6901960784313725,1);const float e6=0.75;const vec4 v6=vec4(0.5843137254901961,0.7686274509803922,0.7411764705882353,1);const float e7=0.88;const vec4 v7=vec4(0.796078431372549,0.8666666666666667,0.8274509803921568,1);const float e8=1.0;const vec4 v8=vec4(0.996078431372549,0.984313725490196,0.9019607843137255,1);float a0=smoothstep(e0,e1,x_2);float a1=smoothstep(e1,e2,x_2);float a2=smoothstep(e2,e3,x_2);float a3=smoothstep(e3,e4,x_2);float a4=smoothstep(e4,e5,x_2);float a5=smoothstep(e5,e6,x_2);float a6=smoothstep(e6,e7,x_2);float a7=smoothstep(e7,e8,x_2);return max(mix(v0,v1,a0)*step(e0,x_2)*step(x_2,e1),max(mix(v1,v2,a1)*step(e1,x_2)*step(x_2,e2),max(mix(v2,v3,a2)*step(e2,x_2)*step(x_2,e3),max(mix(v3,v4,a3)*step(e3,x_2)*step(x_2,e4),max(mix(v4,v5,a4)*step(e4,x_2)*step(x_2,e5),max(mix(v5,v6,a5)*step(e5,x_2)*step(x_2,e6),max(mix(v6,v7,a6)*step(e6,x_2)*step(x_2,e7),mix(v7,v8,a7)*step(e7,x_2)*step(x_2,e8))))))));}vec4 velocity_green_2558432129(float x_27){const float e0=0.0;const vec4 v0=vec4(0.09019607843137255,0.13725490196078433,0.07450980392156863,1);const float e1=0.13;const vec4 v1=vec4(0.09411764705882353,0.25098039215686274,0.14901960784313725,1);const float e2=0.25;const vec4 v2=vec4(0.043137254901960784,0.37254901960784315,0.17647058823529413,1);const float e3=0.38;const vec4 v3=vec4(0.15294117647058825,0.4823529411764706,0.13725490196078433,1);const float e4=0.5;const vec4 v4=vec4(0.37254901960784315,0.5725490196078431,0.047058823529411764,1);const float e5=0.63;const vec4 v5=vec4(0.596078431372549,0.6470588235294118,0.07058823529411765,1);const float e6=0.75;const vec4 v6=vec4(0.788235294117647,0.7294117647058823,0.27058823529411763,1);const float e7=0.88;const vec4 v7=vec4(0.9137254901960784,0.8470588235294118,0.5372549019607843,1);const float e8=1.0;const vec4 v8=vec4(1,0.9921568627450981,0.803921568627451,1);float a0=smoothstep(e0,e1,x_27);float a1=smoothstep(e1,e2,x_27);float a2=smoothstep(e2,e3,x_27);float a3=smoothstep(e3,e4,x_27);float a4=smoothstep(e4,e5,x_27);float a5=smoothstep(e5,e6,x_27);float a6=smoothstep(e6,e7,x_27);float a7=smoothstep(e7,e8,x_27);return max(mix(v0,v1,a0)*step(e0,x_27)*step(x_27,e1),max(mix(v1,v2,a1)*step(e1,x_27)*step(x_27,e2),max(mix(v2,v3,a2)*step(e2,x_27)*step(x_27,e3),max(mix(v3,v4,a3)*step(e3,x_27)*step(x_27,e4),max(mix(v4,v5,a4)*step(e4,x_27)*step(x_27,e5),max(mix(v5,v6,a5)*step(e5,x_27)*step(x_27,e6),max(mix(v6,v7,a6)*step(e6,x_27)*step(x_27,e7),mix(v7,v8,a7)*step(e7,x_27)*step(x_27,e8))))))));}vec4 cubehelix(float x_37){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.07;const vec4 v1=vec4(0.08627450980392157,0.0196078431372549,0.23137254901960785,1);const float e2=0.13;const vec4 v2=vec4(0.23529411764705882,0.01568627450980392,0.4117647058823529,1);const float e3=0.2;const vec4 v3=vec4(0.42745098039215684,0.00392156862745098,0.5294117647058824,1);const float e4=0.27;const vec4 v4=vec4(0.6313725490196078,0,0.5764705882352941,1);const float e5=0.33;const vec4 v5=vec4(0.8235294117647058,0.00784313725490196,0.5568627450980392,1);const float e6=0.4;const vec4 v6=vec4(0.984313725490196,0.043137254901960784,0.4823529411764706,1);const float e7=0.47;const vec4 v7=vec4(1,0.11372549019607843,0.3803921568627451,1);const float e8=0.53;const vec4 v8=vec4(1,0.21176470588235294,0.27058823529411763,1);const float e9=0.6;const vec4 v9=vec4(1,0.3333333333333333,0.1803921568627451,1);const float e10=0.67;const vec4 v10=vec4(1,0.47058823529411764,0.13333333333333333,1);const float e11=0.73;const vec4 v11=vec4(1,0.615686274509804,0.1450980392156863,1);const float e12=0.8;const vec4 v12=vec4(0.9450980392156862,0.7490196078431373,0.2235294117647059,1);const float e13=0.87;const vec4 v13=vec4(0.8784313725490196,0.8627450980392157,0.36470588235294116,1);const float e14=0.93;const vec4 v14=vec4(0.8549019607843137,0.9450980392156862,0.5568627450980392,1);const float e15=1.0;const vec4 v15=vec4(0.8901960784313725,0.9921568627450981,0.7764705882352941,1);float a0=smoothstep(e0,e1,x_37);float a1=smoothstep(e1,e2,x_37);float a2=smoothstep(e2,e3,x_37);float a3=smoothstep(e3,e4,x_37);float a4=smoothstep(e4,e5,x_37);float a5=smoothstep(e5,e6,x_37);float a6=smoothstep(e6,e7,x_37);float a7=smoothstep(e7,e8,x_37);float a8=smoothstep(e8,e9,x_37);float a9=smoothstep(e9,e10,x_37);float a10=smoothstep(e10,e11,x_37);float a11=smoothstep(e11,e12,x_37);float a12=smoothstep(e12,e13,x_37);float a13=smoothstep(e13,e14,x_37);float a14=smoothstep(e14,e15,x_37);return max(mix(v0,v1,a0)*step(e0,x_37)*step(x_37,e1),max(mix(v1,v2,a1)*step(e1,x_37)*step(x_37,e2),max(mix(v2,v3,a2)*step(e2,x_37)*step(x_37,e3),max(mix(v3,v4,a3)*step(e3,x_37)*step(x_37,e4),max(mix(v4,v5,a4)*step(e4,x_37)*step(x_37,e5),max(mix(v5,v6,a5)*step(e5,x_37)*step(x_37,e6),max(mix(v6,v7,a6)*step(e6,x_37)*step(x_37,e7),max(mix(v7,v8,a7)*step(e7,x_37)*step(x_37,e8),max(mix(v8,v9,a8)*step(e8,x_37)*step(x_37,e9),max(mix(v9,v10,a9)*step(e9,x_37)*step(x_37,e10),max(mix(v10,v11,a10)*step(e10,x_37)*step(x_37,e11),max(mix(v11,v12,a11)*step(e11,x_37)*step(x_37,e12),max(mix(v12,v13,a12)*step(e12,x_37)*step(x_37,e13),max(mix(v13,v14,a13)*step(e13,x_37)*step(x_37,e14),mix(v14,v15,a14)*step(e14,x_37)*step(x_37,e15)))))))))))))));}float sample_and_apply_contrast_limits(SAMPLER_TYPE channel,vec2 vTexCoord,vec2 contrastLimits){float fragIntensity=float(texture(channel,vTexCoord).r);float contrastLimitsAppliedToIntensity=(fragIntensity-contrastLimits[0])/max(0.0005,(contrastLimits[1]-contrastLimits[0]));return max(0.,contrastLimitsAppliedToIntensity);}vec3 process_channel_intensity(float intensity,vec3 colors,int channelIndex,bool inLensAndUseLens,int lensSelection){float useColorValue=float(int((inLensAndUseLens&&channelIndex==lensSelection)||(!inLensAndUseLens)));vec3 rgb=max(0.,min(1.,intensity))*max(vec3(colors),(1.-useColorValue)*vec3(1.,1.,1.));return rgb;}vec4 apply_opacity(vec3 color,bool useTransparentColor,vec3 transparentColor,float opacity){return vec4(color,(color==transparentColor&&useTransparentColor)? 0. : opacity);}vec4 colormap(float intensity,float opacity,bool useTransparentColor){return apply_opacity(COLORMAP_FUNCTION(min(1.,intensity)).xyz,useTransparentColor,COLORMAP_FUNCTION(0.).xyz,opacity);}";
var channels$1 = {
  name: "channel-intensity-module",
  defines: {
    SAMPLER_TYPE: "usampler2D",
    COLORMAP_FUNCTION: ""
  },
  fs: fs$3
};
var fs$2 = "#define GLSLIFY 1\nbool frag_in_lens_bounds(vec2 lensCenter,vec2 vTexCoord,float majorLensAxis,float minorLensAxis,float lensBorderRadius){return pow((lensCenter.x-vTexCoord.x)/majorLensAxis,2.)+pow((lensCenter.y-vTexCoord.y)/minorLensAxis,2.)<(1.-lensBorderRadius);}bool frag_on_lens_bounds(vec2 lensCenter,vec2 vTexCoord,float majorLensAxis,float minorLensAxis,float lensBorderRadius){float ellipseDistance=pow((lensCenter.x-vTexCoord.x)/majorLensAxis,2.)+pow((lensCenter.y-vTexCoord.y)/minorLensAxis,2.);return ellipseDistance<=1.&&ellipseDistance>=(1.-lensBorderRadius);}";
var lens = {
  name: "lens-module",
  defines: {
    SAMPLER_TYPE: "usampler2D"
  },
  fs: fs$2
};
var MAX_COLOR_INTENSITY = 255;
var DEFAULT_COLOR_OFF = [0, 0, 0];
var MAX_CHANNELS = 6;
var DEFAULT_FONT_FAMILY = "-apple-system, 'Helvetica Neue', Arial, sans-serif";
var DTYPE_VALUES = {
  Uint8: {
    format: GL.R8UI,
    dataFormat: GL.RED_INTEGER,
    type: GL.UNSIGNED_BYTE,
    max: __pow(2, 8) - 1,
    sampler: "usampler2D"
  },
  Uint16: {
    format: GL.R16UI,
    dataFormat: GL.RED_INTEGER,
    type: GL.UNSIGNED_SHORT,
    max: __pow(2, 16) - 1,
    sampler: "usampler2D"
  },
  Uint32: {
    format: GL.R32UI,
    dataFormat: GL.RED_INTEGER,
    type: GL.UNSIGNED_INT,
    max: __pow(2, 32) - 1,
    sampler: "usampler2D"
  },
  Float32: {
    format: GL.R32F,
    dataFormat: GL.RED,
    type: GL.FLOAT,
    max: 3.4 * __pow(10, 38),
    sampler: "sampler2D"
  },
  Int8: {
    format: GL.R8I,
    dataFormat: GL.RED_INTEGER,
    type: GL.BYTE,
    max: __pow(2, 8 - 1) - 1,
    sampler: "isampler2D"
  },
  Int16: {
    format: GL.R16I,
    dataFormat: GL.RED_INTEGER,
    type: GL.SHORT,
    max: __pow(2, 16 - 1) - 1,
    sampler: "isampler2D"
  },
  Int32: {
    format: GL.R32I,
    dataFormat: GL.RED_INTEGER,
    type: GL.INT,
    max: __pow(2, 32 - 1) - 1,
    sampler: "isampler2D"
  },
  Float64: {
    format: GL.R32F,
    dataFormat: GL.RED,
    type: GL.FLOAT,
    max: 3.4 * __pow(10, 38),
    sampler: "sampler2D",
    cast: (data) => new Float32Array(data)
  }
};
var COLORMAPS = [
  "jet",
  "hsv",
  "hot",
  "cool",
  "spring",
  "summer",
  "autumn",
  "winter",
  "bone",
  "copper",
  "greys",
  "yignbu",
  "greens",
  "yiorrd",
  "bluered",
  "rdbu",
  "picnic",
  "rainbow",
  "portland",
  "blackbody",
  "earth",
  "electric",
  "alpha",
  "viridis",
  "inferno",
  "magma",
  "plasma",
  "warm",
  "rainbow-soft",
  "bathymetry",
  "cdom",
  "chlorophyll",
  "density",
  "freesurface-blue",
  "freesurface-red",
  "oxygen",
  "par",
  "phase",
  "salinity",
  "temperature",
  "turbidity",
  "velocity-blue",
  "velocity-green",
  "cubehelix"
];
var RENDERING_MODES;
(function(RENDERING_MODES2) {
  RENDERING_MODES2["MAX_INTENSITY_PROJECTION"] = "Maximum Intensity Projection";
  RENDERING_MODES2["MIN_INTENSITY_PROJECTION"] = "Minimum Intensity Projection";
  RENDERING_MODES2["ADDITIVE"] = "Additive";
})(RENDERING_MODES || (RENDERING_MODES = {}));
function range2(len) {
  return [...Array(len).keys()];
}
function padWithDefault(arr, defaultValue, padWidth) {
  for (let i = 0; i < padWidth; i += 1) {
    arr.push(defaultValue);
  }
  return arr;
}
function getDtypeValues(dtype) {
  const values = DTYPE_VALUES[dtype];
  if (!values) {
    const valid = Object.keys(DTYPE_VALUES);
    throw Error(`Dtype not supported, got ${dtype}. Must be one of ${valid}.`);
  }
  return values;
}
function padColorsAndWindows({
  contrastLimits,
  colors,
  channelsVisible,
  domain,
  dtype
}) {
  const lengths = [contrastLimits.length, colors.length];
  if (lengths.every((l) => l !== lengths[0])) {
    throw Error("Inconsistent number of slider values and colors provided");
  }
  const newColors = colors.map((color, i) => channelsVisible[i] ? color.map((c) => c / MAX_COLOR_INTENSITY) : DEFAULT_COLOR_OFF);
  const maxSliderValue = domain && domain[1] || getDtypeValues(dtype).max;
  const newContrastLimits = contrastLimits.map((slider, i) => channelsVisible[i] ? slider : [maxSliderValue, maxSliderValue]);
  const padSize = MAX_CHANNELS - newColors.length;
  if (padSize < 0) {
    throw Error(`${lengths} channels passed in, but only 6 are allowed.`);
  }
  const paddedColors = padWithDefault(newColors, DEFAULT_COLOR_OFF, padSize);
  const paddedContrastLimits = padWithDefault(newContrastLimits, [maxSliderValue, maxSliderValue], padSize);
  const paddedColorsAndWindows = {
    paddedContrastLimits: paddedContrastLimits.reduce((acc, val) => acc.concat(val), []),
    paddedColors: paddedColors.reduce((acc, val) => acc.concat(val), [])
  };
  return paddedColorsAndWindows;
}
function onPointer(layer) {
  const { viewportId, lensRadius } = layer.props;
  if (!viewportId) {
    layer.setState({ unprojectLensBounds: [0, 0, 0, 0] });
    return;
  }
  const { mousePosition } = layer.context;
  const layerView = layer.context.deck.viewManager.views.filter((view) => view.id === viewportId)[0];
  const viewState = layer.context.deck.viewManager.viewState[viewportId];
  const viewport = layerView.makeViewport(__spreadProps(__spreadValues({}, viewState), {
    viewState
  }));
  if (mousePosition && viewport.containsPixel(mousePosition)) {
    const offsetMousePosition = {
      x: mousePosition.x - viewport.x,
      y: mousePosition.y - viewport.y
    };
    const mousePositionBounds = [
      [offsetMousePosition.x - lensRadius, offsetMousePosition.y],
      [offsetMousePosition.x, offsetMousePosition.y + lensRadius],
      [offsetMousePosition.x + lensRadius, offsetMousePosition.y],
      [offsetMousePosition.x, offsetMousePosition.y - lensRadius]
    ];
    const unprojectLensBounds = mousePositionBounds.map((bounds, i) => viewport.unproject(bounds)[i % 2]);
    layer.setState({ unprojectLensBounds });
  } else {
    layer.setState({ unprojectLensBounds: [0, 0, 0, 0] });
  }
}
function getPhysicalSizeScalingMatrix(loader) {
  var _a2, _b2;
  const { x, y, z } = (_b2 = (_a2 = loader == null ? void 0 : loader.meta) == null ? void 0 : _a2.physicalSizes) != null ? _b2 : {};
  if ((x == null ? void 0 : x.size) && (y == null ? void 0 : y.size) && (z == null ? void 0 : z.size)) {
    const min = Math.min(z.size, x.size, y.size);
    const ratio = [x.size / min, y.size / min, z.size / min];
    return new Matrix4().scale(ratio);
  }
  return new Matrix4().identity();
}
var SHADER_MODULES = [
  { fs: fs1, fscmap: fsColormap1, vs: vs1 },
  { fs: fs2, fscmap: fsColormap2, vs: vs2 }
];
function validateWebGL2Filter(gl, interpolation) {
  const canShowFloat = hasFeature(gl, FEATURES.TEXTURE_FLOAT);
  const canShowLinear = hasFeature(gl, FEATURES.TEXTURE_FILTER_LINEAR_FLOAT);
  if (!canShowFloat) {
    throw new Error("WebGL1 context does not support floating point textures.  Unable to display raster data.");
  }
  if (!canShowLinear && interpolation === GL.LINEAR) {
    console.warn("LINEAR filtering not supported in WebGL1 context.  Falling back to NEAREST.");
    return GL.NEAREST;
  }
  return interpolation;
}
function getRenderingAttrs$1(dtype, gl, interpolation) {
  const isLinear = interpolation === GL.LINEAR;
  if (!isWebGL2(gl)) {
    return {
      format: GL.LUMINANCE,
      dataFormat: GL.LUMINANCE,
      type: GL.FLOAT,
      sampler: "sampler2D",
      shaderModule: SHADER_MODULES[0],
      filter: validateWebGL2Filter(gl, interpolation),
      cast: (data) => new Float32Array(data)
    };
  }
  const values = getDtypeValues(isLinear ? "Float32" : dtype);
  return __spreadProps(__spreadValues({}, values), {
    shaderModule: SHADER_MODULES[1],
    filter: interpolation,
    cast: isLinear ? (data) => new Float32Array(data) : (data) => data
  });
}
var defaultProps$8 = {
  pickable: { type: "boolean", value: true, compare: true },
  coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN,
  channelData: { type: "object", value: {}, compare: true },
  bounds: { type: "array", value: [0, 0, 1, 1], compare: true },
  colors: { type: "array", value: [], compare: true },
  contrastLimits: { type: "array", value: [], compare: true },
  channelsVisible: { type: "array", value: [], compare: true },
  opacity: { type: "number", value: 1, compare: true },
  dtype: { type: "string", value: "Uint16", compare: true },
  colormap: { type: "string", value: "", compare: true },
  isLensOn: { type: "boolean", value: false, compare: true },
  lensSelection: { type: "number", value: 0, compare: true },
  lensBorderColor: { type: "array", value: [255, 255, 255], compare: true },
  lensBorderRadius: { type: "number", value: 0.02, compare: true },
  unprojectLensBounds: { type: "array", value: [0, 0, 0, 0], compare: true },
  transparentColor: { type: "array", value: null, compare: true },
  interpolation: {
    type: "number",
    value: GL.NEAREST,
    compare: true
  }
};
var XRLayer = class extends Layer {
  getShaders() {
    const { colormap, dtype, interpolation } = this.props;
    const { shaderModule, sampler } = getRenderingAttrs$1(dtype, this.context.gl, interpolation);
    return super.getShaders({
      fs: colormap ? shaderModule.fscmap : shaderModule.fs,
      vs: shaderModule.vs,
      defines: {
        SAMPLER_TYPE: sampler,
        COLORMAP_FUNCTION: colormap || "viridis"
      },
      modules: [project32, picking, channels$1, lens]
    });
  }
  initializeState() {
    const { gl } = this.context;
    gl.pixelStorei(GL.UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(GL.PACK_ALIGNMENT, 1);
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      positions: {
        size: 3,
        type: GL.DOUBLE,
        fp64: this.use64bitPositions(),
        update: this.calculatePositions,
        noAlloc: true
      }
    });
    this.setState({
      numInstances: 1,
      positions: new Float64Array(12)
    });
  }
  finalizeState() {
    super.finalizeState();
    if (this.state.textures) {
      Object.values(this.state.textures).forEach((tex) => tex && tex.delete());
    }
  }
  updateState({ props, oldProps, changeFlags }) {
    var _a2, _b2;
    if (changeFlags.extensionsChanged || props.colormap !== oldProps.colormap || props.interpolation !== oldProps.interpolation) {
      const { gl } = this.context;
      if (this.state.model) {
        this.state.model.delete();
      }
      this.setState({ model: this._getModel(gl) });
      this.getAttributeManager().invalidateAll();
    }
    if (props.channelData !== oldProps.channelData && ((_a2 = props.channelData) == null ? void 0 : _a2.data) !== ((_b2 = oldProps.channelData) == null ? void 0 : _b2.data) || props.interpolation !== oldProps.interpolation) {
      this.loadChannelTextures(props.channelData);
    }
    const attributeManager = this.getAttributeManager();
    if (props.bounds !== oldProps.bounds) {
      attributeManager.invalidate("positions");
    }
  }
  _getModel(gl) {
    if (!gl) {
      return null;
    }
    return new Model(gl, __spreadProps(__spreadValues({}, this.getShaders()), {
      id: this.props.id,
      geometry: new Geometry({
        drawMode: GL.TRIANGLE_FAN,
        vertexCount: 4,
        attributes: {
          texCoords: new Float32Array([0, 1, 0, 0, 1, 0, 1, 1])
        }
      }),
      isInstanced: false
    }));
  }
  calculatePositions(attributes) {
    const { positions } = this.state;
    const { bounds } = this.props;
    positions[0] = bounds[0];
    positions[1] = bounds[1];
    positions[2] = 0;
    positions[3] = bounds[0];
    positions[4] = bounds[3];
    positions[5] = 0;
    positions[6] = bounds[2];
    positions[7] = bounds[3];
    positions[8] = 0;
    positions[9] = bounds[2];
    positions[10] = bounds[1];
    positions[11] = 0;
    attributes.value = positions;
  }
  draw({ uniforms }) {
    const { textures, model } = this.state;
    if (textures && model) {
      const {
        contrastLimits,
        colors,
        opacity,
        domain,
        dtype,
        channelsVisible,
        unprojectLensBounds,
        bounds,
        isLensOn,
        lensSelection,
        lensBorderColor,
        lensBorderRadius,
        transparentColor
      } = this.props;
      const numTextures = Object.values(textures).filter((t) => t).length;
      const { paddedContrastLimits, paddedColors } = padColorsAndWindows({
        contrastLimits: contrastLimits.slice(0, numTextures),
        colors: colors.slice(0, numTextures),
        channelsVisible: channelsVisible.slice(0, numTextures),
        domain,
        dtype
      });
      const [
        leftMouseBound,
        bottomMouseBound,
        rightMouseBound,
        topMouseBound
      ] = unprojectLensBounds;
      const [left, bottom, right, top] = bounds;
      const leftMouseBoundScaled = (leftMouseBound - left) / (right - left);
      const bottomMouseBoundScaled = (bottomMouseBound - top) / (bottom - top);
      const rightMouseBoundScaled = (rightMouseBound - left) / (right - left);
      const topMouseBoundScaled = (topMouseBound - top) / (bottom - top);
      model.setUniforms(__spreadValues(__spreadProps(__spreadValues({}, uniforms), {
        colors: paddedColors,
        contrastLimits: paddedContrastLimits,
        opacity,
        majorLensAxis: (rightMouseBoundScaled - leftMouseBoundScaled) / 2,
        minorLensAxis: (bottomMouseBoundScaled - topMouseBoundScaled) / 2,
        lensCenter: [
          (rightMouseBoundScaled + leftMouseBoundScaled) / 2,
          (bottomMouseBoundScaled + topMouseBoundScaled) / 2
        ],
        isLensOn,
        lensSelection,
        lensBorderColor,
        lensBorderRadius,
        transparentColor: (transparentColor || [0, 0, 0]).map((i) => i / 255),
        useTransparentColor: Boolean(transparentColor)
      }), textures)).draw();
    }
  }
  loadChannelTextures(channelData) {
    const textures = {
      channel0: null,
      channel1: null,
      channel2: null,
      channel3: null,
      channel4: null,
      channel5: null
    };
    if (this.state.textures) {
      Object.values(this.state.textures).forEach((tex) => tex && tex.delete());
    }
    if (channelData && Object.keys(channelData).length > 0 && channelData.data) {
      channelData.data.forEach((d, i) => {
        textures[`channel${i}`] = this.dataToTexture(d, channelData.width, channelData.height);
      }, this);
      this.setState({ textures });
    }
  }
  dataToTexture(data, width, height) {
    var _a2, _b2;
    const { interpolation } = this.props;
    const attrs = getRenderingAttrs$1(this.props.dtype, this.context.gl, interpolation);
    return new Texture2D(this.context.gl, {
      width,
      height,
      data: (_b2 = (_a2 = attrs.cast) == null ? void 0 : _a2.call(attrs, data)) != null ? _b2 : data,
      mipmaps: false,
      parameters: {
        [GL.TEXTURE_MIN_FILTER]: attrs.filter,
        [GL.TEXTURE_MAG_FILTER]: attrs.filter,
        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,
        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE
      },
      format: attrs.format,
      dataFormat: attrs.dataFormat,
      type: attrs.type
    });
  }
};
XRLayer.layerName = "XRLayer";
XRLayer.defaultProps = defaultProps$8;
var PHOTOMETRIC_INTERPRETATIONS = {
  WhiteIsZero: 0,
  BlackIsZero: 1,
  RGB: 2,
  Palette: 3,
  TransparencyMask: 4,
  CMYK: 5,
  YCbCr: 6,
  CIELab: 8,
  ICCLab: 9
};
var defaultProps$7 = __spreadProps(__spreadValues({}, BitmapLayer$1.defaultProps), {
  pickable: { type: "boolean", value: true, compare: true },
  coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN
});
var getPhotometricInterpretationShader = (photometricInterpretation, transparentColorInHook) => {
  const useTransparentColor = transparentColorInHook ? "true" : "false";
  const transparentColorVector = `vec3(${(transparentColorInHook || [0, 0, 0]).map((i) => String(i / 255)).join(",")})`;
  switch (photometricInterpretation) {
    case PHOTOMETRIC_INTERPRETATIONS.RGB:
      return `color[3] = (${useTransparentColor} && (color.rgb == ${transparentColorVector})) ? 0.0 : color.a;`;
    case PHOTOMETRIC_INTERPRETATIONS.WhiteIsZero:
      return `          float value = 1.0 - (color.r / 256.0);
          color = vec4(value, value, value, (${useTransparentColor} && vec3(value, value, value) == ${transparentColorVector}) ? 0.0 : color.a);
        `;
    case PHOTOMETRIC_INTERPRETATIONS.BlackIsZero:
      return `          float value = (color.r / 256.0);
          color = vec4(value, value, value, (${useTransparentColor} && vec3(value, value, value) == ${transparentColorVector}) ? 0.0 : color.a);
        `;
    case PHOTOMETRIC_INTERPRETATIONS.YCbCr:
      return `          float y = color[0];
          float cb = color[1];
          float cr = color[2];
          color[0] = (y + (1.40200 * (cr - .5)));
          color[1] = (y - (0.34414 * (cb - .5)) - (0.71414 * (cr - .5)));
          color[2] = (y + (1.77200 * (cb - .5)));
          color[3] = (${useTransparentColor} && distance(color.rgb, ${transparentColorVector}) < 0.01) ? 0.0 : color.a;
        `;
    default:
      console.error("Unsupported photometric interpretation or none provided.  No transformation will be done to image data");
      return "";
  }
};
var getTransparentColor = (photometricInterpretation) => {
  switch (photometricInterpretation) {
    case PHOTOMETRIC_INTERPRETATIONS.RGB:
      return [0, 0, 0, 0];
    case PHOTOMETRIC_INTERPRETATIONS.WhiteIsZero:
      return [255, 255, 255, 0];
    case PHOTOMETRIC_INTERPRETATIONS.BlackIsZero:
      return [0, 0, 0, 0];
    case PHOTOMETRIC_INTERPRETATIONS.YCbCr:
      return [16, 128, 128, 0];
    default:
      console.error("Unsupported photometric interpretation or none provided.  No transformation will be done to image data");
      return [0, 0, 0, 0];
  }
};
var BitmapLayerWrapper = class extends BitmapLayer$1 {
  _getModel(gl) {
    const { photometricInterpretation, transparentColorInHook } = this.props;
    const photometricInterpretationShader = getPhotometricInterpretationShader(photometricInterpretation, transparentColorInHook);
    if (!gl) {
      return null;
    }
    return new Model(gl, __spreadProps(__spreadValues({}, this.getShaders()), {
      id: this.props.id,
      geometry: new Geometry({
        drawMode: GL.TRIANGLES,
        vertexCount: 6
      }),
      isInstanced: false,
      inject: {
        "fs:DECKGL_FILTER_COLOR": photometricInterpretationShader
      }
    }));
  }
};
var BitmapLayer = class extends CompositeLayer {
  initializeState(args) {
    const { gl } = this.context;
    gl.pixelStorei(GL.UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(GL.PACK_ALIGNMENT, 1);
    super.initializeState(args);
  }
  renderLayers() {
    const {
      photometricInterpretation,
      transparentColor: transparentColorInHook
    } = this.props;
    const transparentColor = getTransparentColor(photometricInterpretation);
    return new BitmapLayerWrapper(this.props, {
      transparentColor,
      transparentColorInHook,
      id: `${this.props.id}-wrapped`
    });
  }
};
BitmapLayer.layerName = "BitmapLayer";
BitmapLayer.PHOTOMETRIC_INTERPRETATIONS = PHOTOMETRIC_INTERPRETATIONS;
BitmapLayer.defaultProps = __spreadProps(__spreadValues({}, defaultProps$7), {
  image: { type: "object", value: {}, compare: true },
  transparentColor: { type: "array", value: [0, 0, 0], compare: true },
  photometricInterpretation: { type: "number", value: 2, compare: true }
});
BitmapLayerWrapper.defaultProps = defaultProps$7;
BitmapLayerWrapper.layerName = "BitmapLayerWrapper";
function getChannelStats(arr) {
  let len = arr.length;
  let min = Infinity;
  let max2 = -Infinity;
  let total = 0;
  while (len--) {
    if (arr[len] < min) {
      min = arr[len];
    }
    if (arr[len] > max2) {
      max2 = arr[len];
    }
    total += arr[len];
  }
  const mean = total / arr.length;
  len = arr.length;
  let sumSquared = 0;
  while (len--) {
    sumSquared += __pow(arr[len] - mean, 2);
  }
  const sd = __pow(sumSquared / arr.length, 0.5);
  const mid = Math.floor(arr.length / 2);
  const firstQuartileLocation = Math.floor(arr.length / 4);
  const thirdQuartileLocation = 3 * Math.floor(arr.length / 4);
  quickselect(arr, mid);
  const median = arr[mid];
  quickselect(arr, firstQuartileLocation, 0, mid);
  const q1 = arr[firstQuartileLocation];
  quickselect(arr, thirdQuartileLocation, mid, arr.length - 1);
  const q3 = arr[thirdQuartileLocation];
  const cutoffArr = arr.filter((i) => i > 0);
  const cutoffPercentile = 5e-4;
  const topCutoffLocation = Math.floor(cutoffArr.length * (1 - cutoffPercentile));
  const bottomCutoffLocation = Math.floor(cutoffArr.length * cutoffPercentile);
  quickselect(cutoffArr, topCutoffLocation);
  quickselect(cutoffArr, bottomCutoffLocation, 0, topCutoffLocation);
  const contrastLimits = [
    cutoffArr[bottomCutoffLocation] || 0,
    cutoffArr[topCutoffLocation] || 0
  ];
  return {
    mean,
    sd,
    q1,
    q3,
    median,
    domain: [min, max2],
    contrastLimits
  };
}
function ensureArray(x) {
  return Array.isArray(x) ? x : [x];
}
function intToRgba(int) {
  if (!Number.isInteger(int)) {
    throw Error("Not an integer.");
  }
  const buffer = new ArrayBuffer(4);
  const view = new DataView(buffer);
  view.setInt32(0, int, false);
  const bytes = new Uint8Array(buffer);
  return Array.from(bytes);
}
function isInterleaved(shape) {
  const lastDimSize = shape[shape.length - 1];
  return lastDimSize === 3 || lastDimSize === 4;
}
function getLabels(dimOrder) {
  return dimOrder.toLowerCase().split("").reverse();
}
function getDims(labels) {
  const lookup = new Map(labels.map((name2, i) => [name2, i]));
  if (lookup.size !== labels.length) {
    throw Error("Labels must be unique, found duplicated label.");
  }
  return (name2) => {
    const index = lookup.get(name2);
    if (index === void 0) {
      throw Error("Invalid dimension.");
    }
    return index;
  };
}
function getImageSize(source) {
  const interleaved = isInterleaved(source.shape);
  const [height, width] = source.shape.slice(interleaved ? -3 : -2);
  return { height, width };
}
function prevPowerOf2(x) {
  return __pow(2, Math.floor(Math.log2(x)));
}
var SIGNAL_ABORTED = "__vivSignalAborted";
function renderSubLayers(props) {
  const {
    bbox: { left, top, right, bottom },
    x,
    y,
    z
  } = props.tile;
  const { data, id, loader, maxZoom } = props;
  if ([left, bottom, right, top].some((v) => v < 0) || !data) {
    return null;
  }
  const base = loader[0];
  const { height, width } = getImageSize(base);
  const bounds = [
    left,
    data.height < base.tileSize ? height : bottom,
    data.width < base.tileSize ? width : right,
    top
  ];
  if (isInterleaved(base.shape)) {
    const { photometricInterpretation = 2 } = base.meta;
    return new BitmapLayer(props, {
      image: data,
      photometricInterpretation,
      bounds,
      id: `tile-sub-layer-${bounds}-${id}`,
      tileId: { x, y, z }
    });
  }
  return new XRLayer(props, {
    channelData: data,
    bounds,
    id: `tile-sub-layer-${bounds}-${id}`,
    tileId: { x, y, z },
    interpolation: z === maxZoom ? GL.NEAREST : GL.LINEAR
  });
}
var defaultProps$6 = {
  pickable: { type: "boolean", value: true, compare: true },
  coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN,
  contrastLimits: { type: "array", value: [], compare: true },
  colors: { type: "array", value: [], compare: true },
  channelsVisible: { type: "array", value: [], compare: true },
  renderSubLayers: { type: "function", value: renderSubLayers, compare: false },
  colormap: { type: "string", value: "", compare: true },
  dtype: { type: "string", value: "Uint16", compare: true },
  domain: { type: "array", value: [], compare: true },
  viewportId: { type: "string", value: "", compare: true },
  unprojectLensBounds: { type: "array", value: [0, 0, 0, 0], compare: true },
  isLensOn: { type: "boolean", value: false, compare: true },
  lensSelection: { type: "number", value: 0, compare: true },
  lensRadius: { type: "number", value: 100, compare: true },
  lensBorderColor: { type: "array", value: [255, 255, 255], compare: true },
  lensBorderRadius: { type: "number", value: 0.02, compare: true },
  transparentColor: { type: "array", value: null, compare: true },
  interpolation: { type: "number", value: null, compare: true }
};
var MultiscaleImageLayerBase = class extends TileLayer {
  _updateTileset() {
    if (!this.props.viewportId) {
      super._updateTileset();
    }
    if (this.props.viewportId && this.context.viewport.id === this.props.viewportId || !this.state.tileset._viewport) {
      super._updateTileset();
    }
  }
};
MultiscaleImageLayerBase.layerName = "MultiscaleImageLayerBase";
MultiscaleImageLayerBase.defaultProps = defaultProps$6;
var defaultProps$5 = {
  pickable: { type: "boolean", value: true, compare: true },
  coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN,
  contrastLimits: { type: "array", value: [], compare: true },
  channelsVisible: { type: "array", value: [], compare: true },
  colors: { type: "array", value: [], compare: true },
  selections: { type: "array", value: [], compare: true },
  colormap: { type: "string", value: "", compare: true },
  domain: { type: "array", value: [], compare: true },
  viewportId: { type: "string", value: "", compare: true },
  loader: {
    type: "object",
    value: {
      getRaster: () => __async(void 0, null, function* () {
        return { data: [], height: 0, width: 0 };
      }),
      dtype: "Uint16"
    },
    compare: true
  },
  isLensOn: { type: "boolean", value: false, compare: true },
  lensSelection: { type: "number", value: 0, compare: true },
  lensRadius: { type: "number", value: 100, compare: true },
  lensBorderColor: { type: "array", value: [255, 255, 255], compare: true },
  lensBorderRadius: { type: "number", value: 0.02, compare: true },
  onClick: { type: "function", value: null, compare: true },
  transparentColor: { type: "array", value: null, compare: true },
  onViewportLoad: { type: "function", value: null, compare: true },
  interpolation: {
    type: "number",
    value: GL.NEAREST,
    compare: true
  }
};
var ImageLayer = class extends CompositeLayer {
  initializeState() {
    this.state = {
      unprojectLensBounds: [0, 0, 0, 0],
      width: 0,
      height: 0,
      data: []
    };
    if (this.context.deck) {
      this.context.deck.eventManager.on({
        pointermove: () => onPointer(this),
        pointerleave: () => onPointer(this),
        wheel: () => onPointer(this)
      });
    }
  }
  finalizeState() {
    this.state.abortController.abort();
  }
  updateState({ props, oldProps }) {
    const loaderChanged = props.loader !== oldProps.loader;
    const selectionsChanged = props.selections !== oldProps.selections;
    if (loaderChanged || selectionsChanged) {
      const { loader, selections = [], onViewportLoad } = this.props;
      const abortController = new AbortController();
      this.setState({ abortController });
      const { signal } = abortController;
      const getRaster = (selection) => loader.getRaster({ selection, signal });
      const dataPromises = selections.map(getRaster);
      Promise.all(dataPromises).then((rasters) => {
        const raster = {
          data: rasters.map((d) => d.data),
          width: rasters[0].width,
          height: rasters[0].height
        };
        if (isInterleaved(loader.shape)) {
          raster.data = raster.data[0];
          if (raster.data.length === raster.width * raster.height * 3) {
            raster.format = GL.RGB;
            raster.dataFormat = GL.RGB;
          }
        }
        if (onViewportLoad) {
          onViewportLoad(raster);
        }
        this.setState(__spreadValues({}, raster));
      }).catch((e) => {
        if (e !== SIGNAL_ABORTED) {
          throw e;
        }
      });
    }
  }
  getPickingInfo({ info, sourceLayer }) {
    info.sourceLayer = sourceLayer;
    info.tile = sourceLayer.props.tile;
    return info;
  }
  renderLayers() {
    const { loader, id } = this.props;
    const { dtype } = loader;
    const { width, height, data, unprojectLensBounds } = this.state;
    if (!(width && height))
      return null;
    const bounds = [0, height, width, 0];
    if (isInterleaved(loader.shape)) {
      const { photometricInterpretation = 2 } = loader.meta;
      return new BitmapLayer(this.props, {
        image: this.state,
        photometricInterpretation,
        bounds,
        id: `image-sub-layer-${bounds}-${id}`
      });
    }
    return new XRLayer(this.props, {
      channelData: { data, height, width },
      bounds,
      id: `image-sub-layer-${bounds}-${id}`,
      dtype,
      unprojectLensBounds
    });
  }
};
ImageLayer.layerName = "ImageLayer";
ImageLayer.defaultProps = defaultProps$5;
var defaultProps$4 = {
  pickable: { type: "boolean", value: true, compare: true },
  onHover: { type: "function", value: null, compare: false },
  contrastLimits: { type: "array", value: [], compare: true },
  colors: { type: "array", value: [], compare: true },
  channelsVisible: { type: "array", value: [], compare: true },
  opacity: { type: "number", value: 1, compare: true },
  colormap: { type: "string", value: "", compare: true },
  domain: { type: "array", value: [], compare: true },
  viewportId: { type: "string", value: "", compare: true },
  isLensOn: { type: "boolean", value: false, compare: true },
  lensSelection: { type: "number", value: 0, compare: true },
  lensRadius: { type: "number", value: 100, compare: true },
  lensBorderColor: { type: "array", value: [255, 255, 255], compare: true },
  lensBorderRadius: { type: "number", value: 0.02, compare: true },
  maxRequests: { type: "number", value: 10, compare: true },
  onClick: { type: "function", value: null, compare: true },
  transparentColor: { type: "array", value: null, compare: true },
  refinementStrategy: { type: "string", value: null, compare: true },
  excludeBackground: { type: "boolean", value: false, compare: true }
};
var MultiscaleImageLayer = class extends CompositeLayer {
  initializeState() {
    this.state = {
      unprojectLensBounds: [0, 0, 0, 0]
    };
    if (this.context.deck) {
      this.context.deck.eventManager.on({
        pointermove: () => onPointer(this),
        pointerleave: () => onPointer(this),
        wheel: () => onPointer(this)
      });
    }
  }
  renderLayers() {
    const {
      loader,
      selections,
      opacity,
      viewportId,
      onTileError,
      onHover,
      id,
      onClick,
      modelMatrix,
      transparentColor,
      excludeBackground,
      refinementStrategy
    } = this.props;
    const { tileSize, dtype } = loader[0];
    const { unprojectLensBounds } = this.state;
    const getTileData = (_0) => __async(this, [_0], function* ({ x, y, z, signal }) {
      if (!selections || selections.length === 0) {
        return null;
      }
      const resolution = Math.round(-z);
      const getTile = (selection) => {
        const config = { x, y, selection, signal };
        return loader[resolution].getTile(config);
      };
      try {
        const tiles = yield Promise.all(selections.map(getTile));
        const tile = {
          data: tiles.map((d) => d.data),
          width: tiles[0].width,
          height: tiles[0].height
        };
        if (isInterleaved(loader[resolution].shape)) {
          tile.data = tile.data[0];
          if (tile.data.length === tile.width * tile.height * 3) {
            tile.format = GL.RGB;
            tile.dataFormat = GL.RGB;
          }
          return tile;
        }
        return tile;
      } catch (err) {
        if (err === SIGNAL_ABORTED) {
          return null;
        }
        throw err;
      }
    });
    const { height, width } = getImageSize(loader[0]);
    const tiledLayer = new MultiscaleImageLayerBase(this.props, {
      id: `Tiled-Image-${id}`,
      getTileData,
      dtype,
      tileSize,
      zoomOffset: Math.round(Math.log2(modelMatrix ? modelMatrix.getScale()[0] : 1)),
      extent: [0, 0, width, height],
      minZoom: Math.round(-(loader.length - 1)),
      maxZoom: 0,
      refinementStrategy: refinementStrategy || (opacity === 1 ? "best-available" : "no-overlap"),
      updateTriggers: {
        getTileData: [loader, selections]
      },
      onTileError: onTileError || loader[0].onTileError,
      unprojectLensBounds
    });
    const lowestResolution = loader[loader.length - 1];
    const implementsGetRaster = typeof lowestResolution.getRaster === "function";
    const layerModelMatrix = modelMatrix ? modelMatrix.clone() : new Matrix4();
    const baseLayer = implementsGetRaster && !excludeBackground && new ImageLayer(this.props, {
      id: `Background-Image-${id}`,
      loader: lowestResolution,
      modelMatrix: layerModelMatrix.scale(__pow(2, loader.length - 1)),
      visible: opacity === 1 && (!viewportId || this.context.viewport.id === viewportId) && !transparentColor,
      pickable: { type: "boolean", value: true, compare: true },
      onHover,
      onClick,
      interpolation: GL.LINEAR
    });
    const layers = [baseLayer, tiledLayer];
    return layers;
  }
};
MultiscaleImageLayer.layerName = "MultiscaleImageLayer";
MultiscaleImageLayer.defaultProps = defaultProps$4;
var defaultProps$3 = {
  pickable: { type: "boolean", value: true, compare: true },
  loader: {
    type: "object",
    value: {
      getRaster: () => __async(void 0, null, function* () {
        return { data: [], height: 0, width: 0 };
      }),
      getRasterSize: () => ({ height: 0, width: 0 }),
      dtype: "<u2"
    },
    compare: true
  },
  id: { type: "string", value: "", compare: true },
  boundingBox: {
    type: "array",
    value: [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0]
    ],
    compare: true
  },
  boundingBoxColor: { type: "array", value: [255, 0, 0], compare: true },
  boundingBoxOutlineWidth: { type: "number", value: 1, compare: true },
  viewportOutlineColor: { type: "array", value: [255, 190, 0], compare: true },
  viewportOutlineWidth: { type: "number", value: 2, compare: true },
  overviewScale: { type: "number", value: 1, compare: true },
  zoom: { type: "number", value: 1, compare: true }
};
var OverviewLayer = class extends CompositeLayer {
  renderLayers() {
    const {
      loader,
      id,
      zoom,
      boundingBox,
      boundingBoxColor,
      boundingBoxOutlineWidth,
      viewportOutlineColor,
      viewportOutlineWidth,
      overviewScale
    } = this.props;
    const { width, height } = getImageSize(loader[0]);
    const z = loader.length - 1;
    const lowestResolution = loader[z];
    const overview = new ImageLayer(this.props, {
      id: `viewport-${id}`,
      modelMatrix: new Matrix4().scale(__pow(2, z) * overviewScale),
      loader: lowestResolution
    });
    const boundingBoxOutline = new PolygonLayer({
      id: `bounding-box-overview-${id}`,
      coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN,
      data: [boundingBox],
      getPolygon: (f) => f,
      filled: false,
      stroked: true,
      getLineColor: boundingBoxColor,
      getLineWidth: boundingBoxOutlineWidth * __pow(2, zoom)
    });
    const viewportOutline = new PolygonLayer({
      id: `viewport-outline-${id}`,
      coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN,
      data: [
        [
          [0, 0],
          [width * overviewScale, 0],
          [width * overviewScale, height * overviewScale],
          [0, height * overviewScale]
        ]
      ],
      getPolygon: (f) => f,
      filled: false,
      stroked: true,
      getLineColor: viewportOutlineColor,
      getLineWidth: viewportOutlineWidth * __pow(2, zoom)
    });
    const layers = [overview, boundingBoxOutline, viewportOutline];
    return layers;
  }
};
OverviewLayer.layerName = "OverviewLayer";
OverviewLayer.defaultProps = defaultProps$3;
function makeBoundingBox(viewState) {
  const viewport = new OrthographicView().makeViewport({
    viewState,
    height: viewState.height,
    width: viewState.width
  });
  return [
    viewport.unproject([0, 0]),
    viewport.unproject([viewport.width, 0]),
    viewport.unproject([viewport.width, viewport.height]),
    viewport.unproject([0, viewport.height])
  ];
}
function getDefaultInitialViewState(loader, viewSize, zoomBackOff = 0, use3d = false, modelMatrix) {
  const source = Array.isArray(loader) ? loader[0] : loader;
  const { width, height } = getImageSize(source);
  const depth = source.shape[source.labels.indexOf("z")];
  const zoom = Math.log2(Math.min(viewSize.width / width, viewSize.height / height)) - zoomBackOff;
  const physicalSizeScalingMatrix = getPhysicalSizeScalingMatrix(source);
  const loaderInitialViewState = {
    target: (modelMatrix || new Matrix4()).transformPoint((use3d ? physicalSizeScalingMatrix : new Matrix4()).transformPoint([
      width / 2,
      height / 2,
      use3d ? depth / 2 : 0
    ])),
    zoom
  };
  return loaderInitialViewState;
}
function getPosition(boundingBox, position, length) {
  const viewLength = boundingBox[2][0] - boundingBox[0][0];
  switch (position) {
    case "bottom-right": {
      const yCoord = boundingBox[2][1] - (boundingBox[2][1] - boundingBox[0][1]) * length;
      const xLeftCoord = boundingBox[2][0] - viewLength * length;
      return [yCoord, xLeftCoord];
    }
    case "top-right": {
      const yCoord = (boundingBox[2][1] - boundingBox[0][1]) * length;
      const xLeftCoord = boundingBox[2][0] - viewLength * length;
      return [yCoord, xLeftCoord];
    }
    case "top-left": {
      const yCoord = (boundingBox[2][1] - boundingBox[0][1]) * length;
      const xLeftCoord = viewLength * length;
      return [yCoord, xLeftCoord];
    }
    case "bottom-left": {
      const yCoord = boundingBox[2][1] - (boundingBox[2][1] - boundingBox[0][1]) * length;
      const xLeftCoord = viewLength * length;
      return [yCoord, xLeftCoord];
    }
    default: {
      throw new Error(`Position ${position} not found`);
    }
  }
}
var defaultProps$2 = {
  pickable: { type: "boolean", value: true, compare: true },
  viewState: {
    type: "object",
    value: { zoom: 0, target: [0, 0, 0] },
    compare: true
  },
  unit: { type: "string", value: "", compare: true },
  size: { type: "number", value: 1, compare: true },
  position: { type: "string", value: "bottom-right", compare: true },
  length: { type: "number", value: 0.085, compare: true }
};
var ScaleBarLayer = class extends CompositeLayer {
  renderLayers() {
    const { id, unit: unit2, size, position, viewState, length } = this.props;
    const boundingBox = makeBoundingBox(viewState);
    const { zoom } = viewState;
    const viewLength = boundingBox[2][0] - boundingBox[0][0];
    const barLength = viewLength * 0.05;
    const barHeight = Math.max(__pow(2, -zoom + 1.5), (boundingBox[2][1] - boundingBox[0][1]) * 7e-3);
    const numUnits = barLength * size;
    const [yCoord, xLeftCoord] = getPosition(boundingBox, position, length);
    const lengthBar = new LineLayer({
      id: `scale-bar-length-${id}`,
      coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN,
      data: [
        [
          [xLeftCoord, yCoord],
          [xLeftCoord + barLength, yCoord]
        ]
      ],
      getSourcePosition: (d) => d[0],
      getTargetPosition: (d) => d[1],
      getWidth: 2,
      getColor: [220, 220, 220]
    });
    const tickBoundsLeft = new LineLayer({
      id: `scale-bar-height-left-${id}`,
      coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN,
      data: [
        [
          [xLeftCoord, yCoord - barHeight],
          [xLeftCoord, yCoord + barHeight]
        ]
      ],
      getSourcePosition: (d) => d[0],
      getTargetPosition: (d) => d[1],
      getWidth: 2,
      getColor: [220, 220, 220]
    });
    const tickBoundsRight = new LineLayer({
      id: `scale-bar-height-right-${id}`,
      coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN,
      data: [
        [
          [xLeftCoord + barLength, yCoord - barHeight],
          [xLeftCoord + barLength, yCoord + barHeight]
        ]
      ],
      getSourcePosition: (d) => d[0],
      getTargetPosition: (d) => d[1],
      getWidth: 2,
      getColor: [220, 220, 220]
    });
    const textLayer = new TextLayer({
      id: `units-label-layer-${id}`,
      coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN,
      data: [
        {
          text: String(numUnits).slice(0, 5).replace(/\.$/, "") + unit2,
          position: [xLeftCoord + barLength * 0.5, yCoord + barHeight * 4]
        }
      ],
      getColor: [220, 220, 220, 255],
      getSize: 12,
      fontFamily: DEFAULT_FONT_FAMILY,
      sizeUnits: "meters",
      sizeScale: __pow(2, -zoom),
      characterSet: [...unit2.split(""), ...range2(10).map((i) => String(i)), "."]
    });
    return [lengthBar, tickBoundsLeft, tickBoundsRight, textLayer];
  }
};
ScaleBarLayer.layerName = "ScaleBarLayer";
ScaleBarLayer.defaultProps = defaultProps$2;
var vs = '#version 300 es\n#define GLSLIFY 1\n#define SHADER_NAME xr-layer-vertex-shader\nin vec3 positions;uniform vec3 eye_pos;uniform mat4 proj;uniform mat4 model;uniform mat4 view;uniform mat4 scale;uniform mat4 resolution;out vec3 vray_dir;flat out vec3 transformed_eye;void main(){gl_Position=proj*view*model*scale*resolution*vec4(positions,1.);/*This first diagram is a skewed volume(i.e a "shear" model matrix applied)top down with the eye marked as #,all in world space^___|__\\|\\\\|\\|____|||\n#\nThis next diagram shows the volume after the inverse model matrix has placed it back in model coordinates,but the eye still in world space.^___|___|||||||__|__||||\n#\nFinally,we apply the inverse model matrix transformation to the eye as well to bring it too into world space.Notice that the ray here matches the "voxels" through which the first ray also passes,as desired.^____/__|/||/||/____|///\n#\n*/transformed_eye=(inverse(resolution)*inverse(scale)*inverse(model)*(vec4(eye_pos,1.))).xyz;vray_dir=positions-transformed_eye;}';
var fs$1 = "#version 300 es\nprecision highp int;precision highp float;precision highp SAMPLER_TYPE;\n#define GLSLIFY 1\nuniform highp SAMPLER_TYPE volume0;uniform highp SAMPLER_TYPE volume1;uniform highp SAMPLER_TYPE volume2;uniform highp SAMPLER_TYPE volume3;uniform highp SAMPLER_TYPE volume4;uniform highp SAMPLER_TYPE volume5;uniform vec3 scaledDimensions;uniform mat4 scale;uniform vec3 normals[NUM_PLANES];uniform float distances[NUM_PLANES];uniform vec2 contrastLimits[6];uniform vec3 colors[6];uniform vec2 xSlice;uniform vec2 ySlice;uniform vec2 zSlice;in vec3 vray_dir;flat in vec3 transformed_eye;out vec4 color;vec2 intersect_box(vec3 orig,vec3 dir){vec3 box_min=vec3(xSlice[0],ySlice[0],zSlice[0]);vec3 box_max=vec3(xSlice[1],ySlice[1],zSlice[1]);vec3 inv_dir=1./dir;vec3 tmin_tmp=(box_min-orig)*inv_dir;vec3 tmax_tmp=(box_max-orig)*inv_dir;vec3 tmin=min(tmin_tmp,tmax_tmp);vec3 tmax=max(tmin_tmp,tmax_tmp);float t0=max(tmin.x,max(tmin.y,tmin.z));float t1=min(tmax.x,min(tmax.y,tmax.z));vec2 val=vec2(t0,t1);return val;}float linear_to_srgb(float x){if(x<=0.0031308f){return 12.92f*x;}return 1.055f*pow(x,1.f/2.4f)-0.055f;}float wang_hash(int seed){seed=(seed ^ 61)^(seed>>16);seed*=9;seed=seed ^(seed>>4);seed*=0x27d4eb2d;seed=seed ^(seed>>15);return float(seed % 2147483647)/float(2147483647);}void main(void){vec3 ray_dir=normalize(vray_dir);vec2 t_hit=intersect_box(transformed_eye,ray_dir);if(t_hit.x>t_hit.y){discard;}t_hit.x=max(t_hit.x,0.);vec3 dt_vec=1./(scale*vec4(abs(ray_dir),1.)).xyz;float dt=1.*min(dt_vec.x,min(dt_vec.y,dt_vec.z));float offset=wang_hash(int(gl_FragCoord.x+640.*gl_FragCoord.y));vec3 p=transformed_eye+(t_hit.x+offset*dt)*ray_dir;_BEFORE_RENDERfor(float t=t_hit.x;t<t_hit.y;t+=dt){float canShow=1.;for(int i=0;i<NUM_PLANES;i+=1){canShow*=max(0.,sign(dot(normals[i],p)+distances[i]));}float canShowXCoordinate=max(p.x-0.,0.)*max(1.-p.x,0.);float canShowYCoordinate=max(p.y-0.,0.)*max(1.-p.y,0.);float canShowZCoordinate=max(p.z-0.,0.)*max(1.-p.z,0.);float canShowCoordinate=float(ceil(canShowXCoordinate*canShowYCoordinate*canShowZCoordinate));canShow=canShowCoordinate*canShow;float intensityValue0=canShow*sample_and_apply_contrast_limits(volume0,p,contrastLimits[0]);float intensityValue1=canShow*sample_and_apply_contrast_limits(volume1,p,contrastLimits[1]);float intensityValue2=canShow*sample_and_apply_contrast_limits(volume2,p,contrastLimits[2]);float intensityValue3=canShow*sample_and_apply_contrast_limits(volume3,p,contrastLimits[3]);float intensityValue4=canShow*sample_and_apply_contrast_limits(volume4,p,contrastLimits[4]);float intensityValue5=canShow*sample_and_apply_contrast_limits(volume5,p,contrastLimits[5]);_RENDERp+=ray_dir*dt;}_AFTER_RENDERcolor.r=linear_to_srgb(color.r);color.g=linear_to_srgb(color.g);color.b=linear_to_srgb(color.b);}";
var fs = "#define GLSLIFY 1\nvec4 jet(float x_17){const float e0=0.0;const vec4 v0=vec4(0,0,0.5137254901960784,1);const float e1=0.125;const vec4 v1=vec4(0,0.23529411764705882,0.6666666666666666,1);const float e2=0.375;const vec4 v2=vec4(0.0196078431372549,1,1,1);const float e3=0.625;const vec4 v3=vec4(1,1,0,1);const float e4=0.875;const vec4 v4=vec4(0.9803921568627451,0,0,1);const float e5=1.0;const vec4 v5=vec4(0.5019607843137255,0,0,1);float a0=smoothstep(e0,e1,x_17);float a1=smoothstep(e1,e2,x_17);float a2=smoothstep(e2,e3,x_17);float a3=smoothstep(e3,e4,x_17);float a4=smoothstep(e4,e5,x_17);return max(mix(v0,v1,a0)*step(e0,x_17)*step(x_17,e1),max(mix(v1,v2,a1)*step(e1,x_17)*step(x_17,e2),max(mix(v2,v3,a2)*step(e2,x_17)*step(x_17,e3),max(mix(v3,v4,a3)*step(e3,x_17)*step(x_17,e4),mix(v4,v5,a4)*step(e4,x_17)*step(x_17,e5)))));}vec4 hsv(float x_18){const float e0=0.0;const vec4 v0=vec4(1,0,0,1);const float e1=0.169;const vec4 v1=vec4(0.9921568627450981,1,0.00784313725490196,1);const float e2=0.173;const vec4 v2=vec4(0.9686274509803922,1,0.00784313725490196,1);const float e3=0.337;const vec4 v3=vec4(0,0.9882352941176471,0.01568627450980392,1);const float e4=0.341;const vec4 v4=vec4(0,0.9882352941176471,0.0392156862745098,1);const float e5=0.506;const vec4 v5=vec4(0.00392156862745098,0.9764705882352941,1,1);const float e6=0.671;const vec4 v6=vec4(0.00784313725490196,0,0.9921568627450981,1);const float e7=0.675;const vec4 v7=vec4(0.03137254901960784,0,0.9921568627450981,1);const float e8=0.839;const vec4 v8=vec4(1,0,0.984313725490196,1);const float e9=0.843;const vec4 v9=vec4(1,0,0.9607843137254902,1);const float e10=1.0;const vec4 v10=vec4(1,0,0.023529411764705882,1);float a0=smoothstep(e0,e1,x_18);float a1=smoothstep(e1,e2,x_18);float a2=smoothstep(e2,e3,x_18);float a3=smoothstep(e3,e4,x_18);float a4=smoothstep(e4,e5,x_18);float a5=smoothstep(e5,e6,x_18);float a6=smoothstep(e6,e7,x_18);float a7=smoothstep(e7,e8,x_18);float a8=smoothstep(e8,e9,x_18);float a9=smoothstep(e9,e10,x_18);return max(mix(v0,v1,a0)*step(e0,x_18)*step(x_18,e1),max(mix(v1,v2,a1)*step(e1,x_18)*step(x_18,e2),max(mix(v2,v3,a2)*step(e2,x_18)*step(x_18,e3),max(mix(v3,v4,a3)*step(e3,x_18)*step(x_18,e4),max(mix(v4,v5,a4)*step(e4,x_18)*step(x_18,e5),max(mix(v5,v6,a5)*step(e5,x_18)*step(x_18,e6),max(mix(v6,v7,a6)*step(e6,x_18)*step(x_18,e7),max(mix(v7,v8,a7)*step(e7,x_18)*step(x_18,e8),max(mix(v8,v9,a8)*step(e8,x_18)*step(x_18,e9),mix(v9,v10,a9)*step(e9,x_18)*step(x_18,e10))))))))));}vec4 hot(float x_13){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.3;const vec4 v1=vec4(0.9019607843137255,0,0,1);const float e2=0.6;const vec4 v2=vec4(1,0.8235294117647058,0,1);const float e3=1.0;const vec4 v3=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_13);float a1=smoothstep(e1,e2,x_13);float a2=smoothstep(e2,e3,x_13);return max(mix(v0,v1,a0)*step(e0,x_13)*step(x_13,e1),max(mix(v1,v2,a1)*step(e1,x_13)*step(x_13,e2),mix(v2,v3,a2)*step(e2,x_13)*step(x_13,e3)));}vec4 cool(float x_24){const float e0=0.0;const vec4 v0=vec4(0.49019607843137253,0,0.7019607843137254,1);const float e1=0.13;const vec4 v1=vec4(0.4549019607843137,0,0.8549019607843137,1);const float e2=0.25;const vec4 v2=vec4(0.3843137254901961,0.2901960784313726,0.9294117647058824,1);const float e3=0.38;const vec4 v3=vec4(0.26666666666666666,0.5725490196078431,0.9058823529411765,1);const float e4=0.5;const vec4 v4=vec4(0,0.8,0.7725490196078432,1);const float e5=0.63;const vec4 v5=vec4(0,0.9686274509803922,0.5725490196078431,1);const float e6=0.75;const vec4 v6=vec4(0,1,0.34509803921568627,1);const float e7=0.88;const vec4 v7=vec4(0.1568627450980392,1,0.03137254901960784,1);const float e8=1.0;const vec4 v8=vec4(0.5764705882352941,1,0,1);float a0=smoothstep(e0,e1,x_24);float a1=smoothstep(e1,e2,x_24);float a2=smoothstep(e2,e3,x_24);float a3=smoothstep(e3,e4,x_24);float a4=smoothstep(e4,e5,x_24);float a5=smoothstep(e5,e6,x_24);float a6=smoothstep(e6,e7,x_24);float a7=smoothstep(e7,e8,x_24);return max(mix(v0,v1,a0)*step(e0,x_24)*step(x_24,e1),max(mix(v1,v2,a1)*step(e1,x_24)*step(x_24,e2),max(mix(v2,v3,a2)*step(e2,x_24)*step(x_24,e3),max(mix(v3,v4,a3)*step(e3,x_24)*step(x_24,e4),max(mix(v4,v5,a4)*step(e4,x_24)*step(x_24,e5),max(mix(v5,v6,a5)*step(e5,x_24)*step(x_24,e6),max(mix(v6,v7,a6)*step(e6,x_24)*step(x_24,e7),mix(v7,v8,a7)*step(e7,x_24)*step(x_24,e8))))))));}vec4 spring(float x_5){const float e0=0.0;const vec4 v0=vec4(1,0,1,1);const float e1=1.0;const vec4 v1=vec4(1,1,0,1);float a0=smoothstep(e0,e1,x_5);return mix(v0,v1,a0)*step(e0,x_5)*step(x_5,e1);}vec4 summer(float x_12){const float e0=0.0;const vec4 v0=vec4(0,0.5019607843137255,0.4,1);const float e1=1.0;const vec4 v1=vec4(1,1,0.4,1);float a0=smoothstep(e0,e1,x_12);return mix(v0,v1,a0)*step(e0,x_12)*step(x_12,e1);}vec4 autumn(float x_25){const float e0=0.0;const vec4 v0=vec4(1,0,0,1);const float e1=1.0;const vec4 v1=vec4(1,1,0,1);float a0=smoothstep(e0,e1,x_25);return mix(v0,v1,a0)*step(e0,x_25)*step(x_25,e1);}vec4 winter(float x_16){const float e0=0.0;const vec4 v0=vec4(0,0,1,1);const float e1=1.0;const vec4 v1=vec4(0,1,0.5019607843137255,1);float a0=smoothstep(e0,e1,x_16);return mix(v0,v1,a0)*step(e0,x_16)*step(x_16,e1);}vec4 bone(float x_15){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.376;const vec4 v1=vec4(0.32941176470588235,0.32941176470588235,0.4549019607843137,1);const float e2=0.753;const vec4 v2=vec4(0.6627450980392157,0.7843137254901961,0.7843137254901961,1);const float e3=1.0;const vec4 v3=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_15);float a1=smoothstep(e1,e2,x_15);float a2=smoothstep(e2,e3,x_15);return max(mix(v0,v1,a0)*step(e0,x_15)*step(x_15,e1),max(mix(v1,v2,a1)*step(e1,x_15)*step(x_15,e2),mix(v2,v3,a2)*step(e2,x_15)*step(x_15,e3)));}vec4 copper(float x_10){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.804;const vec4 v1=vec4(1,0.6274509803921569,0.4,1);const float e2=1.0;const vec4 v2=vec4(1,0.7803921568627451,0.4980392156862745,1);float a0=smoothstep(e0,e1,x_10);float a1=smoothstep(e1,e2,x_10);return max(mix(v0,v1,a0)*step(e0,x_10)*step(x_10,e1),mix(v1,v2,a1)*step(e1,x_10)*step(x_10,e2));}vec4 greys(float x_4){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=1.0;const vec4 v1=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_4);return mix(v0,v1,a0)*step(e0,x_4)*step(x_4,e1);}vec4 yignbu(float x_32){const float e0=0.0;const vec4 v0=vec4(0.03137254901960784,0.11372549019607843,0.34509803921568627,1);const float e1=0.125;const vec4 v1=vec4(0.1450980392156863,0.20392156862745098,0.5803921568627451,1);const float e2=0.25;const vec4 v2=vec4(0.13333333333333333,0.3686274509803922,0.6588235294117647,1);const float e3=0.375;const vec4 v3=vec4(0.11372549019607843,0.5686274509803921,0.7529411764705882,1);const float e4=0.5;const vec4 v4=vec4(0.2549019607843137,0.7137254901960784,0.7686274509803922,1);const float e5=0.625;const vec4 v5=vec4(0.4980392156862745,0.803921568627451,0.7333333333333333,1);const float e6=0.75;const vec4 v6=vec4(0.7803921568627451,0.9137254901960784,0.7058823529411765,1);const float e7=0.875;const vec4 v7=vec4(0.9294117647058824,0.9725490196078431,0.8509803921568627,1);const float e8=1.0;const vec4 v8=vec4(1,1,0.8509803921568627,1);float a0=smoothstep(e0,e1,x_32);float a1=smoothstep(e1,e2,x_32);float a2=smoothstep(e2,e3,x_32);float a3=smoothstep(e3,e4,x_32);float a4=smoothstep(e4,e5,x_32);float a5=smoothstep(e5,e6,x_32);float a6=smoothstep(e6,e7,x_32);float a7=smoothstep(e7,e8,x_32);return max(mix(v0,v1,a0)*step(e0,x_32)*step(x_32,e1),max(mix(v1,v2,a1)*step(e1,x_32)*step(x_32,e2),max(mix(v2,v3,a2)*step(e2,x_32)*step(x_32,e3),max(mix(v3,v4,a3)*step(e3,x_32)*step(x_32,e4),max(mix(v4,v5,a4)*step(e4,x_32)*step(x_32,e5),max(mix(v5,v6,a5)*step(e5,x_32)*step(x_32,e6),max(mix(v6,v7,a6)*step(e6,x_32)*step(x_32,e7),mix(v7,v8,a7)*step(e7,x_32)*step(x_32,e8))))))));}vec4 greens(float x_34){const float e0=0.0;const vec4 v0=vec4(0,0.26666666666666666,0.10588235294117647,1);const float e1=0.125;const vec4 v1=vec4(0,0.42745098039215684,0.17254901960784313,1);const float e2=0.25;const vec4 v2=vec4(0.13725490196078433,0.5450980392156862,0.27058823529411763,1);const float e3=0.375;const vec4 v3=vec4(0.2549019607843137,0.6705882352941176,0.36470588235294116,1);const float e4=0.5;const vec4 v4=vec4(0.4549019607843137,0.7686274509803922,0.4627450980392157,1);const float e5=0.625;const vec4 v5=vec4(0.6313725490196078,0.8509803921568627,0.6078431372549019,1);const float e6=0.75;const vec4 v6=vec4(0.7803921568627451,0.9137254901960784,0.7529411764705882,1);const float e7=0.875;const vec4 v7=vec4(0.8980392156862745,0.9607843137254902,0.8784313725490196,1);const float e8=1.0;const vec4 v8=vec4(0.9686274509803922,0.9882352941176471,0.9607843137254902,1);float a0=smoothstep(e0,e1,x_34);float a1=smoothstep(e1,e2,x_34);float a2=smoothstep(e2,e3,x_34);float a3=smoothstep(e3,e4,x_34);float a4=smoothstep(e4,e5,x_34);float a5=smoothstep(e5,e6,x_34);float a6=smoothstep(e6,e7,x_34);float a7=smoothstep(e7,e8,x_34);return max(mix(v0,v1,a0)*step(e0,x_34)*step(x_34,e1),max(mix(v1,v2,a1)*step(e1,x_34)*step(x_34,e2),max(mix(v2,v3,a2)*step(e2,x_34)*step(x_34,e3),max(mix(v3,v4,a3)*step(e3,x_34)*step(x_34,e4),max(mix(v4,v5,a4)*step(e4,x_34)*step(x_34,e5),max(mix(v5,v6,a5)*step(e5,x_34)*step(x_34,e6),max(mix(v6,v7,a6)*step(e6,x_34)*step(x_34,e7),mix(v7,v8,a7)*step(e7,x_34)*step(x_34,e8))))))));}vec4 yiorrd(float x_41){const float e0=0.0;const vec4 v0=vec4(0.5019607843137255,0,0.14901960784313725,1);const float e1=0.125;const vec4 v1=vec4(0.7411764705882353,0,0.14901960784313725,1);const float e2=0.25;const vec4 v2=vec4(0.8901960784313725,0.10196078431372549,0.10980392156862745,1);const float e3=0.375;const vec4 v3=vec4(0.9882352941176471,0.3058823529411765,0.16470588235294117,1);const float e4=0.5;const vec4 v4=vec4(0.9921568627450981,0.5529411764705883,0.23529411764705882,1);const float e5=0.625;const vec4 v5=vec4(0.996078431372549,0.6980392156862745,0.2980392156862745,1);const float e6=0.75;const vec4 v6=vec4(0.996078431372549,0.8509803921568627,0.4627450980392157,1);const float e7=0.875;const vec4 v7=vec4(1,0.9294117647058824,0.6274509803921569,1);const float e8=1.0;const vec4 v8=vec4(1,1,0.8,1);float a0=smoothstep(e0,e1,x_41);float a1=smoothstep(e1,e2,x_41);float a2=smoothstep(e2,e3,x_41);float a3=smoothstep(e3,e4,x_41);float a4=smoothstep(e4,e5,x_41);float a5=smoothstep(e5,e6,x_41);float a6=smoothstep(e6,e7,x_41);float a7=smoothstep(e7,e8,x_41);return max(mix(v0,v1,a0)*step(e0,x_41)*step(x_41,e1),max(mix(v1,v2,a1)*step(e1,x_41)*step(x_41,e2),max(mix(v2,v3,a2)*step(e2,x_41)*step(x_41,e3),max(mix(v3,v4,a3)*step(e3,x_41)*step(x_41,e4),max(mix(v4,v5,a4)*step(e4,x_41)*step(x_41,e5),max(mix(v5,v6,a5)*step(e5,x_41)*step(x_41,e6),max(mix(v6,v7,a6)*step(e6,x_41)*step(x_41,e7),mix(v7,v8,a7)*step(e7,x_41)*step(x_41,e8))))))));}vec4 bluered(float x_23){const float e0=0.0;const vec4 v0=vec4(0,0,1,1);const float e1=1.0;const vec4 v1=vec4(1,0,0,1);float a0=smoothstep(e0,e1,x_23);return mix(v0,v1,a0)*step(e0,x_23)*step(x_23,e1);}vec4 rdbu(float x_1){const float e0=0.0;const vec4 v0=vec4(0.0196078431372549,0.0392156862745098,0.6745098039215687,1);const float e1=0.35;const vec4 v1=vec4(0.41568627450980394,0.5372549019607843,0.9686274509803922,1);const float e2=0.5;const vec4 v2=vec4(0.7450980392156863,0.7450980392156863,0.7450980392156863,1);const float e3=0.6;const vec4 v3=vec4(0.8627450980392157,0.6666666666666666,0.5176470588235295,1);const float e4=0.7;const vec4 v4=vec4(0.9019607843137255,0.5686274509803921,0.35294117647058826,1);const float e5=1.0;const vec4 v5=vec4(0.6980392156862745,0.0392156862745098,0.10980392156862745,1);float a0=smoothstep(e0,e1,x_1);float a1=smoothstep(e1,e2,x_1);float a2=smoothstep(e2,e3,x_1);float a3=smoothstep(e3,e4,x_1);float a4=smoothstep(e4,e5,x_1);return max(mix(v0,v1,a0)*step(e0,x_1)*step(x_1,e1),max(mix(v1,v2,a1)*step(e1,x_1)*step(x_1,e2),max(mix(v2,v3,a2)*step(e2,x_1)*step(x_1,e3),max(mix(v3,v4,a3)*step(e3,x_1)*step(x_1,e4),mix(v4,v5,a4)*step(e4,x_1)*step(x_1,e5)))));}vec4 picnic(float x_42){const float e0=0.0;const vec4 v0=vec4(0,0,1,1);const float e1=0.1;const vec4 v1=vec4(0.2,0.6,1,1);const float e2=0.2;const vec4 v2=vec4(0.4,0.8,1,1);const float e3=0.3;const vec4 v3=vec4(0.6,0.8,1,1);const float e4=0.4;const vec4 v4=vec4(0.8,0.8,1,1);const float e5=0.5;const vec4 v5=vec4(1,1,1,1);const float e6=0.6;const vec4 v6=vec4(1,0.8,1,1);const float e7=0.7;const vec4 v7=vec4(1,0.6,1,1);const float e8=0.8;const vec4 v8=vec4(1,0.4,0.8,1);const float e9=0.9;const vec4 v9=vec4(1,0.4,0.4,1);const float e10=1.0;const vec4 v10=vec4(1,0,0,1);float a0=smoothstep(e0,e1,x_42);float a1=smoothstep(e1,e2,x_42);float a2=smoothstep(e2,e3,x_42);float a3=smoothstep(e3,e4,x_42);float a4=smoothstep(e4,e5,x_42);float a5=smoothstep(e5,e6,x_42);float a6=smoothstep(e6,e7,x_42);float a7=smoothstep(e7,e8,x_42);float a8=smoothstep(e8,e9,x_42);float a9=smoothstep(e9,e10,x_42);return max(mix(v0,v1,a0)*step(e0,x_42)*step(x_42,e1),max(mix(v1,v2,a1)*step(e1,x_42)*step(x_42,e2),max(mix(v2,v3,a2)*step(e2,x_42)*step(x_42,e3),max(mix(v3,v4,a3)*step(e3,x_42)*step(x_42,e4),max(mix(v4,v5,a4)*step(e4,x_42)*step(x_42,e5),max(mix(v5,v6,a5)*step(e5,x_42)*step(x_42,e6),max(mix(v6,v7,a6)*step(e6,x_42)*step(x_42,e7),max(mix(v7,v8,a7)*step(e7,x_42)*step(x_42,e8),max(mix(v8,v9,a8)*step(e8,x_42)*step(x_42,e9),mix(v9,v10,a9)*step(e9,x_42)*step(x_42,e10))))))))));}vec4 rainbow(float x_31){const float e0=0.0;const vec4 v0=vec4(0.5882352941176471,0,0.35294117647058826,1);const float e1=0.125;const vec4 v1=vec4(0,0,0.7843137254901961,1);const float e2=0.25;const vec4 v2=vec4(0,0.09803921568627451,1,1);const float e3=0.375;const vec4 v3=vec4(0,0.596078431372549,1,1);const float e4=0.5;const vec4 v4=vec4(0.17254901960784313,1,0.5882352941176471,1);const float e5=0.625;const vec4 v5=vec4(0.592156862745098,1,0,1);const float e6=0.75;const vec4 v6=vec4(1,0.9176470588235294,0,1);const float e7=0.875;const vec4 v7=vec4(1,0.43529411764705883,0,1);const float e8=1.0;const vec4 v8=vec4(1,0,0,1);float a0=smoothstep(e0,e1,x_31);float a1=smoothstep(e1,e2,x_31);float a2=smoothstep(e2,e3,x_31);float a3=smoothstep(e3,e4,x_31);float a4=smoothstep(e4,e5,x_31);float a5=smoothstep(e5,e6,x_31);float a6=smoothstep(e6,e7,x_31);float a7=smoothstep(e7,e8,x_31);return max(mix(v0,v1,a0)*step(e0,x_31)*step(x_31,e1),max(mix(v1,v2,a1)*step(e1,x_31)*step(x_31,e2),max(mix(v2,v3,a2)*step(e2,x_31)*step(x_31,e3),max(mix(v3,v4,a3)*step(e3,x_31)*step(x_31,e4),max(mix(v4,v5,a4)*step(e4,x_31)*step(x_31,e5),max(mix(v5,v6,a5)*step(e5,x_31)*step(x_31,e6),max(mix(v6,v7,a6)*step(e6,x_31)*step(x_31,e7),mix(v7,v8,a7)*step(e7,x_31)*step(x_31,e8))))))));}vec4 portland(float x_21){const float e0=0.0;const vec4 v0=vec4(0.047058823529411764,0.2,0.5137254901960784,1);const float e1=0.25;const vec4 v1=vec4(0.0392156862745098,0.5333333333333333,0.7294117647058823,1);const float e2=0.5;const vec4 v2=vec4(0.9490196078431372,0.8274509803921568,0.2196078431372549,1);const float e3=0.75;const vec4 v3=vec4(0.9490196078431372,0.5607843137254902,0.2196078431372549,1);const float e4=1.0;const vec4 v4=vec4(0.8509803921568627,0.11764705882352941,0.11764705882352941,1);float a0=smoothstep(e0,e1,x_21);float a1=smoothstep(e1,e2,x_21);float a2=smoothstep(e2,e3,x_21);float a3=smoothstep(e3,e4,x_21);return max(mix(v0,v1,a0)*step(e0,x_21)*step(x_21,e1),max(mix(v1,v2,a1)*step(e1,x_21)*step(x_21,e2),max(mix(v2,v3,a2)*step(e2,x_21)*step(x_21,e3),mix(v3,v4,a3)*step(e3,x_21)*step(x_21,e4))));}vec4 blackbody(float x_38){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.2;const vec4 v1=vec4(0.9019607843137255,0,0,1);const float e2=0.4;const vec4 v2=vec4(0.9019607843137255,0.8235294117647058,0,1);const float e3=0.7;const vec4 v3=vec4(1,1,1,1);const float e4=1.0;const vec4 v4=vec4(0.6274509803921569,0.7843137254901961,1,1);float a0=smoothstep(e0,e1,x_38);float a1=smoothstep(e1,e2,x_38);float a2=smoothstep(e2,e3,x_38);float a3=smoothstep(e3,e4,x_38);return max(mix(v0,v1,a0)*step(e0,x_38)*step(x_38,e1),max(mix(v1,v2,a1)*step(e1,x_38)*step(x_38,e2),max(mix(v2,v3,a2)*step(e2,x_38)*step(x_38,e3),mix(v3,v4,a3)*step(e3,x_38)*step(x_38,e4))));}vec4 earth(float x_29){const float e0=0.0;const vec4 v0=vec4(0,0,0.5098039215686274,1);const float e1=0.1;const vec4 v1=vec4(0,0.7058823529411765,0.7058823529411765,1);const float e2=0.2;const vec4 v2=vec4(0.1568627450980392,0.8235294117647058,0.1568627450980392,1);const float e3=0.4;const vec4 v3=vec4(0.9019607843137255,0.9019607843137255,0.19607843137254902,1);const float e4=0.6;const vec4 v4=vec4(0.47058823529411764,0.27450980392156865,0.0784313725490196,1);const float e5=1.0;const vec4 v5=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_29);float a1=smoothstep(e1,e2,x_29);float a2=smoothstep(e2,e3,x_29);float a3=smoothstep(e3,e4,x_29);float a4=smoothstep(e4,e5,x_29);return max(mix(v0,v1,a0)*step(e0,x_29)*step(x_29,e1),max(mix(v1,v2,a1)*step(e1,x_29)*step(x_29,e2),max(mix(v2,v3,a2)*step(e2,x_29)*step(x_29,e3),max(mix(v3,v4,a3)*step(e3,x_29)*step(x_29,e4),mix(v4,v5,a4)*step(e4,x_29)*step(x_29,e5)))));}vec4 electric(float x_9){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.15;const vec4 v1=vec4(0.11764705882352941,0,0.39215686274509803,1);const float e2=0.4;const vec4 v2=vec4(0.47058823529411764,0,0.39215686274509803,1);const float e3=0.6;const vec4 v3=vec4(0.6274509803921569,0.35294117647058826,0,1);const float e4=0.8;const vec4 v4=vec4(0.9019607843137255,0.7843137254901961,0,1);const float e5=1.0;const vec4 v5=vec4(1,0.9803921568627451,0.8627450980392157,1);float a0=smoothstep(e0,e1,x_9);float a1=smoothstep(e1,e2,x_9);float a2=smoothstep(e2,e3,x_9);float a3=smoothstep(e3,e4,x_9);float a4=smoothstep(e4,e5,x_9);return max(mix(v0,v1,a0)*step(e0,x_9)*step(x_9,e1),max(mix(v1,v2,a1)*step(e1,x_9)*step(x_9,e2),max(mix(v2,v3,a2)*step(e2,x_9)*step(x_9,e3),max(mix(v3,v4,a3)*step(e3,x_9)*step(x_9,e4),mix(v4,v5,a4)*step(e4,x_9)*step(x_9,e5)))));}vec4 alpha(float x_0){const float e0=0.0;const vec4 v0=vec4(1,1,1,0);const float e1=1.0;const vec4 v1=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_0);return mix(v0,v1,a0)*step(e0,x_0)*step(x_0,e1);}vec4 viridis(float x_22){const float e0=0.0;const vec4 v0=vec4(0.26666666666666666,0.00392156862745098,0.32941176470588235,1);const float e1=0.13;const vec4 v1=vec4(0.2784313725490196,0.17254901960784313,0.47843137254901963,1);const float e2=0.25;const vec4 v2=vec4(0.23137254901960785,0.3176470588235294,0.5450980392156862,1);const float e3=0.38;const vec4 v3=vec4(0.17254901960784313,0.44313725490196076,0.5568627450980392,1);const float e4=0.5;const vec4 v4=vec4(0.12941176470588237,0.5647058823529412,0.5529411764705883,1);const float e5=0.63;const vec4 v5=vec4(0.15294117647058825,0.6784313725490196,0.5058823529411764,1);const float e6=0.75;const vec4 v6=vec4(0.3607843137254902,0.7843137254901961,0.38823529411764707,1);const float e7=0.88;const vec4 v7=vec4(0.6666666666666666,0.8627450980392157,0.19607843137254902,1);const float e8=1.0;const vec4 v8=vec4(0.9921568627450981,0.9058823529411765,0.1450980392156863,1);float a0=smoothstep(e0,e1,x_22);float a1=smoothstep(e1,e2,x_22);float a2=smoothstep(e2,e3,x_22);float a3=smoothstep(e3,e4,x_22);float a4=smoothstep(e4,e5,x_22);float a5=smoothstep(e5,e6,x_22);float a6=smoothstep(e6,e7,x_22);float a7=smoothstep(e7,e8,x_22);return max(mix(v0,v1,a0)*step(e0,x_22)*step(x_22,e1),max(mix(v1,v2,a1)*step(e1,x_22)*step(x_22,e2),max(mix(v2,v3,a2)*step(e2,x_22)*step(x_22,e3),max(mix(v3,v4,a3)*step(e3,x_22)*step(x_22,e4),max(mix(v4,v5,a4)*step(e4,x_22)*step(x_22,e5),max(mix(v5,v6,a5)*step(e5,x_22)*step(x_22,e6),max(mix(v6,v7,a6)*step(e6,x_22)*step(x_22,e7),mix(v7,v8,a7)*step(e7,x_22)*step(x_22,e8))))))));}vec4 inferno(float x_30){const float e0=0.0;const vec4 v0=vec4(0,0,0.01568627450980392,1);const float e1=0.13;const vec4 v1=vec4(0.12156862745098039,0.047058823529411764,0.2823529411764706,1);const float e2=0.25;const vec4 v2=vec4(0.3333333333333333,0.058823529411764705,0.42745098039215684,1);const float e3=0.38;const vec4 v3=vec4(0.5333333333333333,0.13333333333333333,0.41568627450980394,1);const float e4=0.5;const vec4 v4=vec4(0.7294117647058823,0.21176470588235294,0.3333333333333333,1);const float e5=0.63;const vec4 v5=vec4(0.8901960784313725,0.34901960784313724,0.2,1);const float e6=0.75;const vec4 v6=vec4(0.9764705882352941,0.5490196078431373,0.0392156862745098,1);const float e7=0.88;const vec4 v7=vec4(0.9764705882352941,0.788235294117647,0.19607843137254902,1);const float e8=1.0;const vec4 v8=vec4(0.9882352941176471,1,0.6431372549019608,1);float a0=smoothstep(e0,e1,x_30);float a1=smoothstep(e1,e2,x_30);float a2=smoothstep(e2,e3,x_30);float a3=smoothstep(e3,e4,x_30);float a4=smoothstep(e4,e5,x_30);float a5=smoothstep(e5,e6,x_30);float a6=smoothstep(e6,e7,x_30);float a7=smoothstep(e7,e8,x_30);return max(mix(v0,v1,a0)*step(e0,x_30)*step(x_30,e1),max(mix(v1,v2,a1)*step(e1,x_30)*step(x_30,e2),max(mix(v2,v3,a2)*step(e2,x_30)*step(x_30,e3),max(mix(v3,v4,a3)*step(e3,x_30)*step(x_30,e4),max(mix(v4,v5,a4)*step(e4,x_30)*step(x_30,e5),max(mix(v5,v6,a5)*step(e5,x_30)*step(x_30,e6),max(mix(v6,v7,a6)*step(e6,x_30)*step(x_30,e7),mix(v7,v8,a7)*step(e7,x_30)*step(x_30,e8))))))));}vec4 magma(float x_33){const float e0=0.0;const vec4 v0=vec4(0,0,0.01568627450980392,1);const float e1=0.13;const vec4 v1=vec4(0.10980392156862745,0.06274509803921569,0.26666666666666666,1);const float e2=0.25;const vec4 v2=vec4(0.30980392156862746,0.07058823529411765,0.4823529411764706,1);const float e3=0.38;const vec4 v3=vec4(0.5058823529411764,0.1450980392156863,0.5058823529411764,1);const float e4=0.5;const vec4 v4=vec4(0.7098039215686275,0.21176470588235294,0.47843137254901963,1);const float e5=0.63;const vec4 v5=vec4(0.8980392156862745,0.3137254901960784,0.39215686274509803,1);const float e6=0.75;const vec4 v6=vec4(0.984313725490196,0.5294117647058824,0.3803921568627451,1);const float e7=0.88;const vec4 v7=vec4(0.996078431372549,0.7607843137254902,0.5294117647058824,1);const float e8=1.0;const vec4 v8=vec4(0.9882352941176471,0.9921568627450981,0.7490196078431373,1);float a0=smoothstep(e0,e1,x_33);float a1=smoothstep(e1,e2,x_33);float a2=smoothstep(e2,e3,x_33);float a3=smoothstep(e3,e4,x_33);float a4=smoothstep(e4,e5,x_33);float a5=smoothstep(e5,e6,x_33);float a6=smoothstep(e6,e7,x_33);float a7=smoothstep(e7,e8,x_33);return max(mix(v0,v1,a0)*step(e0,x_33)*step(x_33,e1),max(mix(v1,v2,a1)*step(e1,x_33)*step(x_33,e2),max(mix(v2,v3,a2)*step(e2,x_33)*step(x_33,e3),max(mix(v3,v4,a3)*step(e3,x_33)*step(x_33,e4),max(mix(v4,v5,a4)*step(e4,x_33)*step(x_33,e5),max(mix(v5,v6,a5)*step(e5,x_33)*step(x_33,e6),max(mix(v6,v7,a6)*step(e6,x_33)*step(x_33,e7),mix(v7,v8,a7)*step(e7,x_33)*step(x_33,e8))))))));}vec4 plasma(float x_3){const float e0=0.0;const vec4 v0=vec4(0.050980392156862744,0.03137254901960784,0.5294117647058824,1);const float e1=0.13;const vec4 v1=vec4(0.29411764705882354,0.011764705882352941,0.6313725490196078,1);const float e2=0.25;const vec4 v2=vec4(0.49019607843137253,0.011764705882352941,0.6588235294117647,1);const float e3=0.38;const vec4 v3=vec4(0.6588235294117647,0.13333333333333333,0.5882352941176471,1);const float e4=0.5;const vec4 v4=vec4(0.796078431372549,0.27450980392156865,0.4745098039215686,1);const float e5=0.63;const vec4 v5=vec4(0.8980392156862745,0.4196078431372549,0.36470588235294116,1);const float e6=0.75;const vec4 v6=vec4(0.9725490196078431,0.5803921568627451,0.2549019607843137,1);const float e7=0.88;const vec4 v7=vec4(0.9921568627450981,0.7647058823529411,0.1568627450980392,1);const float e8=1.0;const vec4 v8=vec4(0.9411764705882353,0.9764705882352941,0.12941176470588237,1);float a0=smoothstep(e0,e1,x_3);float a1=smoothstep(e1,e2,x_3);float a2=smoothstep(e2,e3,x_3);float a3=smoothstep(e3,e4,x_3);float a4=smoothstep(e4,e5,x_3);float a5=smoothstep(e5,e6,x_3);float a6=smoothstep(e6,e7,x_3);float a7=smoothstep(e7,e8,x_3);return max(mix(v0,v1,a0)*step(e0,x_3)*step(x_3,e1),max(mix(v1,v2,a1)*step(e1,x_3)*step(x_3,e2),max(mix(v2,v3,a2)*step(e2,x_3)*step(x_3,e3),max(mix(v3,v4,a3)*step(e3,x_3)*step(x_3,e4),max(mix(v4,v5,a4)*step(e4,x_3)*step(x_3,e5),max(mix(v5,v6,a5)*step(e5,x_3)*step(x_3,e6),max(mix(v6,v7,a6)*step(e6,x_3)*step(x_3,e7),mix(v7,v8,a7)*step(e7,x_3)*step(x_3,e8))))))));}vec4 warm(float x_43){const float e0=0.0;const vec4 v0=vec4(0.49019607843137253,0,0.7019607843137254,1);const float e1=0.13;const vec4 v1=vec4(0.6745098039215687,0,0.7333333333333333,1);const float e2=0.25;const vec4 v2=vec4(0.8588235294117647,0,0.6666666666666666,1);const float e3=0.38;const vec4 v3=vec4(1,0,0.5098039215686274,1);const float e4=0.5;const vec4 v4=vec4(1,0.24705882352941178,0.2901960784313726,1);const float e5=0.63;const vec4 v5=vec4(1,0.4823529411764706,0,1);const float e6=0.75;const vec4 v6=vec4(0.9176470588235294,0.6901960784313725,0,1);const float e7=0.88;const vec4 v7=vec4(0.7450980392156863,0.8941176470588236,0,1);const float e8=1.0;const vec4 v8=vec4(0.5764705882352941,1,0,1);float a0=smoothstep(e0,e1,x_43);float a1=smoothstep(e1,e2,x_43);float a2=smoothstep(e2,e3,x_43);float a3=smoothstep(e3,e4,x_43);float a4=smoothstep(e4,e5,x_43);float a5=smoothstep(e5,e6,x_43);float a6=smoothstep(e6,e7,x_43);float a7=smoothstep(e7,e8,x_43);return max(mix(v0,v1,a0)*step(e0,x_43)*step(x_43,e1),max(mix(v1,v2,a1)*step(e1,x_43)*step(x_43,e2),max(mix(v2,v3,a2)*step(e2,x_43)*step(x_43,e3),max(mix(v3,v4,a3)*step(e3,x_43)*step(x_43,e4),max(mix(v4,v5,a4)*step(e4,x_43)*step(x_43,e5),max(mix(v5,v6,a5)*step(e5,x_43)*step(x_43,e6),max(mix(v6,v7,a6)*step(e6,x_43)*step(x_43,e7),mix(v7,v8,a7)*step(e7,x_43)*step(x_43,e8))))))));}vec4 rainbow_soft_1310269270(float x_14){const float e0=0.0;const vec4 v0=vec4(0.49019607843137253,0,0.7019607843137254,1);const float e1=0.1;const vec4 v1=vec4(0.7803921568627451,0,0.7058823529411765,1);const float e2=0.2;const vec4 v2=vec4(1,0,0.4745098039215686,1);const float e3=0.3;const vec4 v3=vec4(1,0.4235294117647059,0,1);const float e4=0.4;const vec4 v4=vec4(0.8705882352941177,0.7607843137254902,0,1);const float e5=0.5;const vec4 v5=vec4(0.5882352941176471,1,0,1);const float e6=0.6;const vec4 v6=vec4(0,1,0.21568627450980393,1);const float e7=0.7;const vec4 v7=vec4(0,0.9647058823529412,0.5882352941176471,1);const float e8=0.8;const vec4 v8=vec4(0.19607843137254902,0.6549019607843137,0.8705882352941177,1);const float e9=0.9;const vec4 v9=vec4(0.403921568627451,0.2,0.9215686274509803,1);const float e10=1.0;const vec4 v10=vec4(0.48627450980392156,0,0.7294117647058823,1);float a0=smoothstep(e0,e1,x_14);float a1=smoothstep(e1,e2,x_14);float a2=smoothstep(e2,e3,x_14);float a3=smoothstep(e3,e4,x_14);float a4=smoothstep(e4,e5,x_14);float a5=smoothstep(e5,e6,x_14);float a6=smoothstep(e6,e7,x_14);float a7=smoothstep(e7,e8,x_14);float a8=smoothstep(e8,e9,x_14);float a9=smoothstep(e9,e10,x_14);return max(mix(v0,v1,a0)*step(e0,x_14)*step(x_14,e1),max(mix(v1,v2,a1)*step(e1,x_14)*step(x_14,e2),max(mix(v2,v3,a2)*step(e2,x_14)*step(x_14,e3),max(mix(v3,v4,a3)*step(e3,x_14)*step(x_14,e4),max(mix(v4,v5,a4)*step(e4,x_14)*step(x_14,e5),max(mix(v5,v6,a5)*step(e5,x_14)*step(x_14,e6),max(mix(v6,v7,a6)*step(e6,x_14)*step(x_14,e7),max(mix(v7,v8,a7)*step(e7,x_14)*step(x_14,e8),max(mix(v8,v9,a8)*step(e8,x_14)*step(x_14,e9),mix(v9,v10,a9)*step(e9,x_14)*step(x_14,e10))))))))));}vec4 bathymetry(float x_36){const float e0=0.0;const vec4 v0=vec4(0.1568627450980392,0.10196078431372549,0.17254901960784313,1);const float e1=0.13;const vec4 v1=vec4(0.23137254901960785,0.19215686274509805,0.35294117647058826,1);const float e2=0.25;const vec4 v2=vec4(0.25098039215686274,0.2980392156862745,0.5450980392156862,1);const float e3=0.38;const vec4 v3=vec4(0.24705882352941178,0.43137254901960786,0.592156862745098,1);const float e4=0.5;const vec4 v4=vec4(0.2823529411764706,0.5568627450980392,0.6196078431372549,1);const float e5=0.63;const vec4 v5=vec4(0.3333333333333333,0.6823529411764706,0.6392156862745098,1);const float e6=0.75;const vec4 v6=vec4(0.47058823529411764,0.807843137254902,0.6392156862745098,1);const float e7=0.88;const vec4 v7=vec4(0.7333333333333333,0.9019607843137255,0.6745098039215687,1);const float e8=1.0;const vec4 v8=vec4(0.9921568627450981,0.996078431372549,0.8,1);float a0=smoothstep(e0,e1,x_36);float a1=smoothstep(e1,e2,x_36);float a2=smoothstep(e2,e3,x_36);float a3=smoothstep(e3,e4,x_36);float a4=smoothstep(e4,e5,x_36);float a5=smoothstep(e5,e6,x_36);float a6=smoothstep(e6,e7,x_36);float a7=smoothstep(e7,e8,x_36);return max(mix(v0,v1,a0)*step(e0,x_36)*step(x_36,e1),max(mix(v1,v2,a1)*step(e1,x_36)*step(x_36,e2),max(mix(v2,v3,a2)*step(e2,x_36)*step(x_36,e3),max(mix(v3,v4,a3)*step(e3,x_36)*step(x_36,e4),max(mix(v4,v5,a4)*step(e4,x_36)*step(x_36,e5),max(mix(v5,v6,a5)*step(e5,x_36)*step(x_36,e6),max(mix(v6,v7,a6)*step(e6,x_36)*step(x_36,e7),mix(v7,v8,a7)*step(e7,x_36)*step(x_36,e8))))))));}vec4 cdom(float x_7){const float e0=0.0;const vec4 v0=vec4(0.1843137254901961,0.058823529411764705,0.24313725490196078,1);const float e1=0.13;const vec4 v1=vec4(0.3411764705882353,0.09019607843137255,0.33725490196078434,1);const float e2=0.25;const vec4 v2=vec4(0.5098039215686274,0.10980392156862745,0.38823529411764707,1);const float e3=0.38;const vec4 v3=vec4(0.6705882352941176,0.1607843137254902,0.3764705882352941,1);const float e4=0.5;const vec4 v4=vec4(0.807843137254902,0.2627450980392157,0.33725490196078434,1);const float e5=0.63;const vec4 v5=vec4(0.9019607843137255,0.41568627450980394,0.32941176470588235,1);const float e6=0.75;const vec4 v6=vec4(0.9490196078431372,0.5843137254901961,0.403921568627451,1);const float e7=0.88;const vec4 v7=vec4(0.9764705882352941,0.7568627450980392,0.5294117647058824,1);const float e8=1.0;const vec4 v8=vec4(0.996078431372549,0.9294117647058824,0.6901960784313725,1);float a0=smoothstep(e0,e1,x_7);float a1=smoothstep(e1,e2,x_7);float a2=smoothstep(e2,e3,x_7);float a3=smoothstep(e3,e4,x_7);float a4=smoothstep(e4,e5,x_7);float a5=smoothstep(e5,e6,x_7);float a6=smoothstep(e6,e7,x_7);float a7=smoothstep(e7,e8,x_7);return max(mix(v0,v1,a0)*step(e0,x_7)*step(x_7,e1),max(mix(v1,v2,a1)*step(e1,x_7)*step(x_7,e2),max(mix(v2,v3,a2)*step(e2,x_7)*step(x_7,e3),max(mix(v3,v4,a3)*step(e3,x_7)*step(x_7,e4),max(mix(v4,v5,a4)*step(e4,x_7)*step(x_7,e5),max(mix(v5,v6,a5)*step(e5,x_7)*step(x_7,e6),max(mix(v6,v7,a6)*step(e6,x_7)*step(x_7,e7),mix(v7,v8,a7)*step(e7,x_7)*step(x_7,e8))))))));}vec4 chlorophyll(float x_6){const float e0=0.0;const vec4 v0=vec4(0.07058823529411765,0.1411764705882353,0.0784313725490196,1);const float e1=0.13;const vec4 v1=vec4(0.09803921568627451,0.24705882352941178,0.1607843137254902,1);const float e2=0.25;const vec4 v2=vec4(0.09411764705882353,0.3568627450980392,0.23137254901960785,1);const float e3=0.38;const vec4 v3=vec4(0.050980392156862744,0.4666666666666667,0.2823529411764706,1);const float e4=0.5;const vec4 v4=vec4(0.07058823529411765,0.5803921568627451,0.3137254901960784,1);const float e5=0.63;const vec4 v5=vec4(0.3137254901960784,0.6784313725490196,0.34901960784313724,1);const float e6=0.75;const vec4 v6=vec4(0.5176470588235295,0.7686274509803922,0.47843137254901963,1);const float e7=0.88;const vec4 v7=vec4(0.6862745098039216,0.8666666666666667,0.6352941176470588,1);const float e8=1.0;const vec4 v8=vec4(0.8431372549019608,0.9764705882352941,0.8156862745098039,1);float a0=smoothstep(e0,e1,x_6);float a1=smoothstep(e1,e2,x_6);float a2=smoothstep(e2,e3,x_6);float a3=smoothstep(e3,e4,x_6);float a4=smoothstep(e4,e5,x_6);float a5=smoothstep(e5,e6,x_6);float a6=smoothstep(e6,e7,x_6);float a7=smoothstep(e7,e8,x_6);return max(mix(v0,v1,a0)*step(e0,x_6)*step(x_6,e1),max(mix(v1,v2,a1)*step(e1,x_6)*step(x_6,e2),max(mix(v2,v3,a2)*step(e2,x_6)*step(x_6,e3),max(mix(v3,v4,a3)*step(e3,x_6)*step(x_6,e4),max(mix(v4,v5,a4)*step(e4,x_6)*step(x_6,e5),max(mix(v5,v6,a5)*step(e5,x_6)*step(x_6,e6),max(mix(v6,v7,a6)*step(e6,x_6)*step(x_6,e7),mix(v7,v8,a7)*step(e7,x_6)*step(x_6,e8))))))));}vec4 density(float x_19){const float e0=0.0;const vec4 v0=vec4(0.21176470588235294,0.054901960784313725,0.1411764705882353,1);const float e1=0.13;const vec4 v1=vec4(0.34901960784313724,0.09019607843137255,0.3137254901960784,1);const float e2=0.25;const vec4 v2=vec4(0.43137254901960786,0.17647058823529413,0.5176470588235295,1);const float e3=0.38;const vec4 v3=vec4(0.47058823529411764,0.30196078431372547,0.6980392156862745,1);const float e4=0.5;const vec4 v4=vec4(0.47058823529411764,0.44313725490196076,0.8352941176470589,1);const float e5=0.63;const vec4 v5=vec4(0.45098039215686275,0.592156862745098,0.8941176470588236,1);const float e6=0.75;const vec4 v6=vec4(0.5254901960784314,0.7254901960784313,0.8901960784313725,1);const float e7=0.88;const vec4 v7=vec4(0.6941176470588235,0.8392156862745098,0.8901960784313725,1);const float e8=1.0;const vec4 v8=vec4(0.9019607843137255,0.9450980392156862,0.9450980392156862,1);float a0=smoothstep(e0,e1,x_19);float a1=smoothstep(e1,e2,x_19);float a2=smoothstep(e2,e3,x_19);float a3=smoothstep(e3,e4,x_19);float a4=smoothstep(e4,e5,x_19);float a5=smoothstep(e5,e6,x_19);float a6=smoothstep(e6,e7,x_19);float a7=smoothstep(e7,e8,x_19);return max(mix(v0,v1,a0)*step(e0,x_19)*step(x_19,e1),max(mix(v1,v2,a1)*step(e1,x_19)*step(x_19,e2),max(mix(v2,v3,a2)*step(e2,x_19)*step(x_19,e3),max(mix(v3,v4,a3)*step(e3,x_19)*step(x_19,e4),max(mix(v4,v5,a4)*step(e4,x_19)*step(x_19,e5),max(mix(v5,v6,a5)*step(e5,x_19)*step(x_19,e6),max(mix(v6,v7,a6)*step(e6,x_19)*step(x_19,e7),mix(v7,v8,a7)*step(e7,x_19)*step(x_19,e8))))))));}vec4 freesurface_blue_3154355989(float x_35){const float e0=0.0;const vec4 v0=vec4(0.11764705882352941,0.01568627450980392,0.43137254901960786,1);const float e1=0.13;const vec4 v1=vec4(0.1843137254901961,0.054901960784313725,0.6901960784313725,1);const float e2=0.25;const vec4 v2=vec4(0.1607843137254902,0.17647058823529413,0.9254901960784314,1);const float e3=0.38;const vec4 v3=vec4(0.09803921568627451,0.38823529411764707,0.8313725490196079,1);const float e4=0.5;const vec4 v4=vec4(0.26666666666666666,0.5137254901960784,0.7843137254901961,1);const float e5=0.63;const vec4 v5=vec4(0.4470588235294118,0.611764705882353,0.7725490196078432,1);const float e6=0.75;const vec4 v6=vec4(0.615686274509804,0.7098039215686275,0.796078431372549,1);const float e7=0.88;const vec4 v7=vec4(0.7843137254901961,0.8156862745098039,0.8470588235294118,1);const float e8=1.0;const vec4 v8=vec4(0.9450980392156862,0.9294117647058824,0.9254901960784314,1);float a0=smoothstep(e0,e1,x_35);float a1=smoothstep(e1,e2,x_35);float a2=smoothstep(e2,e3,x_35);float a3=smoothstep(e3,e4,x_35);float a4=smoothstep(e4,e5,x_35);float a5=smoothstep(e5,e6,x_35);float a6=smoothstep(e6,e7,x_35);float a7=smoothstep(e7,e8,x_35);return max(mix(v0,v1,a0)*step(e0,x_35)*step(x_35,e1),max(mix(v1,v2,a1)*step(e1,x_35)*step(x_35,e2),max(mix(v2,v3,a2)*step(e2,x_35)*step(x_35,e3),max(mix(v3,v4,a3)*step(e3,x_35)*step(x_35,e4),max(mix(v4,v5,a4)*step(e4,x_35)*step(x_35,e5),max(mix(v5,v6,a5)*step(e5,x_35)*step(x_35,e6),max(mix(v6,v7,a6)*step(e6,x_35)*step(x_35,e7),mix(v7,v8,a7)*step(e7,x_35)*step(x_35,e8))))))));}vec4 freesurface_red_1679163293(float x_20){const float e0=0.0;const vec4 v0=vec4(0.23529411764705882,0.03529411764705882,0.07058823529411765,1);const float e1=0.13;const vec4 v1=vec4(0.39215686274509803,0.06666666666666667,0.10588235294117647,1);const float e2=0.25;const vec4 v2=vec4(0.5568627450980392,0.0784313725490196,0.11372549019607843,1);const float e3=0.38;const vec4 v3=vec4(0.6941176470588235,0.16862745098039217,0.10588235294117647,1);const float e4=0.5;const vec4 v4=vec4(0.7529411764705882,0.3411764705882353,0.24705882352941178,1);const float e5=0.63;const vec4 v5=vec4(0.803921568627451,0.49019607843137253,0.4117647058823529,1);const float e6=0.75;const vec4 v6=vec4(0.8470588235294118,0.6352941176470588,0.5803921568627451,1);const float e7=0.88;const vec4 v7=vec4(0.8901960784313725,0.7803921568627451,0.7568627450980392,1);const float e8=1.0;const vec4 v8=vec4(0.9450980392156862,0.9294117647058824,0.9254901960784314,1);float a0=smoothstep(e0,e1,x_20);float a1=smoothstep(e1,e2,x_20);float a2=smoothstep(e2,e3,x_20);float a3=smoothstep(e3,e4,x_20);float a4=smoothstep(e4,e5,x_20);float a5=smoothstep(e5,e6,x_20);float a6=smoothstep(e6,e7,x_20);float a7=smoothstep(e7,e8,x_20);return max(mix(v0,v1,a0)*step(e0,x_20)*step(x_20,e1),max(mix(v1,v2,a1)*step(e1,x_20)*step(x_20,e2),max(mix(v2,v3,a2)*step(e2,x_20)*step(x_20,e3),max(mix(v3,v4,a3)*step(e3,x_20)*step(x_20,e4),max(mix(v4,v5,a4)*step(e4,x_20)*step(x_20,e5),max(mix(v5,v6,a5)*step(e5,x_20)*step(x_20,e6),max(mix(v6,v7,a6)*step(e6,x_20)*step(x_20,e7),mix(v7,v8,a7)*step(e7,x_20)*step(x_20,e8))))))));}vec4 oxygen(float x_11){const float e0=0.0;const vec4 v0=vec4(0.25098039215686274,0.0196078431372549,0.0196078431372549,1);const float e1=0.13;const vec4 v1=vec4(0.41568627450980394,0.023529411764705882,0.058823529411764705,1);const float e2=0.25;const vec4 v2=vec4(0.5647058823529412,0.10196078431372549,0.027450980392156862,1);const float e3=0.38;const vec4 v3=vec4(0.6588235294117647,0.25098039215686274,0.011764705882352941,1);const float e4=0.5;const vec4 v4=vec4(0.7372549019607844,0.39215686274509803,0.01568627450980392,1);const float e5=0.63;const vec4 v5=vec4(0.807843137254902,0.5333333333333333,0.043137254901960784,1);const float e6=0.75;const vec4 v6=vec4(0.8627450980392157,0.6823529411764706,0.09803921568627451,1);const float e7=0.88;const vec4 v7=vec4(0.9058823529411765,0.8431372549019608,0.17254901960784313,1);const float e8=1.0;const vec4 v8=vec4(0.9725490196078431,0.996078431372549,0.4117647058823529,1);float a0=smoothstep(e0,e1,x_11);float a1=smoothstep(e1,e2,x_11);float a2=smoothstep(e2,e3,x_11);float a3=smoothstep(e3,e4,x_11);float a4=smoothstep(e4,e5,x_11);float a5=smoothstep(e5,e6,x_11);float a6=smoothstep(e6,e7,x_11);float a7=smoothstep(e7,e8,x_11);return max(mix(v0,v1,a0)*step(e0,x_11)*step(x_11,e1),max(mix(v1,v2,a1)*step(e1,x_11)*step(x_11,e2),max(mix(v2,v3,a2)*step(e2,x_11)*step(x_11,e3),max(mix(v3,v4,a3)*step(e3,x_11)*step(x_11,e4),max(mix(v4,v5,a4)*step(e4,x_11)*step(x_11,e5),max(mix(v5,v6,a5)*step(e5,x_11)*step(x_11,e6),max(mix(v6,v7,a6)*step(e6,x_11)*step(x_11,e7),mix(v7,v8,a7)*step(e7,x_11)*step(x_11,e8))))))));}vec4 par(float x_28){const float e0=0.0;const vec4 v0=vec4(0.2,0.0784313725490196,0.09411764705882353,1);const float e1=0.13;const vec4 v1=vec4(0.35294117647058826,0.12549019607843137,0.13725490196078433,1);const float e2=0.25;const vec4 v2=vec4(0.5058823529411764,0.17254901960784313,0.13333333333333333,1);const float e3=0.38;const vec4 v3=vec4(0.6235294117647059,0.26666666666666666,0.09803921568627451,1);const float e4=0.5;const vec4 v4=vec4(0.7137254901960784,0.38823529411764707,0.07450980392156863,1);const float e5=0.63;const vec4 v5=vec4(0.7803921568627451,0.5254901960784314,0.08627450980392157,1);const float e6=0.75;const vec4 v6=vec4(0.8313725490196079,0.6705882352941176,0.13725490196078433,1);const float e7=0.88;const vec4 v7=vec4(0.8666666666666667,0.8235294117647058,0.21176470588235294,1);const float e8=1.0;const vec4 v8=vec4(0.8823529411764706,0.9921568627450981,0.29411764705882354,1);float a0=smoothstep(e0,e1,x_28);float a1=smoothstep(e1,e2,x_28);float a2=smoothstep(e2,e3,x_28);float a3=smoothstep(e3,e4,x_28);float a4=smoothstep(e4,e5,x_28);float a5=smoothstep(e5,e6,x_28);float a6=smoothstep(e6,e7,x_28);float a7=smoothstep(e7,e8,x_28);return max(mix(v0,v1,a0)*step(e0,x_28)*step(x_28,e1),max(mix(v1,v2,a1)*step(e1,x_28)*step(x_28,e2),max(mix(v2,v3,a2)*step(e2,x_28)*step(x_28,e3),max(mix(v3,v4,a3)*step(e3,x_28)*step(x_28,e4),max(mix(v4,v5,a4)*step(e4,x_28)*step(x_28,e5),max(mix(v5,v6,a5)*step(e5,x_28)*step(x_28,e6),max(mix(v6,v7,a6)*step(e6,x_28)*step(x_28,e7),mix(v7,v8,a7)*step(e7,x_28)*step(x_28,e8))))))));}vec4 phase(float x_39){const float e0=0.0;const vec4 v0=vec4(0.5686274509803921,0.4117647058823529,0.07058823529411765,1);const float e1=0.13;const vec4 v1=vec4(0.7215686274509804,0.2784313725490196,0.14901960784313725,1);const float e2=0.25;const vec4 v2=vec4(0.7294117647058823,0.22745098039215686,0.45098039215686275,1);const float e3=0.38;const vec4 v3=vec4(0.6274509803921569,0.2784313725490196,0.7254901960784313,1);const float e4=0.5;const vec4 v4=vec4(0.43137254901960786,0.3803921568627451,0.8549019607843137,1);const float e5=0.63;const vec4 v5=vec4(0.19607843137254902,0.4823529411764706,0.6431372549019608,1);const float e6=0.75;const vec4 v6=vec4(0.12156862745098039,0.5137254901960784,0.43137254901960786,1);const float e7=0.88;const vec4 v7=vec4(0.30196078431372547,0.5058823529411764,0.13333333333333333,1);const float e8=1.0;const vec4 v8=vec4(0.5686274509803921,0.4117647058823529,0.07058823529411765,1);float a0=smoothstep(e0,e1,x_39);float a1=smoothstep(e1,e2,x_39);float a2=smoothstep(e2,e3,x_39);float a3=smoothstep(e3,e4,x_39);float a4=smoothstep(e4,e5,x_39);float a5=smoothstep(e5,e6,x_39);float a6=smoothstep(e6,e7,x_39);float a7=smoothstep(e7,e8,x_39);return max(mix(v0,v1,a0)*step(e0,x_39)*step(x_39,e1),max(mix(v1,v2,a1)*step(e1,x_39)*step(x_39,e2),max(mix(v2,v3,a2)*step(e2,x_39)*step(x_39,e3),max(mix(v3,v4,a3)*step(e3,x_39)*step(x_39,e4),max(mix(v4,v5,a4)*step(e4,x_39)*step(x_39,e5),max(mix(v5,v6,a5)*step(e5,x_39)*step(x_39,e6),max(mix(v6,v7,a6)*step(e6,x_39)*step(x_39,e7),mix(v7,v8,a7)*step(e7,x_39)*step(x_39,e8))))))));}vec4 salinity(float x_26){const float e0=0.0;const vec4 v0=vec4(0.16470588235294117,0.09411764705882353,0.4235294117647059,1);const float e1=0.13;const vec4 v1=vec4(0.12941176470588237,0.19607843137254902,0.6352941176470588,1);const float e2=0.25;const vec4 v2=vec4(0.058823529411764705,0.35294117647058826,0.5686274509803921,1);const float e3=0.38;const vec4 v3=vec4(0.1568627450980392,0.4627450980392157,0.5372549019607843,1);const float e4=0.5;const vec4 v4=vec4(0.23137254901960785,0.5725490196078431,0.5294117647058824,1);const float e5=0.63;const vec4 v5=vec4(0.30980392156862746,0.6862745098039216,0.49411764705882355,1);const float e6=0.75;const vec4 v6=vec4(0.47058823529411764,0.796078431372549,0.40784313725490196,1);const float e7=0.88;const vec4 v7=vec4(0.7568627450980392,0.8666666666666667,0.39215686274509803,1);const float e8=1.0;const vec4 v8=vec4(0.9921568627450981,0.9372549019607843,0.6039215686274509,1);float a0=smoothstep(e0,e1,x_26);float a1=smoothstep(e1,e2,x_26);float a2=smoothstep(e2,e3,x_26);float a3=smoothstep(e3,e4,x_26);float a4=smoothstep(e4,e5,x_26);float a5=smoothstep(e5,e6,x_26);float a6=smoothstep(e6,e7,x_26);float a7=smoothstep(e7,e8,x_26);return max(mix(v0,v1,a0)*step(e0,x_26)*step(x_26,e1),max(mix(v1,v2,a1)*step(e1,x_26)*step(x_26,e2),max(mix(v2,v3,a2)*step(e2,x_26)*step(x_26,e3),max(mix(v3,v4,a3)*step(e3,x_26)*step(x_26,e4),max(mix(v4,v5,a4)*step(e4,x_26)*step(x_26,e5),max(mix(v5,v6,a5)*step(e5,x_26)*step(x_26,e6),max(mix(v6,v7,a6)*step(e6,x_26)*step(x_26,e7),mix(v7,v8,a7)*step(e7,x_26)*step(x_26,e8))))))));}vec4 temperature(float x_8){const float e0=0.0;const vec4 v0=vec4(0.01568627450980392,0.13725490196078433,0.2,1);const float e1=0.13;const vec4 v1=vec4(0.09019607843137255,0.2,0.47843137254901963,1);const float e2=0.25;const vec4 v2=vec4(0.3333333333333333,0.23137254901960785,0.615686274509804,1);const float e3=0.38;const vec4 v3=vec4(0.5058823529411764,0.30980392156862746,0.5607843137254902,1);const float e4=0.5;const vec4 v4=vec4(0.6862745098039216,0.37254901960784315,0.5098039215686274,1);const float e5=0.63;const vec4 v5=vec4(0.8705882352941177,0.4392156862745098,0.396078431372549,1);const float e6=0.75;const vec4 v6=vec4(0.9764705882352941,0.5725490196078431,0.25882352941176473,1);const float e7=0.88;const vec4 v7=vec4(0.9764705882352941,0.7686274509803922,0.2549019607843137,1);const float e8=1.0;const vec4 v8=vec4(0.9098039215686274,0.9803921568627451,0.3568627450980392,1);float a0=smoothstep(e0,e1,x_8);float a1=smoothstep(e1,e2,x_8);float a2=smoothstep(e2,e3,x_8);float a3=smoothstep(e3,e4,x_8);float a4=smoothstep(e4,e5,x_8);float a5=smoothstep(e5,e6,x_8);float a6=smoothstep(e6,e7,x_8);float a7=smoothstep(e7,e8,x_8);return max(mix(v0,v1,a0)*step(e0,x_8)*step(x_8,e1),max(mix(v1,v2,a1)*step(e1,x_8)*step(x_8,e2),max(mix(v2,v3,a2)*step(e2,x_8)*step(x_8,e3),max(mix(v3,v4,a3)*step(e3,x_8)*step(x_8,e4),max(mix(v4,v5,a4)*step(e4,x_8)*step(x_8,e5),max(mix(v5,v6,a5)*step(e5,x_8)*step(x_8,e6),max(mix(v6,v7,a6)*step(e6,x_8)*step(x_8,e7),mix(v7,v8,a7)*step(e7,x_8)*step(x_8,e8))))))));}vec4 turbidity(float x_40){const float e0=0.0;const vec4 v0=vec4(0.13333333333333333,0.12156862745098039,0.10588235294117647,1);const float e1=0.13;const vec4 v1=vec4(0.2549019607843137,0.19607843137254902,0.1607843137254902,1);const float e2=0.25;const vec4 v2=vec4(0.3843137254901961,0.27058823529411763,0.20392156862745098,1);const float e3=0.38;const vec4 v3=vec4(0.5137254901960784,0.34901960784313724,0.2235294117647059,1);const float e4=0.5;const vec4 v4=vec4(0.6313725490196078,0.4392156862745098,0.23137254901960785,1);const float e5=0.63;const vec4 v5=vec4(0.7254901960784313,0.5490196078431373,0.25882352941176473,1);const float e6=0.75;const vec4 v6=vec4(0.792156862745098,0.6823529411764706,0.34509803921568627,1);const float e7=0.88;const vec4 v7=vec4(0.8470588235294118,0.8196078431372549,0.49411764705882355,1);const float e8=1.0;const vec4 v8=vec4(0.9137254901960784,0.9647058823529412,0.6705882352941176,1);float a0=smoothstep(e0,e1,x_40);float a1=smoothstep(e1,e2,x_40);float a2=smoothstep(e2,e3,x_40);float a3=smoothstep(e3,e4,x_40);float a4=smoothstep(e4,e5,x_40);float a5=smoothstep(e5,e6,x_40);float a6=smoothstep(e6,e7,x_40);float a7=smoothstep(e7,e8,x_40);return max(mix(v0,v1,a0)*step(e0,x_40)*step(x_40,e1),max(mix(v1,v2,a1)*step(e1,x_40)*step(x_40,e2),max(mix(v2,v3,a2)*step(e2,x_40)*step(x_40,e3),max(mix(v3,v4,a3)*step(e3,x_40)*step(x_40,e4),max(mix(v4,v5,a4)*step(e4,x_40)*step(x_40,e5),max(mix(v5,v6,a5)*step(e5,x_40)*step(x_40,e6),max(mix(v6,v7,a6)*step(e6,x_40)*step(x_40,e7),mix(v7,v8,a7)*step(e7,x_40)*step(x_40,e8))))))));}vec4 velocity_blue_297387650(float x_2){const float e0=0.0;const vec4 v0=vec4(0.06666666666666667,0.12549019607843137,0.25098039215686274,1);const float e1=0.13;const vec4 v1=vec4(0.13725490196078433,0.20392156862745098,0.4549019607843137,1);const float e2=0.25;const vec4 v2=vec4(0.11372549019607843,0.3176470588235294,0.611764705882353,1);const float e3=0.38;const vec4 v3=vec4(0.12156862745098039,0.44313725490196076,0.6352941176470588,1);const float e4=0.5;const vec4 v4=vec4(0.19607843137254902,0.5647058823529412,0.6627450980392157,1);const float e5=0.63;const vec4 v5=vec4(0.3411764705882353,0.6784313725490196,0.6901960784313725,1);const float e6=0.75;const vec4 v6=vec4(0.5843137254901961,0.7686274509803922,0.7411764705882353,1);const float e7=0.88;const vec4 v7=vec4(0.796078431372549,0.8666666666666667,0.8274509803921568,1);const float e8=1.0;const vec4 v8=vec4(0.996078431372549,0.984313725490196,0.9019607843137255,1);float a0=smoothstep(e0,e1,x_2);float a1=smoothstep(e1,e2,x_2);float a2=smoothstep(e2,e3,x_2);float a3=smoothstep(e3,e4,x_2);float a4=smoothstep(e4,e5,x_2);float a5=smoothstep(e5,e6,x_2);float a6=smoothstep(e6,e7,x_2);float a7=smoothstep(e7,e8,x_2);return max(mix(v0,v1,a0)*step(e0,x_2)*step(x_2,e1),max(mix(v1,v2,a1)*step(e1,x_2)*step(x_2,e2),max(mix(v2,v3,a2)*step(e2,x_2)*step(x_2,e3),max(mix(v3,v4,a3)*step(e3,x_2)*step(x_2,e4),max(mix(v4,v5,a4)*step(e4,x_2)*step(x_2,e5),max(mix(v5,v6,a5)*step(e5,x_2)*step(x_2,e6),max(mix(v6,v7,a6)*step(e6,x_2)*step(x_2,e7),mix(v7,v8,a7)*step(e7,x_2)*step(x_2,e8))))))));}vec4 velocity_green_2558432129(float x_27){const float e0=0.0;const vec4 v0=vec4(0.09019607843137255,0.13725490196078433,0.07450980392156863,1);const float e1=0.13;const vec4 v1=vec4(0.09411764705882353,0.25098039215686274,0.14901960784313725,1);const float e2=0.25;const vec4 v2=vec4(0.043137254901960784,0.37254901960784315,0.17647058823529413,1);const float e3=0.38;const vec4 v3=vec4(0.15294117647058825,0.4823529411764706,0.13725490196078433,1);const float e4=0.5;const vec4 v4=vec4(0.37254901960784315,0.5725490196078431,0.047058823529411764,1);const float e5=0.63;const vec4 v5=vec4(0.596078431372549,0.6470588235294118,0.07058823529411765,1);const float e6=0.75;const vec4 v6=vec4(0.788235294117647,0.7294117647058823,0.27058823529411763,1);const float e7=0.88;const vec4 v7=vec4(0.9137254901960784,0.8470588235294118,0.5372549019607843,1);const float e8=1.0;const vec4 v8=vec4(1,0.9921568627450981,0.803921568627451,1);float a0=smoothstep(e0,e1,x_27);float a1=smoothstep(e1,e2,x_27);float a2=smoothstep(e2,e3,x_27);float a3=smoothstep(e3,e4,x_27);float a4=smoothstep(e4,e5,x_27);float a5=smoothstep(e5,e6,x_27);float a6=smoothstep(e6,e7,x_27);float a7=smoothstep(e7,e8,x_27);return max(mix(v0,v1,a0)*step(e0,x_27)*step(x_27,e1),max(mix(v1,v2,a1)*step(e1,x_27)*step(x_27,e2),max(mix(v2,v3,a2)*step(e2,x_27)*step(x_27,e3),max(mix(v3,v4,a3)*step(e3,x_27)*step(x_27,e4),max(mix(v4,v5,a4)*step(e4,x_27)*step(x_27,e5),max(mix(v5,v6,a5)*step(e5,x_27)*step(x_27,e6),max(mix(v6,v7,a6)*step(e6,x_27)*step(x_27,e7),mix(v7,v8,a7)*step(e7,x_27)*step(x_27,e8))))))));}vec4 cubehelix(float x_37){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.07;const vec4 v1=vec4(0.08627450980392157,0.0196078431372549,0.23137254901960785,1);const float e2=0.13;const vec4 v2=vec4(0.23529411764705882,0.01568627450980392,0.4117647058823529,1);const float e3=0.2;const vec4 v3=vec4(0.42745098039215684,0.00392156862745098,0.5294117647058824,1);const float e4=0.27;const vec4 v4=vec4(0.6313725490196078,0,0.5764705882352941,1);const float e5=0.33;const vec4 v5=vec4(0.8235294117647058,0.00784313725490196,0.5568627450980392,1);const float e6=0.4;const vec4 v6=vec4(0.984313725490196,0.043137254901960784,0.4823529411764706,1);const float e7=0.47;const vec4 v7=vec4(1,0.11372549019607843,0.3803921568627451,1);const float e8=0.53;const vec4 v8=vec4(1,0.21176470588235294,0.27058823529411763,1);const float e9=0.6;const vec4 v9=vec4(1,0.3333333333333333,0.1803921568627451,1);const float e10=0.67;const vec4 v10=vec4(1,0.47058823529411764,0.13333333333333333,1);const float e11=0.73;const vec4 v11=vec4(1,0.615686274509804,0.1450980392156863,1);const float e12=0.8;const vec4 v12=vec4(0.9450980392156862,0.7490196078431373,0.2235294117647059,1);const float e13=0.87;const vec4 v13=vec4(0.8784313725490196,0.8627450980392157,0.36470588235294116,1);const float e14=0.93;const vec4 v14=vec4(0.8549019607843137,0.9450980392156862,0.5568627450980392,1);const float e15=1.0;const vec4 v15=vec4(0.8901960784313725,0.9921568627450981,0.7764705882352941,1);float a0=smoothstep(e0,e1,x_37);float a1=smoothstep(e1,e2,x_37);float a2=smoothstep(e2,e3,x_37);float a3=smoothstep(e3,e4,x_37);float a4=smoothstep(e4,e5,x_37);float a5=smoothstep(e5,e6,x_37);float a6=smoothstep(e6,e7,x_37);float a7=smoothstep(e7,e8,x_37);float a8=smoothstep(e8,e9,x_37);float a9=smoothstep(e9,e10,x_37);float a10=smoothstep(e10,e11,x_37);float a11=smoothstep(e11,e12,x_37);float a12=smoothstep(e12,e13,x_37);float a13=smoothstep(e13,e14,x_37);float a14=smoothstep(e14,e15,x_37);return max(mix(v0,v1,a0)*step(e0,x_37)*step(x_37,e1),max(mix(v1,v2,a1)*step(e1,x_37)*step(x_37,e2),max(mix(v2,v3,a2)*step(e2,x_37)*step(x_37,e3),max(mix(v3,v4,a3)*step(e3,x_37)*step(x_37,e4),max(mix(v4,v5,a4)*step(e4,x_37)*step(x_37,e5),max(mix(v5,v6,a5)*step(e5,x_37)*step(x_37,e6),max(mix(v6,v7,a6)*step(e6,x_37)*step(x_37,e7),max(mix(v7,v8,a7)*step(e7,x_37)*step(x_37,e8),max(mix(v8,v9,a8)*step(e8,x_37)*step(x_37,e9),max(mix(v9,v10,a9)*step(e9,x_37)*step(x_37,e10),max(mix(v10,v11,a10)*step(e10,x_37)*step(x_37,e11),max(mix(v11,v12,a11)*step(e11,x_37)*step(x_37,e12),max(mix(v12,v13,a12)*step(e12,x_37)*step(x_37,e13),max(mix(v13,v14,a13)*step(e13,x_37)*step(x_37,e14),mix(v14,v15,a14)*step(e14,x_37)*step(x_37,e15)))))))))))))));}float sample_and_apply_contrast_limits(SAMPLER_TYPE channel,vec3 vTexCoord,vec2 contrastLimits){float fragIntensity=float(texture(channel,vTexCoord).r);float contrastLimitsAppliedToIntensity=(fragIntensity-contrastLimits[0])/max(0.0005,(contrastLimits[1]-contrastLimits[0]));return max(0.,contrastLimitsAppliedToIntensity);}vec4 colormap(float intensity,float opacity){return vec4(COLORMAP_FUNCTION(min(1.,intensity)).xyz,opacity);}";
var channels = {
  name: "channel-intensity-module",
  fs
};
var RENDERING_MODES_BLEND = {
  [RENDERING_MODES.MAX_INTENSITY_PROJECTION]: {
    _BEFORE_RENDER: `      float maxVals[6] = float[6](-1.0, -1.0, -1.0, -1.0, -1.0, -1.0);
    `,
    _RENDER: `    
      float intensityArray[6] = float[6](intensityValue0, intensityValue1, intensityValue2, intensityValue3, intensityValue4, intensityValue5);

      for(int i = 0; i < 6; i++) {
        if(intensityArray[i] > maxVals[i]) {
          maxVals[i] = intensityArray[i];
        }
      }
    `,
    _AFTER_RENDER: `      vec3 rgbCombo = vec3(0.0);
      for(int i = 0; i < 6; i++) {
        rgbCombo += max(0.0, min(1.0, maxVals[i])) * vec3(colors[i]);
      }
      color = vec4(rgbCombo, 1.0);
    `
  },
  [RENDERING_MODES.MIN_INTENSITY_PROJECTION]: {
    _BEFORE_RENDER: `      float minVals[6] = float[6](1. / 0., 1. / 0., 1. / 0., 1. / 0., 1. / 0., 1. / 0.);
    `,
    _RENDER: `    
      float intensityArray[6] = float[6](intensityValue0, intensityValue1, intensityValue2, intensityValue3, intensityValue4, intensityValue5);

      for(int i = 0; i < 6; i++) {
        if(intensityArray[i] < minVals[i]) {
          minVals[i] = intensityArray[i];
        }
      }
    `,
    _AFTER_RENDER: `      vec3 rgbCombo = vec3(0.0);
      for(int i = 0; i < 6; i++) {
        rgbCombo += max(0.0, min(1.0, minVals[i])) * vec3(colors[i]);
      }
      color = vec4(rgbCombo, 1.0);
    `
  },
  [RENDERING_MODES.ADDITIVE]: {
    _BEFORE_RENDER: ``,
    _RENDER: `      vec3 rgbCombo = vec3(0.0);
      vec3 hsvCombo = vec3(0.0);
      float intensityArray[6] = float[6](intensityValue0, intensityValue1, intensityValue2, intensityValue3, intensityValue4, intensityValue5);
      float total = 0.0;
      for(int i = 0; i < 6; i++) {
        float intensityValue = intensityArray[i];
        rgbCombo += max(0.0, min(1.0, intensityValue)) * colors[i];
        total += intensityValue;
      }
      // Do not go past 1 in opacity.
      total = min(total, 1.0);
      vec4 val_color = vec4(rgbCombo, total);
      // Opacity correction
      val_color.a = 1.0 - pow(1.0 - val_color.a, 1.0);
      color.rgb += (1.0 - color.a) * val_color.a * val_color.rgb;
      color.a += (1.0 - color.a) * val_color.a;
      if (color.a >= 0.95) {
        break;
      }
    `,
    _AFTER_RENDER: ``
  }
};
var RENDERING_MODES_COLORMAP = {
  [RENDERING_MODES.MAX_INTENSITY_PROJECTION]: {
    _BEFORE_RENDER: `      float maxVals[6] = float[6](-1.0, -1.0, -1.0, -1.0, -1.0, -1.0);
    `,
    _RENDER: `    
      float intensityArray[6] = float[6](intensityValue0, intensityValue1, intensityValue2, intensityValue3, intensityValue4, intensityValue5);

      for(int i = 0; i < 6; i++) {
        if(intensityArray[i] > maxVals[i]) {
          maxVals[i] = intensityArray[i];
        }
      }
    `,
    _AFTER_RENDER: `      float total = 0.0;
      for(int i = 0; i < 6; i++) {
        total += maxVals[i];
      }
      // Do not go past 1 in opacity/colormap value.
      total = min(total, 1.0);
      color = colormap(total, total);
    `
  },
  [RENDERING_MODES.MIN_INTENSITY_PROJECTION]: {
    _BEFORE_RENDER: `      float minVals[6] = float[6](1. / 0., 1. / 0., 1. / 0., 1. / 0., 1. / 0., 1. / 0.);
    `,
    _RENDER: `    
      float intensityArray[6] = float[6](intensityValue0, intensityValue1, intensityValue2, intensityValue3, intensityValue4, intensityValue5);

      for(int i = 0; i < 6; i++) {
        if(intensityArray[i] < minVals[i]) {
          minVals[i] = intensityArray[i];
        }
      }
    `,
    _AFTER_RENDER: `      float total = 0.0;
      for(int i = 0; i < 6; i++) {
        total += minVals[i];
      }
      // Do not go past 1 in opacity/colormap value.
      total = min(total, 1.0);
      color = colormap(total, total);
    `
  },
  [RENDERING_MODES.ADDITIVE]: {
    _BEFORE_RENDER: ``,
    _RENDER: `    float intensityArray[6] = float[6](intensityValue0, intensityValue1, intensityValue2, intensityValue3, intensityValue4, intensityValue5);
		float total = 0.0;

		for(int i = 0; i < 6; i++) {
			total += intensityArray[i];
		}
		// Do not go past 1 in opacity/colormap value.
		total = min(total, 1.0);

		vec4 val_color = colormap(total, total);

		// Opacity correction
		val_color.a = 1.0 - pow(1.0 - val_color.a, 1.0);
		color.rgb += (1.0 - color.a) * val_color.a * val_color.rgb;
		color.a += (1.0 - color.a) * val_color.a;
		if (color.a >= 0.95) {
			break;
		}
    p += ray_dir * dt;
    `,
    _AFTER_RENDER: ``
  }
};
var CUBE_STRIP = [
  1,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0
];
var NUM_PLANES_DEFAULT = 1;
var defaultProps$1 = {
  pickable: false,
  coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN,
  channelData: { type: "object", value: {}, compare: true },
  colors: { type: "array", value: [], compare: true },
  contrastLimits: { type: "array", value: [], compare: true },
  dtype: { type: "string", value: "Uint8", compare: true },
  colormap: { type: "string", value: "", compare: true },
  xSlice: { type: "array", value: null, compare: true },
  ySlice: { type: "array", value: null, compare: true },
  zSlice: { type: "array", value: null, compare: true },
  clippingPlanes: { type: "array", value: [], compare: true },
  renderingMode: {
    type: "string",
    value: RENDERING_MODES.ADDITIVE,
    compare: true
  },
  resolutionMatrix: { type: "object", value: new Matrix4(), compare: true }
};
function getRenderingAttrs() {
  const values = getDtypeValues("Float32");
  return __spreadProps(__spreadValues({}, values), {
    sampler: values.sampler.replace("2D", "3D"),
    cast: (data) => new Float32Array(data)
  });
}
function removeExtraColormapFunctionsFromShader(colormap) {
  const discardColormaps = COLORMAPS.filter((i) => i !== (colormap || "viridis")).map((i) => i.replace(/-/g, "_"));
  const discardRegex = new RegExp(`vec4 (${discardColormaps.join("(_([0-9]*))?|")})\\(float x_[0-9]+\\){([^}]+)}`, "g");
  const channelsModules = __spreadProps(__spreadValues({}, channels), {
    fs: channels.fs.replace(discardRegex, ""),
    defines: {
      COLORMAP_FUNCTION: colormap || "viridis"
    }
  });
  return channelsModules;
}
var XR3DLayer = class extends Layer {
  initializeState() {
    const { gl } = this.context;
    this.setState({
      model: this._getModel(gl)
    });
    gl.pixelStorei(GL.UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(GL.PACK_ALIGNMENT, 1);
  }
  getShaders() {
    const { colormap, renderingMode, clippingPlanes } = this.props;
    const { sampler } = getRenderingAttrs();
    const { _BEFORE_RENDER, _RENDER, _AFTER_RENDER } = colormap ? RENDERING_MODES_COLORMAP[renderingMode] : RENDERING_MODES_BLEND[renderingMode];
    const channelsModules = removeExtraColormapFunctionsFromShader(colormap);
    return super.getShaders({
      vs,
      fs: fs$1.replace("_BEFORE_RENDER", _BEFORE_RENDER).replace("_RENDER", _RENDER).replace("_AFTER_RENDER", _AFTER_RENDER),
      defines: {
        SAMPLER_TYPE: sampler,
        COLORMAP_FUNCTION: colormap || "viridis",
        NUM_PLANES: String(clippingPlanes.length || NUM_PLANES_DEFAULT)
      },
      modules: [channelsModules]
    });
  }
  finalizeState() {
    super.finalizeState();
    if (this.state.textures) {
      Object.values(this.state.textures).forEach((tex) => tex && tex.delete());
    }
  }
  updateState({ props, oldProps, changeFlags }) {
    var _a2, _b2;
    if (changeFlags.extensionsChanged || props.colormap !== oldProps.colormap || props.renderingMode !== oldProps.renderingMode || props.clippingPlanes.length !== oldProps.clippingPlanes.length) {
      const { gl } = this.context;
      if (this.state.model) {
        this.state.model.delete();
      }
      this.setState({ model: this._getModel(gl) });
    }
    if (props.channelData && ((_a2 = props == null ? void 0 : props.channelData) == null ? void 0 : _a2.data) !== ((_b2 = oldProps == null ? void 0 : oldProps.channelData) == null ? void 0 : _b2.data)) {
      this.loadTexture(props.channelData);
    }
  }
  _getModel(gl) {
    if (!gl) {
      return null;
    }
    return new Model(gl, __spreadProps(__spreadValues({}, this.getShaders()), {
      geometry: new Geometry({
        drawMode: gl.TRIANGLE_STRIP,
        attributes: {
          positions: new Float32Array(CUBE_STRIP)
        }
      })
    }));
  }
  draw({ uniforms }) {
    const { textures, model, scaleMatrix } = this.state;
    const {
      contrastLimits,
      colors,
      xSlice,
      ySlice,
      zSlice,
      modelMatrix,
      channelsVisible,
      domain,
      dtype,
      clippingPlanes,
      resolutionMatrix
    } = this.props;
    const {
      viewMatrix,
      viewMatrixInverse,
      projectionMatrix
    } = this.context.viewport;
    if (textures && model && scaleMatrix) {
      const { paddedContrastLimits, paddedColors } = padColorsAndWindows({
        contrastLimits,
        colors,
        channelsVisible,
        domain,
        dtype
      });
      const invertedScaleMatrix = scaleMatrix.clone().invert();
      const invertedResolutionMatrix = resolutionMatrix.clone().invert();
      const paddedClippingPlanes = padWithDefault(clippingPlanes.map((p) => p.clone().transform(invertedScaleMatrix).transform(invertedResolutionMatrix)), new Plane([1, 0, 0]), clippingPlanes.length || NUM_PLANES_DEFAULT);
      const normals = paddedClippingPlanes.map((plane) => plane.normal).flat();
      const distances = paddedClippingPlanes.map((plane) => plane.distance);
      model.setUniforms(__spreadProps(__spreadValues(__spreadValues({}, uniforms), textures), {
        contrastLimits: paddedContrastLimits,
        colors: paddedColors,
        xSlice: new Float32Array(xSlice ? xSlice.map((i) => i / scaleMatrix[0] / resolutionMatrix[0]) : [0, 1]),
        ySlice: new Float32Array(ySlice ? ySlice.map((i) => i / scaleMatrix[5] / resolutionMatrix[5]) : [0, 1]),
        zSlice: new Float32Array(zSlice ? zSlice.map((i) => i / scaleMatrix[10] / resolutionMatrix[10]) : [0, 1]),
        eye_pos: new Float32Array([
          viewMatrixInverse[12],
          viewMatrixInverse[13],
          viewMatrixInverse[14]
        ]),
        view: viewMatrix,
        proj: projectionMatrix,
        scale: scaleMatrix,
        resolution: resolutionMatrix,
        model: modelMatrix || new Matrix4(),
        normals,
        distances
      })).draw();
    }
  }
  loadTexture(channelData) {
    const textures = {
      volume0: null,
      volume1: null,
      volume2: null,
      volume3: null,
      volume4: null,
      volume5: null
    };
    if (this.state.textures) {
      Object.values(this.state.textures).forEach((tex) => tex && tex.delete());
    }
    if (channelData && Object.keys(channelData).length > 0 && channelData.data) {
      const { height, width, depth } = channelData;
      channelData.data.forEach((d, i) => {
        textures[`volume${i}`] = this.dataToTexture(d, width, height, depth);
      }, this);
      this.setState({
        textures,
        scaleMatrix: new Matrix4().scale(this.props.physicalSizeScalingMatrix.transformPoint([
          width,
          height,
          depth
        ]))
      });
    }
  }
  dataToTexture(data, width, height, depth) {
    var _a2, _b2;
    const attrs = getRenderingAttrs();
    const texture = new Texture3D(this.context.gl, {
      width,
      height,
      depth,
      data: (_b2 = (_a2 = attrs.cast) == null ? void 0 : _a2.call(attrs, data)) != null ? _b2 : data,
      format: attrs.dataFormat,
      dataFormat: attrs.format,
      type: attrs.type,
      mipmaps: false,
      parameters: {
        [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,
        [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,
        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,
        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE,
        [GL.TEXTURE_WRAP_R]: GL.CLAMP_TO_EDGE
      }
    });
    return texture;
  }
};
XR3DLayer.layerName = "XR3DLayer";
XR3DLayer.defaultProps = defaultProps$1;
function getVolume(_0) {
  return __async(this, arguments, function* ({
    source,
    selection,
    onUpdate = () => {
    },
    downsampleDepth = 1,
    signal
  }) {
    const { shape, labels, dtype } = source;
    const { height, width } = getImageSize(source);
    const depth = shape[labels.indexOf("z")];
    const depthDownsampled = Math.max(1, Math.floor(depth / downsampleDepth));
    const rasterSize = height * width;
    const name2 = `${dtype}Array`;
    const TypedArray = globalThis[name2];
    const volumeData = new TypedArray(rasterSize * depthDownsampled);
    yield Promise.all(new Array(depthDownsampled).fill(0).map((_, z) => __async(this, null, function* () {
      const depthSelection = __spreadProps(__spreadValues({}, selection), {
        z: z * downsampleDepth
      });
      const { data: rasterData } = yield source.getRaster({
        selection: depthSelection,
        signal
      });
      let r = 0;
      onUpdate();
      while (r < rasterSize) {
        const volIndex = z * rasterSize + (rasterSize - r - 1);
        const rasterIndex = (width - r - 1) % width + width * Math.floor(r / width);
        volumeData[volIndex] = rasterData[rasterIndex];
        r += 1;
      }
      onUpdate();
    })));
    return {
      data: volumeData,
      height,
      width,
      depth: depthDownsampled
    };
  });
}
var getTextLayer = (text, viewport, id) => {
  return new TextLayer({
    id: `text-${id}`,
    coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN,
    data: [
      {
        text,
        position: viewport.position
      }
    ],
    getColor: [220, 220, 220, 255],
    getSize: 25,
    sizeUnits: "meters",
    sizeScale: __pow(2, -viewport.zoom),
    fontFamily: "Helvetica"
  });
};
var defaultProps = {
  pickable: false,
  coordinateSystem: COORDINATE_SYSTEM2.CARTESIAN,
  contrastLimits: { type: "array", value: [], compare: true },
  channelsVisible: { type: "array", value: [], compare: true },
  colors: { type: "array", value: [], compare: true },
  colormap: { type: "string", value: "", compare: true },
  selections: { type: "array", value: [], compare: true },
  resolution: { type: "number", value: 0, compare: true },
  domain: { type: "array", value: [], compare: true },
  loader: {
    type: "object",
    value: [
      {
        getRaster: () => __async(void 0, null, function* () {
          return { data: [], height: 0, width: 0 };
        }),
        dtype: "Uint16",
        shape: [1],
        labels: ["z"]
      }
    ],
    compare: true
  },
  xSlice: { type: "array", value: null, compare: true },
  ySlice: { type: "array", value: null, compare: true },
  zSlice: { type: "array", value: null, compare: true },
  clippingPlanes: { type: "array", value: [], compare: true },
  renderingMode: {
    type: "string",
    value: RENDERING_MODES.MAX_INTENSITY_PROJECTION,
    compare: true
  },
  onUpdate: { type: "function", value: () => {
  }, compare: true },
  useProgressIndicator: { type: "boolean", value: true, compare: true },
  useWebGL1Warning: { type: "boolean", value: true, compare: true }
};
var VolumeLayer = class extends CompositeLayer {
  clearState() {
    this.setState({
      height: null,
      width: null,
      depth: null,
      data: null,
      physicalSizeScalingMatrix: null,
      resolutionMatrix: null,
      progress: 0,
      abortController: null
    });
  }
  finalizeState() {
    this.state.abortController.abort();
  }
  updateState({ oldProps, props }) {
    const loaderChanged = props.loader !== oldProps.loader;
    const resolutionChanged = props.resolution !== oldProps.resolution;
    const selectionsChanged = props.selections !== oldProps.selections;
    if (resolutionChanged) {
      this.clearState();
    }
    if (loaderChanged || selectionsChanged || resolutionChanged) {
      const {
        loader,
        selections = [],
        resolution,
        onViewportLoad
      } = this.props;
      const source = loader[resolution];
      let progress = 0;
      const totalRequests = (source.shape[source.labels.indexOf("z")] >> resolution) * selections.length;
      const onUpdate = () => {
        progress += 0.5 / totalRequests;
        if (this.props.onUpdate) {
          this.props.onUpdate({ progress });
        }
        this.setState({ progress });
      };
      const abortController = new AbortController();
      this.setState({ abortController });
      const { signal } = abortController;
      const volumePromises = selections.map((selection) => getVolume({
        selection,
        source,
        onUpdate,
        downsampleDepth: __pow(2, resolution),
        signal
      }));
      const physicalSizeScalingMatrix = getPhysicalSizeScalingMatrix(loader[resolution]);
      Promise.all(volumePromises).then((volumes) => {
        if (onViewportLoad) {
          onViewportLoad(volumes);
        }
        const volume = {
          data: volumes.map((d) => d.data),
          width: volumes[0].width,
          height: volumes[0].height,
          depth: volumes[0].depth
        };
        this.setState(__spreadProps(__spreadValues({}, volume), {
          physicalSizeScalingMatrix,
          resolutionMatrix: new Matrix4().scale(__pow(2, resolution))
        }));
      });
    }
  }
  renderLayers() {
    const {
      loader,
      id,
      resolution,
      useProgressIndicator,
      useWebGL1Warning
    } = this.props;
    const { dtype } = loader[resolution];
    const {
      data,
      width,
      height,
      depth,
      progress,
      physicalSizeScalingMatrix,
      resolutionMatrix
    } = this.state;
    const { gl } = this.context;
    if (!isWebGL2(gl) && useWebGL1Warning) {
      const { viewport } = this.context;
      return getTextLayer([
        "Volume rendering is only available on browsers that support WebGL2. If you",
        "are using Safari, you can turn on WebGL2 by navigating in the top menubar",
        "to check Develop > Experimental Features > WebGL 2.0 and then refreshing",
        "the page."
      ].join("\n"), viewport, id);
    }
    if (!(width && height) && useProgressIndicator) {
      const { viewport } = this.context;
      return getTextLayer(`Loading Volume ${String((progress || 0) * 100).slice(0, 5)}%...`, viewport, id);
    }
    return new XR3DLayer(this.props, {
      channelData: { data, width, height, depth },
      id: `XR3DLayer-${0}-${height}-${width}-${0}-${resolution}-${id}`,
      physicalSizeScalingMatrix,
      parameters: {
        [GL.CULL_FACE]: true,
        [GL.CULL_FACE_MODE]: GL.FRONT,
        [GL.DEPTH_TEST]: false,
        blendFunc: [GL.SRC_ALPHA, GL.ONE],
        blend: true
      },
      resolutionMatrix,
      dtype
    });
  }
};
VolumeLayer.layerName = "VolumeLayer";
VolumeLayer.defaultProps = defaultProps;
var VIV_PROXY_KEY = "__viv";
var OFFSETS_PROXY_KEY = `${VIV_PROXY_KEY}-offsets`;
function checkProxies(tiff) {
  if (!isProxy(tiff, OFFSETS_PROXY_KEY)) {
    console.warn("GeoTIFF source is missing offsets proxy.");
  }
}
function isProxy(tiff, proxyFlag) {
  return tiff[proxyFlag];
}
function createOffsetsProxy(tiff, offsets) {
  const get = (target, key) => {
    if (key === "getImage") {
      return (index) => {
        if (!(index in target.ifdRequests) && index in offsets) {
          const offset = offsets[index];
          target.ifdRequests[index] = target.parseFileDirectoryAt(offset);
        }
        return target.getImage(index);
      };
    }
    if (key === OFFSETS_PROXY_KEY) {
      return true;
    }
    return Reflect.get(target, key);
  };
  return new Proxy(tiff, { get });
}
var encodedJs = "KGZ1bmN0aW9uICgpIHsKICAndXNlIHN0cmljdCc7CgogIGZ1bmN0aW9uIGRlY29kZVJvd0FjYyhyb3csIHN0cmlkZSkgewogICAgbGV0IGxlbmd0aCA9IHJvdy5sZW5ndGggLSBzdHJpZGU7CiAgICBsZXQgb2Zmc2V0ID0gMDsKICAgIGRvIHsKICAgICAgZm9yIChsZXQgaSA9IHN0cmlkZTsgaSA+IDA7IGktLSkgewogICAgICAgIHJvd1tvZmZzZXQgKyBzdHJpZGVdICs9IHJvd1tvZmZzZXRdOwogICAgICAgIG9mZnNldCsrOwogICAgICB9CgogICAgICBsZW5ndGggLT0gc3RyaWRlOwogICAgfSB3aGlsZSAobGVuZ3RoID4gMCk7CiAgfQoKICBmdW5jdGlvbiBkZWNvZGVSb3dGbG9hdGluZ1BvaW50KHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSkgewogICAgbGV0IGluZGV4ID0gMDsKICAgIGxldCBjb3VudCA9IHJvdy5sZW5ndGg7CiAgICBjb25zdCB3YyA9IGNvdW50IC8gYnl0ZXNQZXJTYW1wbGU7CgogICAgd2hpbGUgKGNvdW50ID4gc3RyaWRlKSB7CiAgICAgIGZvciAobGV0IGkgPSBzdHJpZGU7IGkgPiAwOyAtLWkpIHsKICAgICAgICByb3dbaW5kZXggKyBzdHJpZGVdICs9IHJvd1tpbmRleF07CiAgICAgICAgKytpbmRleDsKICAgICAgfQogICAgICBjb3VudCAtPSBzdHJpZGU7CiAgICB9CgogICAgY29uc3QgY29weSA9IHJvdy5zbGljZSgpOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3YzsgKytpKSB7CiAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYnl0ZXNQZXJTYW1wbGU7ICsrYikgewogICAgICAgIHJvd1soYnl0ZXNQZXJTYW1wbGUgKiBpKSArIGJdID0gY29weVsoKGJ5dGVzUGVyU2FtcGxlIC0gYiAtIDEpICogd2MpICsgaV07CiAgICAgIH0KICAgIH0KICB9CgogIGZ1bmN0aW9uIGFwcGx5UHJlZGljdG9yKGJsb2NrLCBwcmVkaWN0b3IsIHdpZHRoLCBoZWlnaHQsIGJpdHNQZXJTYW1wbGUsCiAgICBwbGFuYXJDb25maWd1cmF0aW9uKSB7CiAgICBpZiAoIXByZWRpY3RvciB8fCBwcmVkaWN0b3IgPT09IDEpIHsKICAgICAgcmV0dXJuIGJsb2NrOwogICAgfQoKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYml0c1BlclNhbXBsZS5sZW5ndGg7ICsraSkgewogICAgICBpZiAoYml0c1BlclNhbXBsZVtpXSAlIDggIT09IDApIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIG9ubHkgbXVsdGlwbGUgb2YgOCBiaXRzIGFyZSBzdXBwb3J0ZWQuJyk7CiAgICAgIH0KICAgICAgaWYgKGJpdHNQZXJTYW1wbGVbaV0gIT09IGJpdHNQZXJTYW1wbGVbMF0pIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIGFsbCBzYW1wbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaXplLicpOwogICAgICB9CiAgICB9CgogICAgY29uc3QgYnl0ZXNQZXJTYW1wbGUgPSBiaXRzUGVyU2FtcGxlWzBdIC8gODsKICAgIGNvbnN0IHN0cmlkZSA9IHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDIgPyAxIDogYml0c1BlclNhbXBsZS5sZW5ndGg7CgogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7ICsraSkgewogICAgICAvLyBMYXN0IHN0cmlwIHdpbGwgYmUgdHJ1bmNhdGVkIGlmIGhlaWdodCAlIHN0cmlwSGVpZ2h0ICE9IDAKICAgICAgaWYgKGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlID49IGJsb2NrLmJ5dGVMZW5ndGgpIHsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBsZXQgcm93OwogICAgICBpZiAocHJlZGljdG9yID09PSAyKSB7IC8vIGhvcml6b250YWwgcHJlZGljdGlvbgogICAgICAgIHN3aXRjaCAoYml0c1BlclNhbXBsZVswXSkgewogICAgICAgICAgY2FzZSA4OgogICAgICAgICAgICByb3cgPSBuZXcgVWludDhBcnJheSgKICAgICAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsCiAgICAgICAgICAgICk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAxNjoKICAgICAgICAgICAgcm93ID0gbmV3IFVpbnQxNkFycmF5KAogICAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSAvIDIsCiAgICAgICAgICAgICk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAzMjoKICAgICAgICAgICAgcm93ID0gbmV3IFVpbnQzMkFycmF5KAogICAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSAvIDQsCiAgICAgICAgICAgICk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmVkaWN0b3IgMiBub3QgYWxsb3dlZCB3aXRoICR7Yml0c1BlclNhbXBsZVswXX0gYml0cyBwZXIgc2FtcGxlLmApOwogICAgICAgIH0KICAgICAgICBkZWNvZGVSb3dBY2Mocm93LCBzdHJpZGUpOwogICAgICB9IGVsc2UgaWYgKHByZWRpY3RvciA9PT0gMykgeyAvLyBob3Jpem9udGFsIGZsb2F0aW5nIHBvaW50CiAgICAgICAgcm93ID0gbmV3IFVpbnQ4QXJyYXkoCiAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsCiAgICAgICAgKTsKICAgICAgICBkZWNvZGVSb3dGbG9hdGluZ1BvaW50KHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBibG9jazsKICB9CgogIGNsYXNzIEJhc2VEZWNvZGVyIHsKICAgIGFzeW5jIGRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpIHsKICAgICAgY29uc3QgZGVjb2RlZCA9IGF3YWl0IHRoaXMuZGVjb2RlQmxvY2soYnVmZmVyKTsKICAgICAgY29uc3QgcHJlZGljdG9yID0gZmlsZURpcmVjdG9yeS5QcmVkaWN0b3IgfHwgMTsKICAgICAgaWYgKHByZWRpY3RvciAhPT0gMSkgewogICAgICAgIGNvbnN0IGlzVGlsZWQgPSAhZmlsZURpcmVjdG9yeS5TdHJpcE9mZnNldHM7CiAgICAgICAgY29uc3QgdGlsZVdpZHRoID0gaXNUaWxlZCA/IGZpbGVEaXJlY3RvcnkuVGlsZVdpZHRoIDogZmlsZURpcmVjdG9yeS5JbWFnZVdpZHRoOwogICAgICAgIGNvbnN0IHRpbGVIZWlnaHQgPSBpc1RpbGVkID8gZmlsZURpcmVjdG9yeS5UaWxlTGVuZ3RoIDogKAogICAgICAgICAgZmlsZURpcmVjdG9yeS5Sb3dzUGVyU3RyaXAgfHwgZmlsZURpcmVjdG9yeS5JbWFnZUxlbmd0aAogICAgICAgICk7CiAgICAgICAgcmV0dXJuIGFwcGx5UHJlZGljdG9yKAogICAgICAgICAgZGVjb2RlZCwgcHJlZGljdG9yLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQsIGZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZSwKICAgICAgICAgIGZpbGVEaXJlY3RvcnkuUGxhbmFyQ29uZmlndXJhdGlvbiwKICAgICAgICApOwogICAgICB9CiAgICAgIHJldHVybiBkZWNvZGVkOwogICAgfQogIH0KCiAgY2xhc3MgUmF3RGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHsKICAgIGRlY29kZUJsb2NrKGJ1ZmZlcikgewogICAgICByZXR1cm4gYnVmZmVyOwogICAgfQogIH0KCiAgbGV0IEEsST1udWxsO2Z1bmN0aW9uIGcoKXtyZXR1cm4gbnVsbCE9PUkmJkkuYnVmZmVyPT09QS5tZW1vcnkuYnVmZmVyfHwoST1uZXcgVWludDhBcnJheShBLm1lbW9yeS5idWZmZXIpKSxJfWxldCBCPTA7bGV0IFE9bnVsbDtmdW5jdGlvbiBDKCl7cmV0dXJuIG51bGwhPT1RJiZRLmJ1ZmZlcj09PUEubWVtb3J5LmJ1ZmZlcnx8KFE9bmV3IEludDMyQXJyYXkoQS5tZW1vcnkuYnVmZmVyKSksUX1hc3luYyBmdW5jdGlvbiBFKEkpe3ZvaWQgMD09PUkmJihJPSIiLnJlcGxhY2UoL1wuanMkLywiX2JnLndhc20iKSk7KCJzdHJpbmciPT10eXBlb2YgSXx8ImZ1bmN0aW9uIj09dHlwZW9mIFJlcXVlc3QmJkkgaW5zdGFuY2VvZiBSZXF1ZXN0fHwiZnVuY3Rpb24iPT10eXBlb2YgVVJMJiZJIGluc3RhbmNlb2YgVVJMKSYmKEk9ZmV0Y2goSSkpO2NvbnN0e2luc3RhbmNlOmcsbW9kdWxlOkJ9PWF3YWl0IGFzeW5jIGZ1bmN0aW9uKEEsSSl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIFJlc3BvbnNlJiZBIGluc3RhbmNlb2YgUmVzcG9uc2Upe2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyl0cnl7cmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKEEsSSl9Y2F0Y2goSSl7aWYoImFwcGxpY2F0aW9uL3dhc20iPT1BLmhlYWRlcnMuZ2V0KCJDb250ZW50LVR5cGUiKSl0aHJvdyBJO2NvbnNvbGUud2FybigiYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nYCBmYWlsZWQgYmVjYXVzZSB5b3VyIHNlcnZlciBkb2VzIG5vdCBzZXJ2ZSB3YXNtIHdpdGggYGFwcGxpY2F0aW9uL3dhc21gIE1JTUUgdHlwZS4gRmFsbGluZyBiYWNrIHRvIGBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZWAgd2hpY2ggaXMgc2xvd2VyLiBPcmlnaW5hbCBlcnJvcjpcbiIsSSk7fWNvbnN0IGc9YXdhaXQgQS5hcnJheUJ1ZmZlcigpO3JldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShnLEkpfXtjb25zdCBnPWF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKEEsSSk7cmV0dXJuIGcgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZT97aW5zdGFuY2U6Zyxtb2R1bGU6QX06Z319KGF3YWl0IEkse30pO3JldHVybiBBPWcuZXhwb3J0cyxFLl9fd2JpbmRnZW5fd2FzbV9tb2R1bGU9QixBfXZhciBEPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRlY29tcHJlc3M6ZnVuY3Rpb24oSSxRKXt0cnl7Y29uc3QgRj1BLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTt2YXIgRT1mdW5jdGlvbihBLEkpe2NvbnN0IFE9SSgxKkEubGVuZ3RoKTtyZXR1cm4gZygpLnNldChBLFEvMSksQj1BLmxlbmd0aCxRfShJLEEuX193YmluZGdlbl9tYWxsb2MpLEQ9QjtBLmRlY29tcHJlc3MoRixFLEQsUSk7dmFyIGk9QygpW0YvNCswXSx3PUMoKVtGLzQrMV0sRz0obz1pLE49dyxnKCkuc3ViYXJyYXkoby8xLG8vMStOKSkuc2xpY2UoKTtyZXR1cm4gQS5fX3diaW5kZ2VuX2ZyZWUoaSwxKncpLEd9ZmluYWxseXtBLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO312YXIgbyxOO30sZGVmYXVsdDpFfSk7Y29uc3QgaT1bNjIsMCwwLDAsNjMsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsMCwwLDAsMCwwLDAsMCwwLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDAsMCwwLDAsMCwwLDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxXTtmdW5jdGlvbiB3KEEpe3JldHVybiBpW0EtNDNdfWNvbnN0IEc9ZnVuY3Rpb24oQSl7bGV0IEksZz1BLmVuZHNXaXRoKCI9PSIpPzI6QS5lbmRzV2l0aCgiPSIpPzE6MCxCPUEubGVuZ3RoLFE9bmV3IFVpbnQ4QXJyYXkoQi80KjMpO2ZvcihsZXQgZz0wLEM9MDtnPEI7Zys9NCxDKz0zKUk9dyhBLmNoYXJDb2RlQXQoZykpPDwxOHx3KEEuY2hhckNvZGVBdChnKzEpKTw8MTJ8dyhBLmNoYXJDb2RlQXQoZysyKSk8PDZ8dyhBLmNoYXJDb2RlQXQoZyszKSksUVtDXT1JPj4xNixRW0MrMV09ST4+OCYyNTUsUVtDKzJdPTI1NSZJO3JldHVybiBRLnN1YmFycmF5KDAsUS5sZW5ndGgtZyl9KCJBR0Z6YlFFQUFBQUJXUTVnQW45L0FYOWdBMzkvZndGL1lBSi9md0JnQVg4QVlBTi9mMzhBWUFGL0FYOWdCSDkvZjM4QVlBUi9mMzkvQVg5Z0JuOS9mMzkvZndCZ0FYOEJmbUFBQUdBRmYzOS9mMzhBWUFWL2YzOS9md0YvWUFKK2Z3Ri9BMjFzQlFnSUN3TUJBZ1VNQVFBQkFBSUFCUUFDQWdZR0RRWURBZ0FDQUFBRUJBUUNBZ1lHQUFZQkJnSUhBd1FEQkFRREF3QURCUU1EQkFRRUJBUUNBZ0FIQUFRQUFnTUJBZ2NGQkFJREFRVUNBZ0lEQWdJREF3Y0NBUUFBQkFJQUNnQUFBUUFGQWdBREJRa0pDUU1DQkFVQmNBRXJLd1VEQVFBUkJna0Jmd0ZCZ0lEQUFBc0hYd1VHYldWdGIzSjVBZ0FLWkdWamIyMXdjbVZ6Y3dBbkgxOWZkMkpwYm1SblpXNWZZV1JrWDNSdlgzTjBZV05yWDNCdmFXNTBaWElBWWhGZlgzZGlhVzVrWjJWdVgyMWhiR3h2WXdCTUQxOWZkMkpwYm1SblpXNWZabkpsWlFCV0NUQUJBRUVCQ3lwcUpEVUNabVZETlFGbVpVTmhhMnBYREQxcFZCb2hTVnRUYUdkZlhERU9YbGhxYVFzY1FXQWJQMlFLc3VnQmJOTXFBZ2gvQVg0Q1FBSkFBa0FDUUNBQVFmVUJUd1JBSUFCQnpmOTdUdzBDSUFCQkMyb2lBRUY0Y1NFR1FaQ253QUFvQWdBaUNFVU5BVUVBSUFacklRUUNRQUpBQW45QkFDQUFRUWgySWdCRkRRQWFRUjhnQmtILy8vOEhTdzBBR2lBR1FRWWdBR2NpQUd0QkgzRjJRUUZ4SUFCQkFYUnJRVDVxQ3lJSFFRSjBRWnlwd0FCcUtBSUFJZ0FFUUNBR1FRQkJHU0FIUVFGMmEwRWZjU0FIUVI5R0czUWhBZ05BQWtBZ0FFRUVhaWdDQUVGNGNTSUZJQVpKRFFBZ0JTQUdheUlGSUFSUERRQWdBQ0VESUFVaUJBMEFRUUFoQkF3REN5QUFRUlJxS0FJQUlnVWdBU0FGSUFBZ0FrRWRka0VFY1dwQkVHb29BZ0FpQUVjYklBRWdCUnNoQVNBQ1FRRjBJUUlnQUEwQUN5QUJCRUFnQVNFQURBSUxJQU1OQWd0QkFDRURRUUlnQjBFZmNYUWlBRUVBSUFCcmNpQUljU0lBUlEwRElBQkJBQ0FBYTNGb1FRSjBRWnlwd0FCcUtBSUFJZ0JGRFFNTEEwQWdBQ0FESUFCQkJHb29BZ0JCZUhFaUFpQUdUeUFDSUFacklnSWdCRWx4SWdFYklRTWdBaUFFSUFFYklRUWdBQ2dDRUNJQ0JIOGdBZ1VnQUVFVWFpZ0NBQXNpQUEwQUN5QURSUTBDQzBHY3FzQUFLQUlBSWdBZ0JrOUJBQ0FFSUFBZ0JtdFBHdzBCSUFNb0FoZ2hCd0pBQWtBZ0F5QURLQUlNSWdGR0JFQWdBMEVVUVJBZ0EwRVVhaUlDS0FJQUlnRWJhaWdDQUNJQURRRkJBQ0VCREFJTElBTW9BZ2dpQUNBQk5nSU1JQUVnQURZQ0NBd0JDeUFDSUFOQkVHb2dBUnNoQWdOQUlBSWhCU0FBSWdGQkZHb2lBaWdDQUNJQVJRUkFJQUZCRUdvaEFpQUJLQUlRSVFBTElBQU5BQXNnQlVFQU5nSUFDd0pBSUFkRkRRQUNRQ0FESUFNb0FoeEJBblJCbktuQUFHb2lBQ2dDQUVjRVFDQUhRUkJCRkNBSEtBSVFJQU5HRzJvZ0FUWUNBQ0FCUlEwQ0RBRUxJQUFnQVRZQ0FDQUJEUUJCa0tmQUFFR1FwOEFBS0FJQVFYNGdBeWdDSEhkeE5nSUFEQUVMSUFFZ0J6WUNHQ0FES0FJUUlnQUVRQ0FCSUFBMkFoQWdBQ0FCTmdJWUN5QURRUlJxS0FJQUlnQkZEUUFnQVVFVWFpQUFOZ0lBSUFBZ0FUWUNHQXNDUUNBRVFSQlBCRUFnQXlBR1FRTnlOZ0lFSUFNZ0Jtb2lCU0FFUVFGeU5nSUVJQVFnQldvZ0JEWUNBQ0FFUVlBQ1R3UkFJQVZDQURjQ0VDQUZBbjlCQUNBRVFRaDJJZ0JGRFFBYVFSOGdCRUgvLy84SFN3MEFHaUFFUVFZZ0FHY2lBR3RCSDNGMlFRRnhJQUJCQVhSclFUNXFDeUlBTmdJY0lBQkJBblJCbktuQUFHb2hBZ0pBQWtBQ1FBSkFRWkNud0FBb0FnQWlBVUVCSUFCQkgzRjBJZ1p4QkVBZ0FpZ0NBQ0lDUVFScUtBSUFRWGh4SUFSSERRRWdBaUVBREFJTFFaQ253QUFnQVNBR2NqWUNBQ0FDSUFVMkFnQU1Bd3NnQkVFQVFSa2dBRUVCZG10QkgzRWdBRUVmUmh0MElRRURRQ0FDSUFGQkhYWkJCSEZxUVJCcUlnWW9BZ0FpQUVVTkFpQUJRUUYwSVFFZ0FDRUNJQUJCQkdvb0FnQkJlSEVnQkVjTkFBc0xJQUFvQWdnaUFpQUZOZ0lNSUFBZ0JUWUNDQ0FGUVFBMkFoZ2dCU0FBTmdJTUlBVWdBallDQ0F3RUN5QUdJQVUyQWdBTElBVWdBallDR0NBRklBVTJBZ3dnQlNBRk5nSUlEQUlMSUFSQkEzWWlBa0VEZEVHVXA4QUFhaUVBQW45QmpLZkFBQ2dDQUNJQlFRRWdBblFpQW5FRVFDQUFLQUlJREFFTFFZeW53QUFnQVNBQ2NqWUNBQ0FBQ3lFQ0lBQWdCVFlDQ0NBQ0lBVTJBZ3dnQlNBQU5nSU1JQVVnQWpZQ0NBd0JDeUFESUFRZ0Jtb2lBRUVEY2pZQ0JDQUFJQU5xSWdBZ0FDZ0NCRUVCY2pZQ0JBc2dBMEVJYWc4TEFrQUNRRUdNcDhBQUtBSUFJZ0ZCRUNBQVFRdHFRWGh4SUFCQkMwa2JJZ1pCQTNZaUFIWWlBa0VEY1VVRVFDQUdRWnlxd0FBb0FnQk5EUU1nQWcwQlFaQ253QUFvQWdBaUFFVU5BeUFBUVFBZ0FHdHhhRUVDZEVHY3FjQUFhaWdDQUNJQlFRUnFLQUlBUVhoeElBWnJJUVFnQVNFQ0EwQWdBU2dDRUNJQVJRUkFJQUZCRkdvb0FnQWlBRVVOQkFzZ0FFRUVhaWdDQUVGNGNTQUdheUlCSUFRZ0FTQUVTU0lCR3lFRUlBQWdBaUFCR3lFQ0lBQWhBUXdBQ3dBTEFrQWdBa0YvYzBFQmNTQUFhaUlBUVFOMFFZeW53QUJxSWdOQkVHb29BZ0FpQWtFSWFpSUZLQUlBSWdRZ0EwRUlhaUlEUndSQUlBUWdBellDRENBRElBUTJBZ2dNQVF0QmpLZkFBQ0FCUVg0Z0FIZHhOZ0lBQ3lBQ0lBQkJBM1FpQUVFRGNqWUNCQ0FBSUFKcUlnQWdBQ2dDQkVFQmNqWUNCQ0FGRHdzQ1FFRUNJQUIwSWdSQkFDQUVhM0lnQWlBQWRIRWlBRUVBSUFCcmNXZ2lBa0VEZEVHTXA4QUFhaUlEUVJCcUtBSUFJZ0JCQ0dvaUJTZ0NBQ0lFSUFOQkNHb2lBMGNFUUNBRUlBTTJBZ3dnQXlBRU5nSUlEQUVMUVl5bndBQWdBVUYrSUFKM2NUWUNBQXNnQUNBR1FRTnlOZ0lFSUFBZ0Jtb2lBeUFDUVFOMElnSWdCbXNpQVVFQmNqWUNCQ0FBSUFKcUlBRTJBZ0JCbktyQUFDZ0NBQ0lBQkVBZ0FFRURkaUlFUVFOMFFaU253QUJxSVFCQnBLckFBQ2dDQUNFQ0FuOUJqS2ZBQUNnQ0FDSUdRUUVnQkVFZmNYUWlCSEVFUUNBQUtBSUlEQUVMUVl5bndBQWdCQ0FHY2pZQ0FDQUFDeUVFSUFBZ0FqWUNDQ0FFSUFJMkFnd2dBaUFBTmdJTUlBSWdCRFlDQ0F0QnBLckFBQ0FETmdJQVFaeXF3QUFnQVRZQ0FDQUZEd3NnQWlnQ0dDRUhBa0FDUUNBQ0lBSW9BZ3dpQVVZRVFDQUNRUlJCRUNBQ1FSUnFJZ0VvQWdBaUF4dHFLQUlBSWdBTkFVRUFJUUVNQWdzZ0FpZ0NDQ0lBSUFFMkFnd2dBU0FBTmdJSURBRUxJQUVnQWtFUWFpQURHeUVEQTBBZ0F5RUZJQUFpQVVFVWFpSURLQUlBSWdCRkJFQWdBVUVRYWlFRElBRW9BaEFoQUFzZ0FBMEFDeUFGUVFBMkFnQUxJQWRGRFFNZ0FpQUNLQUljUVFKMFFaeXB3QUJxSWdBb0FnQkhCRUFnQjBFUVFSUWdCeWdDRUNBQ1JodHFJQUUyQWdBZ0FVVU5CQXdEQ3lBQUlBRTJBZ0FnQVEwQ1FaQ253QUJCa0tmQUFDZ0NBRUYrSUFJb0FoeDNjVFlDQUF3REN3SkFBa0FDUUFKQUFrQkJuS3JBQUNnQ0FDSUFJQVpKQkVCQm9LckFBQ2dDQUNJQUlBWkxEUU5CQUNFQ0lBWkJyNEFFYWlJQVFSQjJRQUFpQVVGL1JnMEdJQUZCRUhRaUJVVU5Ca0dzcXNBQUlBQkJnSUI4Y1NJRVFheXF3QUFvQWdCcUlnQTJBZ0JCc0tyQUFFR3dxc0FBS0FJQUlnRWdBQ0FCSUFCTEd6WUNBRUdvcXNBQUtBSUFJZ05GRFFGQnRLckFBQ0VBQTBBZ0FDZ0NBQ0lCSUFBb0FnUWlCMm9nQlVZTkF5QUFLQUlJSWdBTkFBc01CQXRCcEtyQUFDZ0NBQ0VDQW44Z0FDQUdheUlCUVE5TkJFQkJwS3JBQUVFQU5nSUFRWnlxd0FCQkFEWUNBQ0FDSUFCQkEzSTJBZ1FnQUNBQ2FpSUJRUVJxSVFBZ0FTZ0NCRUVCY2d3QkMwR2Nxc0FBSUFFMkFnQkJwS3JBQUNBQ0lBWnFJZ1EyQWdBZ0JDQUJRUUZ5TmdJRUlBQWdBbW9nQVRZQ0FDQUNRUVJxSVFBZ0JrRURjZ3NoQVNBQUlBRTJBZ0FnQWtFSWFnOExRY2lxd0FBb0FnQWlBRUVBSUFBZ0JVMGJSUVJBUWNpcXdBQWdCVFlDQUF0QnpLckFBRUgvSHpZQ0FFRzBxc0FBSUFVMkFnQkJ3S3JBQUVFQU5nSUFRYmlxd0FBZ0JEWUNBRUdncDhBQVFaU253QUEyQWdCQnFLZkFBRUdjcDhBQU5nSUFRWnlud0FCQmxLZkFBRFlDQUVHd3A4QUFRYVNud0FBMkFnQkJwS2ZBQUVHY3A4QUFOZ0lBUWJpbndBQkJyS2ZBQURZQ0FFR3NwOEFBUWFTbndBQTJBZ0JCd0tmQUFFRzBwOEFBTmdJQVFiU253QUJCcktmQUFEWUNBRUhJcDhBQVFieW53QUEyQWdCQnZLZkFBRUcwcDhBQU5nSUFRZENud0FCQnhLZkFBRFlDQUVIRXA4QUFRYnlud0FBMkFnQkIyS2ZBQUVITXA4QUFOZ0lBUWN5bndBQkJ4S2ZBQURZQ0FFSGdwOEFBUWRTbndBQTJBZ0JCMUtmQUFFSE1wOEFBTmdJQVFkeW53QUJCMUtmQUFEWUNBRUhvcDhBQVFkeW53QUEyQWdCQjVLZkFBRUhjcDhBQU5nSUFRZkNud0FCQjVLZkFBRFlDQUVIc3A4QUFRZVNud0FBMkFnQkIrS2ZBQUVIc3A4QUFOZ0lBUWZTbndBQkI3S2ZBQURZQ0FFR0FxTUFBUWZTbndBQTJBZ0JCL0tmQUFFSDBwOEFBTmdJQVFZaW93QUJCL0tmQUFEWUNBRUdFcU1BQVFmeW53QUEyQWdCQmtLakFBRUdFcU1BQU5nSUFRWXlvd0FCQmhLakFBRFlDQUVHWXFNQUFRWXlvd0FBMkFnQkJsS2pBQUVHTXFNQUFOZ0lBUWFDb3dBQkJsS2pBQURZQ0FFR29xTUFBUVp5b3dBQTJBZ0JCbktqQUFFR1VxTUFBTmdJQVFiQ293QUJCcEtqQUFEWUNBRUdrcU1BQVFaeW93QUEyQWdCQnVLakFBRUdzcU1BQU5nSUFRYXlvd0FCQnBLakFBRFlDQUVIQXFNQUFRYlNvd0FBMkFnQkJ0S2pBQUVHc3FNQUFOZ0lBUWNpb3dBQkJ2S2pBQURZQ0FFRzhxTUFBUWJTb3dBQTJBZ0JCMEtqQUFFSEVxTUFBTmdJQVFjU293QUJCdktqQUFEWUNBRUhZcU1BQVFjeW93QUEyQWdCQnpLakFBRUhFcU1BQU5nSUFRZUNvd0FCQjFLakFBRFlDQUVIVXFNQUFRY3lvd0FBMkFnQkI2S2pBQUVIY3FNQUFOZ0lBUWR5b3dBQkIxS2pBQURZQ0FFSHdxTUFBUWVTb3dBQTJBZ0JCNUtqQUFFSGNxTUFBTmdJQVFmaW93QUJCN0tqQUFEWUNBRUhzcU1BQVFlU293QUEyQWdCQmdLbkFBRUgwcU1BQU5nSUFRZlNvd0FCQjdLakFBRFlDQUVHSXFjQUFRZnlvd0FBMkFnQkIvS2pBQUVIMHFNQUFOZ0lBUVpDcHdBQkJoS25BQURZQ0FFR0VxY0FBUWZ5b3dBQTJBZ0JCbUtuQUFFR01xY0FBTmdJQVFZeXB3QUJCaEtuQUFEWUNBRUdvcXNBQUlBVTJBZ0JCbEtuQUFFR01xY0FBTmdJQVFhQ3F3QUFnQkVGWWFpSUFOZ0lBSUFVZ0FFRUJjallDQkNBQUlBVnFRU2cyQWdSQnhLckFBRUdBZ0lBQk5nSUFEQU1MSUFCQkRHb29BZ0FnQlNBRFRYSWdBU0FEUzNJTkFTQUFJQVFnQjJvMkFnUkJxS3JBQUVHb3FzQUFLQUlBSWdCQkQycEJlSEVpQVVGNGFqWUNBRUdncXNBQVFhQ3F3QUFvQWdBZ0JHb2lCQ0FBSUFGcmFrRUlhaUlETmdJQUlBRkJmR29nQTBFQmNqWUNBQ0FBSUFScVFTZzJBZ1JCeEtyQUFFR0FnSUFCTmdJQURBSUxRYUNxd0FBZ0FDQUdheUlDTmdJQVFhaXF3QUJCcUtyQUFDZ0NBQ0lBSUFacUlnRTJBZ0FnQVNBQ1FRRnlOZ0lFSUFBZ0JrRURjallDQkNBQVFRaHFJUUlNQWd0QnlLckFBRUhJcXNBQUtBSUFJZ0FnQlNBQUlBVkpHellDQUNBRUlBVnFJUUZCdEtyQUFDRUFBa0FEUUNBQklBQW9BZ0JIQkVBZ0FDZ0NDQ0lBRFFFTUFnc0xJQUJCREdvb0FnQU5BQ0FBSUFVMkFnQWdBQ0FBS0FJRUlBUnFOZ0lFSUFVZ0JrRURjallDQkNBRklBWnFJUUFnQVNBRmF5QUdheUVHQWtBQ1FDQUJRYWlxd0FBb0FnQkhCRUJCcEtyQUFDZ0NBQ0FCUmcwQklBRkJCR29vQWdBaUFrRURjVUVCUmdSQUlBRWdBa0Y0Y1NJQ0VCRWdBaUFHYWlFR0lBRWdBbW9oQVFzZ0FTQUJLQUlFUVg1eE5nSUVJQUFnQmtFQmNqWUNCQ0FBSUFacUlBWTJBZ0FnQmtHQUFrOEVRQ0FBUWdBM0FoQWdBQUovUVFBZ0JrRUlkaUlDUlEwQUdrRWZJQVpCLy8vL0Iwc05BQm9nQmtFR0lBSm5JZ0pyUVI5eGRrRUJjU0FDUVFGMGEwRSthZ3NpQVRZQ0hDQUJRUUowUVp5cHdBQnFJUUlDUUFKQUFrQUNRRUdRcDhBQUtBSUFJZ1JCQVNBQlFSOXhkQ0lEY1FSQUlBSW9BZ0FpQWtFRWFpZ0NBRUY0Y1NBR1J3MEJJQUloQkF3Q0MwR1FwOEFBSUFNZ0JISTJBZ0FnQWlBQU5nSUFEQU1MSUFaQkFFRVpJQUZCQVhaclFSOXhJQUZCSDBZYmRDRUJBMEFnQWlBQlFSMTJRUVJ4YWtFUWFpSURLQUlBSWdSRkRRSWdBVUVCZENFQklBUWlBa0VFYWlnQ0FFRjRjU0FHUncwQUN3c2dCQ2dDQ0NJQ0lBQTJBZ3dnQkNBQU5nSUlJQUJCQURZQ0dDQUFJQVEyQWd3Z0FDQUNOZ0lJREFVTElBTWdBRFlDQUFzZ0FDQUNOZ0lZSUFBZ0FEWUNEQ0FBSUFBMkFnZ01Bd3NnQmtFRGRpSUJRUU4wUVpTbndBQnFJUUlDZjBHTXA4QUFLQUlBSWdSQkFTQUJkQ0lCY1FSQUlBSW9BZ2dNQVF0QmpLZkFBQ0FCSUFSeU5nSUFJQUlMSVFFZ0FpQUFOZ0lJSUFFZ0FEWUNEQ0FBSUFJMkFnd2dBQ0FCTmdJSURBSUxRYWlxd0FBZ0FEWUNBRUdncXNBQVFhQ3F3QUFvQWdBZ0Jtb2lBallDQUNBQUlBSkJBWEkyQWdRTUFRdEJwS3JBQUNBQU5nSUFRWnlxd0FCQm5LckFBQ2dDQUNBR2FpSUNOZ0lBSUFBZ0FrRUJjallDQkNBQUlBSnFJQUkyQWdBTElBVkJDR29QQzBHMHFzQUFJUUFEUUFKQUlBQW9BZ0FpQVNBRFRRUkFJQUVnQUNnQ0JHb2lCeUFEU3cwQkN5QUFLQUlJSVFBTUFRc0xRYWlxd0FBZ0JUWUNBRUdncXNBQUlBUkJXR29pQURZQ0FDQUZJQUJCQVhJMkFnUWdBQ0FGYWtFb05nSUVRY1Nxd0FCQmdJQ0FBVFlDQUNBRElBZEJZR3BCZUhGQmVHb2lBQ0FBSUFOQkVHcEpHeUlCUVJzMkFnUkJ0S3JBQUNrQ0FDRUpJQUZCRUdwQnZLckFBQ2tDQURjQ0FDQUJJQWszQWdoQndLckFBRUVBTmdJQVFiaXF3QUFnQkRZQ0FFRzBxc0FBSUFVMkFnQkJ2S3JBQUNBQlFRaHFOZ0lBSUFGQkhHb2hBQU5BSUFCQkJ6WUNBQ0FISUFCQkJHb2lBRXNOQUFzZ0FTQURSZzBBSUFFZ0FTZ0NCRUYrY1RZQ0JDQURJQUVnQTJzaUJVRUJjallDQkNBQklBVTJBZ0FnQlVHQUFrOEVRQ0FEUWdBM0FoQWdBMEVjYWdKL1FRQWdCVUVJZGlJQVJRMEFHa0VmSUFWQi8vLy9CMHNOQUJvZ0JVRUdJQUJuSWdCclFSOXhka0VCY1NBQVFRRjBhMEUrYWdzaUFEWUNBQ0FBUVFKMFFaeXB3QUJxSVFFQ1FBSkFBa0FDUUVHUXA4QUFLQUlBSWdSQkFTQUFRUjl4ZENJSGNRUkFJQUVvQWdBaUJFRUVhaWdDQUVGNGNTQUZSdzBCSUFRaEFBd0NDMEdRcDhBQUlBUWdCM0kyQWdBZ0FTQUROZ0lBSUFOQkdHb2dBVFlDQUF3REN5QUZRUUJCR1NBQVFRRjJhMEVmY1NBQVFSOUdHM1FoQVFOQUlBUWdBVUVkZGtFRWNXcEJFR29pQnlnQ0FDSUFSUTBDSUFGQkFYUWhBU0FBSVFRZ0FFRUVhaWdDQUVGNGNTQUZSdzBBQ3dzZ0FDZ0NDQ0lCSUFNMkFnd2dBQ0FETmdJSUlBTkJHR3BCQURZQ0FDQURJQUEyQWd3Z0F5QUJOZ0lJREFNTElBY2dBellDQUNBRFFSaHFJQVEyQWdBTElBTWdBellDRENBRElBTTJBZ2dNQVFzZ0JVRURkaUlCUVFOMFFaU253QUJxSVFBQ2YwR01wOEFBS0FJQUlnUkJBU0FCZENJQmNRUkFJQUFvQWdnTUFRdEJqS2ZBQUNBQklBUnlOZ0lBSUFBTElRRWdBQ0FETmdJSUlBRWdBellDRENBRElBQTJBZ3dnQXlBQk5nSUlDMEdncXNBQUtBSUFJZ0FnQmswTkFFR2dxc0FBSUFBZ0Jtc2lBallDQUVHb3FzQUFRYWlxd0FBb0FnQWlBQ0FHYWlJQk5nSUFJQUVnQWtFQmNqWUNCQ0FBSUFaQkEzSTJBZ1FnQUVFSWFnOExJQUlQQ3lBQklBYzJBaGdnQWlnQ0VDSUFCRUFnQVNBQU5nSVFJQUFnQVRZQ0dBc2dBa0VVYWlnQ0FDSUFSUTBBSUFGQkZHb2dBRFlDQUNBQUlBRTJBaGdMQWtBZ0JFRVFUd1JBSUFJZ0JrRURjallDQkNBQ0lBWnFJZ01nQkVFQmNqWUNCQ0FESUFScUlBUTJBZ0JCbktyQUFDZ0NBQ0lBQkVBZ0FFRURkaUlGUVFOMFFaU253QUJxSVFCQnBLckFBQ2dDQUNFQkFuOUJqS2ZBQUNnQ0FDSUdRUUVnQlVFZmNYUWlCWEVFUUNBQUtBSUlEQUVMUVl5bndBQWdCU0FHY2pZQ0FDQUFDeUVGSUFBZ0FUWUNDQ0FGSUFFMkFnd2dBU0FBTmdJTUlBRWdCVFlDQ0F0QnBLckFBQ0FETmdJQVFaeXF3QUFnQkRZQ0FBd0JDeUFDSUFRZ0Jtb2lBRUVEY2pZQ0JDQUFJQUpxSWdBZ0FDZ0NCRUVCY2pZQ0JBc2dBa0VJYWd2aEVBSVNmd0orSXdCQmdBRnJJZ1lrQUNBR0lBTTJBaXdnQmlBQ05nSW9Ba0FDZndKQUFrQUNRQUpBSUFFdEFFZEZCRUFnQVNrRE9DRVlJQUZDQURjRE9BSi9JQmhDLy84RGcxQkZCRUFnR0VJd2lLY2hFU0FZUWhDSXB5RU1JQmhDSUlpbkRBRUxJQVpCSUdvZ0FTQUdRU2hxRUNzZ0JpOEJJRVVFUUVFQklRME1CZ3RCQXlFTklBWXZBU0lpRENJQ0lBRXZBVUJQRFFVZ0FpQUJMd0ZDUmcwQ0lBRXZBVVFnREVILy93TnhSZzBESUFGQkdHb29BZ0JGRFFVZ0FVRW9haUFCUVJCcUlnY2dEQkFtR2lBQktBSVlJZ0lnREVILy93TnhJZ3BORFFRZ0J5Z0NBQ0FLUVFKMGFpSUNMUUFDSVJFZ0FpOEJBQXNoRXlBR1FSaHFJQUZCS0dvUVFpQUdLQUlZSVFJQ1FDQUdLQUljSWdjZ0JVMEVRQ0FIRFFGQkFTRVNRUUVoRFNBRklRZEJBUXdIQ3lBRlJRUkFRUUVoRFVFQUlRZEJBUXdIQ3lBRUlBSWdCUkJMR2lBQlFUQnFJZ0lnQWlnQ0FDQUZhallDQUVHSWc4QUFJUVJCQUNFTlFRQWhCMEVCREFZTElBUWdBaUFIRUVzZ0FVRXdhaUlDSUFJb0FnQWdCMm8yQWdBZ0Iyb2hCQ0FGSUFkcklRZEJBQ0VOUVFFTUJRc2dBRUVDT2dBSUlBQkNBRGNDQUF3RkN5QUJJQUV0QUVZaUIwRUJhaUlDT2dBS0lBRkJBU0FIUVE5eGRFRUNhanNCUUNBQlFYOGdBa0VQY1hSQmYzTTdBUWdnQVVFUWFpQUhFQTFCQUNFTVFRQWhEU0FGSVFkQkFBd0RDeUFCUVFFNkFFZEJBaUVOREFFTElBb2dBa0hvaHNBQUVEWUFDMEVBSVF3Z0JTRUhRUUFMSVFJZ0JrRTRha0VBTmdJQUlBWkNBRGNETUNBR1FjZ0Fha0VBTmdJQUlBWkNBRGNEUUNBR1Fmd0Fha0VBTmdJQUlBWkI5QUJxUVFBMkFnQWdCa0hzQUdwQkFEWUNBQ0FHUWVRQWFrRUFOZ0lBSUFaQjNBQnFRUUEyQWdBZ0JrSFlpY0FBTmdKNElBWkIySW5BQURZQ2NDQUdRZGlKd0FBMkFtZ2dCa0hZaWNBQU5nSmdJQVpCMkluQUFEWUNXQ0FHUVFBMkFsUWdCa0hZaWNBQU5nSlFBa0FDZndKQUlBSkZEUUFnQVVFUWFpRVVJQUZCS0dvaEZTQUdRY2dBYWlFWElBWkJQbW9oRmdKQUFrQUNRQUpBQWtBQ1FBSkFBa0FEUUFKQUFrQWdCdzBBSUFaQkVHb2dGUkJDSUFZb0FoUkZEUUJCQUNFSERBRUxJQUVnQmtFb2FoQVlRUUFoQ3lBWElSQkJBQ0VPQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQTBBZ0FTMEFDeUlDSUFFdEFBb2lDRWtOQVNBQklBSWdDR3M2QUFzZ0JrRXdhaUFMYWlJS0lBRXZBUWdpQWlBQktRTUFJQWl0aVNJWXAzRTdBUUFnQVNBWUlBS3RRbitGUW9DQWZJU0ROd01BSUE0RVFDQU9RWDlxUVFWTERRVWdCeUFMSUJacUx3RUFJZ0pKRFFZZ0VDQUVOZ0lBSUJCQkJHb2dBallDQUNBSElBSnJJUWNnQWlBRWFpRUVDeUFCTHdGQUlnSWdEbXBCLy84RGNTQUJMd0VJSUFFdEFFaHJRZi8vQTNGR0RRSWdDaThCQUNJS0lBRXZBVUpHSUFvZ0FrOXlEUUlnQ2lBQkx3RkVSZzBDSUFFb0FpUWlBaUFLVFEwR0lBY2dBU2dDSENBS1FRRjBhaThCQUNJQ1NRMENJQTVCQVdvaERpQUxJQlpxUVFKcUlBSTdBUUFnRUVFSWFpRVFJQXRCQW1vaUMwRU1SdzBBQzBFR0lRNUJCU0VRSUFZdkFUb2hDQXdIQ3lBT0RRRkJBU0FOSUJJYklRME1DQXNnRGtFQmFpRU9DeUFPUVFkUERRTWdCa0V3YWlBT1FYOXFJaEJCQVhScUx3RUFJUWdnRUEwRUlBd2hDZ3dGQ3lBT1FYOXFRUVpCbUlUQUFCQTJBQXRCNklIQUFFRWpRZmlDd0FBUVNBQUxJQW9nQWtHb2hNQUFFRFlBQ3lBT1FRWkJ1SVRBQUJBM0FBc2dCa0hRQUdvaEFpQUdRVEJxSVFzRFFDQUdRUWhxSUJRZ0ZDQUxMd0VBSWdvZ0FpZ0NBQ0FDUVFScUtBSUFFQ2tnREJBaklBWXRBQW9oRVNBR0x3RUlJUk1nQVNBQkx3RkFRUUZxT3dGQUlBdEJBbW9oQ3lBQ1FRaHFJUUlnQ2lFTUlCQkJmMm9pRUEwQUN5QU9RUU4wSUFacVFVQnJJZ0lvQWdRaENTQUNRUUEyQWdRZ0FpZ0NBQ0VQSUFKQmlJUEFBRFlDQUFzZ0NDSU1JQUV2QVVKR0RRTUNRQ0FCTHdGRUlBaEhCRUFnQ0NBQkx3RkFJZ0pORFFGQkF5RU5RUUFNRFFzZ0FVRUJPZ0JIUVFJaERVRUFEQXdMQW44Z0J3Si9Ba0FDUUNBQ0lBaEhCRUFnQVNnQ0pDSUNJQWhMRFFFZ0NDQUNRZGlFd0FBUU5nQUxJQUVvQWlRaUFpQUtRZi8vQTNFaUNFME5DQ0FISUFFb0Fod2dDRUVCZEdvdkFRQkJBV3BCLy84RGNTSUNUdzBCSUE4RVFDQUJLQUlzSWdJZ0NVa05DaUFCS0FJb0lBOGdDUkJMR2lBQklBazJBakFnQVNBSk5nSTBDMEVBSVE4Z0ZSQXpJUXRCQVF3REN5QUhJQUVvQWh3Z0NFRUJkR292QVFBaUFra0VRRUVBSVE4Z0ZTQVVJQXdRSmlFTFFRRU1Bd3NnRkNBTUlBUWdBaEFwSVFzZ0Fnd0JDeUFQUlFSQUlBRW9BaXdpQ0NBQktBSTBJZ2xKRFFrZ0ZTZ0NBQ0VQQ3lBSlJRMEVJQWtnQWtzTkNTQVBMUUFBSVFzZ0JDQVBJQWtRU3lBQ0lBbEdEUW9nQ1dvZ0N6b0FBQ0FDQ3lJSmF5RUhJQWtnQkNJUGFpRUVRUUFMSUFFb0FoaEIveDlOQkVBZ0JpQVVJQXNnQ2hBaklBRXZBVUFoRUNBR0xRQUNJUkVnQmk4QkFDRVRBa0FnQVMwQUNpSUlRUXRMRFFBZ0VDQUJMd0VJSWdvZ0FTMEFTR3RCLy84RGNVY05BQ0FCSUFoQkFXbzZBQW9nQVNBS1FRRjBRUUZ5T3dFSUN5QUJJQkJCQVdvN0FVQUxRUUFoRWtVTkFRc0xRZ0VoR1NBUFJRMEtJQUVvQWl3aUFpQUpTUTBISUFFb0FpZ2dEeUFKRUVzYUlBRWdDVFlDTUNBQklBazJBalFNQ2d0QkFFRUFRWWlGd0FBUU5nQUxJQUVRTkF3R0N5QUlJQUpCeUlUQUFCQTJBQXNnQ1NBQ1FlaUV3QUFRTndBTElBa2dDRUg0aE1BQUVEY0FDeUFKSUFKQm1JWEFBQkEzQUF0QkFFRUFRYWlGd0FBUU5nQUxJQWtnQWtHNGhjQUFFRGNBQzBFQUN5RU1RUUFoRTBFQUlSRUxJQUFnQlNBSGF6WUNCQ0FBSUFNZ0JpZ0NMQ0lDYXpZQ0FDQUFRUUFnRFNBRElBSkxHeUFOSUExQkFVWWJPZ0FJSUFFZ0RLMUMvLzhEZzBJUWhpQVpoQ0FUclVMLy93T0RRaUNHaENBUnJVTC9BWU5DTUlhRU53TTRDeUFHUVlBQmFpUUFDOVlRQWhGL0FuNGpBRUdBQVdzaUJpUUFJQVlnQXpZQ0xDQUdJQUkyQWlnQ1FBSi9Ba0FDUUFKQUFrQWdBUzBBUjBVRVFDQUJLUU00SVJjZ0FVSUFOd000QW44Z0YwTC8vd09EVUVVRVFDQVhRakNJcHlFUklCZENFSWluSVF3Z0YwSWdpS2NNQVFzZ0JrRWdhaUFCSUFaQktHb1FMaUFHTHdFZ1JRUkFRUUVoRFF3R0MwRURJUTBnQmk4QklpSU1JZ0lnQVM4QlFFOE5CU0FDSUFFdkFVSkdEUUlnQVM4QlJDQU1RZi8vQTNGR0RRTWdBVUVZYWlnQ0FFVU5CU0FCUVNocUlBRkJFR29pQnlBTUVDWWFJQUVvQWhnaUFpQU1RZi8vQTNFaUNVME5CQ0FIS0FJQUlBbEJBblJxSWdJdEFBSWhFU0FDTHdFQUN5RVNJQVpCR0dvZ0FVRW9haEJDSUFZb0FoZ2hBZ0pBSUFZb0Fod2lCeUFGVFFSQUlBY05BVUVCSVFoQkFTRU5JQVVoQjBFQkRBY0xJQVZGQkVCQkFTRU5RUUFoQjBFQkRBY0xJQVFnQWlBRkVFc2FJQUZCTUdvaUFpQUNLQUlBSUFWcU5nSUFRWWlEd0FBaEJFRUFJUTFCQUNFSFFRRU1CZ3NnQkNBQ0lBY1FTeUFCUVRCcUlnSWdBaWdDQUNBSGFqWUNBQ0FIYWlFRUlBVWdCMnNoQjBFQUlRMUJBUXdGQ3lBQVFRSTZBQWdnQUVJQU53SUFEQVVMSUFFZ0FTMEFSaUlIUVFGcUlnSTZBQW9nQVVFQklBZEJEM0YwUVFKcU93RkFJQUZCZnlBQ1FROXhkRUYvY3pzQkNDQUJRUkJxSUFjUURVRUFJUXhCQUNFTklBVWhCMEVBREFNTElBRkJBVG9BUjBFQ0lRME1BUXNnQ1NBQ1FlaUd3QUFRTmdBTFFRQWhEQ0FGSVFkQkFBc2hBaUFHUVRocVFRQTJBZ0FnQmtJQU53TXdJQVpCeUFCcVFRQTJBZ0FnQmtJQU53TkFJQVpCL0FCcVFRQTJBZ0FnQmtIMEFHcEJBRFlDQUNBR1Fld0Fha0VBTmdJQUlBWkI1QUJxUVFBMkFnQWdCa0hjQUdwQkFEWUNBQ0FHUWRpSndBQTJBbmdnQmtIWWljQUFOZ0p3SUFaQjJJbkFBRFlDYUNBR1FkaUp3QUEyQW1BZ0JrSFlpY0FBTmdKWUlBWkJBRFlDVkNBR1FkaUp3QUEyQWxBQ1FBSi9Ba0FnQWtVTkFDQUJRUkJxSVJNZ0FVRW9haUVVSUFaQnlBQnFJUllnQmtFK2FpRVZBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBTkFBa0FDUUNBSERRQWdCa0VRYWlBVUVFSWdCaWdDRkVVTkFFRUFJUWNNQVFzZ0FTQUdRU2hxRUNCQkFDRUxJQlloRUVFQUlRNENRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQURRQ0FCTFFBTElnSWdBUzBBQ2lJSlNRMEJJQUVnQWlBSmF6b0FDeUFCSUFFcEF3QWlGeUFKclVJL2c0ZzNBd0FnQmtFd2FpQUxhaUlKSUFFdkFRZ2dGNmR4T3dFQUlBNEVRQ0FPUVg5cVFRVkxEUVVnQnlBTElCVnFMd0VBSWdKSkRRWWdFQ0FFTmdJQUlCQkJCR29nQWpZQ0FDQUhJQUpySVFjZ0FpQUVhaUVFQ3lBQkx3RkFJZ0lnRG1wQi8vOERjU0FCTHdFSUlBRXRBRWhyUWYvL0EzRkdEUUlnQ1M4QkFDSUpJQUV2QVVKR0lBa2dBazl5RFFJZ0NTQUJMd0ZFUmcwQ0lBRW9BaVFpQWlBSlRRMEdJQWNnQVNnQ0hDQUpRUUYwYWk4QkFDSUNTUTBDSUE1QkFXb2hEaUFMSUJWcVFRSnFJQUk3QVFBZ0VFRUlhaUVRSUF0QkFtb2lDMEVNUncwQUMwRUdJUTVCQlNFUUlBWXZBVG9oQ0F3SEN5QU9EUUZCQVNBTklBZ2JJUTBNQ0FzZ0RrRUJhaUVPQ3lBT1FRZFBEUU1nQmtFd2FpQU9RWDlxSWhCQkFYUnFMd0VBSVFnZ0VBMEVJQXdoQ1F3RkN5QU9RWDlxUVFaQm1JVEFBQkEyQUF0QjZJSEFBRUVqUWZpQ3dBQVFTQUFMSUFrZ0FrR29oTUFBRURZQUN5QU9RUVpCdUlUQUFCQTNBQXNnQmtIUUFHb2hBaUFHUVRCcUlRc0RRQ0FHUVFocUlCTWdFeUFMTHdFQUlna2dBaWdDQUNBQ1FRUnFLQUlBRUNrZ0RCQWpJQVl0QUFvaEVTQUdMd0VJSVJJZ0FTQUJMd0ZBUVFGcU93RkFJQXRCQW1vaEN5QUNRUWhxSVFJZ0NTRU1JQkJCZjJvaUVBMEFDeUFPUVFOMElBWnFRVUJySWdJb0FnUWhDaUFDUVFBMkFnUWdBaWdDQUNFUElBSkJpSVBBQURZQ0FBc2dDQ0lNSUFFdkFVSkdEUU1DUUNBQkx3RkVJQWhIQkVBZ0NDQUJMd0ZBSWdKTkRRRkJBeUVOUVFBTURRc2dBVUVCT2dCSFFRSWhEVUVBREF3TEFuOGdCd0ovQWtBQ1FDQUNJQWhIQkVBZ0FTZ0NKQ0lDSUFoTERRRWdDQ0FDUWRpRXdBQVFOZ0FMSUFFb0FpUWlBaUFKUWYvL0EzRWlDRTBOQ0NBSElBRW9BaHdnQ0VFQmRHb3ZBUUJCQVdwQi8vOERjU0lDVHcwQklBOEVRQ0FCS0FJc0lnSWdDa2tOQ2lBQktBSW9JQThnQ2hCTEdpQUJJQW8yQWpBZ0FTQUtOZ0kwQzBFQUlROGdGQkF6SVF0QkFRd0RDeUFISUFFb0Fod2dDRUVCZEdvdkFRQWlBa2tFUUVFQUlROGdGQ0FUSUF3UUppRUxRUUVNQXdzZ0V5QU1JQVFnQWhBcElRc2dBZ3dCQ3lBUFJRUkFJQUVvQWl3aUNDQUJLQUkwSWdwSkRRa2dGQ2dDQUNFUEN5QUtSUTBFSUFvZ0Frc05DU0FQTFFBQUlRc2dCQ0FQSUFvUVN5QUNJQXBHRFFvZ0Ntb2dDem9BQUNBQ0N5SUtheUVISUFvZ0JDSVBhaUVFUVFBTElBRW9BaGhCL3g5TkJFQWdCaUFUSUFzZ0NSQWpJQUV2QVVBaEVDQUdMUUFDSVJFZ0JpOEJBQ0VTQWtBZ0FTMEFDaUlJUVF0TERRQWdFQ0FCTHdFSUlna2dBUzBBU0d0Qi8vOERjVWNOQUNBQklBaEJBV282QUFvZ0FTQUpRUUYwUVFGeU93RUlDeUFCSUJCQkFXbzdBVUFMUVFBaENFVU5BUXNMUWdFaEdDQVBSUTBLSUFFb0Fpd2lBaUFLU1EwSElBRW9BaWdnRHlBS0VFc2FJQUVnQ2pZQ01DQUJJQW8yQWpRTUNndEJBRUVBUVlpRndBQVFOZ0FMSUFFUU5Bd0dDeUFJSUFKQnlJVEFBQkEyQUFzZ0NpQUNRZWlFd0FBUU53QUxJQW9nQ0VINGhNQUFFRGNBQ3lBS0lBSkJtSVhBQUJBM0FBdEJBRUVBUWFpRndBQVFOZ0FMSUFvZ0FrRzRoY0FBRURjQUMwRUFDeUVNUVFBaEVrRUFJUkVMSUFBZ0JTQUhhellDQkNBQUlBTWdCaWdDTENJQ2F6WUNBQ0FBUVFBZ0RTQURJQUpMR3lBTklBMUJBVVliT2dBSUlBRWdESzFDLy84RGcwSVFoaUFZaENBU3JVTC8vd09EUWlDR2hDQVJyVUwvQVlOQ01JYUVOd000Q3lBR1FZQUJhaVFBQzZvSUFRWi9Jd0JCOEFCcklnVWtBQ0FGSUFNMkFnd2dCU0FDTmdJSVFRRWhCeUFCSVFZQ1FDQUJRWUVDU1EwQVFRQWdBV3NoQ1VHQUFpRUlBMEFDUUNBSUlBRlBEUUJCQUNFSElBQWdDR29zQUFCQnYzOU1EUUFnQ0NFR0RBSUxJQWhCZjJvaEJrRUFJUWNnQ0VFQlJnMEJJQWdnQ1dvZ0JpRUlRUUZIRFFBTEN5QUZJQVkyQWhRZ0JTQUFOZ0lRSUFWQkFFRUZJQWNiTmdJY0lBVkI4SXZBQUVIQWtzQUFJQWNiTmdJWUFrQUNmd0pBQWtBZ0FpQUJTeUlISUFNZ0FVdHlSUVJBSUFJZ0Ewc05BUUpBSUFKRklBRWdBa1p5UlFSQUlBRWdBazBOQVNBQUlBSnFMQUFBUVVCSURRRUxJQU1oQWdzZ0JTQUNOZ0lnSUFKQkFDQUJJQUpIRzBVRVFDQUNJUWNNQXdzZ0FVRUJhaUVEQTBBQ1FDQUNJQUZQRFFBZ0FDQUNhaXdBQUVGQVNBMEFJQUloQnlBRlFTUnFEQVVMSUFKQmYyb2hCeUFDUVFGR0RRTWdBaUFEUmlBSElRSkZEUUFMREFJTElBVWdBaUFESUFjYk5nSW9JQVZCeEFCcVFRTTJBZ0FnQlVIY0FHcEJIVFlDQUNBRlFkUUFha0VkTmdJQUlBVkNBemNDTkNBRlFlaVN3QUEyQWpBZ0JVRWNOZ0pNSUFVZ0JVSElBR28yQWtBZ0JTQUZRUmhxTmdKWUlBVWdCVUVRYWpZQ1VDQUZJQVZCS0dvMkFrZ01Bd3NnQlVIa0FHcEJIVFlDQUNBRlFkd0Fha0VkTmdJQUlBVkIxQUJxUVJ3MkFnQWdCVUhFQUdwQkJEWUNBQ0FGUWdRM0FqUWdCVUdrazhBQU5nSXdJQVZCSERZQ1RDQUZJQVZCeUFCcU5nSkFJQVVnQlVFWWFqWUNZQ0FGSUFWQkVHbzJBbGdnQlNBRlFReHFOZ0pRSUFVZ0JVRUlhallDU0F3Q0N5QUZRU1JxQ3lFSUFrQWdBU0FIUmcwQVFRRWhBd0pBQWtBQ1FDQUFJQWRxSWdZc0FBQWlBa0YvVEFSQVFRQWhBeUFBSUFGcUlnRWhBQ0FCSUFaQkFXcEhCRUFnQmkwQUFVRS9jU0VESUFaQkFtb2hBQXNnQWtFZmNTRUpJQUpCL3dGeFFkOEJTdzBCSUFNZ0NVRUdkSEloQWd3Q0N5QUZJQUpCL3dGeE5nSWtJQVZCS0dvaEFRd0NDMEVBSVFvZ0FTRUdJQUFnQVVjRVFDQUFMUUFBUVQ5eElRb2dBRUVCYWlFR0N5QUtJQU5CQm5SeUlRQWdBa0gvQVhGQjhBRkpCRUFnQUNBSlFReDBjaUVDREFFTFFRQWhBaUFCSUFaSEJIOGdCaTBBQUVFL2NRVkJBQXNnQ1VFU2RFR0FnUEFBY1NBQVFRWjBjbklpQWtHQWdNUUFSZzBDQ3lBRklBSTJBaVJCQVNFRElBVkJLR29oQVNBQ1FZQUJTUTBBUVFJaEF5QUNRWUFRU1EwQVFRTkJCQ0FDUVlDQUJFa2JJUU1MSUFVZ0J6WUNLQ0FGSUFNZ0IybzJBaXdnQlVIRUFHcEJCVFlDQUNBRlFld0Fha0VkTmdJQUlBVkI1QUJxUVIwMkFnQWdCVUhjQUdwQkhqWUNBQ0FGUWRRQWFrRWZOZ0lBSUFWQ0JUY0NOQ0FGUWZpVHdBQTJBakFnQlNBQk5nSllJQVVnQ0RZQ1VDQUZRUncyQWt3Z0JTQUZRY2dBYWpZQ1FDQUZJQVZCR0dvMkFtZ2dCU0FGUVJCcU5nSmdJQVVnQlVFZ2FqWUNTQXdCQzBIOGk4QUFRU3NnQkJCSUFBc2dCVUV3YWlBRUVGRUFDOUlJQVFWL0lBQkJlR29pQVNBQVFYeHFLQUlBSWdOQmVIRWlBR29oQWdKQUFrQWdBMEVCY1EwQUlBTkJBM0ZGRFFFZ0FTZ0NBQ0lESUFCcUlRQWdBU0FEYXlJQlFhU3F3QUFvQWdCR0JFQWdBaWdDQkVFRGNVRURSdzBCUVp5cXdBQWdBRFlDQUNBQ0lBSW9BZ1JCZm5FMkFnUWdBU0FBUVFGeU5nSUVJQUFnQVdvZ0FEWUNBQThMSUFFZ0F4QVJDd0pBSUFKQkJHb2lCQ2dDQUNJRFFRSnhCRUFnQkNBRFFYNXhOZ0lBSUFFZ0FFRUJjallDQkNBQUlBRnFJQUEyQWdBTUFRc0NRQ0FDUWFpcXdBQW9BZ0JIQkVCQnBLckFBQ2dDQUNBQ1JnMEJJQUlnQTBGNGNTSUNFQkVnQVNBQUlBSnFJZ0JCQVhJMkFnUWdBQ0FCYWlBQU5nSUFJQUZCcEtyQUFDZ0NBRWNOQWtHY3FzQUFJQUEyQWdBUEMwR29xc0FBSUFFMkFnQkJvS3JBQUVHZ3FzQUFLQUlBSUFCcUlnQTJBZ0FnQVNBQVFRRnlOZ0lFUWFTcXdBQW9BZ0FnQVVZRVFFR2Nxc0FBUVFBMkFnQkJwS3JBQUVFQU5nSUFDMEhFcXNBQUtBSUFJZ0lnQUU4TkFrR29xc0FBS0FJQUlnQkZEUUlDUUVHZ3FzQUFLQUlBSWdOQktVa05BRUcwcXNBQUlRRURRQ0FCS0FJQUlnUWdBRTBFUUNBRUlBRW9BZ1JxSUFCTERRSUxJQUVvQWdnaUFRMEFDd3RCektyQUFBSi9RZjhmUWJ5cXdBQW9BZ0FpQUVVTkFCcEJBQ0VCQTBBZ0FVRUJhaUVCSUFBb0FnZ2lBQTBBQ3lBQlFmOGZJQUZCL3g5TEd3czJBZ0FnQXlBQ1RRMENRY1Nxd0FCQmZ6WUNBQThMUWFTcXdBQWdBVFlDQUVHY3FzQUFRWnlxd0FBb0FnQWdBR29pQURZQ0FDQUJJQUJCQVhJMkFnUWdBQ0FCYWlBQU5nSUFEd3RCektyQUFBSi9Ba0FnQUVHQUFrOEVRQ0FCUWdBM0FoQWdBVUVjYWdKL1FRQWdBRUVJZGlJQ1JRMEFHa0VmSUFCQi8vLy9CMHNOQUJvZ0FFRUdJQUpuSWdKclFSOXhka0VCY1NBQ1FRRjBhMEUrYWdzaUF6WUNBQ0FEUVFKMFFaeXB3QUJxSVFJQ1FBSkFBa0FDUUFKQVFaQ253QUFvQWdBaUJFRUJJQU5CSDNGMElnVnhCRUFnQWlnQ0FDSUNRUVJxS0FJQVFYaHhJQUJIRFFFZ0FpRUREQUlMUVpDbndBQWdCQ0FGY2pZQ0FDQUNJQUUyQWdBTUF3c2dBRUVBUVJrZ0EwRUJkbXRCSDNFZ0EwRWZSaHQwSVFRRFFDQUNJQVJCSFhaQkJIRnFRUkJxSWdVb0FnQWlBMFVOQWlBRVFRRjBJUVFnQXlJQ1FRUnFLQUlBUVhoeElBQkhEUUFMQ3lBREtBSUlJZ0FnQVRZQ0RDQURJQUUyQWdnZ0FVRVlha0VBTmdJQUlBRWdBellDRENBQklBQTJBZ2dNQWdzZ0JTQUJOZ0lBQ3lBQlFSaHFJQUkyQWdBZ0FTQUJOZ0lNSUFFZ0FUWUNDQXRCektyQUFFSE1xc0FBS0FJQVFYOXFJZ0EyQWdBZ0FBMERRYnlxd0FBb0FnQWlBQTBCUWY4ZkRBSUxJQUJCQTNZaUFrRURkRUdVcDhBQWFpRUFBbjlCaktmQUFDZ0NBQ0lEUVFFZ0FuUWlBbkVFUUNBQUtBSUlEQUVMUVl5bndBQWdBaUFEY2pZQ0FDQUFDeUVDSUFBZ0FUWUNDQ0FDSUFFMkFnd2dBU0FBTmdJTUlBRWdBallDQ0E4TFFRQWhBUU5BSUFGQkFXb2hBU0FBS0FJSUlnQU5BQXNnQVVIL0h5QUJRZjhmU3hzTE5nSUFDd3VXQndFS2Z5QUFLQUlRSVFNQ1FBSkFBa0FnQUNnQ0NDSU1RUUZIQkVBZ0EwRUJSZzBCREFNTElBTkJBVWNOQVFzZ0FTQUNhaUVEQWtBQ1FDQUFRUlJxS0FJQUlnaEZCRUFnQVNFRURBRUxJQUVoQkFOQUlBTWdCQ0lIUmcwQ0lBZEJBV29oQkFKQUlBY3NBQUFpQmtGL1NnMEFJQVpCL3dGeElRa0NmeUFESUFSR0JFQkJBQ0VLSUFNTUFRc2dCeTBBQVVFL2NTRUtJQWRCQW1vaUJBc2hCaUFKUWVBQlNRMEFBbjhnQXlBR1JnUkFRUUFoQ3lBRERBRUxJQVl0QUFCQlAzRWhDeUFHUVFGcUlnUUxJUVlnQ1VId0FVa05BQ0FESUFaR0JIOUJBQVVnQmtFQmFpRUVJQVl0QUFCQlAzRUxJQWxCRW5SQmdJRHdBSEVnQ2tFTWRISWdDMEVHZEhKeVFZQ0F4QUJHRFFNTElBUWdCMnNnQldvaEJTQUlRWDlxSWdnTkFBc0xJQU1nQkVZTkFBSkFJQVFzQUFBaUIwRi9TZzBBQW44Z0F5QUVRUUZxUmdSQUlBTWhDRUVBREFFTElBUkJBbW9oQ0NBRUxRQUJRVDl4UVFaMEN5QUhRZjhCY1VIZ0FVa05BQUovSUFNZ0NFWUVRQ0FESVFaQkFBd0JDeUFJUVFGcUlRWWdDQzBBQUVFL2NRc2dCMEgvQVhGQjhBRkpEUUFnQjBIL0FYRWhCM0loQkNBRElBWkdCSDlCQUFVZ0JpMEFBRUUvY1FzZ0IwRVNkRUdBZ1BBQWNTQUVRUVowY25KQmdJREVBRVlOQVFzQ1FDQUZSU0FDSUFWR2NrVUVRRUVBSVFNZ0JTQUNUdzBCSUFFZ0JXb3NBQUJCUUVnTkFRc2dBU0VEQ3lBRklBSWdBeHNoQWlBRElBRWdBeHNoQVFzZ0RFRUJSZzBBREFFTEFrQWdBZ1JBUVFBaEJDQUNJUVVnQVNFREEwQWdCQ0FETFFBQVFjQUJjVUdBQVVacUlRUWdBMEVCYWlFRElBVkJmMm9pQlEwQUN5QUNJQVJySUFBb0Fnd2lCazhOQWtFQUlRUWdBaUVGSUFFaEF3TkFJQVFnQXkwQUFFSEFBWEZCZ0FGR2FpRUVJQU5CQVdvaEF5QUZRWDlxSWdVTkFBc01BUXRCQUNFRUlBQW9BZ3dpQmcwQURBRUxRUUFoQXlBRUlBSnJJQVpxSWdRaEJRSkFBa0FDUUVFQUlBQXRBQ0FpQmlBR1FRTkdHMEVEY1VFQmF3NERBUUFCQWdzZ0JFRUJkaUVESUFSQkFXcEJBWFloQlF3QkMwRUFJUVVnQkNFREN5QURRUUZxSVFNQ1FBTkFJQU5CZjJvaUF3UkFJQUFvQWhnZ0FDZ0NCQ0FBS0FJY0tBSVFFUUFBUlEwQkRBSUxDeUFBS0FJRUlRUWdBQ2dDR0NBQklBSWdBQ2dDSENnQ0RCRUJBQTBBSUFWQkFXb2hBeUFBS0FJY0lRRWdBQ2dDR0NFQUEwQWdBMEYvYWlJRFJRUkFRUUFQQ3lBQUlBUWdBU2dDRUJFQUFFVU5BQXNMUVFFUEN5QUFLQUlZSUFFZ0FpQUFRUnhxS0FJQUtBSU1FUUVBQzdzR0FRUi9JQUFnQVdvaEFnSkFBa0FnQUVFRWFpZ0NBQ0lEUVFGeERRQWdBMEVEY1VVTkFTQUFLQUlBSWdNZ0FXb2hBU0FBSUFOcklnQkJwS3JBQUNnQ0FFWUVRQ0FDS0FJRVFRTnhRUU5IRFFGQm5LckFBQ0FCTmdJQUlBSWdBaWdDQkVGK2NUWUNCQ0FBSUFGQkFYSTJBZ1FnQWlBQk5nSUFEd3NnQUNBREVCRUxBa0FnQWtFRWFpZ0NBQ0lEUVFKeEJFQWdBa0VFYWlBRFFYNXhOZ0lBSUFBZ0FVRUJjallDQkNBQUlBRnFJQUUyQWdBTUFRc0NRQ0FDUWFpcXdBQW9BZ0JIQkVCQnBLckFBQ2dDQUNBQ1JnMEJJQUlnQTBGNGNTSUNFQkVnQUNBQklBSnFJZ0ZCQVhJMkFnUWdBQ0FCYWlBQk5nSUFJQUJCcEtyQUFDZ0NBRWNOQWtHY3FzQUFJQUUyQWdBUEMwR29xc0FBSUFBMkFnQkJvS3JBQUVHZ3FzQUFLQUlBSUFGcUlnRTJBZ0FnQUNBQlFRRnlOZ0lFSUFCQnBLckFBQ2dDQUVjTkFrR2Nxc0FBUVFBMkFnQkJwS3JBQUVFQU5nSUFEd3RCcEtyQUFDQUFOZ0lBUVp5cXdBQkJuS3JBQUNnQ0FDQUJhaUlCTmdJQUlBQWdBVUVCY2pZQ0JDQUFJQUZxSUFFMkFnQVBDeUFCUVlBQ1R3UkFJQUJDQURjQ0VDQUFRUnhxQW45QkFDQUJRUWgySWdKRkRRQWFRUjhnQVVILy8vOEhTdzBBR2lBQlFRWWdBbWNpQW10QkgzRjJRUUZ4SUFKQkFYUnJRVDVxQ3lJRE5nSUFJQU5CQW5SQm5LbkFBR29oQWdKQUFrQUNRQUpBUVpDbndBQW9BZ0FpQkVFQklBTkJIM0YwSWdWeEJFQWdBaWdDQUNJQ1FRUnFLQUlBUVhoeElBRkhEUUVnQWlFRERBSUxRWkNud0FBZ0JDQUZjallDQUNBQ0lBQTJBZ0FNQXdzZ0FVRUFRUmtnQTBFQmRtdEJIM0VnQTBFZlJodDBJUVFEUUNBQ0lBUkJIWFpCQkhGcVFSQnFJZ1VvQWdBaUEwVU5BaUFFUVFGMElRUWdBeUlDUVFScUtBSUFRWGh4SUFGSERRQUxDeUFES0FJSUlnRWdBRFlDRENBRElBQTJBZ2dnQUVFWWFrRUFOZ0lBSUFBZ0F6WUNEQ0FBSUFFMkFnZ1BDeUFGSUFBMkFnQUxJQUJCR0dvZ0FqWUNBQ0FBSUFBMkFnd2dBQ0FBTmdJSUR3c2dBVUVEZGlJQ1FRTjBRWlNud0FCcUlRRUNmMEdNcDhBQUtBSUFJZ05CQVNBQ2RDSUNjUVJBSUFFb0FnZ01BUXRCaktmQUFDQUNJQU55TmdJQUlBRUxJUUlnQVNBQU5nSUlJQUlnQURZQ0RDQUFJQUUyQWd3Z0FDQUNOZ0lJQ3d1cUJnRUhmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBRUdBZ0FSUEJFQWdBRUdBZ0FoSkRRRWdBRUcxMlhOcVFiWGJLMGtnQUVIaWkzUnFRZUlMU1hJZ0FFR2ZxSFJxUVo4WVNTQUFRZDdpZEdwQkRrbHljaUFBUWY3Ly93QnhRWjd3Q2tZZ0FFR2lzblZxUVNKSmNpQUFRY3VSZFdwQkMwbHljZzBDSUFCQjhJTTRTUThMSUFCQmdQNERjVUVJZGlFR1FlaVV3QUFoQVNBQVFmOEJjU0VIQTBBQ1FDQUJRUUpxSVFVZ0FpQUJMUUFCSWdScUlRTWdCaUFCTFFBQUlnRkhCRUFnQVNBR1N3MEJJQU1oQWlBRklnRkJ1cFhBQUVjTkFnd0JDeUFESUFKSkRRUWdBMEdpQWtzTkJTQUNRYnFWd0FCcUlRRUNRQU5BSUFSRkRRRWdCRUYvYWlFRUlBRXRBQUFnQVVFQmFpRUJJQWRIRFFBTFFRQWhCQXdFQ3lBRElRSWdCU0lCUWJxVndBQkhEUUVMQ3lBQVFmLy9BM0VoQTBIY2w4QUFJUUZCQVNFRUEwQWdBVUVCYWlFQUFuOGdBQ0FCTFFBQUlnSkJHSFJCR0hVaUJVRUFUZzBBR2lBQVFaR2F3QUJHRFFZZ0FTMEFBU0FGUWY4QWNVRUlkSEloQWlBQlFRSnFDeUVCSUFNZ0Ftc2lBMEVBU0EwQ0lBUkJBWE1oQkNBQlFaR2F3QUJIRFFBTERBRUxJQUJCZ1A0RGNVRUlkaUVHUVpHYXdBQWhBU0FBUWY4QmNTRUhBMEFDUUNBQlFRSnFJUVVnQWlBQkxRQUJJZ1JxSVFNZ0JpQUJMUUFBSWdGSEJFQWdBU0FHU3cwQklBTWhBaUFGSWdGQjNackFBRWNOQWd3QkN5QURJQUpKRFFZZ0EwR3ZBVXNOQnlBQ1FkMmF3QUJxSVFFQ1FBTkFJQVJGRFFFZ0JFRi9haUVFSUFFdEFBQWdBVUVCYWlFQklBZEhEUUFMUVFBaEJBd0RDeUFESVFJZ0JTSUJRZDJhd0FCSERRRUxDeUFBUWYvL0EzRWhBMEdNbk1BQUlRRkJBU0VFQTBBZ0FVRUJhaUVBQW44Z0FDQUJMUUFBSWdKQkdIUkJHSFVpQlVFQVRnMEFHaUFBUWErZndBQkdEUWdnQVMwQUFTQUZRZjhBY1VFSWRISWhBaUFCUVFKcUN5RUJJQU1nQW1zaUEwRUFTQTBCSUFSQkFYTWhCQ0FCUWErZndBQkhEUUFMQ3lBRVFRRnhEd3NnQWlBRFFjaVV3QUFRT0FBTElBTkJvZ0pCeUpUQUFCQTNBQXRCL0l2QUFFRXJRZGlVd0FBUVNBQUxJQUlnQTBISWxNQUFFRGdBQ3lBRFFhOEJRY2lVd0FBUU53QUxRZnlMd0FCQkswSFlsTUFBRUVnQUM3RUZBUWQvUVN0QmdJREVBQ0FBS0FJQUlnbEJBWEVpQlJzaENpQUVJQVZxSVFnQ1FDQUpRUVJ4UlFSQVFRQWhBUXdCQ3lBQ0JFQWdBaUVHSUFFaEJRTkFJQWNnQlMwQUFFSEFBWEZCZ0FGR2FpRUhJQVZCQVdvaEJTQUdRWDlxSWdZTkFBc0xJQUlnQ0dvZ0Iyc2hDQXNDUUFKQUlBQW9BZ2hCQVVjRVFDQUFJQW9nQVNBQ0VFWU5BUXdDQ3lBQVFReHFLQUlBSWdZZ0NFMEVRQ0FBSUFvZ0FTQUNFRVlOQVF3Q0N3SkFBa0FDUUFKQUlBbEJDSEVFUUNBQUtBSUVJUWtnQUVFd05nSUVJQUF0QUNBaEN5QUFRUUU2QUNBZ0FDQUtJQUVnQWhCR0RRVkJBQ0VGSUFZZ0NHc2lBU0VDUVFFZ0FDMEFJQ0lHSUFaQkEwWWJRUU54UVFGckRnTUNBUUlEQzBFQUlRVWdCaUFJYXlJR0lRZ0NRQUpBQWtCQkFTQUFMUUFnSWdjZ0IwRURSaHRCQTNGQkFXc09Bd0VBQVFJTElBWkJBWFloQlNBR1FRRnFRUUYySVFnTUFRdEJBQ0VJSUFZaEJRc2dCVUVCYWlFRkEwQWdCVUYvYWlJRlJRMEVJQUFvQWhnZ0FDZ0NCQ0FBS0FJY0tBSVFFUUFBUlEwQUMwRUJEd3NnQVVFQmRpRUZJQUZCQVdwQkFYWWhBZ3dCQzBFQUlRSWdBU0VGQ3lBRlFRRnFJUVVDUUFOQUlBVkJmMm9pQlVVTkFTQUFLQUlZSUFBb0FnUWdBQ2dDSENnQ0VCRUFBRVVOQUF0QkFROExJQUFvQWdRaEFTQUFLQUlZSUFNZ0JDQUFLQUljS0FJTUVRRUFEUUVnQWtFQmFpRUhJQUFvQWh3aEFpQUFLQUlZSVFNRFFDQUhRWDlxSWdjRVFDQURJQUVnQWlnQ0VCRUFBRVVOQVF3REN3c2dBQ0FMT2dBZ0lBQWdDVFlDQkVFQUR3c2dBQ2dDQkNFRklBQWdDaUFCSUFJUVJnMEFJQUFvQWhnZ0F5QUVJQUFvQWh3b0Fnd1JBUUFOQUNBSVFRRnFJUWNnQUNnQ0hDRUJJQUFvQWhnaEFBTkFJQWRCZjJvaUIwVUVRRUVBRHdzZ0FDQUZJQUVvQWhBUkFBQkZEUUFMQzBFQkR3c2dBQ2dDR0NBRElBUWdBRUVjYWlnQ0FDZ0NEQkVCQUF2MEJRRUtmeU1BUVRCcklnTWtBQ0FEUVNScUlBRTJBZ0FnQTBFRE9nQW9JQU5DZ0lDQWdJQUVOd01JSUFNZ0FEWUNJQ0FEUVFBMkFoZ2dBMEVBTmdJUUFuOENRQUpBQWtBZ0FpZ0NDQ0lFQkVBZ0FpZ0NBQ0VHSUFJb0FnUWlDQ0FDUVF4cUtBSUFJZ1VnQlNBSVN4c2lCVVVOQVNBQUlBWW9BZ0FnQmlnQ0JDQUJLQUlNRVFFQURRTWdCa0VNYWlFQUlBSW9BaFFoQnlBQ0tBSVFJUW9nQlNFSkEwQWdBeUFFUVJ4cUxRQUFPZ0FvSUFNZ0JFRUVhaWtDQUVJZ2lUY0RDQ0FFUVJocUtBSUFJUUpCQUNFTFFRQWhBUUpBQWtBQ1FDQUVRUlJxS0FJQVFRRnJEZ0lBQWdFTElBSWdCMDhFUUNBQ0lBZEJ0SkRBQUJBMkFBc2dBa0VEZENBS2FpSU1LQUlFUVNCSERRRWdEQ2dDQUNnQ0FDRUNDMEVCSVFFTElBTWdBallDRkNBRElBRTJBaEFnQkVFUWFpZ0NBQ0VDQWtBQ1FBSkFJQVJCREdvb0FnQkJBV3NPQWdBQ0FRc2dBaUFIVHdSQUlBSWdCMEcwa01BQUVEWUFDeUFDUVFOMElBcHFJZ0VvQWdSQklFY05BU0FCS0FJQUtBSUFJUUlMUVFFaEN3c2dBeUFDTmdJY0lBTWdDellDR0NBRUtBSUFJZ0VnQjBrRVFDQUtJQUZCQTNScUlnRW9BZ0FnQTBFSWFpQUJLQUlFRVFBQURRVWdDVUYvYWlJSlJRMEVJQVJCSUdvaEJDQUFRWHhxSVFFZ0FDZ0NBQ0VDSUFCQkNHb2hBQ0FES0FJZ0lBRW9BZ0FnQWlBREtBSWtLQUlNRVFFQVJRMEJEQVVMQ3lBQklBZEJwSkRBQUJBMkFBc2dBaWdDQUNFR0lBSW9BZ1FpQ0NBQ1FSUnFLQUlBSWdVZ0JTQUlTeHNpQlVVTkFDQUNLQUlRSVFRZ0FDQUdLQUlBSUFZb0FnUWdBU2dDREJFQkFBMENJQVpCREdvaEFDQUZJUUlEUUNBRUtBSUFJQU5CQ0dvZ0JFRUVhaWdDQUJFQUFBMERJQUpCZjJvaUFrVU5BaUFFUVFocUlRUWdBRUY4YWlFQklBQW9BZ0FoQ1NBQVFRaHFJUUFnQXlnQ0lDQUJLQUlBSUFrZ0F5Z0NKQ2dDREJFQkFFVU5BQXNNQWd0QkFDRUZDeUFJSUFWTEJFQWdBeWdDSUNBR0lBVkJBM1JxSWdBb0FnQWdBQ2dDQkNBREtBSWtLQUlNRVFFQURRRUxRUUFNQVF0QkFRc2dBMEV3YWlRQUM0MEZBUWQvQWtBZ0FVSE0vM3RMRFFCQkVDQUJRUXRxUVhoeElBRkJDMGtiSVFJZ0FFRjhhaUlGS0FJQUlnWkJlSEVoQXdKQUFrQUNRQUpBQWtBQ1FDQUdRUU54QkVBZ0FFRjRhaUlISUFOcUlRZ2dBeUFDVHcwQlFhaXF3QUFvQWdBZ0NFWU5Ba0drcXNBQUtBSUFJQWhHRFFNZ0NFRUVhaWdDQUNJR1FRSnhEUVlnQmtGNGNTSUdJQU5xSWdNZ0FrOE5CQXdHQ3lBQ1FZQUNTU0FESUFKQkJISkpjaUFESUFKclFZR0FDRTl5RFFVTUJBc2dBeUFDYXlJQlFSQkpEUU1nQlNBQ0lBWkJBWEZ5UVFKeU5nSUFJQUlnQjJvaUJDQUJRUU55TmdJRUlBZ2dDQ2dDQkVFQmNqWUNCQ0FFSUFFUUJnd0RDMEdncXNBQUtBSUFJQU5xSWdNZ0FrME5BeUFGSUFJZ0JrRUJjWEpCQW5JMkFnQWdBaUFIYWlJQklBTWdBbXNpQkVFQmNqWUNCRUdncXNBQUlBUTJBZ0JCcUtyQUFDQUJOZ0lBREFJTFFaeXF3QUFvQWdBZ0Eyb2lBeUFDU1EwQ0FrQWdBeUFDYXlJQlFROU5CRUFnQlNBR1FRRnhJQU55UVFKeU5nSUFJQU1nQjJvaUFTQUJLQUlFUVFGeU5nSUVRUUFoQVF3QkN5QUZJQUlnQmtFQmNYSkJBbkkyQWdBZ0FpQUhhaUlFSUFGQkFYSTJBZ1FnQXlBSGFpSUNJQUUyQWdBZ0FpQUNLQUlFUVg1eE5nSUVDMEdrcXNBQUlBUTJBZ0JCbktyQUFDQUJOZ0lBREFFTElBZ2dCaEFSSUFNZ0Ftc2lBVUVRVHdSQUlBVWdBaUFGS0FJQVFRRnhja0VDY2pZQ0FDQUNJQWRxSWdRZ0FVRURjallDQkNBRElBZHFJZ0lnQWlnQ0JFRUJjallDQkNBRUlBRVFCZ3dCQ3lBRklBTWdCU2dDQUVFQmNYSkJBbkkyQWdBZ0F5QUhhaUlCSUFFb0FnUkJBWEkyQWdRTElBQWhCQXdCQ3lBQkVBQWlBa1VOQUNBQ0lBQWdBVUY4UVhnZ0JTZ0NBQ0lFUVFOeEd5QUVRWGh4YWlJRUlBUWdBVXNiRUVzZ0FCQUVEd3NnQkF2MEJBRUpmeU1BUVRCcklnUWtBQUpBQW44Z0FnUkFJQVJCS0dvaENRTkFBa0FnQUNnQ0NDMEFBRVVOQUNBQUtBSUFRY2lOd0FCQkJDQUFLQUlFS0FJTUVRRUFSUTBBUVFFTUF3c2dCRUVLTmdJb0lBUkNpb0NBZ0JBM0F5QWdCQ0FDTmdJY1FRQWhCU0FFUVFBMkFoZ2dCQ0FDTmdJVUlBUWdBVFlDRUVFQklRY2dBU0VHSUFJaUF5RUlBbjhDUUFKQUEwQWdCU0FHYWlFR0lBUWdCMnBCSjJvdEFBQWhDZ0pBQWtBQ1FDQURRUWROQkVBZ0EwVU5BU0FJSUFWcklRdEJBQ0VEQTBBZ0F5QUdhaTBBQUNBS1JnMEVJQXNnQTBFQmFpSURSdzBBQ3d3QkN5QUVRUWhxSUFvZ0JpQURFQlFnQkNnQ0NFRUJSZzBCSUFRb0Fod2hDQXNnQkNBSU5nSVlEQVFMSUFRb0Fnd2hBeUFFS0FJa0lRY2dCQ2dDR0NFRkN5QUVJQU1nQldwQkFXb2lCVFlDR0FKQUFrQWdCU0FIU1FSQUlBUW9BaFFoQXd3QkN5QUVLQUlVSWdNZ0JVa05BQ0FIUVFWUERRTWdCU0FIYXlJR0lBUW9BaEJxSWdnZ0NVWU5BU0FJSUFrZ0J4QkVSUTBCQ3lBRUtBSWNJZ2dnQlVrZ0F5QUlTWElOQXlBSUlBVnJJUU1nQkNnQ0VDRUdEQUVMQ3lBQUtBSUlRUUU2QUFBZ0JrRUJhZ3dDQ3lBSFFRUkJzSkxBQUJBM0FBc2dBQ2dDQ0VFQU9nQUFJQUlMSVFNZ0FDZ0NCQ0VHSUFBb0FnQWhCUUpBQWtBZ0EwVWdBaUFEUm5KRkJFQWdBaUFEU3dSQUlBRWdBMm9pQnl3QUFFRy9mMG9OQWdzZ0FTQUNRUUFnQTBITWpjQUFFQU1BQ3lBRklBRWdBeUFHS0FJTUVRRUFSUTBCUVFFTUJBdEJBU0FGSUFFZ0F5QUdLQUlNRVFFQURRTWFJQWNzQUFCQnYzOU1EUVFMSUFFZ0Eyb2hBU0FDSUFOcklnSU5BQXNMUVFBTElBUkJNR29rQUE4TElBRWdBaUFESUFKQjNJM0FBQkFEQUF1NkF3RUVmeU1BUVJCcklnSWtBQ0FBS0FJQUlRUUNRQUpBQWtBQ2Z3SkFBa0FnQVVHQUFVOEVRQ0FDUVFBMkFnd2dBVUdBRUVrTkFTQUNRUXhxSVFBZ0FVR0FnQVJKQkVBZ0FpQUJRVDl4UVlBQmNqb0FEaUFDSUFGQkRIWkI0QUZ5T2dBTUlBSWdBVUVHZGtFL2NVR0FBWEk2QUExQkF5RUJEQVlMSUFJZ0FVRS9jVUdBQVhJNkFBOGdBaUFCUVJKMlFmQUJjam9BRENBQ0lBRkJCblpCUDNGQmdBRnlPZ0FPSUFJZ0FVRU1ka0UvY1VHQUFYSTZBQTFCQkNFQkRBVUxJQVFvQWdnaUFDQUVRUVJxS0FJQVJ3UkFJQVFvQWdBaEJRd0VDd0pBSUFCQkFXb2lBeUFBU1EwQUlBQkJBWFFpQlNBRElBVWdBMHNiSWdOQkNDQURRUWhMR3lFRElBQUVRQ0FEUVFCSURRRWdCQ2dDQUNJRlJRMERJQVVnQUVFQklBTVFWUXdFQ3lBRFFRQk9EUUlMRUYwQUN5QUNJQUZCUDNGQmdBRnlPZ0FOSUFJZ0FVRUdka0hBQVhJNkFBd2dBa0VNYWlFQVFRSWhBUXdEQ3lBRFFRRVFXUXNpQlFSQUlBUWdCVFlDQUNBRVFRUnFJQU0yQWdBZ0JDZ0NDQ0VBREFFTElBTkJBUkJqQUFzZ0FDQUZhaUFCT2dBQUlBUWdCQ2dDQ0VFQmFqWUNDQXdCQ3lBRUlBQWdBQ0FCYWhBZkN5QUNRUkJxSkFCQkFBdTBBd0VFZnlBQVFRQTJBZ2dnQUVFVWFrRUFOZ0lBSUFGQkQzRWhCQ0FBUVF4cUlRSkJBQ0VCQTBBZ0FDZ0NCQ0FCUmdSQUlBQWdBUkE4SUFBb0FnZ2hBUXNnQUNnQ0FDQUJRUUowYWlJQklBTTZBQUlnQVVFQU93RUFJQUFnQUNnQ0NFRUJhallDQ0NBQUtBSVVJZ0VnQUNnQ0VFWUVRQ0FDSUFFUU95QUFLQUlVSVFFTElBQW9BZ3dnQVVFQmRHcEJBVHNCQUNBQUlBQW9BaFJCQVdvMkFoUWdBQ2dDQ0NFQklBTkJBV29pQlNFRElBVkIvLzhEY1NBRWRrVU5BQXNnQUNnQ0JDQUJSZ1JBSUFBZ0FSQThJQUFvQWdnaEFRc2dBQ2dDQUNBQlFRSjBhaUlCUVFBNkFBSWdBVUVBT3dFQUlBQWdBQ2dDQ0VFQmFqWUNDQ0FBS0FJVUlnRWdBQ2dDRUVZRVFDQUNJQUVRT3lBQUtBSVVJUUVMSUFBb0Fnd2dBVUVCZEdwQkFEc0JBQ0FBSUFBb0FoUkJBV28yQWhRZ0FDZ0NDQ0lCSUFBb0FnUkdCRUFnQUNBQkVEd2dBQ2dDQ0NFQkN5QUFLQUlBSUFGQkFuUnFJZ0ZCQURvQUFpQUJRUUE3QVFBZ0FDQUFLQUlJUVFGcU5nSUlJQUFvQWhRaUFTQUFLQUlRUmdSQUlBSWdBUkE3SUFBb0FoUWhBUXNnQUNnQ0RDQUJRUUYwYWtFQU93RUFJQUFnQUNnQ0ZFRUJhallDRkF2K0F3SURmd0YrSUFFb0FoaEJKeUFCUVJ4cUtBSUFLQUlRRVFBQVJRUkFRZlFBSVFOQkFpRUNBa0FDUUFKQUFrQUNRQUpBSUFBb0FnQWlBRUYzYWc0ZkJRRURBd0FEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdRREF3TURCQUlMUWZJQUlRTU1CQXRCN2dBaEF3d0RDeUFBUWR3QVJnMEJDd0ovQW40Q1FDQUFFQTlGQkVBZ0FCQUhSUTBCUVFFTUF3c2dBRUVCY21kQkFuWkJCM090UW9DQWdJRFFBSVFNQVFzZ0FFRUJjbWRCQW5aQkIzT3RRb0NBZ0lEUUFJUUxJUVZCQXdzaEFpQUFJUU1NQVFzZ0FDRURDd05BSUFJaEJFSGNBQ0VBUVFFaEFnSkFBbjRDUUFKQUFrQUNRQ0FFUVFGckRnTUJCUUFDQ3dKQUFrQUNRQUpBSUFWQ0lJaW5RZjhCY1VFQmF3NEZBd0lCQUFZRkMwSDFBQ0VBSUFWQy8vLy8vNDlnZzBLQWdJQ0FNSVFNQmd0Qit3QWhBQ0FGUXYvLy8vK1BZSU5DZ0lDQWdDQ0VEQVVMUVRCQjF3QWdBeUFGcHlJRVFRSjBRUnh4ZGtFUGNTSUFRUXBKR3lBQWFpRUFJQVZDZjN4Qy8vLy8vdytESUFWQ2dJQ0FnSENEaENBRURRUWFJQVZDLy8vLy80OWdnMEtBZ0lDQUVJUU1CQXRCL1FBaEFDQUZRdi8vLy8rUFlJTU1Bd3RCQUNFQ0lBTWhBQXdEQ3lBQktBSVlRU2NnQVNnQ0hDZ0NFQkVBQUE4TElBVkMvLy8vLzQ5Z2cwS0FnSUNBd0FDRUN5RUZRUU1oQWdzZ0FTZ0NHQ0FBSUFFb0Fod29BaEFSQUFCRkRRQUxDMEVCQzZBREFRVi9Ba0FDUUVFQVFROGdBRUdrbWdSSkd5SUJJQUZCQ0dvaUFTQUJRUUowUVppZ3dBQnFLQUlBUVF0MElBQkJDM1FpQWtzYklnRWdBVUVFYWlJQklBRkJBblJCbUtEQUFHb29BZ0JCQzNRZ0Frc2JJZ0VnQVVFQ2FpSUJJQUZCQW5SQm1LREFBR29vQWdCQkMzUWdBa3NiSWdFZ0FVRUJhaUlCSUFGQkFuUkJtS0RBQUdvb0FnQkJDM1FnQWtzYklnTkJBblJCbUtEQUFHb29BZ0JCQzNRaUFTQUNSaUFCSUFKSmFpQURhaUlDUVI1TkJFQkJzUVVoQkNBQ1FSNUhCRUFnQWtFQ2RFR2NvTUFBYWlnQ0FFRVZkaUVFQzBFQUlRRWdBa0YvYWlJRElBSk5CRUFnQTBFZlR3MERJQU5CQW5SQm1LREFBR29vQWdCQi8vLy9BSEVoQVFzQ1FDQUVJQUpCQW5SQm1LREFBR29vQWdCQkZYWWlBMEVCYWtZTkFDQUFJQUZySVFJZ0EwR3hCU0FEUWJFRlN4c2hCU0FFUVg5cUlRRkJBQ0VBQTBBZ0F5QUZSZzBESUFBZ0EwR1VvY0FBYWkwQUFHb2lBQ0FDU3cwQklBRWdBMEVCYWlJRFJ3MEFDeUFCSVFNTElBTkJBWEVQQ3lBQ1FSOUIySi9BQUJBMkFBc2dCVUd4QlVIb244QUFFRFlBQ3lBRFFSOUIrSi9BQUJBMkFBdm9BZ0VGZndKQVFjMy9leUFBUVJBZ0FFRVFTeHNpQUdzZ0FVME5BQ0FBUVJBZ0FVRUxha0Y0Y1NBQlFRdEpHeUlFYWtFTWFoQUFJZ0pGRFFBZ0FrRjRhaUVCQWtBZ0FFRi9haUlESUFKeFJRUkFJQUVoQUF3QkN5QUNRWHhxSWdVb0FnQWlCa0Y0Y1NBQ0lBTnFRUUFnQUd0eFFYaHFJZ0lnQUNBQ2FpQUNJQUZyUVJCTEd5SUFJQUZySWdKcklRTWdCa0VEY1FSQUlBQWdBeUFBS0FJRVFRRnhja0VDY2pZQ0JDQUFJQU5xSWdNZ0F5Z0NCRUVCY2pZQ0JDQUZJQUlnQlNnQ0FFRUJjWEpCQW5JMkFnQWdBQ0FBS0FJRVFRRnlOZ0lFSUFFZ0FoQUdEQUVMSUFFb0FnQWhBU0FBSUFNMkFnUWdBQ0FCSUFKcU5nSUFDd0pBSUFCQkJHb29BZ0FpQVVFRGNVVU5BQ0FCUVhoeElnSWdCRUVRYWswTkFDQUFRUVJxSUFRZ0FVRUJjWEpCQW5JMkFnQWdBQ0FFYWlJQklBSWdCR3NpQkVFRGNqWUNCQ0FBSUFKcUlnSWdBaWdDQkVFQmNqWUNCQ0FCSUFRUUJnc2dBRUVJYWlFREN5QURDNFVEQVFSL0FrQUNRQ0FCUVlBQ1R3UkFJQUJCR0dvb0FnQWhCQUpBQWtBZ0FDQUFLQUlNSWdKR0JFQWdBRUVVUVJBZ0FFRVVhaUlDS0FJQUlnTWJhaWdDQUNJQkRRRkJBQ0VDREFJTElBQW9BZ2dpQVNBQ05nSU1JQUlnQVRZQ0NBd0JDeUFDSUFCQkVHb2dBeHNoQXdOQUlBTWhCU0FCSWdKQkZHb2lBeWdDQUNJQlJRUkFJQUpCRUdvaEF5QUNLQUlRSVFFTElBRU5BQXNnQlVFQU5nSUFDeUFFUlEwQ0lBQWdBRUVjYWlnQ0FFRUNkRUdjcWNBQWFpSUJLQUlBUndSQUlBUkJFRUVVSUFRb0FoQWdBRVliYWlBQ05nSUFJQUpGRFFNTUFnc2dBU0FDTmdJQUlBSU5BVUdRcDhBQVFaQ253QUFvQWdCQmZpQUFLQUljZDNFMkFnQVBDeUFBUVF4cUtBSUFJZ0lnQUVFSWFpZ0NBQ0lBUndSQUlBQWdBallDRENBQ0lBQTJBZ2dQQzBHTXA4QUFRWXlud0FBb0FnQkJmaUFCUVFOMmQzRTJBZ0FNQVFzZ0FpQUVOZ0lZSUFBb0FoQWlBUVJBSUFJZ0FUWUNFQ0FCSUFJMkFoZ0xJQUJCRkdvb0FnQWlBRVVOQUNBQ1FSUnFJQUEyQWdBZ0FDQUNOZ0lZQ3d1akF3SUVmd0orSXdCQlFHb2lBaVFBUVFFaEJBSkFJQUF0QUFRTkFDQUFMUUFGSVFVZ0FDZ0NBQ0lETFFBQVFRUnhSUVJBSUFNb0FoaEI4WTNBQUVIempjQUFJQVViUVFKQkF5QUZHeUFEUVJ4cUtBSUFLQUlNRVFFQURRRWdBQ2dDQUNJREtBSVlRYzZtd0FCQkJ5QURRUnhxS0FJQUtBSU1FUUVBRFFFZ0FDZ0NBQ0lES0FJWVFhZU13QUJCQWlBRFFSeHFLQUlBS0FJTUVRRUFEUUVnQVNBQUtBSUFRWlNnd0FBb0FnQVJBQUFoQkF3QkN5QUZSUVJBSUFNb0FoaEI3STNBQUVFRElBTkJIR29vQWdBb0Fnd1JBUUFOQVNBQUtBSUFJUU1MSUFKQkFUb0FGeUFDUVRScVFiQ053QUEyQWdBZ0FpQURLUUlZTndNSUlBSWdBa0VYYWpZQ0VDQURLUUlJSVFZZ0F5a0NFQ0VISUFJZ0F5MEFJRG9BT0NBQ0lBYzNBeWdnQWlBR053TWdJQUlnQXlrQ0FEY0RHQ0FDSUFKQkNHbzJBakFnQWtFSWFrSE9wc0FBUVFjUUN3MEFJQUpCQ0dwQnA0ekFBRUVDRUFzTkFDQUJJQUpCR0dwQmxLREFBQ2dDQUJFQUFBMEFJQUlvQWpCQjc0M0FBRUVDSUFJb0FqUW9BZ3dSQVFBaEJBc2dBRUVCT2dBRklBQWdCRG9BQkNBQ1FVQnJKQUFMNWdJQ0JuOEJmaU1BUVRCcklnUWtBQ0FFUVJCcUVDb2dCQ0FFS0FJVUlnVTJBaHdnQkNBRUtBSVFJZ1kyQWhnZ0JFRUlhaUFEUVFBUVFDQUVLUU1JSVFvZ0FFRUFOZ0lJSUFBZ0NqY0NBQUpBQWtBZ0F3UkFRUUFoQmtFQUlRVURRQ0FBSUFWQmdDQVFPaUFBSUFNZ0FDZ0NCQ0lISUFjZ0Ewc2JFRThnQmlBQ1N3MENJQUFvQWdBaENDQUFLQUlJSWdjZ0JVa05BeUFFUVNCcUlBUkJHR29pQ1NnQ0FDQUJJQVpxSUFJZ0Jtc2dCU0FJYWlBSElBVnJJQWtvQWdRb0Fnd1JDQUFnQkNnQ0pDQUZhaUVISUFRb0FpQWhDQ0FBS0FJSUlnVWdCMDhFUUNBQUtBSUFHaUFBSUFjMkFnZ2dCeUVGQ3lBRUxRQW9RUUpIQkVBZ0JpQUlhaUVHSUFVZ0Ewa05BUXNMSUFRb0FoZ2hCaUFFS0FJY0lRVUxJQVlnQlNnQ0FCRURBQ0FFS0FJY0lnQW9BZ2dhSUFRb0FoZ2hBU0FBS0FJRUJFQWdBUkFFQ3lBRVFUQnFKQUFQQ3lBR0lBSkJ5SUhBQUJBNUFBc2dCU0FIUWRpQndBQVFPUUFMMkFJQkJYOENRQUpBQWtBQ1FBSkFJQUpCQTJwQmZIRWdBbXNpQkVVTkFDQURJQVFnQkNBRFN4c2lCVVVOQUVFQUlRUWdBVUgvQVhFaEJnSkFBMEFnQWlBRWFpMEFBQ0FHUmcwQklBVWdCRUVCYWlJRVJ3MEFDeUFGSUFOQmVHb2lCRTBOQWd3REMwRUJJUWNNQXdzZ0EwRjRhaUVFUVFBaEJRc2dBVUgvQVhGQmdZS0VDR3doQmdOQUlBSWdCV29pQjBFRWFpZ0NBQ0FHY3lJSVFYOXpJQWhCLy8zN2QycHhJQWNvQWdBZ0JuTWlCMEYvY3lBSFFmLzkrM2RxY1hKQmdJR0NoSGh4UlFSQUlBVkJDR29pQlNBRVRRMEJDd3NnQlNBRFN3MENDMEVBSVFZQ2YwRUFJQU1nQlVZTkFCb2dBaUFGYWlFQ0lBTWdCV3NoQmtFQUlRUWdBVUgvQVhFaEFRSkFBMEFnQWlBRWFpMEFBQ0FCUmcwQklBWWdCRUVCYWlJRVJ3MEFDMEVBREFFTElBUWhCa0VCQ3lFSElBVWdCbW9oQkFzZ0FDQUVOZ0lFSUFBZ0J6WUNBQThMSUFVZ0EwSG9rTUFBRURrQUM3NENBZ1YvQVg0akFFRXdheUlFSkFCQkp5RUNBa0FnQUVLUXpnQlVCRUFnQUNFSERBRUxBMEFnQkVFSmFpQUNhaUlEUVh4cUlBQWdBRUtRemdDQUlnZENrTTRBZm4ybklnVkIvLzhEY1VIa0FHNGlCa0VCZEVHbWpzQUFhaThBQURzQUFDQURRWDVxSUFVZ0JrSGtBR3hyUWYvL0EzRkJBWFJCcG83QUFHb3ZBQUE3QUFBZ0FrRjhhaUVDSUFCQy84SFhMMVlnQnlFQURRQUxDeUFIcHlJRFFlTUFTZ1JBSUFKQmZtb2lBaUFFUVFscWFpQUhweUlESUFOQi8vOERjVUhrQUc0aUEwSGtBR3hyUWYvL0EzRkJBWFJCcG83QUFHb3ZBQUE3QUFBTEFrQWdBMEVLVGdSQUlBSkJmbW9pQWlBRVFRbHFhaUFEUVFGMFFhYU93QUJxTHdBQU93QUFEQUVMSUFKQmYyb2lBaUFFUVFscWFpQURRVEJxT2dBQUN5QUJRZkNMd0FCQkFDQUVRUWxxSUFKcVFTY2dBbXNRQ0NBRVFUQnFKQUFMb3dJQ0JIOEJmaU1BUVVCcUlnUWtBQUpBQWtBQ1FDQUNJQU5xSWdNZ0FrOEVRQ0FCS0FJRUlRVWdCRUVZYWtLQmdJQ0FFRGNEQUNBRUtBSWNJZ0pCZjJvaUJpQUVLQUlZYWtFQUlBSnJJZ2R4clNBRlFRRjBJZ1VnQXlBRklBTkxHeUlEUVFnZ0EwRUlTeHV0ZmlJSVFpQ0lweUFDUlhJTkFTQUNhVUVCUmdSQUlBaW5JQVpxSUFkeElRTU1Bd3NnQkVFd2FoQXdBQXNnQkVFSWFpQURRUUFRV2lBQUlBUXBBd2czQWdSQkFTRUNEQUlMUVFBaEFnc2dCRUV3YWlBQkVFMGdCRUVnYWlBRElBSWdCRUV3YWhBbFFRRWhBaUFFUVNocUtBSUFJUU1nQkNnQ0pDRUZJQVFvQWlCQkFVY0VRQ0FCSUFVZ0F4QmFRUUFoQWd3QkN5QUVRUkJxSUFVZ0F4QmFJQUFnQkNrREVEY0NCQXNnQUNBQ05nSUFJQVJCUUdza0FBdXVBZ0VJZnlNQVFUQnJJZ0VrQUVHQUlDRUNJQUZCR0dvUUx5QUJLQUljSVFRZ0FTZ0NHQ0VGSUFGQkVHb1FNaUFCS0FJVUlRWWdBU2dDRUNFSElBRkJDR3BCZ0NCQkFSQkFJQUZCZ0NBMkFpZ2dBU0FCS0FJTUlnZzJBaVFnQVNBQktBSUlJZ00yQWlBZ0NFR0JJRThFUUNBQlFTQnFRWUFnRUVVZ0FTZ0NJQ0VESUFFb0FpZ2hBZ3NnQUVFQU93QkhJQUJCQURzQk9DQUFJQU0yQWlnZ0FDQUZOZ0lRSUFCQkNEb0FSaUFBUVFBNkFBc2dBRUlBTndNQUlBQkJNR3BDQURjREFDQUFRU3hxSUFJMkFnQWdBRUVrYWtFQU5nSUFJQUJCSUdvZ0JqWUNBQ0FBUVJ4cUlBYzJBZ0FnQUVFWWFrRUFOZ0lBSUFCQkZHb2dCRFlDQUNBQVFRazZBQW9nQUVHQUFqc0JRaUFBUVlFQ093RkVJQUJCZ2dJN0FVQWdBRUgvQXpzQkNDQUJRVEJxSkFBTHh3SUNCWDhCZmlNQVFSQnJJZ01rQUNBQUxRQUxJUUlnQTBJQU53TUlJQUVvQWdBaEJRSkFBa0FnQUFKL0lBRW9BZ1FpQkVIQUFDQUNheUlHUWZnQmNVRURkaUlDU1FSQUlBUkJDVThOQWlBRFFRaHFJQVVnQkJCTEdpQUJRUUEyQWdRZ0FVR0lnOEFBTmdJQUlBUkJBM1FNQVFzZ0JrSC9BWEZCeUFCUERRSWdBMEVJYWlBRklBSVFTeG9nQVNBRUlBSnJOZ0lFSUFFZ0FpQUZhallDQUNBR1FmZ0JjUXNnQUMwQUN5SUJham9BQ3lBQUlBQXBBd0FnQXlrRENDSUhRamlHSUFkQ0tJWkNnSUNBZ0lDQXdQOEFnNFFnQjBJWWhrS0FnSUNBZ09BL2d5QUhRZ2lHUW9DQWdJRHdINE9FaENBSFFnaUlRb0NBZ1BnUGd5QUhRaGlJUW9DQS9BZURoQ0FIUWlpSVFvRCtBNE1nQjBJNGlJU0VoQ0FCUVQ5eHJZaUVOd01BSUFOQkVHb2tBQThMSUFSQkNFSFloY0FBRURjQUN5QUNRUWhCeUlYQUFCQTNBQXVxQWdFRGZ5TUFRWUFCYXlJRUpBQUNRQUpBQW44Q1FDQUJLQUlBSWdOQkVIRkZCRUFnQUNnQ0FDRUNJQU5CSUhFTkFTQUNyU0FCRUJVTUFnc2dBQ2dDQUNFQ1FRQWhBQU5BSUFBZ0JHcEIvd0JxSUFKQkQzRWlBMEV3Y2lBRFFkY0FhaUFEUVFwSkd6b0FBQ0FBUVg5cUlRQWdBa0VFZGlJQ0RRQUxJQUJCZ0FGcUlnSkJnUUZQRFFJZ0FVR2tqc0FBUVFJZ0FDQUVha0dBQVdwQkFDQUFheEFJREFFTFFRQWhBQU5BSUFBZ0JHcEIvd0JxSUFKQkQzRWlBMEV3Y2lBRFFUZHFJQU5CQ2trYk9nQUFJQUJCZjJvaEFDQUNRUVIySWdJTkFBc2dBRUdBQVdvaUFrR0JBVThOQWlBQlFhU093QUJCQWlBQUlBUnFRWUFCYWtFQUlBQnJFQWdMSUFSQmdBRnFKQUFQQ3lBQ1FZQUJRWlNPd0FBUU9RQUxJQUpCZ0FGQmxJN0FBQkE1QUF1eEFnRUVmeU1BUVVCcUlnSWtBQ0FCS0FJRUlnTkZCRUFnQVVFRWFpRURJQUVvQWdBaEJDQUNRUUEyQWlBZ0FrSUJOd01ZSUFJZ0FrRVlhallDSkNBQ1FUaHFJQVJCRUdvcEFnQTNBd0FnQWtFd2FpQUVRUWhxS1FJQU53TUFJQUlnQkNrQ0FEY0RLQ0FDUVNScVFkaUp3QUFnQWtFb2FoQUpHaUFDUVJCcUlnUWdBaWdDSURZQ0FDQUNJQUlwQXhnM0F3Z0NRQ0FCS0FJRUlnVkZEUUFnQVVFSWFpZ0NBRVVOQUNBRkVBUUxJQU1nQWlrRENEY0NBQ0FEUVFocUlBUW9BZ0EyQWdBZ0F5Z0NBQ0VEQ3lBQlFRRTJBZ1FnQVVFTWFpZ0NBQ0VFSUFGQkNHb2lBU2dDQUNFRklBRkNBRGNDQUVFTVFRUVFXU0lCUlFSQVFReEJCQkJqQUFzZ0FTQUVOZ0lJSUFFZ0JUWUNCQ0FCSUFNMkFnQWdBRUdRaThBQU5nSUVJQUFnQVRZQ0FDQUNRVUJySkFBTC9BRUJBbjhqQUVFUWF5SUNKQUFnQUNnQ0FDQUNRUUEyQWd3Q2Z3SkFBa0FnQVVHQUFVOEVRQ0FCUVlBUVNRMEJJQUpCREdvaEFDQUJRWUNBQkU4TkFpQUNJQUZCUDNGQmdBRnlPZ0FPSUFJZ0FVRU1ka0hnQVhJNkFBd2dBaUFCUVFaMlFUOXhRWUFCY2pvQURVRUREQU1MSUFJZ0FUb0FEQ0FDUVF4cUlRQkJBUXdDQ3lBQ0lBRkJQM0ZCZ0FGeU9nQU5JQUlnQVVFR2RrSEFBWEk2QUF3Z0FrRU1haUVBUVFJTUFRc2dBaUFCUVQ5eFFZQUJjam9BRHlBQ0lBRkJFblpCOEFGeU9nQU1JQUlnQVVFR2RrRS9jVUdBQVhJNkFBNGdBaUFCUVF4MlFUOXhRWUFCY2pvQURVRUVDeUVCSUFBZ0FSQUxJQUpCRUdva0FBdjVBUUVDZnlNQVFSQnJJZ0lrQUNBQ1FRQTJBZ3dDZndKQUFrQWdBVUdBQVU4RVFDQUJRWUFRU1EwQklBSkJER29oQXlBQlFZQ0FCRThOQWlBQ0lBRkJQM0ZCZ0FGeU9nQU9JQUlnQVVFTWRrSGdBWEk2QUF3Z0FpQUJRUVoyUVQ5eFFZQUJjam9BRFVFRERBTUxJQUlnQVRvQURDQUNRUXhxSVFOQkFRd0NDeUFDSUFGQlAzRkJnQUZ5T2dBTklBSWdBVUVHZGtIQUFYSTZBQXdnQWtFTWFpRURRUUlNQVFzZ0FpQUJRVDl4UVlBQmNqb0FEeUFDSUFGQkVuWkI4QUZ5T2dBTUlBSWdBVUVHZGtFL2NVR0FBWEk2QUE0Z0FpQUJRUXgyUVQ5eFFZQUJjam9BRFVFRUN5RUJJQUFnQXlBQkVBc2dBa0VRYWlRQUMvd0JBUU4vSXdCQklHc2lCQ1FBQWtBZ0FrRUJhaUlESUFKUEJFQWdBU2dDQkNJQ1FRRjBJZ1VnQXlBRklBTkxHeUlEUVFRZ0EwRUVTeHNpQTBILy8vLy9BM0VnQTBaQkFYUWhCU0FEUVFKMElRTUNRQ0FDQkVBZ0JFRVlha0VDTmdJQUlBUWdBa0VDZERZQ0ZDQUVJQUVvQWdBMkFoQU1BUXNnQkVFQU5nSVFDeUFFSUFNZ0JTQUVRUkJxRUNWQkFTRUNJQVJCQ0dvb0FnQWhBeUFFS0FJRUlRVWdCQ2dDQUVFQlJ3UkFJQUVnQlRZQ0FDQUJJQU5CQW5ZMkFnUkJBQ0VDREFJTElBQWdCVFlDQkNBQVFRaHFJQU0yQWdBTUFRc2dBQ0FETmdJRUlBQkJDR3BCQURZQ0FFRUJJUUlMSUFBZ0FqWUNBQ0FFUVNCcUpBQUw4QUVCQkg4akFFRWdheUlFSkFBQ1FDQUNRUUZxSWdNZ0FrOEVRQ0FCS0FJRUlnVkJBWFFpQWlBRElBSWdBMHNiSWdOQkJDQURRUVJMR3lJRElBTnFJZ1lnQTA5QkFYUWhBd0pBSUFVRVFDQUVRUmhxUVFJMkFnQWdCQ0FDTmdJVUlBUWdBU2dDQURZQ0VBd0JDeUFFUVFBMkFoQUxJQVFnQmlBRElBUkJFR29RSlVFQklRSWdCRUVJYWlnQ0FDRURJQVFvQWdRaEJTQUVLQUlBUVFGSEJFQWdBU0FGTmdJQUlBRWdBMEVCZGpZQ0JFRUFJUUlNQWdzZ0FDQUZOZ0lFSUFCQkNHb2dBellDQUF3QkN5QUFJQU0yQWdRZ0FFRUlha0VBTmdJQVFRRWhBZ3NnQUNBQ05nSUFJQVJCSUdva0FBdlpBUUVEZndKQUlBQkJCR29vQWdBaUJDQUFRUWhxS0FJQUlnTnJJQUlnQVdzaUJVOEVRQ0FBS0FJQUlRUU1BUXNDZndKQUFrQWdBeUFGYWlJQ0lBTkpEUUFnQkVFQmRDSURJQUlnQXlBQ1N4c2lBa0VJSUFKQkNFc2JJUUlnQkFSQUlBSkJBRWdOQVNBQUtBSUFJZ05GRFFJZ0F5QUVRUUVnQWhCVkRBTUxJQUpCQUU0TkFRc1FYUUFMSUFKQkFSQlpDeUlFQkVBZ0FDQUVOZ0lBSUFCQkJHb2dBallDQUNBQVFRaHFLQUlBSVFNTUFRc2dBa0VCRUdNQUN5QURJQVJxSUFFZ0JSQkxHaUFBUVFocUlnQWdBQ2dDQUNBRmFqWUNBQXZvQVFFRmZ5TUFRUkJySWdNa0FDQUFMUUFMSVFJZ0EwSUFOd01JSUFFb0FnQWhCUUpBQWtBZ0FBSi9JQUVvQWdRaUJFSEFBQ0FDYXlJR1FmZ0JjVUVEZGlJQ1NRUkFJQVJCQ1U4TkFpQURRUWhxSUFVZ0JCQkxHaUFCUVFBMkFnUWdBVUdJZzhBQU5nSUFJQVJCQTNRTUFRc2dCa0gvQVhGQnlBQlBEUUlnQTBFSWFpQUZJQUlRU3hvZ0FTQUVJQUpyTmdJRUlBRWdBaUFGYWpZQ0FDQUdRZmdCY1FzZ0FDMEFDeUlCYWpvQUN5QUFJQUFwQXdBZ0F5a0RDQ0FCUVQ5eHJZYUVOd01BSUFOQkVHb2tBQThMSUFSQkNFSDRoY0FBRURjQUN5QUNRUWhCNklYQUFCQTNBQXZjQVFFRWZ5TUFRVUJxSWdJa0FDQUJRUVJxSVFRZ0FTZ0NCRVVFUUNBQktBSUFJUU1nQWtFQU5nSWdJQUpDQVRjREdDQUNJQUpCR0dvMkFpUWdBa0U0YWlBRFFSQnFLUUlBTndNQUlBSkJNR29nQTBFSWFpa0NBRGNEQUNBQ0lBTXBBZ0EzQXlnZ0FrRWtha0hZaWNBQUlBSkJLR29RQ1JvZ0FrRVFhaUlESUFJb0FpQTJBZ0FnQWlBQ0tRTVlOd01JQWtBZ0FTZ0NCQ0lGUlEwQUlBRkJDR29vQWdCRkRRQWdCUkFFQ3lBRUlBSXBBd2czQWdBZ0JFRUlhaUFES0FJQU5nSUFDeUFBUVpDTHdBQTJBZ1FnQUNBRU5nSUFJQUpCUUdza0FBdVlBZ0VDZnlNQVFTQnJJZ1FrQUVFQklRVkJpS2ZBQUVHSXA4QUFLQUlBUVFGcU5nSUFBa0FDUUFKQVFkQ3F3QUFvQWdCQkFVY0VRRUhRcXNBQVFvR0FnSUFRTndNQURBRUxRZFNxd0FCQjFLckFBQ2dDQUVFQmFpSUZOZ0lBSUFWQkFrc05BUXNnQkNBRE5nSWNJQVFnQWpZQ0dDQUVRZkNKd0FBMkFoUWdCRUh3aWNBQU5nSVFRZnltd0FBb0FnQWlBa0YvVEEwQVFmeW13QUFnQWtFQmFpSUNOZ0lBUWZ5bXdBQkJoS2ZBQUNnQ0FDSURCSDlCZ0tmQUFDZ0NBQ0FFUVFocUlBQWdBU2dDRUJFQ0FDQUVJQVFwQXdnM0F4QWdCRUVRYWlBREtBSU1FUUlBUWZ5bXdBQW9BZ0FGSUFJTFFYOXFOZ0lBSUFWQkFVME5BUXNBQ3lNQVFSQnJJZ0lrQUNBQ0lBRTJBZ3dnQWlBQU5nSUlBQXZNQVFFQ2Z5QUJRUlJxS0FJQUlnVWdBMEgvL3dOeElnUkxCRUFnQVNnQ0RDQUVRUUYwYWk4QkFDRUZJQUVvQWdnaUJDQUJLQUlFUmdSQUlBRWdCQkE4SUFFb0FnZ2hCQXNnQVNnQ0FDQUVRUUowYWlJRUlBSTZBQUlnQkNBRE93RUFJQUVnQVNnQ0NFRUJhallDQ0NBQktBSVVJZ1FnQVVFUWFpZ0NBRVlFUUNBQlFReHFJQVFRT3lBQktBSVVJUVFMSUFFb0Fnd2dCRUVCZEdvZ0JVRUJhanNCQUNBQklBRW9BaFJCQVdvMkFoUWdBQ0FDT2dBQ0lBQWdBenNCQUE4TElBUWdCVUg0aHNBQUVEWUFDOFFCQVFKL0l3QkJFR3NpQWlRQUlBSWdBYTFDZ0lDQWdCQkNBQ0FCS0FJWVFjV213QUJCQ1NBQlFSeHFLQUlBS0FJTUVRRUFHNFEzQXdBZ0FpQUFOZ0lNSUFJZ0FrRU1haEFTSUFJdEFBUWhBU0FDTFFBRkJFQWdBVUgvQVhFaEFDQUNBbjlCQVNBQURRQWFJQUlvQWdBaUFFRWNhaWdDQUNnQ0RDRUJJQUFvQWhnaEF5QUFMUUFBUVFSeFJRUkFJQU5COTQzQUFFRUNJQUVSQVFBTUFRc2dBMEgyamNBQVFRRWdBUkVCQUFzaUFUb0FCQXNnQWtFUWFpUUFJQUZCL3dGeFFRQkhDNm9CQVFKL0FrQUNRQUpBSUFJRVFFRUJJUVFnQVVFQVRnMEJEQUlMSUFBZ0FUWUNCRUVCSVFRTUFRc0NRQUpBQWtBQ1FBSkFJQU1vQWdBaUJVVUVRQ0FCUlEwQkRBTUxJQU1vQWdRaUF3MEJJQUVOQWdzZ0FpRUREQU1MSUFVZ0F5QUNJQUVRVlNJRFJRMEJEQUlMSUFFZ0FoQlpJZ01OQVFzZ0FDQUJOZ0lFSUFJaEFRd0NDeUFBSUFNMkFnUkJBQ0VFREFFTFFRQWhBUXNnQUNBRU5nSUFJQUJCQ0dvZ0FUWUNBQXVmQVFFRGZ5QUFRZ0EzQWdnQ1FDQUJRUlJxS0FJQUlnUWdBa0gvL3dOeElnTkxCRUFnQVNnQ0RDQURRUUYwYWk4QkFDRURJQUFvQWdRaEJDQUFRUUEyQWdRZ0FDZ0NBQ0VGSUFCQkFUWUNBQ0FFSUFOSkRRRWdBU0FDSUFVZ0F4QXBJQUFvQWdRRVFDQUFLQUlBRUFRTElBQWdBellDRENBQUlBUTJBZ1FnQUNBRk5nSUFEd3NnQXlBRVFiaUd3QUFRTmdBTElBTWdCRUhJaHNBQUVEY0FDNGNCQVFKL0l3QkJNR3NpQkNRQUlBUkJJR29pQlNBQ05nSUlJQVVnQWpZQ0JDQUZJQUUyQWdBZ0JFRUlhaUFFUVNCcUVFNGdCRUVRYWlBRUtBSUlJZ0VnQkNnQ0RDSUNJQU1RRXlBQ0JFQWdBUkFFQ3lBRVFTaHFJQVJCR0dvb0FnQTJBZ0FnQkNBRUtRTVFOd01nSUFRZ0JFRWdhaEJPSUFBZ0JDa0RBRGNEQUNBRVFUQnFKQUFMZ2dFQkJuOGpBRUVRYXlJREpBQWdBQ0FBS0FJSUlBRVFPaUFBS0FJQUlRVWdBQ2dDQ0NFQ0lBTkJDR3BCQVNBQkVGb2dBaUFGYWlFRUlBTW9BZ3dpQmlBREtBSUlJZ2RMQkVBZ0JDQUdJQWRyRUZJZ0JTQUNJQVpxSUFkcklnSnFJUVFMSUFBZ0FRUi9JQVJCQURvQUFDQUNRUUZxQlNBQ0N6WUNDQ0FEUVJCcUpBQUxqZ0VCQTM4Z0FDZ0NDQ0lFSUFGQi8vOERjU0lGU3dSQUlBTUVRQ0FBS0FJQUlRUWdBa0YvYWlFRklBRWhBQU5BSUFRZ0FFSC8vd054UVFKMGFpSUdMd0VBSVFBZ0F5QUZhaUFHTFFBQ09nQUFJQUFnQVNBQUlBRkIvLzhEY1VrYklRQWdBMEYvYWlJRERRQUxJQUl0QUFBUEMwRUFRUUJCbUlmQUFCQTJBQXNnQlVFQmFpQUVRWWlId0FBUU53QUxhQUVDZnlNQVFkQUFheUlDSkFBakFFRXdheUlCSkFBZ0FVRUlPZ0FQSUFGQk1Hb2tBQ0FDRUJkQjBBQkJDQkJaSWdFRVFDQUJJQUpCMEFBUVN4b2dBVUVCT2dCSUlBQkJwSVBBQURZQ0JDQUFJQUUyQWdBZ0FrSFFBR29rQUE4TFFkQUFRUWdRWXdBTGdBRUNBbjhCZmlBQkxRQUxJZ1FnQVMwQUNpSURTUVJBSUFFZ0FoQVlJQUV0QUFzaEJDQUJMUUFLSVFNTElBUWdBMEgvQVhGSkJIOUJBQVVnQVNBRUlBTnJPZ0FMSUFFZ0FTa0RBQ0FEcllraUJTQUJMd0VJSWdHdFFuK0ZRb0NBZklTRE53TUFJQUVnQmFkeElRTkJBUXNoQVNBQUlBTTdBUUlnQUNBQk93RUFDNklCQVFOL0l3QkJFR3NpQVNRQUlBQW9BZ0FpQWtFVWFpZ0NBQ0VEQWtBQ2Z3SkFBa0FnQWlnQ0JBNENBQUVEQ3lBRERRSkJBQ0VDUWZDSndBQU1BUXNnQXcwQklBSW9BZ0FpQXlnQ0JDRUNJQU1vQWdBTElRTWdBU0FDTmdJRUlBRWdBellDQUNBQlFmeUt3QUFnQUNnQ0JDZ0NDQ0FBS0FJSUVDSUFDeUFCUVFBMkFnUWdBU0FDTmdJQUlBRkI2SXJBQUNBQUtBSUVLQUlJSUFBb0FnZ1FJZ0FMZ1FFQkEzOGdBU2dDQkNJRElBSlBCRUFDUUNBRFJRMEFJQUVvQWdBaEJBSkFBa0FnQWtVRVFFRUJJUU1nQkJBRURBRUxJQVFnQTBFQklBSVFWU0lEUlEwQkN5QUJJQUkyQWdRZ0FTQUROZ0lBREFFTElBQWdBallDQkNBQVFRaHFRUUUyQWdCQkFTRUZDeUFBSUFVMkFnQVBDMEdVaU1BQVFTUkJ1SWpBQUJCSUFBdDFBZ0ovQVg0Z0FTMEFDeUlFSUFFdEFBb2lBMGtFUUNBQklBSVFJQ0FCTFFBTElRUWdBUzBBQ2lFREN5QUVJQU5CL3dGeFNRUi9RUUFGSUFFZ0JDQURhem9BQ3lBQklBRXBBd0FpQlNBRHJVSS9nNGczQXdBZ0FTOEJDQ0FGcDNFaEEwRUJDeUVCSUFBZ0F6c0JBaUFBSUFFN0FRQUxNQUVCZndKQUFrQkJnSUFCUVFJUVdTSUJEUUVNQUF0QmdJQUJRUUlRWXdBTElBQWdBVFlDQUNBQVFZQWdOZ0lFQzRZQkFRRi9Jd0JCUUdvaUFTUUFJQUZCS3pZQ0RDQUJRWUNCd0FBMkFnZ2dBVUdzZ2NBQU5nSVVJQUVnQURZQ0VDQUJRU3hxUVFJMkFnQWdBVUU4YWtFaE5nSUFJQUZDQWpjQ0hDQUJRYXlNd0FBMkFoZ2dBVUVkTmdJMElBRWdBVUV3YWpZQ0tDQUJJQUZCRUdvMkFqZ2dBU0FCUVFocU5nSXdJQUZCR0dwQjhJREFBQkJSQUF0eEFRTi9Jd0JCSUdzaUFpUUFBa0FnQUNBQkVCa05BQ0FCUVJ4cUtBSUFJUU1nQVNnQ0dDQUNRUnhxUVFBMkFnQWdBa0h3aThBQU5nSVlJQUpDQVRjQ0RDQUNRZlNMd0FBMkFnZ2dBeUFDUVFocUVBa05BQ0FBUVFScUlBRVFHU0FDUVNCcUpBQVBDeUFDUVNCcUpBQkJBUXN3QVFGL0FrQUNRRUdBd0FCQkFoQlpJZ0VOQVF3QUMwR0F3QUJCQWhCakFBc2dBQ0FCTmdJQUlBQkJnQ0EyQWdRTGV3RUNmd0pBQWtBZ0FDZ0NCQ0lCQkVBZ0FDZ0NEQ0lDSUFGUERRRWdBQ2dDQUNJQklBSnFJQUV0QUFBNkFBQWdBRUVBTmdJSUlBQWdBQ2dDREVFQmFqWUNEQ0FBS0FJRVJRMENJQUFvQWdBdEFBQVBDMEVBUVFCQmlJYkFBQkEyQUFzZ0FpQUJRWmlHd0FBUU5nQUxRUUJCQUVHb2hzQUFFRFlBQzJnQkFuOGdBQ0FBTFFCR0lnRkJBV29pQWpvQUNpQUFRUUVnQVVFUGNYUkJBbW9pQVRzQlFDQUFRWDhnQWtFUGNYUkJmM003QVFnZ0FFRVlhaWdDQUNBQlFmLy9BM0VpQVU4RVFDQUFJQUUyQWhnTElBQkJKR29vQWdBZ0FVOEVRQ0FBSUFFMkFpUUxDMUFCQVg4Z0FFRVVhaWdDQUNJQlJTQUJRUUowUlhKRkJFQWdBQ2dDRUJBRUN5QUFRU0JxS0FJQUlnRkZJQUZCQVhSRmNrVUVRQ0FBS0FJY0VBUUxJQUJCTEdvb0FnQUVRQ0FBS0FJb0VBUUxDMndCQVg4akFFRXdheUlESkFBZ0F5QUJOZ0lFSUFNZ0FEWUNBQ0FEUVJ4cVFRSTJBZ0FnQTBFc2FrRWNOZ0lBSUFOQ0FqY0NEQ0FEUVlDTndBQTJBZ2dnQTBFY05nSWtJQU1nQTBFZ2FqWUNHQ0FESUFNMkFpZ2dBeUFEUVFScU5nSWdJQU5CQ0dvZ0FoQlJBQXRzQVFGL0l3QkJNR3NpQXlRQUlBTWdBVFlDQkNBRElBQTJBZ0FnQTBFY2FrRUNOZ0lBSUFOQkxHcEJIRFlDQUNBRFFnSTNBZ3dnQTBITWtjQUFOZ0lJSUFOQkhEWUNKQ0FESUFOQklHbzJBaGdnQXlBRFFRUnFOZ0lvSUFNZ0F6WUNJQ0FEUVFocUlBSVFVUUFMYkFFQmZ5TUFRVEJySWdNa0FDQURJQUUyQWdRZ0F5QUFOZ0lBSUFOQkhHcEJBallDQUNBRFFTeHFRUncyQWdBZ0EwSUNOd0lNSUFOQmdKTEFBRFlDQ0NBRFFSdzJBaVFnQXlBRFFTQnFOZ0lZSUFNZ0EwRUVhallDS0NBRElBTTJBaUFnQTBFSWFpQUNFRkVBQzJ3QkFYOGpBRUV3YXlJREpBQWdBeUFCTmdJRUlBTWdBRFlDQUNBRFFSeHFRUUkyQWdBZ0EwRXNha0VjTmdJQUlBTkNBamNDRENBRFFheVJ3QUEyQWdnZ0EwRWNOZ0lrSUFNZ0EwRWdhallDR0NBRElBTkJCR28yQWlnZ0F5QUROZ0lnSUFOQkNHb2dBaEJSQUF0Y0FRRi9Jd0JCRUdzaUF5UUFBa0FnQUNnQ0JDQUJheUFDVHdSQUlBTkJBRFlDQUF3QkN5QURJQUFnQVNBQ0VCWWdBeWdDQUVFQlJ3MEFJQU5CQ0dvb0FnQWlBQVJBSUFNb0FnUWdBQkJqQUFzUVhRQUxJQU5CRUdva0FBdGFBUUYvSXdCQkVHc2lBaVFBQWtBZ0FDZ0NCQ0FCYTBFQlR3UkFJQUpCQURZQ0FBd0JDeUFDSUFBZ0FSQWVJQUlvQWdCQkFVY05BQ0FDUVFocUtBSUFJZ0FFUUNBQ0tBSUVJQUFRWXdBTEVGMEFDeUFDUVJCcUpBQUxXZ0VCZnlNQVFSQnJJZ0lrQUFKQUlBQW9BZ1FnQVd0QkFVOEVRQ0FDUVFBMkFnQU1BUXNnQWlBQUlBRVFIU0FDS0FJQVFRRkhEUUFnQWtFSWFpZ0NBQ0lBQkVBZ0FpZ0NCQ0FBRUdNQUN4QmRBQXNnQWtFUWFpUUFDMWtCQVg4akFFRWdheUlDSkFBZ0FpQUFLQUlBTmdJRUlBSkJHR29nQVVFUWFpa0NBRGNEQUNBQ1FSQnFJQUZCQ0dvcEFnQTNBd0FnQWlBQktRSUFOd01JSUFKQkJHcEIySW5BQUNBQ1FRaHFFQWtnQWtFZ2FpUUFDMFlBQWtCQkNDQUNTUVJBQW45QkNDQUNTUVJBSUFJZ0F4QVFEQUVMSUFNUUFBc2lBZzBCUVFBUEN5QUFJQU1RQ2c4TElBSWdBQ0FESUFFZ0FTQURTeHNRU3lBQUVBUUxXUUVCZnlNQVFTQnJJZ0lrQUNBQ0lBQW9BZ0EyQWdRZ0FrRVlhaUFCUVJCcUtRSUFOd01BSUFKQkVHb2dBVUVJYWlrQ0FEY0RBQ0FDSUFFcEFnQTNBd2dnQWtFRWFrSHdqOEFBSUFKQkNHb1FDU0FDUVNCcUpBQUxXUUFDUUFKQUFrQWdBVUYvU2dSQUFrQWdBZ1JBSUFFTkFRd0VDeUFCUlEwRElBRkJBUkJaSWdJTkJBd0NDeUFCRUVjaUFrVU5BUXdEQ3hCZEFBc2dBVUVCRUdNQUMwRUJJUUlMSUFBZ0FUWUNCQ0FBSUFJMkFnQUxWZ0VCZnlNQVFTQnJJZ0lrQUNBQ0lBQTJBZ1FnQWtFWWFpQUJRUkJxS1FJQU53TUFJQUpCRUdvZ0FVRUlhaWtDQURjREFDQUNJQUVwQWdBM0F3Z2dBa0VFYWtId2o4QUFJQUpCQ0dvUUNTQUNRU0JxSkFBTFdRRURmd0pBSUFFb0Fnd2lBaUFCS0FJSUlnTlBCRUFnQVNnQ0JDSUVJQUpKRFFFZ0FTZ0NBQ0VCSUFBZ0FpQURhellDQkNBQUlBRWdBMm8yQWdBUEN5QURJQUpCMkliQUFCQTRBQXNnQWlBRVFkaUd3QUFRTndBTFZRRUJmeUFBUVJCcUlBQXRBRVlRRFNBQVFRQTZBRWNnQUVFQU93RTRJQUJCTUdwQ0FEY0RBQ0FBUVFBNkFBc2dBRUlBTndNQUlBQWdBQzBBUmtFQmFpSUJPZ0FLSUFCQmZ5QUJRUTl4ZEVGL2N6c0JDQXREQVFOL0FrQWdBa1VOQUFOQUlBQXRBQUFpQkNBQkxRQUFJZ1ZHQkVBZ0FFRUJhaUVBSUFGQkFXb2hBU0FDUVg5cUlnSU5BUXdDQ3dzZ0JDQUZheUVEQ3lBREMwVUJBWDhqQUVFUWF5SUNKQUFnQWlBQUlBRVFMUUpBSUFJb0FnQkJBVVlFUUNBQ1FRaHFLQUlBSWdCRkRRRWdBaWdDQkNBQUVHTUFDeUFDUVJCcUpBQVBDeEJkQUF0S0FBSi9JQUZCZ0lERUFFY0VRRUVCSUFBb0FoZ2dBU0FBUVJ4cUtBSUFLQUlRRVFBQURRRWFDeUFDUlFSQVFRQVBDeUFBS0FJWUlBSWdBeUFBUVJ4cUtBSUFLQUlNRVFFQUN3c21BUUYvQWtBZ0FCQUFJZ0ZGRFFBZ0FVRjhhaTBBQUVFRGNVVU5BQ0FCSUFBUVVnc2dBUXRIQVFGL0l3QkJJR3NpQXlRQUlBTkJGR3BCQURZQ0FDQURRZkNMd0FBMkFoQWdBMElCTndJRUlBTWdBVFlDSENBRElBQTJBaGdnQXlBRFFSaHFOZ0lBSUFNZ0FoQlJBQXRFQVFKL0lBRW9BZ1FoQWlBQktBSUFJUU5CQ0VFRUVGa2lBVVVFUUVFSVFRUVFZd0FMSUFFZ0FqWUNCQ0FCSUFNMkFnQWdBRUdnaThBQU5nSUVJQUFnQVRZQ0FBdGJBUU4vSXdCQkVHc2lBU1FBSUFBb0Fnd2lBa1VFUUVHQWlzQUFRU3RCeUlyQUFCQklBQXNnQUNnQ0NDSURSUVJBUVlDS3dBQkJLMEhZaXNBQUVFZ0FDeUFCSUFJMkFnZ2dBU0FBTmdJRUlBRWdBellDQUNBQkVGQUFDek1CQVg4Z0FnUkFJQUFoQXdOQUlBTWdBUzBBQURvQUFDQUJRUUZxSVFFZ0EwRUJhaUVESUFKQmYyb2lBZzBBQ3dzZ0FBc3NBQUpBSUFCQmZFMEVRQ0FBUlFSQVFRUWhBQXdDQ3lBQUlBQkJmVWxCQW5RUVdTSUFEUUVMQUFzZ0FBc3hBUUYvSUFFb0FnUWlBZ1JBSUFBZ0FqWUNCQ0FBUVFocVFRRTJBZ0FnQUNBQktBSUFOZ0lBRHdzZ0FFRUFOZ0lBQ3pFQkFYOGdBQ0FCS0FJRUlBRW9BZ2dpQWtzRWZ5QUJJQUlRUlNBQktBSUlCU0FDQ3pZQ0JDQUFJQUVvQWdBMkFnQUxLQUVCZnlBQUtBSUlJZ0lnQVU4RVFDQUFLQUlBR2lBQUlBRTJBZ2dQQ3lBQUlBRWdBbXNRS0Fzc0FRRi9Jd0JCRUdzaUFTUUFJQUZCQ0dvZ0FFRUlhaWdDQURZQ0FDQUJJQUFwQWdBM0F3QWdBUkFzQUFzMEFRRi9Jd0JCRUdzaUFpUUFJQUlnQVRZQ0RDQUNJQUEyQWdnZ0FrRzhqTUFBTmdJRUlBSkI4SXZBQURZQ0FDQUNFRW9BQ3lFQUlBRUVRQU5BSUFCQkFEb0FBQ0FBUVFGcUlRQWdBVUYvYWlJQkRRQUxDd3NnQVFGL0FrQWdBQ2dDQUNJQlJRMEFJQUJCQkdvb0FnQkZEUUFnQVJBRUN3c2dBUUYvQWtBZ0FDZ0NCQ0lCUlEwQUlBQkJDR29vQWdCRkRRQWdBUkFFQ3dzTUFDQUFJQUVnQWlBREVENExDd0FnQVFSQUlBQVFCQXNMRWdBZ0FDZ0NBQ0FCSUFFZ0Ftb1FIMEVBQ3hRQUlBQW9BZ0FnQVNBQUtBSUVLQUlNRVFBQUN4a0FBbjlCQ0NBQlNRUkFJQUVnQUJBUURBRUxJQUFRQUFzTEVBQWdBQ0FDTmdJRUlBQWdBVFlDQUFzVEFDQUFRYUNMd0FBMkFnUWdBQ0FCTmdJQUN4QUFJQUVnQUNnQ0FDQUFLQUlFRUFVTEVRQkJ6SXZBQUVFUlFlQ0x3QUFRU0FBTERnQWdBQ2dDQUJvRFFBd0FDd0FMQ3dBZ0FEVUNBQ0FCRUJVTERRQWdBQ2dDQUNBQklBSVFDd3NMQUNBQU1RQUFJQUVRRlFzTEFDQUFJd0JxSkFBakFBc1pBQ0FBSUFGQitLYkFBQ2dDQUNJQVFRNGdBQnNSQWdBQUN3MEFJQUZCeEpEQUFFRUNFQVVMQ1FBZ0FFRUFPZ0JIQ3djQUlBQXRBRWNMRFFCQzlQbWU1dTZqcXZuK0FBc05BRUwzdU83NnFzelY3dVVBQ3d3QVF1blFvdHZNb3VxN1Jnc0RBQUVMQXdBQkN3dmZKZ0VBUVlDQXdBQUwxU1l2VlhObGNuTXZabTA0TVRNdkxuSjFjM1IxY0M5MGIyOXNZMmhoYVc1ekwzTjBZV0pzWlMxNE9EWmZOalF0WVhCd2JHVXRaR0Z5ZDJsdUwyeHBZaTl5ZFhOMGJHbGlMM055WXk5eWRYTjBMMnhwWW5KaGNua3ZZMjl5WlM5emNtTXZZV3hzYjJNdmJHRjViM1YwTG5KekFBQVFBSEFBQUFBTEFRQUFPUUFBQUdOaGJHeGxaQ0JnVW1WemRXeDBPanAxYm5keVlYQW9LV0FnYjI0Z1lXNGdZRVZ5Y21BZ2RtRnNkV1VBQVFBQUFBQUFBQUFCQUFBQUFnQUFBSE55WXk5c2FXSXVjbk1BQUx3QUVBQUtBQUFBR3dBQUFBNEFBQUM4QUJBQUNnQUFBQndBQUFBU0FBQUFZWE56WlhKMGFXOXVJR1poYVd4bFpEb2diV2xrSUR3OUlITmxiR1l1YkdWdUtDa3ZWWE5sY25NdlptMDRNVE12TG5KMWMzUjFjQzkwYjI5c1kyaGhhVzV6TDNOMFlXSnNaUzE0T0RaZk5qUXRZWEJ3YkdVdFpHRnlkMmx1TDJ4cFlpOXlkWE4wYkdsaUwzTnlZeTl5ZFhOMEwyeHBZbkpoY25rdlkyOXlaUzl6Y21NdmMyeHBZMlV2Ylc5a0xuSnpDd0VRQUcwQUFBRDlCQUFBQ1FBQUFBTUFBQUJRQUFBQUNBQUFBQVFBQUFBRkFBQUFCZ0FBQUFjQUFBQUlBQUFBVUFBQUFBZ0FBQUFKQUFBQUNnQUFBQXNBQUFBTUFBQUFMMVZ6WlhKekwyWnRPREV6THk1allYSm5ieTl5WldkcGMzUnllUzl6Y21NdloybDBhSFZpTG1OdmJTMHhaV05qTmpJNU9XUmlPV1ZqT0RJekwzZGxaWHBzTFRBdU1TNDBMM055WXk5a1pXTnZaR1V1Y25NQUFNQUJFQUJXQUFBQVdnSUFBQjhBQUFEQUFSQUFWZ0FBQUcwQ0FBQWJBQUFBd0FFUUFGWUFBQUNDQWdBQUpnQUFBTUFCRUFCV0FBQUFxd0lBQUJFQUFBREFBUkFBVmdBQUFLMENBQUFSQUFBQXdBRVFBRllBQUFDNUFnQUFHUUFBQU1BQkVBQldBQUFBelFJQUFDSUFBQURBQVJBQVZnQUFBTThDQUFBYkFBQUF3QUVRQUZZQUFBRFFBZ0FBRlFBQUFNQUJFQUJXQUFBQTBRSUFBQlVBQUFEQUFSQUFWZ0FBQVBvQ0FBQU5BQUFBd0FFUUFGWUFBQUJGQXdBQUVRQUFBTUFCRUFCV0FBQUFTd01BQUJFQUFBREFBUkFBVmdBQUFJb0RBQUFSQUFBQXdBRVFBRllBQUFDUUF3QUFFUUFBQU1BQkVBQldBQUFBdkFNQUFDY0FBQURBQVJBQVZnQUFBTHdEQUFBSkFBQUF3QUVRQUZZQUFBQy9Bd0FBQ1FBQUFNQUJFQUJXQUFBQXhnTUFBQlVBQUFEQUFSQUFWZ0FBQU1rREFBQVlBQUFBd0FFUUFGWUFBQURTQXdBQUNnQUFBTUFCRUFCV0FBQUErQU1BQUFvQUFBREFBUkFBVmdBQUFBVUVBQUFWQUFBQXdBRVFBRllBQUFBTkJBQUFGZ0FBQU1BQkVBQldBQUFBR0FRQUFBa0FBQUF2VlhObGNuTXZabTA0TVRNdkxuSjFjM1IxY0M5MGIyOXNZMmhoYVc1ekwzTjBZV0pzWlMxNE9EWmZOalF0WVhCd2JHVXRaR0Z5ZDJsdUwyeHBZaTl5ZFhOMGJHbGlMM055WXk5eWRYTjBMMnhwWW5KaGNua3ZZV3hzYjJNdmMzSmpMM0poZDE5MlpXTXVjbk5VY21sbFpDQjBieUJ6YUhKcGJtc2dkRzhnWVNCc1lYSm5aWElnWTJGd1lXTnBkSG1vQXhBQWJBQUFBTVVCQUFBSkFBQUFUV0Y0YVcxMWJTQmpiMlJsSUhOcGVtVWdNVElnY21WeGRXbHlaV1FzSUdkdmRDQUFTQVFRQUNNQUFBQXZWWE5sY25NdlptMDRNVE12TG1OaGNtZHZMM0psWjJsemRISjVMM055WXk5bmFYUm9kV0l1WTI5dExURmxZMk0yTWprNVpHSTVaV000TWpNdmQyVmxlbXd0TUM0eExqUXZjM0pqTDJ4cFlpNXljd0IwQkJBQVV3QUFBRTBBQUFBRkFBQUFEd0FBQUFRQUFBQUVBQUFBRUFBQUFCRUFBQUFTQUFBQUR3QUFBQUFBQUFBQkFBQUFFd0FBQUdOaGJHeGxaQ0JnVDNCMGFXOXVPanAxYm5keVlYQW9LV0FnYjI0Z1lTQmdUbTl1WldBZ2RtRnNkV1ZzYVdKeVlYSjVMM04wWkM5emNtTXZjR0Z1YVdOcmFXNW5Mbkp6QUNzRkVBQWNBQUFBN1FFQUFCOEFBQUFyQlJBQUhBQUFBTzRCQUFBZUFBQUFGQUFBQUJBQUFBQUVBQUFBRlFBQUFCWUFBQUFQQUFBQUNBQUFBQVFBQUFBWEFBQUFHQUFBQUJrQUFBQU1BQUFBQkFBQUFCb0FBQUFQQUFBQUNBQUFBQVFBQUFBYkFBQUFiR2xpY21GeWVTOWhiR3h2WXk5emNtTXZjbUYzWDNabFl5NXljMk5oY0dGamFYUjVJRzkyWlhKbWJHOTNBQUFBc0FVUUFCd0FBQUFlQWdBQUJRQUFBR0F1TGdEeEJSQUFBZ0FBQUdOaGJHeGxaQ0JnVDNCMGFXOXVPanAxYm5keVlYQW9LV0FnYjI0Z1lTQmdUbTl1WldBZ2RtRnNkV1U2SUFBQUFQQUZFQUFBQUFBQUp3WVFBQUlBQUFBaUFBQUFBQUFBQUFFQUFBQWpBQUFBYVc1a1pYZ2diM1YwSUc5bUlHSnZkVzVrY3pvZ2RHaGxJR3hsYmlCcGN5QWdZblYwSUhSb1pTQnBibVJsZUNCcGN5QUFBRXdHRUFBZ0FBQUFiQVlRQUJJQUFBQnNhV0p5WVhKNUwyTnZjbVV2YzNKakwyWnRkQzlpZFdsc1pHVnljeTV5Y3lJQUFBQU1BQUFBQkFBQUFDUUFBQUFsQUFBQUpnQUFBQ0FnSUNDUUJoQUFJQUFBQURJQUFBQWhBQUFBa0FZUUFDQUFBQUF6QUFBQUVnQUFBQ0I3Q2l3S0xDQWdleUI5SUgxc2FXSnlZWEo1TDJOdmNtVXZjM0pqTDJadGRDOXVkVzB1Y25QNUJoQUFHd0FBQUdVQUFBQVVBQUFBTUhnd01EQXhNREl3TXpBME1EVXdOakEzTURnd09URXdNVEV4TWpFek1UUXhOVEUyTVRjeE9ERTVNakF5TVRJeU1qTXlOREkxTWpZeU56STRNamt6TURNeE16SXpNek0wTXpVek5qTTNNemd6T1RRd05ERTBNalF6TkRRME5UUTJORGMwT0RRNU5UQTFNVFV5TlRNMU5EVTFOVFkxTnpVNE5UazJNRFl4TmpJMk16WTBOalUyTmpZM05qZzJPVGN3TnpFM01qY3pOelEzTlRjMk56YzNPRGM1T0RBNE1UZ3lPRE00TkRnMU9EWTROemc0T0RrNU1Ea3hPVEk1TXprME9UVTVOamszT1RnNU9RQUFJZ0FBQUFRQUFBQUVBQUFBSndBQUFDZ0FBQUFwQUFBQWJHbGljbUZ5ZVM5amIzSmxMM055WXk5bWJYUXZiVzlrTG5KekFBZ0lFQUFiQUFBQVZRUUFBQkVBQUFBSUNCQUFHd0FBQUY4RUFBQWtBQUFBS0Nsc2FXSnlZWEo1TDJOdmNtVXZjM0pqTDNOc2FXTmxMMjFsYldOb2NpNXljd0FBUmdnUUFDQUFBQUJhQUFBQUJRQUFBSEpoYm1kbElITjBZWEowSUdsdVpHVjRJQ0J2ZFhRZ2IyWWdjbUZ1WjJVZ1ptOXlJSE5zYVdObElHOW1JR3hsYm1kMGFDQjRDQkFBRWdBQUFJb0lFQUFpQUFBQWNtRnVaMlVnWlc1a0lHbHVaR1Y0SUx3SUVBQVFBQUFBaWdnUUFDSUFBQUJ6YkdsalpTQnBibVJsZUNCemRHRnlkSE1nWVhRZ0lHSjFkQ0JsYm1SeklHRjBJQURjQ0JBQUZnQUFBUElJRUFBTkFBQUFiR2xpY21GeWVTOWpiM0psTDNOeVl5OXpkSEl2Y0dGMGRHVnliaTV5Y3dBUUNSQUFId0FBQUxBQkFBQW1BQUFBV3k0dUxsMWllWFJsSUdsdVpHVjRJQ0JwY3lCdmRYUWdiMllnWW05MWJtUnpJRzltSUdBQUFFVUpFQUFMQUFBQVVBa1FBQllBQUFEd0JSQUFBUUFBQUdKbFoybHVJRHc5SUdWdVpDQW9JRHc5SUNrZ2QyaGxiaUJ6YkdsamFXNW5JR0FBQUlBSkVBQU9BQUFBamdrUUFBUUFBQUNTQ1JBQUVBQUFBUEFGRUFBQkFBQUFJR2x6SUc1dmRDQmhJR05vWVhJZ1ltOTFibVJoY25rN0lHbDBJR2x6SUdsdWMybGtaU0FnS0dKNWRHVnpJQ2tnYjJZZ1lFVUpFQUFMQUFBQXhBa1FBQ1lBQUFEcUNSQUFDQUFBQVBJSkVBQUdBQUFBOEFVUUFBRUFBQUJzYVdKeVlYSjVMMk52Y21VdmMzSmpMM1Z1YVdOdlpHVXZjSEpwYm5SaFlteGxMbkp6QUFBQUlBb1FBQ1VBQUFBS0FBQUFIQUFBQUNBS0VBQWxBQUFBR2dBQUFEWUFBQUFBQVFNRkJRWUdBd2NHQ0FnSkVRb2NDeGtNRkEwUURnMFBCQkFERWhJVENSWUJGd1VZQWhrREdnY2NBaDBCSHhZZ0F5c0RMQUl0Q3k0Qk1BTXhBaklCcHdLcEFxb0Vxd2o2QXZzRi9RVCtBLzhKclhoNWk0MmlNRmRZaTR5UUhCM2REZzlMVFB2OExpOC9YRjFmdGVLRWpZNlJrcW14dXJ2RnhzbkszdVRsL3dBRUVSSXBNVFEzT2pzOVNVcGRoSTZTcWJHMHVydkd5czdQNU9VQUJBME9FUklwTVRRNk8wVkdTVXBlWkdXRWtadWR5YzdQRFJFcFJVbFhaR1dOa2FtMHVydkZ5ZC9rNWZBTkVVVkpaR1dBaExLOHZyL1YxL0R4ZzRXTHBLYSt2OFhIenMvYTIwaVl2YzNHenM5SlRrOVhXVjVmaVk2UHNiYTN2OEhHeDljUkZoZGJYUGIzL3YrQURXMXgzdDhPRHg5dWJ4d2RYMzErcnErN3ZQb1dGeDRmUmtkT1QxaGFYRjUrZjdYRjFOWGM4UEgxY25PUGRIV1dMMThtTGkrbnI3ZS94OC9YMzVwQWw1Z3dqeC9Bd2M3L1RrOWFXd2NJRHhBbkwrN3ZibTgzUFQ5Q1JaQ1IvdjlUWjNYSXlkRFIyTm5uL3Y4QUlGOGlndDhFZ2tRSUd3UUdFWUdzRG9Dck5TZ0xnT0FER1FnQkJDOEVOQVFIQXdFSEJnY1JDbEFQRWdkVkJ3TUVIQW9KQXdnREJ3TUNBd01EREFRRkF3c0dBUTRWQlRvREVRY0dCUkFIVndjQ0J4VU5VQVJEQXkwREFRUVJCZzhNT2dRZEpWOGdiUVJxSllESUJZS3dBeG9HZ3YwRFdRY1ZDeGNKRkF3VURHb0dDZ1lhQmxrSEt3VkdDaXdFREFRQkF6RUxMQVFhQmdzRGdLd0dDZ1loUDB3RUxRTjBDRHdERHdNOEJ6Z0lLd1dDL3hFWUNDOFJMUU1nRUNFUGdJd0VncGNaQ3hXSWxBVXZCVHNIQWc0WUNZQ3pMWFFNZ05ZYURBV0Evd1dBM3d6dURRT0VqUU0zQ1lGY0ZJQzRDSURMS2pnRENnWTRDRVlJREFaMEN4NERXZ1JaQ1lDREdCd0tGZ2xNQklDS0JxdWtEQmNFTWFFRWdkb21Cd3dGQllDbEVZRnRFSGdvS2daTUJJQ05CSUMrQXhzRER3MEFCZ0VCQXdFRUFnZ0lDUUlLQlFzQ0RnUVFBUkVDRWdVVEVSUUJGUUlYQWhrTkhBVWRDQ1FCYWdOckFyd0MwUUxVRE5VSjFnTFhBdG9CNEFYaEF1Z0M3aUR3QlBnQytRTDZBdnNCRENjN1BrNVBqNTZlbndZSENUWTlQbGJ6ME5FRUZCZzJOMVpYZjZxdXI3MDE0QktIaVk2ZUJBME9FUklwTVRRNlJVWkpTazVQWkdWY3RyY2JIQWNJQ2dzVUZ6WTVPcWlwMk5rSk41Q1JxQWNLT3o1bWFZK1NiMS91NzFwaW1wc25LRldkb0tHanBLZW9yYnE4eEFZTERCVWRPajlGVWFhbnpNMmdCeGthSWlVK1A4WEdCQ0FqSlNZb016ZzZTRXBNVUZOVlZsaGFYRjVnWTJWbWEzTjRmWCtLcEtxdnNNRFFycTk1ekc1dmsxNGlld1VEQkMwRFpnTUJMeTZBZ2gwRE1ROGNCQ1FKSGdVckJVUUVEaXFBcWdZa0JDUUVLQWcwQ3dHQWtJRTNDUllLQ0lDWU9RTmpDQWt3RmdVaEF4c0ZBVUE0QkVzRkx3UUtCd2tIUUNBbkJBd0pOZ002QlJvSEJBd0hVRWszTXcwekJ5NElDb0VtVWs0b0NDcFdIQlFYQ1U0RUhnOUREaGtIQ2daSUNDY0pkUXMvUVNvR093VUtCbEVHQVFVUUF3V0FpMkllU0FnS2dLWmVJa1VMQ2dZTkV6a0hDallzQkJDQXdEeGtVd3hJQ1FwR1JSdElDRk1kT1lFSFJnb2RBMGRKTndNT0NBb0dPUWNLZ1RZWmdMY0JEeklOZzV0bWRRdUF4SXE4aEMrUDBZSkhvYm1DT1FjcUJBSmdKZ3BHQ2lnRkU0S3dXMlZMQkRrSEVVQUZDd0lPbC9nSWhOWXFDYUwzZ1I4eEF4RUVDSUdNaVFSckJRMERDUWNRazJDQTlncHpDRzRYUm9DYUZBeFhDUm1BaDRGSEE0VkNEeFdGVUN1QTFTMERHZ1FDZ1hBNkJRR0ZBSURYS1V3RUNnUUNneEZFVEQyQXdqd0dBUVJWQlJzMEFvRU9MQVJrREZZS2dLNDRIUTBzQkFrSEFnNEdnSnFEMkFnTkF3MERkQXhaQnd3VURBUTRDQW9HS0FnaVRvRlVEQlVEQXdVSENSa0hCd2tERFFjcGdNc2xDb1FHYkdsaWNtRnllUzlqYjNKbEwzTnlZeTkxYm1samIyUmxMM1Z1YVdOdlpHVmZaR0YwWVM1eWN3Q3ZEeEFBS0FBQUFFc0FBQUFvQUFBQXJ3OFFBQ2dBQUFCWEFBQUFGZ0FBQUs4UEVBQW9BQUFBVWdBQUFENEFBQUFpQUFBQUJBQUFBQVFBQUFBcUFBQUFBQU1BQUlNRUlBQ1JCV0FBWFJPZ0FCSVhvQjRNSU9BZTd5d2dLeW93b0N0dnBtQXNBcWpnTEI3NzRDMEEvcUExbnYvZ05mMEJZVFlCQ3FFMkpBMWhONnNPNFRndkdDRTVNQnhoUnZNZW9VcndhbUZPVDIraFRwMjhJVTlsMGVGUEFOb2hVQURnNFZFdzRXRlQ3T0toVk5EbzRWUWdBQzVWOEFHL1ZRQndBQWNBTFFFQkFRSUJBZ0VCU0Fzd0ZSQUJaUWNDQmdJQ0FRUWpBUjRiV3dzNkNRa0JHQVFCQ1FFREFRVXJBM2NQQVNBM0FRRUJCQWdFQVFNSENnSWRBVG9CQVFFQ0JBZ0JDUUVLQWhvQkFnSTVBUVFDQkFJQ0F3TUJIZ0lEQVFzQ09RRUVCUUVDQkFFVUFoWUdBUUU2QVFFQ0FRUUlBUWNEQ2dJZUFUc0JBUUVNQVFrQktBRURBVGtEQlFNQkJBY0NDd0lkQVRvQkFnRUNBUU1CQlFJSEFnc0NIQUk1QWdFQkFnUUlBUWtCQ2dJZEFVZ0JCQUVDQXdFQkNBRlJBUUlIREFoaUFRSUpDd1pLQWhzQkFRRUJBVGNPQVFVQkFnVUxBU1FKQVdZRUFRWUJBZ0lDR1FJRUF4QUVEUUVDQWdZQkR3RUFBd0FESFFNZEFoNENRQUlCQndnQkFnc0pBUzBEZHdJaUFYWURCQUlKQVFZRDJ3SUNBVG9CQVFjQkFRRUJBZ2dHQ2dJQk1CRS9CREFIQVFFRkFTZ0pEQUlnQkFJQ0FRTTRBUUVDQXdFQkF6b0lBZ0tZQXdFTkFRY0VBUVlCQXdMR09nRUZBQUhESVFBRGpRRmdJQUFHYVFJQUJBRUtJQUpRQWdBQkF3RUVBUmtDQlFHWEFob1NEUUVtQ0JrTExnTXdBUUlFQWdJbkFVTUdBZ0lDQWd3QkNBRXZBVE1CQVFNQ0FnVUNBUUVxQWdnQjdnRUNBUVFCQUFFQUVCQVFBQUlBQWVJQmxRVUFBd0VDQlFRb0F3UUJwUUlBQkFBQ21RdXdBVFlQT0FNeEJBSUNSUU1rQlFFSVBnRU1BalFKQ2dRQ0FWOERBZ0VCQWdZQm9BRURDQlVDT1FJQkFRRUJGZ0VPQndNRnd3Z0NBd0VCRndGUkFRSUdBUUVDQVFFQ0FRTHJBUUlFQmdJQkFoc0NWUWdDQVFFQ2FnRUJBUUlHQVFGbEF3SUVBUVVBQ1FFQzlRRUtBZ0VCQkFHUUJBSUNCQUVnQ2lnR0FnUUlBUWtHQWdNdURRRUNBQWNCQmdFQlVoWUNCd0VDQVFKNkJnTUJBUUlCQndFQlNBSURBUUVCQUFJQUJUc0hBQUUvQkZFQkFBSUFBUUVEQkFVSUNBSUhIZ1NVQXdBM0JESUlBUTRCRmdVQkR3QUhBUkVDQndFQ0FRVUFCd0FFQUFkdEJ3QmdnUEFBVEdGNWIzVjBSWEp5Y0hKcGRtRjBaUUI3Q1hCeWIyUjFZMlZ5Y3dJSWJHRnVaM1ZoWjJVQkJGSjFjM1FBREhCeWIyTmxjM05sWkMxaWVRTUZjblZ6ZEdNZE1TNDBPUzR3SUNobE1UZzROR0U0WlRNZ01qQXlNQzB4TWkweU9Ta0dkMkZzY25WekJqQXVNVGd1TUF4M1lYTnRMV0pwYm1SblpXNFNNQzR5TGpjd0lDaGlOak0xTldNeU56QXAiKTtsZXQgbzthc3luYyBmdW5jdGlvbiBOKEEsSSl7b3x8KG89YXdhaXQoYXN5bmMoKT0+KGF3YWl0IEUoRyksRCkpKCkpO2NvbnN0IGc9by5kZWNvbXByZXNzKEEsSSk7aWYoMD09PWcubGVuZ3RoKXRocm93IEVycm9yKCJGYWlsZWQgdG8gZGVjb2RlIHdpdGggTFpXIGRlY29kZXIuIik7cmV0dXJuIGd9CgogIGNsYXNzIExaV0RlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7CiAgICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5KSB7CiAgICAgIHN1cGVyKCk7CiAgICAgIGNvbnN0IHdpZHRoID0gZmlsZURpcmVjdG9yeS5UaWxlV2lkdGggfHwgZmlsZURpcmVjdG9yeS5JbWFnZVdpZHRoOwogICAgICBjb25zdCBoZWlnaHQgPSBmaWxlRGlyZWN0b3J5LlRpbGVMZW5ndGggfHwgZmlsZURpcmVjdG9yeS5JbWFnZUxlbmd0aDsKICAgICAgY29uc3QgbmJ5dGVzID0gZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlWzBdIC8gODsKICAgICAgdGhpcy5tYXhVbmNvbXByZXNzZWRTaXplID0gd2lkdGggKiBoZWlnaHQgKiBuYnl0ZXM7CiAgICB9CgogICAgYXN5bmMgZGVjb2RlQmxvY2soYnVmZmVyKSB7CiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTsKICAgICAgY29uc3QgZGVjb2RlZCA9IGF3YWl0IE4oYnl0ZXMsIHRoaXMubWF4VW5jb21wcmVzc2VkU2l6ZSk7CiAgICAgIHJldHVybiBkZWNvZGVkLmJ1ZmZlcjsKICAgIH0KICB9CgogIC8qIC0qLSB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgYy1iYXNpYy1vZmZzZXQ6IDIgLSotIC8KICAvKiB2aW06IHNldCBzaGlmdHdpZHRoPTIgdGFic3RvcD0yIGF1dG9pbmRlbnQgY2luZGVudCBleHBhbmR0YWI6ICovCiAgLyoKICAgICBDb3B5cmlnaHQgMjAxMSBub3RtYXN0ZXJ5ZXQKICAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICAgICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiAgICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CiAgICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAogICAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKICAgICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAogICAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgogICAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKICAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KICAqLwoKICAvLyAtIFRoZSBKUEVHIHNwZWNpZmljYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoZSBJVFUgQ0NJVFQgUmVjb21tZW5kYXRpb24gVC44MQogIC8vICAgKHd3dy53My5vcmcvR3JhcGhpY3MvSlBFRy9pdHUtdDgxLnBkZikKICAvLyAtIFRoZSBKRklGIHNwZWNpZmljYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoZSBKUEVHIEZpbGUgSW50ZXJjaGFuZ2UgRm9ybWF0CiAgLy8gICAod3d3LnczLm9yZy9HcmFwaGljcy9KUEVHL2pmaWYzLnBkZikKICAvLyAtIFRoZSBBZG9iZSBBcHBsaWNhdGlvbi1TcGVjaWZpYyBKUEVHIG1hcmtlcnMgaW4gdGhlIFN1cHBvcnRpbmcgdGhlIERDVCBGaWx0ZXJzCiAgLy8gICBpbiBQb3N0U2NyaXB0IExldmVsIDIsIFRlY2huaWNhbCBOb3RlICM1MTE2CiAgLy8gICAocGFydG5lcnMuYWRvYmUuY29tL3B1YmxpYy9kZXZlbG9wZXIvZW4vcHMvc2RrLzUxMTYuRENUX0ZpbHRlci5wZGYpCgoKICBjb25zdCBkY3RaaWdaYWcgPSBuZXcgSW50MzJBcnJheShbCiAgICAwLAogICAgMSwgOCwKICAgIDE2LCA5LCAyLAogICAgMywgMTAsIDE3LCAyNCwKICAgIDMyLCAyNSwgMTgsIDExLCA0LAogICAgNSwgMTIsIDE5LCAyNiwgMzMsIDQwLAogICAgNDgsIDQxLCAzNCwgMjcsIDIwLCAxMywgNiwKICAgIDcsIDE0LCAyMSwgMjgsIDM1LCA0MiwgNDksIDU2LAogICAgNTcsIDUwLCA0MywgMzYsIDI5LCAyMiwgMTUsCiAgICAyMywgMzAsIDM3LCA0NCwgNTEsIDU4LAogICAgNTksIDUyLCA0NSwgMzgsIDMxLAogICAgMzksIDQ2LCA1MywgNjAsCiAgICA2MSwgNTQsIDQ3LAogICAgNTUsIDYyLAogICAgNjMsCiAgXSk7CgogIGNvbnN0IGRjdENvczEgPSA0MDE3OyAvLyBjb3MocGkvMTYpCiAgY29uc3QgZGN0U2luMSA9IDc5OTsgLy8gc2luKHBpLzE2KQogIGNvbnN0IGRjdENvczMgPSAzNDA2OyAvLyBjb3MoMypwaS8xNikKICBjb25zdCBkY3RTaW4zID0gMjI3NjsgLy8gc2luKDMqcGkvMTYpCiAgY29uc3QgZGN0Q29zNiA9IDE1Njc7IC8vIGNvcyg2KnBpLzE2KQogIGNvbnN0IGRjdFNpbjYgPSAzNzg0OyAvLyBzaW4oNipwaS8xNikKICBjb25zdCBkY3RTcXJ0MiA9IDU3OTM7IC8vIHNxcnQoMikKICBjb25zdCBkY3RTcXJ0MWQyID0gMjg5NjsvLyBzcXJ0KDIpIC8gMgoKICBmdW5jdGlvbiBidWlsZEh1ZmZtYW5UYWJsZShjb2RlTGVuZ3RocywgdmFsdWVzKSB7CiAgICBsZXQgayA9IDA7CiAgICBjb25zdCBjb2RlID0gW107CiAgICBsZXQgbGVuZ3RoID0gMTY7CiAgICB3aGlsZSAobGVuZ3RoID4gMCAmJiAhY29kZUxlbmd0aHNbbGVuZ3RoIC0gMV0pIHsKICAgICAgLS1sZW5ndGg7CiAgICB9CiAgICBjb2RlLnB1c2goeyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pOwoKICAgIGxldCBwID0gY29kZVswXTsKICAgIGxldCBxOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvZGVMZW5ndGhzW2ldOyBqKyspIHsKICAgICAgICBwID0gY29kZS5wb3AoKTsKICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gdmFsdWVzW2tdOwogICAgICAgIHdoaWxlIChwLmluZGV4ID4gMCkgewogICAgICAgICAgcCA9IGNvZGUucG9wKCk7CiAgICAgICAgfQogICAgICAgIHAuaW5kZXgrKzsKICAgICAgICBjb2RlLnB1c2gocCk7CiAgICAgICAgd2hpbGUgKGNvZGUubGVuZ3RoIDw9IGkpIHsKICAgICAgICAgIGNvZGUucHVzaChxID0geyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pOwogICAgICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47CiAgICAgICAgICBwID0gcTsKICAgICAgICB9CiAgICAgICAgaysrOwogICAgICB9CiAgICAgIGlmIChpICsgMSA8IGxlbmd0aCkgewogICAgICAgIC8vIHAgaGVyZSBwb2ludHMgdG8gbGFzdCBjb2RlCiAgICAgICAgY29kZS5wdXNoKHEgPSB7IGNoaWxkcmVuOiBbXSwgaW5kZXg6IDAgfSk7CiAgICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47CiAgICAgICAgcCA9IHE7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBjb2RlWzBdLmNoaWxkcmVuOwogIH0KCiAgZnVuY3Rpb24gZGVjb2RlU2NhbihkYXRhLCBpbml0aWFsT2Zmc2V0LAogICAgZnJhbWUsIGNvbXBvbmVudHMsIHJlc2V0SW50ZXJ2YWwsCiAgICBzcGVjdHJhbFN0YXJ0LCBzcGVjdHJhbEVuZCwKICAgIHN1Y2Nlc3NpdmVQcmV2LCBzdWNjZXNzaXZlKSB7CiAgICBjb25zdCB7IG1jdXNQZXJMaW5lLCBwcm9ncmVzc2l2ZSB9ID0gZnJhbWU7CgogICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpbml0aWFsT2Zmc2V0OwogICAgbGV0IG9mZnNldCA9IGluaXRpYWxPZmZzZXQ7CiAgICBsZXQgYml0c0RhdGEgPSAwOwogICAgbGV0IGJpdHNDb3VudCA9IDA7CiAgICBmdW5jdGlvbiByZWFkQml0KCkgewogICAgICBpZiAoYml0c0NvdW50ID4gMCkgewogICAgICAgIGJpdHNDb3VudC0tOwogICAgICAgIHJldHVybiAoYml0c0RhdGEgPj4gYml0c0NvdW50KSAmIDE7CiAgICAgIH0KICAgICAgYml0c0RhdGEgPSBkYXRhW29mZnNldCsrXTsKICAgICAgaWYgKGJpdHNEYXRhID09PSAweEZGKSB7CiAgICAgICAgY29uc3QgbmV4dEJ5dGUgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICBpZiAobmV4dEJ5dGUpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBtYXJrZXI6ICR7KChiaXRzRGF0YSA8PCA4KSB8IG5leHRCeXRlKS50b1N0cmluZygxNil9YCk7CiAgICAgICAgfQogICAgICAgIC8vIHVuc3R1ZmYgMAogICAgICB9CiAgICAgIGJpdHNDb3VudCA9IDc7CiAgICAgIHJldHVybiBiaXRzRGF0YSA+Pj4gNzsKICAgIH0KICAgIGZ1bmN0aW9uIGRlY29kZUh1ZmZtYW4odHJlZSkgewogICAgICBsZXQgbm9kZSA9IHRyZWU7CiAgICAgIGxldCBiaXQ7CiAgICAgIHdoaWxlICgoYml0ID0gcmVhZEJpdCgpKSAhPT0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduCiAgICAgICAgbm9kZSA9IG5vZGVbYml0XTsKICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSB7CiAgICAgICAgICByZXR1cm4gbm9kZTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGh1ZmZtYW4gc2VxdWVuY2UnKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICBmdW5jdGlvbiByZWNlaXZlKGluaXRpYWxMZW5ndGgpIHsKICAgICAgbGV0IGxlbmd0aCA9IGluaXRpYWxMZW5ndGg7CiAgICAgIGxldCBuID0gMDsKICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHsKICAgICAgICBjb25zdCBiaXQgPSByZWFkQml0KCk7CiAgICAgICAgaWYgKGJpdCA9PT0gbnVsbCkgewogICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsKICAgICAgICB9CiAgICAgICAgbiA9IChuIDw8IDEpIHwgYml0OwogICAgICAgIC0tbGVuZ3RoOwogICAgICB9CiAgICAgIHJldHVybiBuOwogICAgfQogICAgZnVuY3Rpb24gcmVjZWl2ZUFuZEV4dGVuZChsZW5ndGgpIHsKICAgICAgY29uc3QgbiA9IHJlY2VpdmUobGVuZ3RoKTsKICAgICAgaWYgKG4gPj0gMSA8PCAobGVuZ3RoIC0gMSkpIHsKICAgICAgICByZXR1cm4gbjsKICAgICAgfQogICAgICByZXR1cm4gbiArICgtMSA8PCBsZW5ndGgpICsgMTsKICAgIH0KICAgIGZ1bmN0aW9uIGRlY29kZUJhc2VsaW5lKGNvbXBvbmVudCwgenopIHsKICAgICAgY29uc3QgdCA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDKTsKICAgICAgY29uc3QgZGlmZiA9IHQgPT09IDAgPyAwIDogcmVjZWl2ZUFuZEV4dGVuZCh0KTsKICAgICAgY29tcG9uZW50LnByZWQgKz0gZGlmZjsKICAgICAgenpbMF0gPSBjb21wb25lbnQucHJlZDsKICAgICAgbGV0IGsgPSAxOwogICAgICB3aGlsZSAoayA8IDY0KSB7CiAgICAgICAgY29uc3QgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7CiAgICAgICAgY29uc3QgcyA9IHJzICYgMTU7CiAgICAgICAgY29uc3QgciA9IHJzID4+IDQ7CiAgICAgICAgaWYgKHMgPT09IDApIHsKICAgICAgICAgIGlmIChyIDwgMTUpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBrICs9IDE2OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBrICs9IHI7CiAgICAgICAgICBjb25zdCB6ID0gZGN0WmlnWmFnW2tdOwogICAgICAgICAgenpbel0gPSByZWNlaXZlQW5kRXh0ZW5kKHMpOwogICAgICAgICAgaysrOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gZGVjb2RlRENGaXJzdChjb21wb25lbnQsIHp6KSB7CiAgICAgIGNvbnN0IHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7CiAgICAgIGNvbnN0IGRpZmYgPSB0ID09PSAwID8gMCA6IChyZWNlaXZlQW5kRXh0ZW5kKHQpIDw8IHN1Y2Nlc3NpdmUpOwogICAgICBjb21wb25lbnQucHJlZCArPSBkaWZmOwogICAgICB6elswXSA9IGNvbXBvbmVudC5wcmVkOwogICAgfQogICAgZnVuY3Rpb24gZGVjb2RlRENTdWNjZXNzaXZlKGNvbXBvbmVudCwgenopIHsKICAgICAgenpbMF0gfD0gcmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmU7CiAgICB9CiAgICBsZXQgZW9icnVuID0gMDsKICAgIGZ1bmN0aW9uIGRlY29kZUFDRmlyc3QoY29tcG9uZW50LCB6eikgewogICAgICBpZiAoZW9icnVuID4gMCkgewogICAgICAgIGVvYnJ1bi0tOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBsZXQgayA9IHNwZWN0cmFsU3RhcnQ7CiAgICAgIGNvbnN0IGUgPSBzcGVjdHJhbEVuZDsKICAgICAgd2hpbGUgKGsgPD0gZSkgewogICAgICAgIGNvbnN0IHJzID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlQUMpOwogICAgICAgIGNvbnN0IHMgPSBycyAmIDE1OwogICAgICAgIGNvbnN0IHIgPSBycyA+PiA0OwogICAgICAgIGlmIChzID09PSAwKSB7CiAgICAgICAgICBpZiAociA8IDE1KSB7CiAgICAgICAgICAgIGVvYnJ1biA9IHJlY2VpdmUocikgKyAoMSA8PCByKSAtIDE7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgayArPSAxNjsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgayArPSByOwogICAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1trXTsKICAgICAgICAgIHp6W3pdID0gcmVjZWl2ZUFuZEV4dGVuZChzKSAqICgxIDw8IHN1Y2Nlc3NpdmUpOwogICAgICAgICAgaysrOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgbGV0IHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMDsKICAgIGxldCBzdWNjZXNzaXZlQUNOZXh0VmFsdWU7CiAgICBmdW5jdGlvbiBkZWNvZGVBQ1N1Y2Nlc3NpdmUoY29tcG9uZW50LCB6eikgewogICAgICBsZXQgayA9IHNwZWN0cmFsU3RhcnQ7CiAgICAgIGNvbnN0IGUgPSBzcGVjdHJhbEVuZDsKICAgICAgbGV0IHIgPSAwOwogICAgICB3aGlsZSAoayA8PSBlKSB7CiAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1trXTsKICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB6elt6XSA8IDAgPyAtMSA6IDE7CiAgICAgICAgc3dpdGNoIChzdWNjZXNzaXZlQUNTdGF0ZSkgewogICAgICAgICAgY2FzZSAwOiB7IC8vIGluaXRpYWwgc3RhdGUKICAgICAgICAgICAgY29uc3QgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7CiAgICAgICAgICAgIGNvbnN0IHMgPSBycyAmIDE1OwogICAgICAgICAgICByID0gcnMgPj4gNDsKICAgICAgICAgICAgaWYgKHMgPT09IDApIHsKICAgICAgICAgICAgICBpZiAociA8IDE1KSB7CiAgICAgICAgICAgICAgICBlb2JydW4gPSByZWNlaXZlKHIpICsgKDEgPDwgcik7CiAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDQ7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHIgPSAxNjsKICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgaWYgKHMgIT09IDEpIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBBQ24gZW5jb2RpbmcnKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlID0gcmVjZWl2ZUFuZEV4dGVuZChzKTsKICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IHIgPyAyIDogMzsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250aW51ZQogICAgICAgICAgfQogICAgICAgICAgY2FzZSAxOiAvLyBza2lwcGluZyByIHplcm8gaXRlbXMKICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgaWYgKHp6W3pdKSB7CiAgICAgICAgICAgICAgenpbel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKSAqIGRpcmVjdGlvbjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByLS07CiAgICAgICAgICAgICAgaWYgKHIgPT09IDApIHsKICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gc3VjY2Vzc2l2ZUFDU3RhdGUgPT09IDIgPyAzIDogMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlIDM6IC8vIHNldCB2YWx1ZSBmb3IgYSB6ZXJvIGl0ZW0KICAgICAgICAgICAgaWYgKHp6W3pdKSB7CiAgICAgICAgICAgICAgenpbel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKSAqIGRpcmVjdGlvbjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB6elt6XSA9IHN1Y2Nlc3NpdmVBQ05leHRWYWx1ZSA8PCBzdWNjZXNzaXZlOwogICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgNDogLy8gZW9iCiAgICAgICAgICAgIGlmICh6elt6XSkgewogICAgICAgICAgICAgIHp6W3pdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSkgKiBkaXJlY3Rpb247CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIGsrKzsKICAgICAgfQogICAgICBpZiAoc3VjY2Vzc2l2ZUFDU3RhdGUgPT09IDQpIHsKICAgICAgICBlb2JydW4tLTsKICAgICAgICBpZiAoZW9icnVuID09PSAwKSB7CiAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGdW5jdGlvbiwgbWN1LCByb3csIGNvbCkgewogICAgICBjb25zdCBtY3VSb3cgPSAobWN1IC8gbWN1c1BlckxpbmUpIHwgMDsKICAgICAgY29uc3QgbWN1Q29sID0gbWN1ICUgbWN1c1BlckxpbmU7CiAgICAgIGNvbnN0IGJsb2NrUm93ID0gKG1jdVJvdyAqIGNvbXBvbmVudC52KSArIHJvdzsKICAgICAgY29uc3QgYmxvY2tDb2wgPSAobWN1Q29sICogY29tcG9uZW50LmgpICsgY29sOwogICAgICBkZWNvZGVGdW5jdGlvbihjb21wb25lbnQsIGNvbXBvbmVudC5ibG9ja3NbYmxvY2tSb3ddW2Jsb2NrQ29sXSk7CiAgICB9CiAgICBmdW5jdGlvbiBkZWNvZGVCbG9jayhjb21wb25lbnQsIGRlY29kZUZ1bmN0aW9uLCBtY3UpIHsKICAgICAgY29uc3QgYmxvY2tSb3cgPSAobWN1IC8gY29tcG9uZW50LmJsb2Nrc1BlckxpbmUpIHwgMDsKICAgICAgY29uc3QgYmxvY2tDb2wgPSBtY3UgJSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTsKICAgICAgZGVjb2RlRnVuY3Rpb24oY29tcG9uZW50LCBjb21wb25lbnQuYmxvY2tzW2Jsb2NrUm93XVtibG9ja0NvbF0pOwogICAgfQoKICAgIGNvbnN0IGNvbXBvbmVudHNMZW5ndGggPSBjb21wb25lbnRzLmxlbmd0aDsKICAgIGxldCBjb21wb25lbnQ7CiAgICBsZXQgaTsKICAgIGxldCBqOwogICAgbGV0IGs7CiAgICBsZXQgbjsKICAgIGxldCBkZWNvZGVGbjsKICAgIGlmIChwcm9ncmVzc2l2ZSkgewogICAgICBpZiAoc3BlY3RyYWxTdGFydCA9PT0gMCkgewogICAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVEQ0ZpcnN0IDogZGVjb2RlRENTdWNjZXNzaXZlOwogICAgICB9IGVsc2UgewogICAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVBQ0ZpcnN0IDogZGVjb2RlQUNTdWNjZXNzaXZlOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICBkZWNvZGVGbiA9IGRlY29kZUJhc2VsaW5lOwogICAgfQoKICAgIGxldCBtY3UgPSAwOwogICAgbGV0IG1hcmtlcjsKICAgIGxldCBtY3VFeHBlY3RlZDsKICAgIGlmIChjb21wb25lbnRzTGVuZ3RoID09PSAxKSB7CiAgICAgIG1jdUV4cGVjdGVkID0gY29tcG9uZW50c1swXS5ibG9ja3NQZXJMaW5lICogY29tcG9uZW50c1swXS5ibG9ja3NQZXJDb2x1bW47CiAgICB9IGVsc2UgewogICAgICBtY3VFeHBlY3RlZCA9IG1jdXNQZXJMaW5lICogZnJhbWUubWN1c1BlckNvbHVtbjsKICAgIH0KCiAgICBjb25zdCB1c2VkUmVzZXRJbnRlcnZhbCA9IHJlc2V0SW50ZXJ2YWwgfHwgbWN1RXhwZWN0ZWQ7CgogICAgd2hpbGUgKG1jdSA8IG1jdUV4cGVjdGVkKSB7CiAgICAgIC8vIHJlc2V0IGludGVydmFsIHN0dWZmCiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHsKICAgICAgICBjb21wb25lbnRzW2ldLnByZWQgPSAwOwogICAgICB9CiAgICAgIGVvYnJ1biA9IDA7CgogICAgICBpZiAoY29tcG9uZW50c0xlbmd0aCA9PT0gMSkgewogICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbMF07CiAgICAgICAgZm9yIChuID0gMDsgbiA8IHVzZWRSZXNldEludGVydmFsOyBuKyspIHsKICAgICAgICAgIGRlY29kZUJsb2NrKGNvbXBvbmVudCwgZGVjb2RlRm4sIG1jdSk7CiAgICAgICAgICBtY3UrKzsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZm9yIChuID0gMDsgbiA8IHVzZWRSZXNldEludGVydmFsOyBuKyspIHsKICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTsKICAgICAgICAgICAgY29uc3QgeyBoLCB2IH0gPSBjb21wb25lbnQ7CiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2OyBqKyspIHsKICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaDsgaysrKSB7CiAgICAgICAgICAgICAgICBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGbiwgbWN1LCBqLCBrKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIG1jdSsrOwoKICAgICAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgb3VyIGV4cGVjdGVkIE1DVSdzLCBzdG9wIGRlY29kaW5nCiAgICAgICAgICBpZiAobWN1ID09PSBtY3VFeHBlY3RlZCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIC8vIGZpbmQgbWFya2VyCiAgICAgIGJpdHNDb3VudCA9IDA7CiAgICAgIG1hcmtlciA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdOwogICAgICBpZiAobWFya2VyIDwgMHhGRjAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZXIgd2FzIG5vdCBmb3VuZCcpOwogICAgICB9CgogICAgICBpZiAobWFya2VyID49IDB4RkZEMCAmJiBtYXJrZXIgPD0gMHhGRkQ3KSB7IC8vIFJTVHgKICAgICAgICBvZmZzZXQgKz0gMjsKICAgICAgfSBlbHNlIHsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBvZmZzZXQgLSBzdGFydE9mZnNldDsKICB9CgogIGZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50RGF0YShmcmFtZSwgY29tcG9uZW50KSB7CiAgICBjb25zdCBsaW5lcyA9IFtdOwogICAgY29uc3QgeyBibG9ja3NQZXJMaW5lLCBibG9ja3NQZXJDb2x1bW4gfSA9IGNvbXBvbmVudDsKICAgIGNvbnN0IHNhbXBsZXNQZXJMaW5lID0gYmxvY2tzUGVyTGluZSA8PCAzOwogICAgY29uc3QgUiA9IG5ldyBJbnQzMkFycmF5KDY0KTsKICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheSg2NCk7CgogICAgLy8gQSBwb3J0IG9mIHBvcHBsZXIncyBJRENUIG1ldGhvZCB3aGljaCBpbiB0dXJuIGlzIHRha2VuIGZyb206CiAgICAvLyAgIENocmlzdG9waCBMb2VmZmxlciwgQWRyaWFhbiBMaWd0ZW5iZXJnLCBHZW9yZ2UgUy4gTW9zY2h5dHosCiAgICAvLyAgICJQcmFjdGljYWwgRmFzdCAxLUQgRENUIEFsZ29yaXRobXMgd2l0aCAxMSBNdWx0aXBsaWNhdGlvbnMiLAogICAgLy8gICBJRUVFIEludGwuIENvbmYuIG9uIEFjb3VzdGljcywgU3BlZWNoICYgU2lnbmFsIFByb2Nlc3NpbmcsIDE5ODksCiAgICAvLyAgIDk4OC05OTEuCiAgICBmdW5jdGlvbiBxdWFudGl6ZUFuZEludmVyc2UoenosIGRhdGFPdXQsIGRhdGFJbikgewogICAgICBjb25zdCBxdCA9IGNvbXBvbmVudC5xdWFudGl6YXRpb25UYWJsZTsKICAgICAgbGV0IHYwOwogICAgICBsZXQgdjE7CiAgICAgIGxldCB2MjsKICAgICAgbGV0IHYzOwogICAgICBsZXQgdjQ7CiAgICAgIGxldCB2NTsKICAgICAgbGV0IHY2OwogICAgICBsZXQgdjc7CiAgICAgIGxldCB0OwogICAgICBjb25zdCBwID0gZGF0YUluOwogICAgICBsZXQgaTsKCiAgICAgIC8vIGRlcXVhbnQKICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHsKICAgICAgICBwW2ldID0genpbaV0gKiBxdFtpXTsKICAgICAgfQoKICAgICAgLy8gaW52ZXJzZSBEQ1Qgb24gcm93cwogICAgICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7CiAgICAgICAgY29uc3Qgcm93ID0gOCAqIGk7CgogICAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHMKICAgICAgICBpZiAocFsxICsgcm93XSA9PT0gMCAmJiBwWzIgKyByb3ddID09PSAwICYmIHBbMyArIHJvd10gPT09IDAKICAgICAgICAgICYmIHBbNCArIHJvd10gPT09IDAgJiYgcFs1ICsgcm93XSA9PT0gMCAmJiBwWzYgKyByb3ddID09PSAwCiAgICAgICAgICAmJiBwWzcgKyByb3ddID09PSAwKSB7CiAgICAgICAgICB0ID0gKChkY3RTcXJ0MiAqIHBbMCArIHJvd10pICsgNTEyKSA+PiAxMDsKICAgICAgICAgIHBbMCArIHJvd10gPSB0OwogICAgICAgICAgcFsxICsgcm93XSA9IHQ7CiAgICAgICAgICBwWzIgKyByb3ddID0gdDsKICAgICAgICAgIHBbMyArIHJvd10gPSB0OwogICAgICAgICAgcFs0ICsgcm93XSA9IHQ7CiAgICAgICAgICBwWzUgKyByb3ddID0gdDsKICAgICAgICAgIHBbNiArIHJvd10gPSB0OwogICAgICAgICAgcFs3ICsgcm93XSA9IHQ7CiAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250aW51ZQogICAgICAgIH0KCiAgICAgICAgLy8gc3RhZ2UgNAogICAgICAgIHYwID0gKChkY3RTcXJ0MiAqIHBbMCArIHJvd10pICsgMTI4KSA+PiA4OwogICAgICAgIHYxID0gKChkY3RTcXJ0MiAqIHBbNCArIHJvd10pICsgMTI4KSA+PiA4OwogICAgICAgIHYyID0gcFsyICsgcm93XTsKICAgICAgICB2MyA9IHBbNiArIHJvd107CiAgICAgICAgdjQgPSAoKGRjdFNxcnQxZDIgKiAocFsxICsgcm93XSAtIHBbNyArIHJvd10pKSArIDEyOCkgPj4gODsKICAgICAgICB2NyA9ICgoZGN0U3FydDFkMiAqIChwWzEgKyByb3ddICsgcFs3ICsgcm93XSkpICsgMTI4KSA+PiA4OwogICAgICAgIHY1ID0gcFszICsgcm93XSA8PCA0OwogICAgICAgIHY2ID0gcFs1ICsgcm93XSA8PCA0OwoKICAgICAgICAvLyBzdGFnZSAzCiAgICAgICAgdCA9ICh2MCAtIHYxICsgMSkgPj4gMTsKICAgICAgICB2MCA9ICh2MCArIHYxICsgMSkgPj4gMTsKICAgICAgICB2MSA9IHQ7CiAgICAgICAgdCA9ICgodjIgKiBkY3RTaW42KSArICh2MyAqIGRjdENvczYpICsgMTI4KSA+PiA4OwogICAgICAgIHYyID0gKCh2MiAqIGRjdENvczYpIC0gKHYzICogZGN0U2luNikgKyAxMjgpID4+IDg7CiAgICAgICAgdjMgPSB0OwogICAgICAgIHQgPSAodjQgLSB2NiArIDEpID4+IDE7CiAgICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7CiAgICAgICAgdjYgPSB0OwogICAgICAgIHQgPSAodjcgKyB2NSArIDEpID4+IDE7CiAgICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7CiAgICAgICAgdjcgPSB0OwoKICAgICAgICAvLyBzdGFnZSAyCiAgICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTsKICAgICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTsKICAgICAgICB2MyA9IHQ7CiAgICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTsKICAgICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTsKICAgICAgICB2MiA9IHQ7CiAgICAgICAgdCA9ICgodjQgKiBkY3RTaW4zKSArICh2NyAqIGRjdENvczMpICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjQgPSAoKHY0ICogZGN0Q29zMykgLSAodjcgKiBkY3RTaW4zKSArIDIwNDgpID4+IDEyOwogICAgICAgIHY3ID0gdDsKICAgICAgICB0ID0gKCh2NSAqIGRjdFNpbjEpICsgKHY2ICogZGN0Q29zMSkgKyAyMDQ4KSA+PiAxMjsKICAgICAgICB2NSA9ICgodjUgKiBkY3RDb3MxKSAtICh2NiAqIGRjdFNpbjEpICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjYgPSB0OwoKICAgICAgICAvLyBzdGFnZSAxCiAgICAgICAgcFswICsgcm93XSA9IHYwICsgdjc7CiAgICAgICAgcFs3ICsgcm93XSA9IHYwIC0gdjc7CiAgICAgICAgcFsxICsgcm93XSA9IHYxICsgdjY7CiAgICAgICAgcFs2ICsgcm93XSA9IHYxIC0gdjY7CiAgICAgICAgcFsyICsgcm93XSA9IHYyICsgdjU7CiAgICAgICAgcFs1ICsgcm93XSA9IHYyIC0gdjU7CiAgICAgICAgcFszICsgcm93XSA9IHYzICsgdjQ7CiAgICAgICAgcFs0ICsgcm93XSA9IHYzIC0gdjQ7CiAgICAgIH0KCiAgICAgIC8vIGludmVyc2UgRENUIG9uIGNvbHVtbnMKICAgICAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkgewogICAgICAgIGNvbnN0IGNvbCA9IGk7CgogICAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHMKICAgICAgICBpZiAocFsoMSAqIDgpICsgY29sXSA9PT0gMCAmJiBwWygyICogOCkgKyBjb2xdID09PSAwICYmIHBbKDMgKiA4KSArIGNvbF0gPT09IDAKICAgICAgICAgICYmIHBbKDQgKiA4KSArIGNvbF0gPT09IDAgJiYgcFsoNSAqIDgpICsgY29sXSA9PT0gMCAmJiBwWyg2ICogOCkgKyBjb2xdID09PSAwCiAgICAgICAgICAmJiBwWyg3ICogOCkgKyBjb2xdID09PSAwKSB7CiAgICAgICAgICB0ID0gKChkY3RTcXJ0MiAqIGRhdGFJbltpICsgMF0pICsgODE5MikgPj4gMTQ7CiAgICAgICAgICBwWygwICogOCkgKyBjb2xdID0gdDsKICAgICAgICAgIHBbKDEgKiA4KSArIGNvbF0gPSB0OwogICAgICAgICAgcFsoMiAqIDgpICsgY29sXSA9IHQ7CiAgICAgICAgICBwWygzICogOCkgKyBjb2xdID0gdDsKICAgICAgICAgIHBbKDQgKiA4KSArIGNvbF0gPSB0OwogICAgICAgICAgcFsoNSAqIDgpICsgY29sXSA9IHQ7CiAgICAgICAgICBwWyg2ICogOCkgKyBjb2xdID0gdDsKICAgICAgICAgIHBbKDcgKiA4KSArIGNvbF0gPSB0OwogICAgICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udGludWUKICAgICAgICB9CgogICAgICAgIC8vIHN0YWdlIDQKICAgICAgICB2MCA9ICgoZGN0U3FydDIgKiBwWygwICogOCkgKyBjb2xdKSArIDIwNDgpID4+IDEyOwogICAgICAgIHYxID0gKChkY3RTcXJ0MiAqIHBbKDQgKiA4KSArIGNvbF0pICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjIgPSBwWygyICogOCkgKyBjb2xdOwogICAgICAgIHYzID0gcFsoNiAqIDgpICsgY29sXTsKICAgICAgICB2NCA9ICgoZGN0U3FydDFkMiAqIChwWygxICogOCkgKyBjb2xdIC0gcFsoNyAqIDgpICsgY29sXSkpICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjcgPSAoKGRjdFNxcnQxZDIgKiAocFsoMSAqIDgpICsgY29sXSArIHBbKDcgKiA4KSArIGNvbF0pKSArIDIwNDgpID4+IDEyOwogICAgICAgIHY1ID0gcFsoMyAqIDgpICsgY29sXTsKICAgICAgICB2NiA9IHBbKDUgKiA4KSArIGNvbF07CgogICAgICAgIC8vIHN0YWdlIDMKICAgICAgICB0ID0gKHYwIC0gdjEgKyAxKSA+PiAxOwogICAgICAgIHYwID0gKHYwICsgdjEgKyAxKSA+PiAxOwogICAgICAgIHYxID0gdDsKICAgICAgICB0ID0gKCh2MiAqIGRjdFNpbjYpICsgKHYzICogZGN0Q29zNikgKyAyMDQ4KSA+PiAxMjsKICAgICAgICB2MiA9ICgodjIgKiBkY3RDb3M2KSAtICh2MyAqIGRjdFNpbjYpICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjMgPSB0OwogICAgICAgIHQgPSAodjQgLSB2NiArIDEpID4+IDE7CiAgICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7CiAgICAgICAgdjYgPSB0OwogICAgICAgIHQgPSAodjcgKyB2NSArIDEpID4+IDE7CiAgICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7CiAgICAgICAgdjcgPSB0OwoKICAgICAgICAvLyBzdGFnZSAyCiAgICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTsKICAgICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTsKICAgICAgICB2MyA9IHQ7CiAgICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTsKICAgICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTsKICAgICAgICB2MiA9IHQ7CiAgICAgICAgdCA9ICgodjQgKiBkY3RTaW4zKSArICh2NyAqIGRjdENvczMpICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjQgPSAoKHY0ICogZGN0Q29zMykgLSAodjcgKiBkY3RTaW4zKSArIDIwNDgpID4+IDEyOwogICAgICAgIHY3ID0gdDsKICAgICAgICB0ID0gKCh2NSAqIGRjdFNpbjEpICsgKHY2ICogZGN0Q29zMSkgKyAyMDQ4KSA+PiAxMjsKICAgICAgICB2NSA9ICgodjUgKiBkY3RDb3MxKSAtICh2NiAqIGRjdFNpbjEpICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjYgPSB0OwoKICAgICAgICAvLyBzdGFnZSAxCiAgICAgICAgcFsoMCAqIDgpICsgY29sXSA9IHYwICsgdjc7CiAgICAgICAgcFsoNyAqIDgpICsgY29sXSA9IHYwIC0gdjc7CiAgICAgICAgcFsoMSAqIDgpICsgY29sXSA9IHYxICsgdjY7CiAgICAgICAgcFsoNiAqIDgpICsgY29sXSA9IHYxIC0gdjY7CiAgICAgICAgcFsoMiAqIDgpICsgY29sXSA9IHYyICsgdjU7CiAgICAgICAgcFsoNSAqIDgpICsgY29sXSA9IHYyIC0gdjU7CiAgICAgICAgcFsoMyAqIDgpICsgY29sXSA9IHYzICsgdjQ7CiAgICAgICAgcFsoNCAqIDgpICsgY29sXSA9IHYzIC0gdjQ7CiAgICAgIH0KCiAgICAgIC8vIGNvbnZlcnQgdG8gOC1iaXQgaW50ZWdlcnMKICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyArK2kpIHsKICAgICAgICBjb25zdCBzYW1wbGUgPSAxMjggKyAoKHBbaV0gKyA4KSA+PiA0KTsKICAgICAgICBpZiAoc2FtcGxlIDwgMCkgewogICAgICAgICAgZGF0YU91dFtpXSA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChzYW1wbGUgPiAwWEZGKSB7CiAgICAgICAgICBkYXRhT3V0W2ldID0gMHhGRjsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZGF0YU91dFtpXSA9IHNhbXBsZTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBmb3IgKGxldCBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7CiAgICAgIGNvbnN0IHNjYW5MaW5lID0gYmxvY2tSb3cgPDwgMzsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHsKICAgICAgICBsaW5lcy5wdXNoKG5ldyBVaW50OEFycmF5KHNhbXBsZXNQZXJMaW5lKSk7CiAgICAgIH0KICAgICAgZm9yIChsZXQgYmxvY2tDb2wgPSAwOyBibG9ja0NvbCA8IGJsb2Nrc1BlckxpbmU7IGJsb2NrQ29sKyspIHsKICAgICAgICBxdWFudGl6ZUFuZEludmVyc2UoY29tcG9uZW50LmJsb2Nrc1tibG9ja1Jvd11bYmxvY2tDb2xdLCByLCBSKTsKCiAgICAgICAgbGV0IG9mZnNldCA9IDA7CiAgICAgICAgY29uc3Qgc2FtcGxlID0gYmxvY2tDb2wgPDwgMzsKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDg7IGorKykgewogICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW3NjYW5MaW5lICsgal07CiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykgewogICAgICAgICAgICBsaW5lW3NhbXBsZSArIGldID0gcltvZmZzZXQrK107CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICByZXR1cm4gbGluZXM7CiAgfQoKICBjbGFzcyBKcGVnU3RyZWFtUmVhZGVyIHsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICB0aGlzLmpmaWYgPSBudWxsOwogICAgICB0aGlzLmFkb2JlID0gbnVsbDsKCiAgICAgIHRoaXMucXVhbnRpemF0aW9uVGFibGVzID0gW107CiAgICAgIHRoaXMuaHVmZm1hblRhYmxlc0FDID0gW107CiAgICAgIHRoaXMuaHVmZm1hblRhYmxlc0RDID0gW107CiAgICAgIHRoaXMucmVzZXRGcmFtZXMoKTsKICAgIH0KCiAgICByZXNldEZyYW1lcygpIHsKICAgICAgdGhpcy5mcmFtZXMgPSBbXTsKICAgIH0KCiAgICBwYXJzZShkYXRhKSB7CiAgICAgIGxldCBvZmZzZXQgPSAwOwogICAgICAvLyBjb25zdCB7IGxlbmd0aCB9ID0gZGF0YTsKICAgICAgZnVuY3Rpb24gcmVhZFVpbnQxNigpIHsKICAgICAgICBjb25zdCB2YWx1ZSA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdOwogICAgICAgIG9mZnNldCArPSAyOwogICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgfQogICAgICBmdW5jdGlvbiByZWFkRGF0YUJsb2NrKCkgewogICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRVaW50MTYoKTsKICAgICAgICBjb25zdCBhcnJheSA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGggLSAyKTsKICAgICAgICBvZmZzZXQgKz0gYXJyYXkubGVuZ3RoOwogICAgICAgIHJldHVybiBhcnJheTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwcmVwYXJlQ29tcG9uZW50cyhmcmFtZSkgewogICAgICAgIGxldCBtYXhIID0gMDsKICAgICAgICBsZXQgbWF4ViA9IDA7CiAgICAgICAgbGV0IGNvbXBvbmVudDsKICAgICAgICBsZXQgY29tcG9uZW50SWQ7CiAgICAgICAgZm9yIChjb21wb25lbnRJZCBpbiBmcmFtZS5jb21wb25lbnRzKSB7CiAgICAgICAgICBpZiAoZnJhbWUuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnRJZCkpIHsKICAgICAgICAgICAgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tjb21wb25lbnRJZF07CiAgICAgICAgICAgIGlmIChtYXhIIDwgY29tcG9uZW50LmgpIHsKICAgICAgICAgICAgICBtYXhIID0gY29tcG9uZW50Lmg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKG1heFYgPCBjb21wb25lbnQudikgewogICAgICAgICAgICAgIG1heFYgPSBjb21wb25lbnQudjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjb25zdCBtY3VzUGVyTGluZSA9IE1hdGguY2VpbChmcmFtZS5zYW1wbGVzUGVyTGluZSAvIDggLyBtYXhIKTsKICAgICAgICBjb25zdCBtY3VzUGVyQ29sdW1uID0gTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDggLyBtYXhWKTsKICAgICAgICBmb3IgKGNvbXBvbmVudElkIGluIGZyYW1lLmNvbXBvbmVudHMpIHsKICAgICAgICAgIGlmIChmcmFtZS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KGNvbXBvbmVudElkKSkgewogICAgICAgICAgICBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2NvbXBvbmVudElkXTsKICAgICAgICAgICAgY29uc3QgYmxvY2tzUGVyTGluZSA9IE1hdGguY2VpbChNYXRoLmNlaWwoZnJhbWUuc2FtcGxlc1BlckxpbmUgLyA4KSAqIGNvbXBvbmVudC5oIC8gbWF4SCk7CiAgICAgICAgICAgIGNvbnN0IGJsb2Nrc1BlckNvbHVtbiA9IE1hdGguY2VpbChNYXRoLmNlaWwoZnJhbWUuc2NhbkxpbmVzIC8gOCkgKiBjb21wb25lbnQudiAvIG1heFYpOwogICAgICAgICAgICBjb25zdCBibG9ja3NQZXJMaW5lRm9yTWN1ID0gbWN1c1BlckxpbmUgKiBjb21wb25lbnQuaDsKICAgICAgICAgICAgY29uc3QgYmxvY2tzUGVyQ29sdW1uRm9yTWN1ID0gbWN1c1BlckNvbHVtbiAqIGNvbXBvbmVudC52OwogICAgICAgICAgICBjb25zdCBibG9ja3MgPSBbXTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3NQZXJDb2x1bW5Gb3JNY3U7IGkrKykgewogICAgICAgICAgICAgIGNvbnN0IHJvdyA9IFtdOwogICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2tzUGVyTGluZUZvck1jdTsgaisrKSB7CiAgICAgICAgICAgICAgICByb3cucHVzaChuZXcgSW50MzJBcnJheSg2NCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBibG9ja3MucHVzaChyb3cpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lID0gYmxvY2tzUGVyTGluZTsKICAgICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbiA9IGJsb2Nrc1BlckNvbHVtbjsKICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrcyA9IGJsb2NrczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnJhbWUubWF4SCA9IG1heEg7CiAgICAgICAgZnJhbWUubWF4ViA9IG1heFY7CiAgICAgICAgZnJhbWUubWN1c1BlckxpbmUgPSBtY3VzUGVyTGluZTsKICAgICAgICBmcmFtZS5tY3VzUGVyQ29sdW1uID0gbWN1c1BlckNvbHVtbjsKICAgICAgfQoKICAgICAgbGV0IGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7CiAgICAgIGlmIChmaWxlTWFya2VyICE9PSAweEZGRDgpIHsgLy8gU09JIChTdGFydCBvZiBJbWFnZSkKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NPSSBub3QgZm91bmQnKTsKICAgICAgfQoKICAgICAgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTsKICAgICAgd2hpbGUgKGZpbGVNYXJrZXIgIT09IDB4RkZEOSkgeyAvLyBFT0kgKEVuZCBvZiBpbWFnZSkKICAgICAgICBzd2l0Y2ggKGZpbGVNYXJrZXIpIHsKICAgICAgICAgIGNhc2UgMHhGRjAwOiBicmVhazsKICAgICAgICAgIGNhc2UgMHhGRkUwOiAvLyBBUFAwIChBcHBsaWNhdGlvbiBTcGVjaWZpYykKICAgICAgICAgIGNhc2UgMHhGRkUxOiAvLyBBUFAxCiAgICAgICAgICBjYXNlIDB4RkZFMjogLy8gQVBQMgogICAgICAgICAgY2FzZSAweEZGRTM6IC8vIEFQUDMKICAgICAgICAgIGNhc2UgMHhGRkU0OiAvLyBBUFA0CiAgICAgICAgICBjYXNlIDB4RkZFNTogLy8gQVBQNQogICAgICAgICAgY2FzZSAweEZGRTY6IC8vIEFQUDYKICAgICAgICAgIGNhc2UgMHhGRkU3OiAvLyBBUFA3CiAgICAgICAgICBjYXNlIDB4RkZFODogLy8gQVBQOAogICAgICAgICAgY2FzZSAweEZGRTk6IC8vIEFQUDkKICAgICAgICAgIGNhc2UgMHhGRkVBOiAvLyBBUFAxMAogICAgICAgICAgY2FzZSAweEZGRUI6IC8vIEFQUDExCiAgICAgICAgICBjYXNlIDB4RkZFQzogLy8gQVBQMTIKICAgICAgICAgIGNhc2UgMHhGRkVEOiAvLyBBUFAxMwogICAgICAgICAgY2FzZSAweEZGRUU6IC8vIEFQUDE0CiAgICAgICAgICBjYXNlIDB4RkZFRjogLy8gQVBQMTUKICAgICAgICAgIGNhc2UgMHhGRkZFOiB7IC8vIENPTSAoQ29tbWVudCkKICAgICAgICAgICAgY29uc3QgYXBwRGF0YSA9IHJlYWREYXRhQmxvY2soKTsKCiAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRTApIHsKICAgICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0QSAmJiBhcHBEYXRhWzFdID09PSAweDQ2ICYmIGFwcERhdGFbMl0gPT09IDB4NDkKICAgICAgICAgICAgICAgICYmIGFwcERhdGFbM10gPT09IDB4NDYgJiYgYXBwRGF0YVs0XSA9PT0gMCkgeyAvLyAnSkZJRlx4MDAnCiAgICAgICAgICAgICAgICB0aGlzLmpmaWYgPSB7CiAgICAgICAgICAgICAgICAgIHZlcnNpb246IHsgbWFqb3I6IGFwcERhdGFbNV0sIG1pbm9yOiBhcHBEYXRhWzZdIH0sCiAgICAgICAgICAgICAgICAgIGRlbnNpdHlVbml0czogYXBwRGF0YVs3XSwKICAgICAgICAgICAgICAgICAgeERlbnNpdHk6IChhcHBEYXRhWzhdIDw8IDgpIHwgYXBwRGF0YVs5XSwKICAgICAgICAgICAgICAgICAgeURlbnNpdHk6IChhcHBEYXRhWzEwXSA8PCA4KSB8IGFwcERhdGFbMTFdLAogICAgICAgICAgICAgICAgICB0aHVtYldpZHRoOiBhcHBEYXRhWzEyXSwKICAgICAgICAgICAgICAgICAgdGh1bWJIZWlnaHQ6IGFwcERhdGFbMTNdLAogICAgICAgICAgICAgICAgICB0aHVtYkRhdGE6IGFwcERhdGEuc3ViYXJyYXkoMTQsIDE0ICsgKDMgKiBhcHBEYXRhWzEyXSAqIGFwcERhdGFbMTNdKSksCiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBUT0RPIEFQUDEgLSBFeGlmCiAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRUUpIHsKICAgICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0MSAmJiBhcHBEYXRhWzFdID09PSAweDY0ICYmIGFwcERhdGFbMl0gPT09IDB4NkYKICAgICAgICAgICAgICAgICYmIGFwcERhdGFbM10gPT09IDB4NjIgJiYgYXBwRGF0YVs0XSA9PT0gMHg2NSAmJiBhcHBEYXRhWzVdID09PSAwKSB7IC8vICdBZG9iZVx4MDAnCiAgICAgICAgICAgICAgICB0aGlzLmFkb2JlID0gewogICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBhcHBEYXRhWzZdLAogICAgICAgICAgICAgICAgICBmbGFnczA6IChhcHBEYXRhWzddIDw8IDgpIHwgYXBwRGF0YVs4XSwKICAgICAgICAgICAgICAgICAgZmxhZ3MxOiAoYXBwRGF0YVs5XSA8PCA4KSB8IGFwcERhdGFbMTBdLAogICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Db2RlOiBhcHBEYXRhWzExXSwKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGNhc2UgMHhGRkRCOiB7IC8vIERRVCAoRGVmaW5lIFF1YW50aXphdGlvbiBUYWJsZXMpCiAgICAgICAgICAgIGNvbnN0IHF1YW50aXphdGlvblRhYmxlc0xlbmd0aCA9IHJlYWRVaW50MTYoKTsKICAgICAgICAgICAgY29uc3QgcXVhbnRpemF0aW9uVGFibGVzRW5kID0gcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoICsgb2Zmc2V0IC0gMjsKICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHF1YW50aXphdGlvblRhYmxlc0VuZCkgewogICAgICAgICAgICAgIGNvbnN0IHF1YW50aXphdGlvblRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdOwogICAgICAgICAgICAgIGNvbnN0IHRhYmxlRGF0YSA9IG5ldyBJbnQzMkFycmF5KDY0KTsKICAgICAgICAgICAgICBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMCkgeyAvLyA4IGJpdCB2YWx1ZXMKICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjQ7IGorKykgewogICAgICAgICAgICAgICAgICBjb25zdCB6ID0gZGN0WmlnWmFnW2pdOwogICAgICAgICAgICAgICAgICB0YWJsZURhdGFbel0gPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgaWYgKChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCkgPT09IDEpIHsgLy8gMTYgYml0CiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDY0OyBqKyspIHsKICAgICAgICAgICAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1tqXTsKICAgICAgICAgICAgICAgICAgdGFibGVEYXRhW3pdID0gcmVhZFVpbnQxNigpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RRVDogaW52YWxpZCB0YWJsZSBzcGVjJyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHRoaXMucXVhbnRpemF0aW9uVGFibGVzW3F1YW50aXphdGlvblRhYmxlU3BlYyAmIDE1XSA9IHRhYmxlRGF0YTsKICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBjYXNlIDB4RkZDMDogLy8gU09GMCAoU3RhcnQgb2YgRnJhbWUsIEJhc2VsaW5lIERDVCkKICAgICAgICAgIGNhc2UgMHhGRkMxOiAvLyBTT0YxIChTdGFydCBvZiBGcmFtZSwgRXh0ZW5kZWQgRENUKQogICAgICAgICAgY2FzZSAweEZGQzI6IHsgLy8gU09GMiAoU3RhcnQgb2YgRnJhbWUsIFByb2dyZXNzaXZlIERDVCkKICAgICAgICAgICAgcmVhZFVpbnQxNigpOyAvLyBza2lwIGRhdGEgbGVuZ3RoCiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gewogICAgICAgICAgICAgIGV4dGVuZGVkOiAoZmlsZU1hcmtlciA9PT0gMHhGRkMxKSwKICAgICAgICAgICAgICBwcm9ncmVzc2l2ZTogKGZpbGVNYXJrZXIgPT09IDB4RkZDMiksCiAgICAgICAgICAgICAgcHJlY2lzaW9uOiBkYXRhW29mZnNldCsrXSwKICAgICAgICAgICAgICBzY2FuTGluZXM6IHJlYWRVaW50MTYoKSwKICAgICAgICAgICAgICBzYW1wbGVzUGVyTGluZTogcmVhZFVpbnQxNigpLAogICAgICAgICAgICAgIGNvbXBvbmVudHM6IHt9LAogICAgICAgICAgICAgIGNvbXBvbmVudHNPcmRlcjogW10sCiAgICAgICAgICAgIH07CgogICAgICAgICAgICBjb25zdCBjb21wb25lbnRzQ291bnQgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgbGV0IGNvbXBvbmVudElkOwogICAgICAgICAgICAvLyBsZXQgbWF4SCA9IDA7CiAgICAgICAgICAgIC8vIGxldCBtYXhWID0gMDsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wb25lbnRzQ291bnQ7IGkrKykgewogICAgICAgICAgICAgIGNvbXBvbmVudElkID0gZGF0YVtvZmZzZXRdOwogICAgICAgICAgICAgIGNvbnN0IGggPSBkYXRhW29mZnNldCArIDFdID4+IDQ7CiAgICAgICAgICAgICAgY29uc3QgdiA9IGRhdGFbb2Zmc2V0ICsgMV0gJiAxNTsKICAgICAgICAgICAgICBjb25zdCBxSWQgPSBkYXRhW29mZnNldCArIDJdOwogICAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHNPcmRlci5wdXNoKGNvbXBvbmVudElkKTsKICAgICAgICAgICAgICBmcmFtZS5jb21wb25lbnRzW2NvbXBvbmVudElkXSA9IHsKICAgICAgICAgICAgICAgIGgsCiAgICAgICAgICAgICAgICB2LAogICAgICAgICAgICAgICAgcXVhbnRpemF0aW9uSWR4OiBxSWQsCiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICBvZmZzZXQgKz0gMzsKICAgICAgICAgICAgfQogICAgICAgICAgICBwcmVwYXJlQ29tcG9uZW50cyhmcmFtZSk7CiAgICAgICAgICAgIHRoaXMuZnJhbWVzLnB1c2goZnJhbWUpOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBjYXNlIDB4RkZDNDogeyAvLyBESFQgKERlZmluZSBIdWZmbWFuIFRhYmxlcykKICAgICAgICAgICAgY29uc3QgaHVmZm1hbkxlbmd0aCA9IHJlYWRVaW50MTYoKTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBodWZmbWFuTGVuZ3RoOykgewogICAgICAgICAgICAgIGNvbnN0IGh1ZmZtYW5UYWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgICBjb25zdCBjb2RlTGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDE2KTsKICAgICAgICAgICAgICBsZXQgY29kZUxlbmd0aFN1bSA9IDA7CiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrLCBvZmZzZXQrKykgewogICAgICAgICAgICAgICAgY29kZUxlbmd0aHNbal0gPSBkYXRhW29mZnNldF07CiAgICAgICAgICAgICAgICBjb2RlTGVuZ3RoU3VtICs9IGNvZGVMZW5ndGhzW2pdOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjb25zdCBodWZmbWFuVmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoY29kZUxlbmd0aFN1bSk7CiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2RlTGVuZ3RoU3VtOyBqKyssIG9mZnNldCsrKSB7CiAgICAgICAgICAgICAgICBodWZmbWFuVmFsdWVzW2pdID0gZGF0YVtvZmZzZXRdOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpICs9IDE3ICsgY29kZUxlbmd0aFN1bTsKCiAgICAgICAgICAgICAgaWYgKChodWZmbWFuVGFibGVTcGVjID4+IDQpID09PSAwKSB7CiAgICAgICAgICAgICAgICB0aGlzLmh1ZmZtYW5UYWJsZXNEQ1todWZmbWFuVGFibGVTcGVjICYgMTVdID0gYnVpbGRIdWZmbWFuVGFibGUoCiAgICAgICAgICAgICAgICAgIGNvZGVMZW5ndGhzLCBodWZmbWFuVmFsdWVzLAogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5odWZmbWFuVGFibGVzQUNbaHVmZm1hblRhYmxlU3BlYyAmIDE1XSA9IGJ1aWxkSHVmZm1hblRhYmxlKAogICAgICAgICAgICAgICAgICBjb2RlTGVuZ3RocywgaHVmZm1hblZhbHVlcywKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGNhc2UgMHhGRkREOiAvLyBEUkkgKERlZmluZSBSZXN0YXJ0IEludGVydmFsKQogICAgICAgICAgICByZWFkVWludDE2KCk7IC8vIHNraXAgZGF0YSBsZW5ndGgKICAgICAgICAgICAgdGhpcy5yZXNldEludGVydmFsID0gcmVhZFVpbnQxNigpOwogICAgICAgICAgICBicmVhazsKCiAgICAgICAgICBjYXNlIDB4RkZEQTogeyAvLyBTT1MgKFN0YXJ0IG9mIFNjYW4pCiAgICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBsZW5ndGgKICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3JzQ291bnQgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IFtdOwogICAgICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuZnJhbWVzWzBdOwogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdG9yc0NvdW50OyBpKyspIHsKICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2RhdGFbb2Zmc2V0KytdXTsKICAgICAgICAgICAgICBjb25zdCB0YWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgICBjb21wb25lbnQuaHVmZm1hblRhYmxlREMgPSB0aGlzLmh1ZmZtYW5UYWJsZXNEQ1t0YWJsZVNwZWMgPj4gNF07CiAgICAgICAgICAgICAgY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDID0gdGhpcy5odWZmbWFuVGFibGVzQUNbdGFibGVTcGVjICYgMTVdOwogICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IHNwZWN0cmFsU3RhcnQgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgY29uc3Qgc3BlY3RyYWxFbmQgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZGVjb2RlU2NhbihkYXRhLCBvZmZzZXQsCiAgICAgICAgICAgICAgZnJhbWUsIGNvbXBvbmVudHMsIHRoaXMucmVzZXRJbnRlcnZhbCwKICAgICAgICAgICAgICBzcGVjdHJhbFN0YXJ0LCBzcGVjdHJhbEVuZCwKICAgICAgICAgICAgICBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiA+PiA0LCBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiAmIDE1KTsKICAgICAgICAgICAgb2Zmc2V0ICs9IHByb2Nlc3NlZDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgY2FzZSAweEZGRkY6IC8vIEZpbGwgYnl0ZXMKICAgICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0XSAhPT0gMHhGRikgeyAvLyBBdm9pZCBza2lwcGluZyBhIHZhbGlkIG1hcmtlci4KICAgICAgICAgICAgICBvZmZzZXQtLTsKICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhazsKCiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQgLSAzXSA9PT0gMHhGRgogICAgICAgICAgICAgICYmIGRhdGFbb2Zmc2V0IC0gMl0gPj0gMHhDMCAmJiBkYXRhW29mZnNldCAtIDJdIDw9IDB4RkUpIHsKICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBpbmNvcnJlY3QgZW5jb2RpbmcgLS0gbGFzdCAweEZGIGJ5dGUgb2YgdGhlIHByZXZpb3VzCiAgICAgICAgICAgICAgLy8gYmxvY2sgd2FzIGVhdGVuIGJ5IHRoZSBlbmNvZGVyCiAgICAgICAgICAgICAgb2Zmc2V0IC09IDM7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIEpQRUcgbWFya2VyICR7ZmlsZU1hcmtlci50b1N0cmluZygxNil9YCk7CiAgICAgICAgfQogICAgICAgIGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7CiAgICAgIH0KICAgIH0KCiAgICBnZXRSZXN1bHQoKSB7CiAgICAgIGNvbnN0IHsgZnJhbWVzIH0gPSB0aGlzOwogICAgICBpZiAodGhpcy5mcmFtZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBmcmFtZXMgd2VyZSBkZWNvZGVkJyk7CiAgICAgIH0gZWxzZSBpZiAodGhpcy5mcmFtZXMubGVuZ3RoID4gMSkgewogICAgICAgIGNvbnNvbGUud2FybignbW9yZSB0aGFuIG9uZSBmcmFtZSBpcyBub3Qgc3VwcG9ydGVkJyk7CiAgICAgIH0KCiAgICAgIC8vIHNldCBlYWNoIGZyYW1lJ3MgY29tcG9uZW50cyBxdWFudGl6YXRpb24gdGFibGUKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZyYW1lcy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGNwID0gdGhpcy5mcmFtZXNbaV0uY29tcG9uZW50czsKICAgICAgICBmb3IgKGNvbnN0IGogb2YgT2JqZWN0LmtleXMoY3ApKSB7CiAgICAgICAgICBjcFtqXS5xdWFudGl6YXRpb25UYWJsZSA9IHRoaXMucXVhbnRpemF0aW9uVGFibGVzW2NwW2pdLnF1YW50aXphdGlvbklkeF07CiAgICAgICAgICBkZWxldGUgY3Bbal0ucXVhbnRpemF0aW9uSWR4OwogICAgICAgIH0KICAgICAgfQoKICAgICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbMF07CiAgICAgIGNvbnN0IHsgY29tcG9uZW50cywgY29tcG9uZW50c09yZGVyIH0gPSBmcmFtZTsKICAgICAgY29uc3Qgb3V0Q29tcG9uZW50cyA9IFtdOwogICAgICBjb25zdCB3aWR0aCA9IGZyYW1lLnNhbXBsZXNQZXJMaW5lOwogICAgICBjb25zdCBoZWlnaHQgPSBmcmFtZS5zY2FuTGluZXM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHNPcmRlci5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50c09yZGVyW2ldXTsKICAgICAgICBvdXRDb21wb25lbnRzLnB1c2goewogICAgICAgICAgbGluZXM6IGJ1aWxkQ29tcG9uZW50RGF0YShmcmFtZSwgY29tcG9uZW50KSwKICAgICAgICAgIHNjYWxlWDogY29tcG9uZW50LmggLyBmcmFtZS5tYXhILAogICAgICAgICAgc2NhbGVZOiBjb21wb25lbnQudiAvIGZyYW1lLm1heFYsCiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogb3V0Q29tcG9uZW50cy5sZW5ndGgpOwogICAgICBsZXQgb2kgPSAwOwogICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7CiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7CiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dENvbXBvbmVudHMubGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gb3V0Q29tcG9uZW50c1tpXTsKICAgICAgICAgICAgb3V0W29pXSA9IGNvbXBvbmVudC5saW5lc1swIHwgeSAqIGNvbXBvbmVudC5zY2FsZVldWzAgfCB4ICogY29tcG9uZW50LnNjYWxlWF07CiAgICAgICAgICAgICsrb2k7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBvdXQ7CiAgICB9CiAgfQoKICBjbGFzcyBKcGVnRGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHsKICAgIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnkpIHsKICAgICAgc3VwZXIoKTsKICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgSnBlZ1N0cmVhbVJlYWRlcigpOwogICAgICBpZiAoZmlsZURpcmVjdG9yeS5KUEVHVGFibGVzKSB7CiAgICAgICAgdGhpcy5yZWFkZXIucGFyc2UoZmlsZURpcmVjdG9yeS5KUEVHVGFibGVzKTsKICAgICAgfQogICAgfQoKICAgIGRlY29kZUJsb2NrKGJ1ZmZlcikgewogICAgICB0aGlzLnJlYWRlci5yZXNldEZyYW1lcygpOwogICAgICB0aGlzLnJlYWRlci5wYXJzZShuZXcgVWludDhBcnJheShidWZmZXIpKTsKICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLmdldFJlc3VsdCgpLmJ1ZmZlcjsKICAgIH0KICB9CgogIC8qISBwYWtvIDIuMC40IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrbyBAbGljZW5zZSAoTUlUIEFORCBabGliKSAqLwogIC8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlcgogIC8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luCiAgLy8KICAvLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZAogIC8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcwogIC8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuCiAgLy8KICAvLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwKICAvLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0CiAgLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOgogIC8vCiAgLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QKICAvLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlCiAgLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUKICAvLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuCiAgLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUKICAvLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4KICAvLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLgoKICAvKiBlc2xpbnQtZGlzYWJsZSBzcGFjZS11bmFyeS1vcHMgKi8KCiAgLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki8KICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qLwoKCiAgLy9jb25zdCBaX0ZJTFRFUkVEICAgICAgICAgID0gMTsKICAvL2NvbnN0IFpfSFVGRk1BTl9PTkxZICAgICAgPSAyOwogIC8vY29uc3QgWl9STEUgICAgICAgICAgICAgICA9IDM7CiAgY29uc3QgWl9GSVhFRCQxICAgICAgICAgICAgICAgPSA0OwogIC8vY29uc3QgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7CgogIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi8KICBjb25zdCBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwOwogIGNvbnN0IFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7CiAgLy9jb25zdCBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFQKICBjb25zdCBaX1VOS05PV04kMSAgICAgICAgICAgICA9IDI7CgogIC8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovCgoKICBmdW5jdGlvbiB6ZXJvJDEoYnVmKSB7IGxldCBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfQoKICAvLyBGcm9tIHp1dGlsLmgKCiAgY29uc3QgU1RPUkVEX0JMT0NLID0gMDsKICBjb25zdCBTVEFUSUNfVFJFRVMgPSAxOwogIGNvbnN0IERZTl9UUkVFUyAgICA9IDI7CiAgLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi8KCiAgY29uc3QgTUlOX01BVENIJDEgICAgPSAzOwogIGNvbnN0IE1BWF9NQVRDSCQxICAgID0gMjU4OwogIC8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi8KCiAgLy8gRnJvbSBkZWZsYXRlLmgKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS4KICAgKi8KCiAgY29uc3QgTEVOR1RIX0NPREVTJDEgID0gMjk7CiAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovCgogIGNvbnN0IExJVEVSQUxTJDEgICAgICA9IDI1NjsKICAvKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi8KCiAgY29uc3QgTF9DT0RFUyQxICAgICAgID0gTElURVJBTFMkMSArIDEgKyBMRU5HVEhfQ09ERVMkMTsKICAvKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi8KCiAgY29uc3QgRF9DT0RFUyQxICAgICAgID0gMzA7CiAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovCgogIGNvbnN0IEJMX0NPREVTJDEgICAgICA9IDE5OwogIC8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqLwoKICBjb25zdCBIRUFQX1NJWkUkMSAgICAgPSAyICogTF9DT0RFUyQxICsgMTsKICAvKiBtYXhpbXVtIGhlYXAgc2l6ZSAqLwoKICBjb25zdCBNQVhfQklUUyQxICAgICAgPSAxNTsKICAvKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi8KCiAgY29uc3QgQnVmX3NpemUgICAgICA9IDE2OwogIC8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi8KCgogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAqIENvbnN0YW50cwogICAqLwoKICBjb25zdCBNQVhfQkxfQklUUyA9IDc7CiAgLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqLwoKICBjb25zdCBFTkRfQkxPQ0sgICA9IDI1NjsKICAvKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovCgogIGNvbnN0IFJFUF8zXzYgICAgID0gMTY7CiAgLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqLwoKICBjb25zdCBSRVBaXzNfMTAgICA9IDE3OwogIC8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqLwoKICBjb25zdCBSRVBaXzExXzEzOCA9IDE4OwogIC8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovCgogIC8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovCiAgY29uc3QgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi8KICAgIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdKTsKCiAgY29uc3QgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqLwogICAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdKTsKCiAgY29uc3QgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovCiAgICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN10pOwoKICBjb25zdCBibF9vcmRlciA9CiAgICBuZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pOwogIC8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi8KCiAgLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZwogICAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLgogICAqLwoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLgogICAqLwoKICAvLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2FwcwoKICBjb25zdCBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi8KCiAgLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzEKICBjb25zdCBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTJDEgKyAyKSAqIDIpOwogIHplcm8kMShzdGF0aWNfbHRyZWUpOwogIC8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vCiAgICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXIKICAgKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXQKICAgKiBiZWxvdykuCiAgICovCgogIGNvbnN0IHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyQxICogMik7CiAgemVybyQxKHN0YXRpY19kdHJlZSk7CiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZQogICAqIDUgYml0cy4pCiAgICovCgogIGNvbnN0IF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7CiAgemVybyQxKF9kaXN0X2NvZGUpOwogIC8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXMKICAgKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mCiAgICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuCiAgICovCgogIGNvbnN0IF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIJDEgLSBNSU5fTUFUQ0gkMSArIDEpOwogIHplcm8kMShfbGVuZ3RoX2NvZGUpOwogIC8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi8KCiAgY29uc3QgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMkMSk7CiAgemVybyQxKGJhc2VfbGVuZ3RoKTsKICAvKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqLwoKICBjb25zdCBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMkMSk7CiAgemVybyQxKGJhc2VfZGlzdCk7CiAgLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi8KCgogIGZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkgewoKICAgIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovCiAgICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi8KICAgIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovCiAgICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqLwogICAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi8KCiAgICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHMKICAgIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoOwogIH0KCgogIGxldCBzdGF0aWNfbF9kZXNjOwogIGxldCBzdGF0aWNfZF9kZXNjOwogIGxldCBzdGF0aWNfYmxfZGVzYzsKCgogIGZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHsKICAgIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi8KICAgIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqLwogICAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi8KICB9CgoKCiAgY29uc3QgZF9jb2RlID0gKGRpc3QpID0+IHsKCiAgICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07CiAgfTsKCgogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLgogICAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi4KICAgKi8KICBjb25zdCBwdXRfc2hvcnQgPSAocywgdykgPT4gewogIC8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTsKICAvLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7CiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7CiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7CiAgfTsKCgogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLgogICAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLgogICAqLwogIGNvbnN0IHNlbmRfYml0cyA9IChzLCB2YWx1ZSwgbGVuZ3RoKSA9PiB7CgogICAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7CiAgICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjsKICAgICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTsKICAgICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTsKICAgICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTsKICAgIH0gZWxzZSB7CiAgICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjsKICAgICAgcy5iaV92YWxpZCArPSBsZW5ndGg7CiAgICB9CiAgfTsKCgogIGNvbnN0IHNlbmRfY29kZSA9IChzLCBjLCB0cmVlKSA9PiB7CgogICAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7CiAgfTsKCgogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyCiAgICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKQogICAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTUKICAgKi8KICBjb25zdCBiaV9yZXZlcnNlID0gKGNvZGUsIGxlbikgPT4gewoKICAgIGxldCByZXMgPSAwOwogICAgZG8gewogICAgICByZXMgfD0gY29kZSAmIDE7CiAgICAgIGNvZGUgPj4+PSAxOwogICAgICByZXMgPDw9IDE7CiAgICB9IHdoaWxlICgtLWxlbiA+IDApOwogICAgcmV0dXJuIHJlcyA+Pj4gMTsKICB9OwoKCiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuCiAgICovCiAgY29uc3QgYmlfZmx1c2ggPSAocykgPT4gewoKICAgIGlmIChzLmJpX3ZhbGlkID09PSAxNikgewogICAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpOwogICAgICBzLmJpX2J1ZiA9IDA7CiAgICAgIHMuYmlfdmFsaWQgPSAwOwoKICAgIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7CiAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmOwogICAgICBzLmJpX2J1ZiA+Pj0gODsKICAgICAgcy5iaV92YWxpZCAtPSA4OwogICAgfQogIH07CgoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aAogICAqIGZvciB0aGUgY3VycmVudCBibG9jay4KICAgKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZAogICAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuCiAgICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZQogICAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC4KICAgKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzCiAgICogICAgIG5vdCBudWxsLgogICAqLwogIGNvbnN0IGdlbl9iaXRsZW4gPSAocywgZGVzYykgPT4KICAvLyAgICBkZWZsYXRlX3N0YXRlICpzOwogIC8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqLwogIHsKICAgIGNvbnN0IHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7CiAgICBjb25zdCBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlOwogICAgY29uc3Qgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7CiAgICBjb25zdCBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7CiAgICBjb25zdCBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzOwogICAgY29uc3QgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTsKICAgIGNvbnN0IG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7CiAgICBsZXQgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi8KICAgIGxldCBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovCiAgICBsZXQgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi8KICAgIGxldCB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqLwogICAgbGV0IGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi8KICAgIGxldCBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi8KCiAgICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTJDE7IGJpdHMrKykgewogICAgICBzLmJsX2NvdW50W2JpdHNdID0gMDsKICAgIH0KCiAgICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heQogICAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuCiAgICAgKi8KICAgIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovCgogICAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkUkMTsgaCsrKSB7CiAgICAgIG4gPSBzLmhlYXBbaF07CiAgICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxOwogICAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHsKICAgICAgICBiaXRzID0gbWF4X2xlbmd0aDsKICAgICAgICBvdmVyZmxvdysrOwogICAgICB9CiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0czsKICAgICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi8KCiAgICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovCgogICAgICBzLmJsX2NvdW50W2JpdHNdKys7CiAgICAgIHhiaXRzID0gMDsKICAgICAgaWYgKG4gPj0gYmFzZSkgewogICAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdOwogICAgICB9CiAgICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLzsKICAgICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTsKICAgICAgaWYgKGhhc19zdHJlZSkgewogICAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTsKICAgICAgfQogICAgfQogICAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfQoKICAgIC8vIFRyYWNlKChzdGRlcnIsIlxuYml0IGxlbmd0aCBvdmVyZmxvd1xuIikpOwogICAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi8KCiAgICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqLwogICAgZG8gewogICAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7CiAgICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfQogICAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovCiAgICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi8KICAgICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tOwogICAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLAogICAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF0KICAgICAgICovCiAgICAgIG92ZXJmbG93IC09IDI7CiAgICB9IHdoaWxlIChvdmVyZmxvdyA+IDApOwoKICAgIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS4KICAgICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGwKICAgICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuCiAgICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLikKICAgICAqLwogICAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7CiAgICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdOwogICAgICB3aGlsZSAobiAhPT0gMCkgewogICAgICAgIG0gPSBzLmhlYXBbLS1oXTsKICAgICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9CiAgICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7CiAgICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLCJjb2RlICVkIGJpdHMgJWQtPiVkXG4iLCBtLCB0cmVlW21dLkxlbiwgYml0cykpOwogICAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87CiAgICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7CiAgICAgICAgfQogICAgICAgIG4tLTsKICAgICAgfQogICAgfQogIH07CgoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmUKICAgKiBvcHRpbWFsKS4KICAgKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvcgogICAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuCiAgICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub24KICAgKiAgICAgemVybyBjb2RlIGxlbmd0aC4KICAgKi8KICBjb25zdCBnZW5fY29kZXMgPSAodHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KSA9PgogIC8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovCiAgLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovCiAgLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqLwogIHsKICAgIGNvbnN0IG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyQxICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovCiAgICBsZXQgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi8KICAgIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqLwogICAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqLwoKICAgIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlcwogICAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuCiAgICAgKi8KICAgIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFMkMTsgYml0cysrKSB7CiAgICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTsKICAgIH0KICAgIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGUKICAgICAqIG11c3QgYmUgYWxsIG9uZXMuCiAgICAgKi8KICAgIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLAogICAgLy8gICAgICAgICJpbmNvbnNpc3RlbnQgYml0IGNvdW50cyIpOwogICAgLy9UcmFjZXYoKHN0ZGVyciwiXG5nZW5fY29kZXM6IG1heF9jb2RlICVkICIsIG1heF9jb2RlKSk7CgogICAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykgewogICAgICBsZXQgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87CiAgICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH0KICAgICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi8KICAgICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7CgogICAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsIlxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSAiLAogICAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTsKICAgIH0KICB9OwoKCiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy4KICAgKi8KICBjb25zdCB0cl9zdGF0aWNfaW5pdCA9ICgpID0+IHsKCiAgICBsZXQgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqLwogICAgbGV0IGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqLwogICAgbGV0IGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi8KICAgIGxldCBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqLwogICAgbGV0IGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqLwogICAgY29uc3QgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMkMSArIDEpOwogICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovCgogICAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKQogICAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuOwoKICAgIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi8KICAvKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSUwogICAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTsKICAgIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzOwogICAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTsKICAgIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzOwogICAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0czsKICAjZW5kaWYqLwoKICAgIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi8KICAgIGxlbmd0aCA9IDA7CiAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTJDEgLSAxOyBjb2RlKyspIHsKICAgICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7CiAgICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykgewogICAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlOwogICAgICB9CiAgICB9CiAgICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2Iik7CiAgICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZAogICAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2UKICAgICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzoKICAgICAqLwogICAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTsKCiAgICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi8KICAgIGRpc3QgPSAwOwogICAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHsKICAgICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDsKICAgICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7CiAgICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTsKICAgICAgfQogICAgfQogICAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCAidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2Iik7CiAgICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi8KICAgIGZvciAoOyBjb2RlIDwgRF9DT0RFUyQxOyBjb2RlKyspIHsKICAgICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3OwogICAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHsKICAgICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlOwogICAgICB9CiAgICB9CiAgICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsICJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyIik7CgogICAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqLwogICAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUyQxOyBiaXRzKyspIHsKICAgICAgYmxfY291bnRbYml0c10gPSAwOwogICAgfQoKICAgIG4gPSAwOwogICAgd2hpbGUgKG4gPD0gMTQzKSB7CiAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4OwogICAgICBuKys7CiAgICAgIGJsX2NvdW50WzhdKys7CiAgICB9CiAgICB3aGlsZSAobiA8PSAyNTUpIHsKICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7CiAgICAgIG4rKzsKICAgICAgYmxfY291bnRbOV0rKzsKICAgIH0KICAgIHdoaWxlIChuIDw9IDI3OSkgewogICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNzsKICAgICAgbisrOwogICAgICBibF9jb3VudFs3XSsrOwogICAgfQogICAgd2hpbGUgKG4gPD0gMjg3KSB7CiAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4OwogICAgICBuKys7CiAgICAgIGJsX2NvdW50WzhdKys7CiAgICB9CiAgICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGUKICAgICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZQogICAgICogYWxsIG9uZXMpCiAgICAgKi8KICAgIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMkMSArIDEsIGJsX2NvdW50KTsKCiAgICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi8KICAgIGZvciAobiA9IDA7IG4gPCBEX0NPREVTJDE7IG4rKykgewogICAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTsKICAgICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7CiAgICB9CgogICAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlcwogICAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyQxICsgMSwgTF9DT0RFUyQxLCBNQVhfQklUUyQxKTsKICAgIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUyQxLCBNQVhfQklUUyQxKTsKICAgIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTJDEsIE1BWF9CTF9CSVRTKTsKCiAgICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlOwogIH07CgoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLgogICAqLwogIGNvbnN0IGluaXRfYmxvY2sgPSAocykgPT4gewoKICAgIGxldCBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi8KCiAgICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi8KICAgIGZvciAobiA9IDA7IG4gPCBMX0NPREVTJDE7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfQogICAgZm9yIChuID0gMDsgbiA8IERfQ09ERVMkMTsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9CiAgICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVMkMTsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9CgogICAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxOwogICAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDsKICAgIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwOwogIH07CgoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnkKICAgKi8KICBjb25zdCBiaV93aW5kdXAgPSAocykgPT4KICB7CiAgICBpZiAocy5iaV92YWxpZCA+IDgpIHsKICAgICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTsKICAgIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHsKICAgICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpOwogICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmOwogICAgfQogICAgcy5iaV9idWYgPSAwOwogICAgcy5iaV92YWxpZCA9IDA7CiAgfTsKCiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHMKICAgKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC4KICAgKi8KICBjb25zdCBjb3B5X2Jsb2NrID0gKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpID0+CiAgLy9EZWZsYXRlU3RhdGUgKnM7CiAgLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqLwogIC8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqLwogIC8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovCiAgewogICAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqLwoKICAgIGlmIChoZWFkZXIpIHsKICAgICAgcHV0X3Nob3J0KHMsIGxlbik7CiAgICAgIHB1dF9zaG9ydChzLCB+bGVuKTsKICAgIH0KICAvLyAgd2hpbGUgKGxlbi0tKSB7CiAgLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTsKICAvLyAgfQogICAgcy5wZW5kaW5nX2J1Zi5zZXQocy53aW5kb3cuc3ViYXJyYXkoYnVmLCBidWYgKyBsZW4pLCBzLnBlbmRpbmcpOwogICAgcy5wZW5kaW5nICs9IGxlbjsKICB9OwoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlbgogICAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLgogICAqLwogIGNvbnN0IHNtYWxsZXIgPSAodHJlZSwgbiwgbSwgZGVwdGgpID0+IHsKCiAgICBjb25zdCBfbjIgPSBuICogMjsKICAgIGNvbnN0IF9tMiA9IG0gKiAyOwogICAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHwKICAgICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTsKICB9OwoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgaywKICAgKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZwogICAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHMKICAgKiB0d28gc29ucykuCiAgICovCiAgY29uc3QgcHFkb3duaGVhcCA9IChzLCB0cmVlLCBrKSA9PgogIC8vICAgIGRlZmxhdGVfc3RhdGUgKnM7CiAgLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi8KICAvLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqLwogIHsKICAgIGNvbnN0IHYgPSBzLmhlYXBba107CiAgICBsZXQgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi8KICAgIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHsKICAgICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi8KICAgICAgaWYgKGogPCBzLmhlYXBfbGVuICYmCiAgICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7CiAgICAgICAgaisrOwogICAgICB9CiAgICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovCiAgICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH0KCiAgICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovCiAgICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTsKICAgICAgayA9IGo7CgogICAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovCiAgICAgIGogPDw9IDE7CiAgICB9CiAgICBzLmhlYXBba10gPSB2OwogIH07CgoKICAvLyBpbmxpbmVkIG1hbnVhbGx5CiAgLy8gY29uc3QgU01BTExFU1QgPSAxOwoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXMKICAgKi8KICBjb25zdCBjb21wcmVzc19ibG9jayA9IChzLCBsdHJlZSwgZHRyZWUpID0+CiAgLy8gICAgZGVmbGF0ZV9zdGF0ZSAqczsKICAvLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovCiAgLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi8KICB7CiAgICBsZXQgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovCiAgICBsZXQgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqLwogICAgbGV0IGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovCiAgICBsZXQgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi8KICAgIGxldCBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqLwoKICAgIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7CiAgICAgIGRvIHsKICAgICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pOwogICAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdOwogICAgICAgIGx4Kys7CgogICAgICAgIGlmIChkaXN0ID09PSAwKSB7CiAgICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqLwogICAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLCIgJyVjJyAiLCBsYykpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovCiAgICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTsKICAgICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMkMSArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi8KICAgICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07CiAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHsKICAgICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07CiAgICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqLwogICAgICAgICAgfQogICAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovCiAgICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpOwogICAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCAiYmFkIGRfY29kZSIpOwoKICAgICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi8KICAgICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07CiAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHsKICAgICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07CiAgICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqLwogICAgICAgICAgfQogICAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi8KCiAgICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi8KICAgICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsCiAgICAgICAgLy8gICAgICAgInBlbmRpbmdCdWYgb3ZlcmZsb3ciKTsKCiAgICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7CiAgICB9CgogICAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpOwogIH07CgoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy4KICAgKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLgogICAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy4KICAgKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoCiAgICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzCiAgICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC4KICAgKi8KICBjb25zdCBidWlsZF90cmVlID0gKHMsIGRlc2MpID0+CiAgLy8gICAgZGVmbGF0ZV9zdGF0ZSAqczsKICAvLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi8KICB7CiAgICBjb25zdCB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7CiAgICBjb25zdCBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlOwogICAgY29uc3QgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlOwogICAgY29uc3QgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtczsKICAgIGxldCBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqLwogICAgbGV0IG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqLwogICAgbGV0IG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi8KCiAgICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluCiAgICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4KICAgICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuCiAgICAgKi8KICAgIHMuaGVhcF9sZW4gPSAwOwogICAgcy5oZWFwX21heCA9IEhFQVBfU0laRSQxOwoKICAgIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7CiAgICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkgewogICAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuOwogICAgICAgIHMuZGVwdGhbbl0gPSAwOwoKICAgICAgfSBlbHNlIHsKICAgICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7CiAgICAgIH0KICAgIH0KCiAgICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLAogICAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lCiAgICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdAogICAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS4KICAgICAqLwogICAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7CiAgICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7CiAgICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTsKICAgICAgcy5kZXB0aFtub2RlXSA9IDA7CiAgICAgIHMub3B0X2xlbi0tOwoKICAgICAgaWYgKGhhc19zdHJlZSkgewogICAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87CiAgICAgIH0KICAgICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovCiAgICB9CiAgICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7CgogICAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLAogICAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6CiAgICAgKi8KICAgIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfQoKICAgIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d28KICAgICAqIGZyZXF1ZW50IG5vZGVzLgogICAgICovCiAgICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi8KICAgIGRvIHsKICAgICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqLwogICAgICAvKioqIHBxcmVtb3ZlICoqKi8KICAgICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsKICAgICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07CiAgICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7CiAgICAgIC8qKiovCgogICAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqLwoKICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovCiAgICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTsKCiAgICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovCiAgICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLzsKICAgICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxOwogICAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTsKCiAgICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovCiAgICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKzsKICAgICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTsKCiAgICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpOwoKICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOwoKICAgIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3cKICAgICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy4KICAgICAqLwogICAgZ2VuX2JpdGxlbihzLCBkZXNjKTsKCiAgICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovCiAgICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpOwogIH07CgoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzCiAgICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS4KICAgKi8KICBjb25zdCBzY2FuX3RyZWUgPSAocywgdHJlZSwgbWF4X2NvZGUpID0+CiAgLy8gICAgZGVmbGF0ZV9zdGF0ZSAqczsKICAvLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi8KICAvLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqLwogIHsKICAgIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi8KICAgIGxldCBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi8KICAgIGxldCBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi8KCiAgICBsZXQgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovCgogICAgbGV0IGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi8KICAgIGxldCBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi8KICAgIGxldCBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi8KCiAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgIG1pbl9jb3VudCA9IDM7CiAgICB9CiAgICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovCgogICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7CiAgICAgIGN1cmxlbiA9IG5leHRsZW47CiAgICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLzsKCiAgICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgIGNvbnRpbnVlOwoKICAgICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkgewogICAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDsKCiAgICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7CgogICAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH0KICAgICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7CgogICAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7CiAgICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7CgogICAgICB9IGVsc2UgewogICAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7CiAgICAgIH0KCiAgICAgIGNvdW50ID0gMDsKICAgICAgcHJldmxlbiA9IGN1cmxlbjsKCiAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgIG1pbl9jb3VudCA9IDM7CgogICAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgIG1heF9jb3VudCA9IDY7CiAgICAgICAgbWluX2NvdW50ID0gMzsKCiAgICAgIH0gZWxzZSB7CiAgICAgICAgbWF4X2NvdW50ID0gNzsKICAgICAgICBtaW5fY291bnQgPSA0OwogICAgICB9CiAgICB9CiAgfTsKCgogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW4KICAgKiBibF90cmVlLgogICAqLwogIGNvbnN0IHNlbmRfdHJlZSA9IChzLCB0cmVlLCBtYXhfY29kZSkgPT4KICAvLyAgICBkZWZsYXRlX3N0YXRlICpzOwogIC8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi8KICAvLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqLwogIHsKICAgIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi8KICAgIGxldCBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi8KICAgIGxldCBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi8KCiAgICBsZXQgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovCgogICAgbGV0IGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi8KICAgIGxldCBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi8KICAgIGxldCBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi8KCiAgICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi8KICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgbWluX2NvdW50ID0gMzsKICAgIH0KCiAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHsKICAgICAgY3VybGVuID0gbmV4dGxlbjsKICAgICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovOwoKICAgICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgY29udGludWU7CgogICAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7CiAgICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTsKCiAgICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7CiAgICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgewogICAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsKICAgICAgICAgIGNvdW50LS07CiAgICAgICAgfQogICAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgIiAzXzY/Iik7CiAgICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7CiAgICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7CgogICAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7CiAgICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTsKICAgICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTsKCiAgICAgIH0gZWxzZSB7CiAgICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpOwogICAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTsKICAgICAgfQoKICAgICAgY291bnQgPSAwOwogICAgICBwcmV2bGVuID0gY3VybGVuOwogICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICBtaW5fY291bnQgPSAzOwoKICAgICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICBtYXhfY291bnQgPSA2OwogICAgICAgIG1pbl9jb3VudCA9IDM7CgogICAgICB9IGVsc2UgewogICAgICAgIG1heF9jb3VudCA9IDc7CiAgICAgICAgbWluX2NvdW50ID0gNDsKICAgICAgfQogICAgfQogIH07CgoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluCiAgICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuCiAgICovCiAgY29uc3QgYnVpbGRfYmxfdHJlZSA9IChzKSA9PiB7CgogICAgbGV0IG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqLwoKICAgIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi8KICAgIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpOwogICAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7CgogICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi8KICAgIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTsKICAgIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHQKICAgICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuCiAgICAgKi8KCiAgICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXQKICAgICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzCiAgICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pCiAgICAgKi8KICAgIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyQxIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkgewogICAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KICAgIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovCiAgICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0OwogICAgLy9UcmFjZXYoKHN0ZGVyciwgIlxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZCIsCiAgICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpOwoKICAgIHJldHVybiBtYXhfYmxpbmRleDsKICB9OwoKCiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlCiAgICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuCiAgICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LgogICAqLwogIGNvbnN0IHNlbmRfYWxsX3RyZWVzID0gKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKSA9PgogIC8vICAgIGRlZmxhdGVfc3RhdGUgKnM7CiAgLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqLwogIHsKICAgIGxldCByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi8KCiAgICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsICJub3QgZW5vdWdoIGNvZGVzIik7CiAgICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUywKICAgIC8vICAgICAgICAidG9vIG1hbnkgY29kZXMiKTsKICAgIC8vVHJhY2V2KChzdGRlcnIsICJcbmJsIGNvdW50czogIikpOwogICAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqLwogICAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7CiAgICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqLwogICAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykgewogICAgICAvL1RyYWNldigoc3RkZXJyLCAiXG5ibCBjb2RlICUyZCAiLCBibF9vcmRlcltyYW5rXSkpOwogICAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpOwogICAgfQogICAgLy9UcmFjZXYoKHN0ZGVyciwgIlxuYmwgdHJlZTogc2VudCAlbGQiLCBzLT5iaXRzX3NlbnQpKTsKCiAgICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi8KICAgIC8vVHJhY2V2KChzdGRlcnIsICJcbmxpdCB0cmVlOiBzZW50ICVsZCIsIHMtPmJpdHNfc2VudCkpOwoKICAgIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi8KICAgIC8vVHJhY2V2KChzdGRlcnIsICJcbmRpc3QgdHJlZTogc2VudCAlbGQiLCBzLT5iaXRzX3NlbnQpKTsKICB9OwoKCiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06CiAgICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOgogICAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGUKICAgKiAgICAgICAiYmxhY2sgbGlzdCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS4KICAgKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlCiAgICogICAgICAgIndoaXRlIGxpc3QiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS4KICAgKiAtIEJJTkFSWSBvdGhlcndpc2UuCiAgICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhCiAgICogICAiZ3JheSBsaXN0IiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOgogICAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS4KICAgKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC4KICAgKi8KICBjb25zdCBkZXRlY3RfZGF0YV90eXBlID0gKHMpID0+IHsKICAgIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlcwogICAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxCiAgICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExCiAgICAgKi8KICAgIGxldCBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjsKICAgIGxldCBuOwoKICAgIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoImJsYWNrLWxpc3RlZCIpIGJ5dGVzLiAqLwogICAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkgewogICAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkgewogICAgICAgIHJldHVybiBaX0JJTkFSWTsKICAgICAgfQogICAgfQoKICAgIC8qIENoZWNrIGZvciB0ZXh0dWFsICgid2hpdGUtbGlzdGVkIikgYnl0ZXMuICovCiAgICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHwKICAgICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7CiAgICAgIHJldHVybiBaX1RFWFQ7CiAgICB9CiAgICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTJDE7IG4rKykgewogICAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7CiAgICAgICAgcmV0dXJuIFpfVEVYVDsKICAgICAgfQogICAgfQoKICAgIC8qIFRoZXJlIGFyZSBubyAiYmxhY2stbGlzdGVkIiBvciAid2hpdGUtbGlzdGVkIiBieXRlczoKICAgICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkICgiZ3JheS1saXN0ZWQiKSBieXRlcyBvbmx5LgogICAgICovCiAgICByZXR1cm4gWl9CSU5BUlk7CiAgfTsKCgogIGxldCBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7CgogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS4KICAgKi8KICBjb25zdCBfdHJfaW5pdCQxID0gKHMpID0+CiAgewoKICAgIGlmICghc3RhdGljX2luaXRfZG9uZSkgewogICAgICB0cl9zdGF0aWNfaW5pdCgpOwogICAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTsKICAgIH0KCiAgICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpOwogICAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTsKICAgIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTsKCiAgICBzLmJpX2J1ZiA9IDA7CiAgICBzLmJpX3ZhbGlkID0gMDsKCiAgICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi8KICAgIGluaXRfYmxvY2socyk7CiAgfTsKCgogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAqIFNlbmQgYSBzdG9yZWQgYmxvY2sKICAgKi8KICBjb25zdCBfdHJfc3RvcmVkX2Jsb2NrJDEgPSAocywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSA9PgogIC8vRGVmbGF0ZVN0YXRlICpzOwogIC8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi8KICAvL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqLwogIC8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqLwogIHsKICAgIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi8KICAgIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi8KICB9OwoKCiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS4KICAgKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci4KICAgKi8KICBjb25zdCBfdHJfYWxpZ24kMSA9IChzKSA9PiB7CiAgICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpOwogICAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTsKICAgIGJpX2ZsdXNoKHMpOwogIH07CgoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWMKICAgKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuCiAgICovCiAgY29uc3QgX3RyX2ZsdXNoX2Jsb2NrJDEgPSAocywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSA9PgogIC8vRGVmbGF0ZVN0YXRlICpzOwogIC8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqLwogIC8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovCiAgLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovCiAgewogICAgbGV0IG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi8KICAgIGxldCBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovCgogICAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqLwogICAgaWYgKHMubGV2ZWwgPiAwKSB7CgogICAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqLwogICAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOJDEpIHsKICAgICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTsKICAgICAgfQoKICAgICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqLwogICAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTsKICAgICAgLy8gVHJhY2V2KChzdGRlcnIsICJcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZCIsIHMtPm9wdF9sZW4sCiAgICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7CgogICAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTsKICAgICAgLy8gVHJhY2V2KChzdGRlcnIsICJcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGQiLCBzLT5vcHRfbGVuLAogICAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpOwogICAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2YKICAgICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy4KICAgICAgICovCgogICAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleAogICAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC4KICAgICAgICovCiAgICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTsKCiAgICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi8KICAgICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzOwogICAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7CgogICAgICAvLyBUcmFjZXYoKHN0ZGVyciwgIlxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgIiwKICAgICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbiwKICAgICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7CgogICAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfQoKICAgIH0gZWxzZSB7CiAgICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsICJsb3N0IGJ1ZiIpOwogICAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovCiAgICB9CgogICAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7CiAgICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi8KCiAgICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuCiAgICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2UKICAgICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuCiAgICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0bwogICAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLgogICAgICAgKi8KICAgICAgX3RyX3N0b3JlZF9ibG9jayQxKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7CgogICAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEJDEgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7CgogICAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsKICAgICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpOwoKICAgIH0gZWxzZSB7CiAgICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOwogICAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTsKICAgICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTsKICAgIH0KICAgIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCAiYmFkIGNvbXByZXNzZWQgc2l6ZSIpOwogICAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUIKICAgICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLgogICAgICovCiAgICBpbml0X2Jsb2NrKHMpOwoKICAgIGlmIChsYXN0KSB7CiAgICAgIGJpX3dpbmR1cChzKTsKICAgIH0KICAgIC8vIFRyYWNldigoc3RkZXJyLCJcbmNvbXBybGVuICVsdSglbHUpICIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLAogICAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7CiAgfTsKCiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmCiAgICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLgogICAqLwogIGNvbnN0IF90cl90YWxseSQxID0gKHMsIGRpc3QsIGxjKSA9PgogIC8vICAgIGRlZmxhdGVfc3RhdGUgKnM7CiAgLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovCiAgLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovCiAgewogICAgLy9sZXQgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTsKCiAgICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjsKICAgIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjsKCiAgICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjsKICAgIHMubGFzdF9saXQrKzsKCiAgICBpZiAoZGlzdCA9PT0gMCkgewogICAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi8KICAgICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrOwogICAgfSBlbHNlIHsKICAgICAgcy5tYXRjaGVzKys7CiAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi8KICAgICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovCiAgICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiYKICAgICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJgogICAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgICJfdHJfdGFsbHk6IGJhZCBtYXRjaCIpOwoKICAgICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyQxICsgMSkgKiAyXS8qLkZyZXEqLysrOwogICAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrOwogICAgfQoKICAvLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLAogIC8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHkKCiAgLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0sKICAvLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovCiAgLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHsKICAvLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi8KICAvLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4OwogIC8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0OwogIC8vCiAgLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykgewogIC8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTsKICAvLyAgICB9CiAgLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7CiAgLy8gICAgLy9UcmFjZXYoKHN0ZGVyciwiXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgIiwKICAvLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLAogIC8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7CiAgLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykgewogIC8vICAgICAgcmV0dXJuIHRydWU7CiAgLy8gICAgfQogIC8vICB9CiAgLy8jZW5kaWYKCiAgICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTsKICAgIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0SwogICAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG8KICAgICAqIDY0Sy0xIGJ5dGVzLgogICAgICovCiAgfTsKCiAgdmFyIF90cl9pbml0XzEgID0gX3RyX2luaXQkMTsKICB2YXIgX3RyX3N0b3JlZF9ibG9ja18xID0gX3RyX3N0b3JlZF9ibG9jayQxOwogIHZhciBfdHJfZmx1c2hfYmxvY2tfMSAgPSBfdHJfZmx1c2hfYmxvY2skMTsKICB2YXIgX3RyX3RhbGx5XzEgPSBfdHJfdGFsbHkkMTsKICB2YXIgX3RyX2FsaWduXzEgPSBfdHJfYWxpZ24kMTsKCiAgdmFyIHRyZWVzID0gewogIAlfdHJfaW5pdDogX3RyX2luaXRfMSwKICAJX3RyX3N0b3JlZF9ibG9jazogX3RyX3N0b3JlZF9ibG9ja18xLAogIAlfdHJfZmx1c2hfYmxvY2s6IF90cl9mbHVzaF9ibG9ja18xLAogIAlfdHJfdGFsbHk6IF90cl90YWxseV8xLAogIAlfdHJfYWxpZ246IF90cl9hbGlnbl8xCiAgfTsKCiAgLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LgogIC8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLgogIC8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS4KCiAgLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyCiAgLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW4KICAvLwogIC8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkCiAgLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzCiAgLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4KICAvLwogIC8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLAogIC8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQKICAvLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6CiAgLy8KICAvLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdAogIC8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUKICAvLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZQogIC8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4KICAvLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZQogIC8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLgogIC8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uCgogIGNvbnN0IGFkbGVyMzIgPSAoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpID0+IHsKICAgIGxldCBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsCiAgICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLAogICAgICAgIG4gPSAwOwoKICAgIHdoaWxlIChsZW4gIT09IDApIHsKICAgICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXAKICAgICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy4KICAgICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuCiAgICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjsKICAgICAgbGVuIC09IG47CgogICAgICBkbyB7CiAgICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDsKICAgICAgICBzMiA9IChzMiArIHMxKSB8MDsKICAgICAgfSB3aGlsZSAoLS1uKTsKCiAgICAgIHMxICU9IDY1NTIxOwogICAgICBzMiAlPSA2NTUyMTsKICAgIH0KCiAgICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7CiAgfTsKCgogIHZhciBhZGxlcjMyXzEgPSBhZGxlcjMyOwoKICAvLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS4KICAvLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzCiAgLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy4KCiAgLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyCiAgLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW4KICAvLwogIC8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkCiAgLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzCiAgLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4KICAvLwogIC8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLAogIC8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQKICAvLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6CiAgLy8KICAvLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdAogIC8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUKICAvLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZQogIC8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4KICAvLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZQogIC8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLgogIC8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uCgogIC8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlCiAgY29uc3QgbWFrZVRhYmxlID0gKCkgPT4gewogICAgbGV0IGMsIHRhYmxlID0gW107CgogICAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykgewogICAgICBjID0gbjsKICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHsKICAgICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpOwogICAgICB9CiAgICAgIHRhYmxlW25dID0gYzsKICAgIH0KCiAgICByZXR1cm4gdGFibGU7CiAgfTsKCiAgLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS4KICBjb25zdCBjcmNUYWJsZSA9IG5ldyBVaW50MzJBcnJheShtYWtlVGFibGUoKSk7CgoKICBjb25zdCBjcmMzMiA9IChjcmMsIGJ1ZiwgbGVuLCBwb3MpID0+IHsKICAgIGNvbnN0IHQgPSBjcmNUYWJsZTsKICAgIGNvbnN0IGVuZCA9IHBvcyArIGxlbjsKCiAgICBjcmMgXj0gLTE7CgogICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7CiAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdOwogICAgfQoKICAgIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwOwogIH07CgoKICB2YXIgY3JjMzJfMSA9IGNyYzMyOwoKICAvLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXIKICAvLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpbgogIC8vCiAgLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQKICAvLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMKICAvLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLgogIC8vCiAgLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsCiAgLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdAogIC8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczoKICAvLwogIC8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90CiAgLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZQogIC8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlCiAgLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLgogIC8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlCiAgLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuCiAgLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4KCiAgdmFyIG1lc3NhZ2VzID0gewogICAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovCiAgICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi8KICAgIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqLwogICAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovCiAgICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi8KICAgICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqLwogICAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovCiAgICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi8KICAgICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqLwogIH07CgogIC8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlcgogIC8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luCiAgLy8KICAvLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZAogIC8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcwogIC8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuCiAgLy8KICAvLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwKICAvLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0CiAgLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOgogIC8vCiAgLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QKICAvLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlCiAgLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUKICAvLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuCiAgLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUKICAvLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4KICAvLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLgoKICB2YXIgY29uc3RhbnRzJDIgPSB7CgogICAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqLwogICAgWl9OT19GTFVTSDogICAgICAgICAwLAogICAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLAogICAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLAogICAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLAogICAgWl9GSU5JU0g6ICAgICAgICAgICA0LAogICAgWl9CTE9DSzogICAgICAgICAgICA1LAogICAgWl9UUkVFUzogICAgICAgICAgICA2LAoKICAgIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXMKICAgICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLgogICAgKi8KICAgIFpfT0s6ICAgICAgICAgICAgICAgMCwKICAgIFpfU1RSRUFNX0VORDogICAgICAgMSwKICAgIFpfTkVFRF9ESUNUOiAgICAgICAgMiwKICAgIFpfRVJSTk86ICAgICAgICAgICAtMSwKICAgIFpfU1RSRUFNX0VSUk9SOiAgICAtMiwKICAgIFpfREFUQV9FUlJPUjogICAgICAtMywKICAgIFpfTUVNX0VSUk9SOiAgICAgICAtNCwKICAgIFpfQlVGX0VSUk9SOiAgICAgICAtNSwKICAgIC8vWl9WRVJTSU9OX0VSUk9SOiAtNiwKCiAgICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi8KICAgIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCwKICAgIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSwKICAgIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSwKICAgIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSwKCgogICAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLAogICAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLAogICAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLAogICAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LAogICAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLAoKICAgIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi8KICAgIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCwKICAgIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSwKICAgIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpCiAgICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsCgogICAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovCiAgICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDgKICAgIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZQogIH07CgogIC8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlcgogIC8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luCiAgLy8KICAvLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZAogIC8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcwogIC8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuCiAgLy8KICAvLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwKICAvLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0CiAgLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOgogIC8vCiAgLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QKICAvLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlCiAgLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUKICAvLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuCiAgLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUKICAvLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4KICAvLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLgoKICBjb25zdCB7IF90cl9pbml0LCBfdHJfc3RvcmVkX2Jsb2NrLCBfdHJfZmx1c2hfYmxvY2ssIF90cl90YWxseSwgX3RyX2FsaWduIH0gPSB0cmVlczsKCgoKCiAgLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki8KICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qLwoKICBjb25zdCB7CiAgICBaX05PX0ZMVVNIOiBaX05PX0ZMVVNIJDIsIFpfUEFSVElBTF9GTFVTSCwgWl9GVUxMX0ZMVVNIOiBaX0ZVTExfRkxVU0gkMSwgWl9GSU5JU0g6IFpfRklOSVNIJDMsIFpfQkxPQ0s6IFpfQkxPQ0skMSwKICAgIFpfT0s6IFpfT0skMywgWl9TVFJFQU1fRU5EOiBaX1NUUkVBTV9FTkQkMywgWl9TVFJFQU1fRVJST1I6IFpfU1RSRUFNX0VSUk9SJDIsIFpfREFUQV9FUlJPUjogWl9EQVRBX0VSUk9SJDIsIFpfQlVGX0VSUk9SOiBaX0JVRl9FUlJPUiQxLAogICAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04kMSwKICAgIFpfRklMVEVSRUQsIFpfSFVGRk1BTl9PTkxZLCBaX1JMRSwgWl9GSVhFRCwgWl9ERUZBVUxUX1NUUkFURUdZOiBaX0RFRkFVTFRfU1RSQVRFR1kkMSwKICAgIFpfVU5LTk9XTiwKICAgIFpfREVGTEFURUQ6IFpfREVGTEFURUQkMgogIH0gPSBjb25zdGFudHMkMjsKCiAgLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki8KCgogIGNvbnN0IE1BWF9NRU1fTEVWRUwgPSA5OwogIC8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqLwogIGNvbnN0IE1BWF9XQklUUyQxID0gMTU7CiAgLyogMzJLIExaNzcgd2luZG93ICovCiAgY29uc3QgREVGX01FTV9MRVZFTCA9IDg7CgoKICBjb25zdCBMRU5HVEhfQ09ERVMgID0gMjk7CiAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovCiAgY29uc3QgTElURVJBTFMgICAgICA9IDI1NjsKICAvKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi8KICBjb25zdCBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTOwogIC8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqLwogIGNvbnN0IERfQ09ERVMgICAgICAgPSAzMDsKICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi8KICBjb25zdCBCTF9DT0RFUyAgICAgID0gMTk7CiAgLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovCiAgY29uc3QgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTsKICAvKiBtYXhpbXVtIGhlYXAgc2l6ZSAqLwogIGNvbnN0IE1BWF9CSVRTICA9IDE1OwogIC8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqLwoKICBjb25zdCBNSU5fTUFUQ0ggPSAzOwogIGNvbnN0IE1BWF9NQVRDSCA9IDI1ODsKICBjb25zdCBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpOwoKICBjb25zdCBQUkVTRVRfRElDVCA9IDB4MjA7CgogIGNvbnN0IElOSVRfU1RBVEUgPSA0MjsKICBjb25zdCBFWFRSQV9TVEFURSA9IDY5OwogIGNvbnN0IE5BTUVfU1RBVEUgPSA3MzsKICBjb25zdCBDT01NRU5UX1NUQVRFID0gOTE7CiAgY29uc3QgSENSQ19TVEFURSA9IDEwMzsKICBjb25zdCBCVVNZX1NUQVRFID0gMTEzOwogIGNvbnN0IEZJTklTSF9TVEFURSA9IDY2NjsKCiAgY29uc3QgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi8KICBjb25zdCBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqLwogIGNvbnN0IEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi8KICBjb25zdCBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi8KCiAgY29uc3QgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuCgogIGNvbnN0IGVyciA9IChzdHJtLCBlcnJvckNvZGUpID0+IHsKICAgIHN0cm0ubXNnID0gbWVzc2FnZXNbZXJyb3JDb2RlXTsKICAgIHJldHVybiBlcnJvckNvZGU7CiAgfTsKCiAgY29uc3QgcmFuayA9IChmKSA9PiB7CiAgICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApOwogIH07CgogIGNvbnN0IHplcm8gPSAoYnVmKSA9PiB7CiAgICBsZXQgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9CiAgfTsKCgogIC8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi8KICBsZXQgSEFTSF9aTElCID0gKHMsIHByZXYsIGRhdGEpID0+ICgocHJldiA8PCBzLmhhc2hfc2hpZnQpIF4gZGF0YSkgJiBzLmhhc2hfbWFzazsKICAvLyBUaGlzIGhhc2ggY2F1c2VzIGxlc3MgY29sbGlzaW9ucywgaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL2lzc3Vlcy8xMzUKICAvLyBCdXQgYnJlYWtzIGJpbmFyeSBjb21wYXRpYmlsaXR5CiAgLy9sZXQgSEFTSF9GQVNUID0gKHMsIHByZXYsIGRhdGEpID0+ICgocHJldiA8PCA4KSArIChwcmV2ID4+IDgpICsgKGRhdGEgPDwgNCkpICYgcy5oYXNoX21hc2s7CiAgbGV0IEhBU0ggPSBIQVNIX1pMSUI7CgogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzCiAgICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdAogICAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuCiAgICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLgogICAqLwogIGNvbnN0IGZsdXNoX3BlbmRpbmcgPSAoc3RybSkgPT4gewogICAgY29uc3QgcyA9IHN0cm0uc3RhdGU7CgogICAgLy9fdHJfZmx1c2hfYml0cyhzKTsKICAgIGxldCBsZW4gPSBzLnBlbmRpbmc7CiAgICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHsKICAgICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7CiAgICB9CiAgICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfQoKICAgIHN0cm0ub3V0cHV0LnNldChzLnBlbmRpbmdfYnVmLnN1YmFycmF5KHMucGVuZGluZ19vdXQsIHMucGVuZGluZ19vdXQgKyBsZW4pLCBzdHJtLm5leHRfb3V0KTsKICAgIHN0cm0ubmV4dF9vdXQgKz0gbGVuOwogICAgcy5wZW5kaW5nX291dCArPSBsZW47CiAgICBzdHJtLnRvdGFsX291dCArPSBsZW47CiAgICBzdHJtLmF2YWlsX291dCAtPSBsZW47CiAgICBzLnBlbmRpbmcgLT0gbGVuOwogICAgaWYgKHMucGVuZGluZyA9PT0gMCkgewogICAgICBzLnBlbmRpbmdfb3V0ID0gMDsKICAgIH0KICB9OwoKCiAgY29uc3QgZmx1c2hfYmxvY2tfb25seSA9IChzLCBsYXN0KSA9PiB7CiAgICBfdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTsKICAgIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0OwogICAgZmx1c2hfcGVuZGluZyhzLnN0cm0pOwogIH07CgoKICBjb25zdCBwdXRfYnl0ZSA9IChzLCBiKSA9PiB7CiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7CiAgfTsKCgogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci4KICAgKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4KICAgKiBwZW5kaW5nX2J1Zi4KICAgKi8KICBjb25zdCBwdXRTaG9ydE1TQiA9IChzLCBiKSA9PiB7CgogICAgLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTsKICAvLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7CiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7CiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmOwogIH07CgoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyCiAgICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2gKICAgKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZAogICAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC4KICAgKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS4KICAgKi8KICBjb25zdCByZWFkX2J1ZiA9IChzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSA9PiB7CgogICAgbGV0IGxlbiA9IHN0cm0uYXZhaWxfaW47CgogICAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfQogICAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfQoKICAgIHN0cm0uYXZhaWxfaW4gLT0gbGVuOwoKICAgIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pOwogICAgYnVmLnNldChzdHJtLmlucHV0LnN1YmFycmF5KHN0cm0ubmV4dF9pbiwgc3RybS5uZXh0X2luICsgbGVuKSwgc3RhcnQpOwogICAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkgewogICAgICBzdHJtLmFkbGVyID0gYWRsZXIzMl8xKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7CiAgICB9CgogICAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7CiAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7CiAgICB9CgogICAgc3RybS5uZXh0X2luICs9IGxlbjsKICAgIHN0cm0udG90YWxfaW4gKz0gbGVuOwoKICAgIHJldHVybiBsZW47CiAgfTsKCgogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZAogICAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCwKICAgKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzCiAgICogZ2FyYmFnZS4KICAgKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50CiAgICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMQogICAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuCiAgICovCiAgY29uc3QgbG9uZ2VzdF9tYXRjaCA9IChzLCBjdXJfbWF0Y2gpID0+IHsKCiAgICBsZXQgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqLwogICAgbGV0IHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqLwogICAgbGV0IG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi8KICAgIGxldCBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi8KICAgIGxldCBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi8KICAgIGxldCBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovCiAgICBjb25zdCBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID8KICAgICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLzsKCiAgICBjb25zdCBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0CgogICAgY29uc3Qgd21hc2sgPSBzLndfbWFzazsKICAgIGNvbnN0IHByZXYgID0gcy5wcmV2OwoKICAgIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsCiAgICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLgogICAgICovCgogICAgY29uc3Qgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDsKICAgIGxldCBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTsKICAgIGxldCBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dOwoKICAgIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LgogICAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS4KICAgICAqLwogICAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsICJDb2RlIHRvbyBjbGV2ZXIiKTsKCiAgICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqLwogICAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7CiAgICAgIGNoYWluX2xlbmd0aCA+Pj0gMjsKICAgIH0KICAgIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnkKICAgICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLgogICAgICovCiAgICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfQoKICAgIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsICJuZWVkIGxvb2thaGVhZCIpOwoKICAgIGRvIHsKICAgICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCAibm8gZnV0dXJlIik7CiAgICAgIG1hdGNoID0gY3VyX21hdGNoOwoKICAgICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlCiAgICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvdwogICAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2UKICAgICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmQKICAgICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy4KICAgICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvCiAgICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLgogICAgICAgKi8KCiAgICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8CiAgICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8CiAgICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fAogICAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KCiAgICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlCiAgICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pCiAgICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5CiAgICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXQKICAgICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguCiAgICAgICAqLwogICAgICBzY2FuICs9IDI7CiAgICAgIG1hdGNoKys7CiAgICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsICJtYXRjaFsyXT8iKTsKCiAgICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247CiAgICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LgogICAgICAgKi8KICAgICAgZG8gewogICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqLwogICAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmCiAgICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYKICAgICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJgogICAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmCiAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpOwoKICAgICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksICJ3aWxkIHNjYW4iKTsKCiAgICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTsKICAgICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDsKCiAgICAgIGlmIChsZW4gPiBiZXN0X2xlbikgewogICAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7CiAgICAgICAgYmVzdF9sZW4gPSBsZW47CiAgICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07CiAgICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTsKICAgICAgfQogICAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTsKCiAgICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHsKICAgICAgcmV0dXJuIGJlc3RfbGVuOwogICAgfQogICAgcmV0dXJuIHMubG9va2FoZWFkOwogIH07CgoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LgogICAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC4KICAgKgogICAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRAogICAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFECiAgICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlCiAgICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2wKICAgKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS4KICAgKi8KICBjb25zdCBmaWxsX3dpbmRvdyA9IChzKSA9PiB7CgogICAgY29uc3QgX3dfc2l6ZSA9IHMud19zaXplOwogICAgbGV0IHAsIG4sIG0sIG1vcmUsIHN0cjsKCiAgICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCAiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkIik7CgogICAgZG8gewogICAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDsKCiAgICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWQKICAgICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi8KICAgICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikgewogICAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHsKICAgICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTsKICAgICAgLy8KICAgICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkgewogICAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmCiAgICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKQogICAgICAvLyAgICAgICAgICovCiAgICAgIC8vICAgICAgICBtb3JlLS07CiAgICAgIC8vICAgIH0KICAgICAgLy99CgoKICAgICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCwKICAgICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi4KICAgICAgICovCiAgICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7CgogICAgICAgIHMud2luZG93LnNldChzLndpbmRvdy5zdWJhcnJheShfd19zaXplLCBfd19zaXplICsgX3dfc2l6ZSksIDApOwogICAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTsKICAgICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7CiAgICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi8KICAgICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7CgogICAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlcwogICAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMAogICAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwCiAgICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZgogICAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKQogICAgICAgICAqLwoKICAgICAgICBuID0gcy5oYXNoX3NpemU7CiAgICAgICAgcCA9IG47CgogICAgICAgIGRvIHsKICAgICAgICAgIG0gPSBzLmhlYWRbLS1wXTsKICAgICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApOwogICAgICAgIH0gd2hpbGUgKC0tbik7CgogICAgICAgIG4gPSBfd19zaXplOwogICAgICAgIHAgPSBuOwoKICAgICAgICBkbyB7CiAgICAgICAgICBtID0gcy5wcmV2Wy0tcF07CiAgICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTsKICAgICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0CiAgICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLgogICAgICAgICAgICovCiAgICAgICAgfSB3aGlsZSAoLS1uKTsKCiAgICAgICAgbW9yZSArPSBfd19zaXplOwogICAgICB9CiAgICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHsKICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6CiAgICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmCiAgICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydAogICAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSkKICAgICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyCiAgICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLAogICAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJgogICAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELgogICAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLgogICAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuCiAgICAgICAqLwogICAgICAvL0Fzc2VydChtb3JlID49IDIsICJtb3JlIDwgMiIpOwogICAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTsKICAgICAgcy5sb29rYWhlYWQgKz0gbjsKCiAgICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqLwogICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7CiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07CgogICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqLwogICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIDFdKTsKICAvLyNpZiBNSU5fTUFUQ0ggIT0gMwogIC8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lcwogIC8vI2VuZGlmCiAgICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7CiAgICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovCiAgICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSk7CgogICAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjsKICAgICAgICAgIHN0cisrOwogICAgICAgICAgcy5pbnNlcnQtLTsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsCiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC4KICAgICAgICovCgogICAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7CgogICAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW4KICAgICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZgogICAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5CiAgICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dAogICAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoCiAgICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLgogICAgICovCiAgLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7CiAgLy8gICAgY29uc3QgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDsKICAvLyAgICBsZXQgaW5pdCA9IDA7CiAgLy8KICAvLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3VycikgewogIC8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUCiAgLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy4KICAvLyAgICAgICAqLwogIC8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyOwogIC8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVCkKICAvLyAgICAgICAgaW5pdCA9IFdJTl9JTklUOwogIC8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpOwogIC8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0OwogIC8vICAgIH0KICAvLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHsKICAvLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGEKICAvLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwCiAgLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy4KICAvLyAgICAgICAqLwogIC8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjsKICAvLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKQogIC8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyOwogIC8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpOwogIC8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0OwogIC8vICAgIH0KICAvLyAgfQogIC8vCiAgLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCwKICAvLyAgICAibm90IGVub3VnaCByb29tIGZvciBzZWFyY2giKTsKICB9OwoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybgogICAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLgogICAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlCiAgICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQKICAgKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uCiAgICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbQogICAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi4KICAgKi8KICBjb25zdCBkZWZsYXRlX3N0b3JlZCA9IChzLCBmbHVzaCkgPT4gewoKICAgIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkCiAgICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjoKICAgICAqLwogICAgbGV0IG1heF9ibG9ja19zaXplID0gMHhmZmZmOwoKICAgIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHsKICAgICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1OwogICAgfQoKICAgIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi8KICAgIGZvciAoOzspIHsKICAgICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovCiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7CgogICAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8CiAgICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgInNsaWRlIHRvbyBsYXRlIik7CiAgLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fAogIC8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkgewogIC8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKCJzbGlkZSB0b28gbGF0ZSIpOwogIC8vICAgICAgfQoKICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gkMikgewogICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICB9CgogICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovCiAgICAgIH0KICAgICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsICJibG9jayBnb25lIik7CiAgLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoImJsb2NrIGdvbmUiKTsKCiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7CiAgICAgIHMubG9va2FoZWFkID0gMDsKCiAgICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqLwogICAgICBjb25zdCBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7CgogICAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkgewogICAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovCiAgICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0OwogICAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7CiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqLwogICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgIH0KICAgICAgICAvKioqLwoKCiAgICAgIH0KICAgICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lCiAgICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6CiAgICAgICAqLwogICAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHsKICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovCiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgfQogICAgICAgIC8qKiovCiAgICAgIH0KICAgIH0KCiAgICBzLmluc2VydCA9IDA7CgogICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQzKSB7CiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi8KICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgIH0KICAgICAgLyoqKi8KICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgfQoKICAgIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkgewogICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovCiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgIH0KICAgICAgLyoqKi8KICAgIH0KCiAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogIH07CgogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnQKICAgKiBibG9jayBzdGF0ZS4KICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHMKICAgKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnQKICAgKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuCiAgICovCiAgY29uc3QgZGVmbGF0ZV9mYXN0ID0gKHMsIGZsdXNoKSA9PiB7CgogICAgbGV0IGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi8KICAgIGxldCBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi8KCiAgICBmb3IgKDs7KSB7CiAgICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdAogICAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlcwogICAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGUKICAgICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC4KICAgICAgICovCiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHsKICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIJDIpIHsKICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovCiAgICAgICAgfQogICAgICB9CgogICAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlCiAgICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOgogICAgICAgKi8KICAgICAgaGFzaF9oZWFkID0gMC8qTklMKi87CiAgICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqLwogICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7CiAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAvKioqLwogICAgICB9CgogICAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLgogICAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSAogICAgICAgKi8KICAgICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHsKICAgICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZwogICAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaAogICAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS4KICAgICAgICAgKi8KICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTsKICAgICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqLwogICAgICB9CiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5CgogICAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsCiAgICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi8KICAgICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTsKCiAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7CgogICAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGgKICAgICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLgogICAgICAgICAqLwogICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi8KICAgICAgICAgIGRvIHsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqLwogICAgICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pOwogICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgICAgLyoqKi8KICAgICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZQogICAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLgogICAgICAgICAgICAgKi8KICAgICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApOwogICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgIH0gZWxzZQogICAgICAgIHsKICAgICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07CiAgICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi8KICAgICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSk7CgogIC8vI2lmIE1JTl9NQVRDSCAhPSAzCiAgLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXMKICAvLyNlbmRpZgogICAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3QKICAgICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuCiAgICAgICAgICAgKi8KICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqLwogICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCIlYyIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7CiAgICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovCiAgICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTsKCiAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgIH0KICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi8KICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICB9CiAgICAgICAgLyoqKi8KICAgICAgfQogICAgfQogICAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpOwogICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQzKSB7CiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi8KICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgIH0KICAgICAgLyoqKi8KICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgfQogICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqLwogICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICB9CiAgICAgIC8qKiovCiAgICB9CiAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICB9OwoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5CiAgICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpcwogICAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uCiAgICovCiAgY29uc3QgZGVmbGF0ZV9zbG93ID0gKHMsIGZsdXNoKSA9PiB7CgogICAgbGV0IGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovCiAgICBsZXQgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovCgogICAgbGV0IG1heF9pbnNlcnQ7CgogICAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovCiAgICBmb3IgKDs7KSB7CiAgICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdAogICAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlcwogICAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGUKICAgICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC4KICAgICAgICovCiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHsKICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIJDIpIHsKICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqLwogICAgICB9CgogICAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlCiAgICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOgogICAgICAgKi8KICAgICAgaGFzaF9oZWFkID0gMC8qTklMKi87CiAgICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqLwogICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7CiAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAvKioqLwogICAgICB9CgogICAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLgogICAgICAgKi8KICAgICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoOwogICAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0OwogICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CgogICAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJgogICAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykgewogICAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nCiAgICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoCiAgICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLgogICAgICAgICAqLwogICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpOwogICAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovCgogICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmCiAgICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkgewoKICAgICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2UKICAgICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuCiAgICAgICAgICAgKi8KICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICB9CiAgICAgIH0KICAgICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50CiAgICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6CiAgICAgICAqLwogICAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkgewogICAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7CiAgICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovCgogICAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpOwoKICAgICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsCiAgICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovCiAgICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC4KICAgICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90CiAgICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpbgogICAgICAgICAqIHRoZSBoYXNoIHRhYmxlLgogICAgICAgICAqLwogICAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxOwogICAgICAgIHMucHJldl9sZW5ndGggLT0gMjsKICAgICAgICBkbyB7CiAgICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHsKICAgICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi8KICAgICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTsKICAgICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICAgIC8qKiovCiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTsKICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgIHMuc3Ryc3RhcnQrKzsKCiAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqLwogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgICAgLyoqKi8KICAgICAgICB9CgogICAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7CiAgICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGEKICAgICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoCiAgICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC4KICAgICAgICAgKi8KICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwiJWMiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTsKICAgICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqLwogICAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pOwoKICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqLwogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAvKioqLwogICAgICAgIH0KICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvcgogICAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLgogICAgICAgICAqLwogICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTsKICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgfQogICAgfQogICAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsICJubyBmbHVzaD8iKTsKICAgIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkgewogICAgICAvL1RyYWNldnYoKHN0ZGVyciwiJWMiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTsKICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi8KICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7CgogICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICB9CiAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7CiAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHsKICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqLwogICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgfQogICAgICAvKioqLwogICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICB9CiAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovCiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgIH0KICAgICAgLyoqKi8KICAgIH0KCiAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICB9OwoKCiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlCiAgICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mCiAgICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKQogICAqLwogIGNvbnN0IGRlZmxhdGVfcmxlID0gKHMsIGZsdXNoKSA9PiB7CgogICAgbGV0IGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi8KICAgIGxldCBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi8KICAgIGxldCBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqLwoKICAgIGNvbnN0IF93aW4gPSBzLndpbmRvdzsKCiAgICBmb3IgKDs7KSB7CiAgICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdAogICAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlcwogICAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuCiAgICAgICAqLwogICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7CiAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCQyKSB7CiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgIH0KICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi8KICAgICAgfQoKICAgICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi8KICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7CiAgICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxOwogICAgICAgIHByZXYgPSBfd2luW3NjYW5dOwogICAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkgewogICAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovCiAgICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmCiAgICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmCiAgICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmCiAgICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmCiAgICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTsKICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pOwogICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCAid2lsZCBzY2FuIik7CiAgICAgIH0KCiAgICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi8KICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkgewogICAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTsKCiAgICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqLwogICAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7CgogICAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICB9IGVsc2UgewogICAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi8KICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwiJWMiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7CiAgICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovCiAgICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTsKCiAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgIH0KICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi8KICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICB9CiAgICAgICAgLyoqKi8KICAgICAgfQogICAgfQogICAgcy5pbnNlcnQgPSAwOwogICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQzKSB7CiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi8KICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgIH0KICAgICAgLyoqKi8KICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgfQogICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqLwogICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICB9CiAgICAgIC8qKiovCiAgICB9CiAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICB9OwoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4KICAgKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLikKICAgKi8KICBjb25zdCBkZWZsYXRlX2h1ZmYgPSAocywgZmx1c2gpID0+IHsKCiAgICBsZXQgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi8KCiAgICBmb3IgKDs7KSB7CiAgICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqLwogICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCQyKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqLwogICAgICAgIH0KICAgICAgfQoKICAgICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovCiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIiVjIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpOwogICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi8KICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTsKICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgcy5zdHJzdGFydCsrOwogICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqLwogICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgIH0KICAgICAgICAvKioqLwogICAgICB9CiAgICB9CiAgICBzLmluc2VydCA9IDA7CiAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHsKICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqLwogICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgfQogICAgICAvKioqLwogICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICB9CiAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovCiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgIH0KICAgICAgLyoqKi8KICAgIH0KICAgIHJldHVybiBCU19CTE9DS19ET05FOwogIH07CgogIC8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvbgogICAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0bwogICAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZQogICAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy4KICAgKi8KICBmdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7CgogICAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoOwogICAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5OwogICAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoOwogICAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47CiAgICB0aGlzLmZ1bmMgPSBmdW5jOwogIH0KCiAgY29uc3QgY29uZmlndXJhdGlvbl90YWJsZSA9IFsKICAgIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi8KICAgIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi8KICAgIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovCiAgICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqLwogICAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi8KCiAgICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi8KICAgIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovCiAgICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqLwogICAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi8KICAgIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovCiAgICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi8KICBdOwoKCiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICogSW5pdGlhbGl6ZSB0aGUgImxvbmdlc3QgbWF0Y2giIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbQogICAqLwogIGNvbnN0IGxtX2luaXQgPSAocykgPT4gewoKICAgIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7CgogICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovCiAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7CgogICAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczoKICAgICAqLwogICAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7CiAgICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoOwogICAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDsKICAgIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluOwoKICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICBzLmxvb2thaGVhZCA9IDA7CiAgICBzLmluc2VydCA9IDA7CiAgICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgcy5pbnNfaCA9IDA7CiAgfTsKCgogIGZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHsKICAgIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi8KICAgIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovCiAgICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqLwogICAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi8KICAgIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqLwogICAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqLwogICAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi8KICAgIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqLwogICAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovCiAgICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQkMjsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi8KICAgIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi8KCiAgICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi8KICAgIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqLwogICAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqLwoKICAgIHRoaXMud2luZG93ID0gbnVsbDsKICAgIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LAogICAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemUKICAgICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2YKICAgICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5cwogICAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuCiAgICAgKi8KCiAgICB0aGlzLndpbmRvd19zaXplID0gMDsKICAgIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyCiAgICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LgogICAgICovCgogICAgdGhpcy5wcmV2ID0gbnVsbDsKICAgIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzCiAgICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLgogICAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuCiAgICAgKi8KCiAgICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovCgogICAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovCiAgICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi8KICAgIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi8KICAgIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqLwoKICAgIHRoaXMuaGFzaF9zaGlmdCA9IDA7CiAgICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dAogICAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0CiAgICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczoKICAgICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHMKICAgICAqLwoKICAgIHRoaXMuYmxvY2tfc3RhcnQgPSAwOwogICAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzCiAgICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLgogICAgICovCgogICAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovCiAgICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi8KICAgIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovCiAgICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqLwogICAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqLwogICAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi8KCiAgICB0aGlzLnByZXZfbGVuZ3RoID0gMDsKICAgIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpcwogICAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uCiAgICAgKi8KCiAgICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwOwogICAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXMKICAgICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGUKICAgICAqIHNwZWVkLgogICAgICovCgogICAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7CiAgICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5CiAgICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbgogICAgICogbGV2ZWxzID49IDQuCiAgICAgKi8KICAgIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5CiAgICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwOwogICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QKICAgICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi4KICAgICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuCiAgICAgKi8KCiAgICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqLwogICAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovCgogICAgdGhpcy5nb29kX21hdGNoID0gMDsKICAgIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqLwoKICAgIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi8KCiAgICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovCgogICAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqLwoKICAgIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi8KICAgIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqLwogICAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovCgogICAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSwKICAgIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmUKICAgIHRoaXMuZHluX2x0cmVlICA9IG5ldyBVaW50MTZBcnJheShIRUFQX1NJWkUgKiAyKTsKICAgIHRoaXMuZHluX2R0cmVlICA9IG5ldyBVaW50MTZBcnJheSgoMiAqIERfQ09ERVMgKyAxKSAqIDIpOwogICAgdGhpcy5ibF90cmVlICAgID0gbmV3IFVpbnQxNkFycmF5KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpOwogICAgemVybyh0aGlzLmR5bl9sdHJlZSk7CiAgICB6ZXJvKHRoaXMuZHluX2R0cmVlKTsKICAgIHplcm8odGhpcy5ibF90cmVlKTsKCiAgICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovCiAgICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqLwogICAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqLwoKICAgIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdOwogICAgdGhpcy5ibF9jb3VudCA9IG5ldyBVaW50MTZBcnJheShNQVhfQklUUyArIDEpOwogICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovCgogICAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovCiAgICB0aGlzLmhlYXAgPSBuZXcgVWludDE2QXJyYXkoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqLwogICAgemVybyh0aGlzLmhlYXApOwoKICAgIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqLwogICAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqLwogICAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC4KICAgICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuCiAgICAgKi8KCiAgICB0aGlzLmRlcHRoID0gbmV3IFVpbnQxNkFycmF5KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTsKICAgIHplcm8odGhpcy5kZXB0aCk7CiAgICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5CiAgICAgKi8KCiAgICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovCgogICAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7CiAgICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yCiAgICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6CiAgICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzCiAgICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0CiAgICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW4KICAgICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvcgogICAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKQogICAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuCiAgICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLgogICAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLgogICAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdAogICAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3IKICAgICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnkKICAgICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZQogICAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZwogICAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS4KICAgICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDQKICAgICAqLwoKICAgIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi8KCiAgICB0aGlzLmRfYnVmID0gMDsKICAgIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmUKICAgICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnCiAgICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuCiAgICAgKi8KCiAgICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovCiAgICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi8KICAgIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovCiAgICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovCgoKICAgIHRoaXMuYmlfYnVmID0gMDsKICAgIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0CiAgICAgKiBzaWduaWZpY2FudCBiaXRzKS4KICAgICAqLwogICAgdGhpcy5iaV92YWxpZCA9IDA7CiAgICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXQKICAgICAqIGFyZSBhbHdheXMgemVyby4KICAgICAqLwoKICAgIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXMKICAgIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuCiAgICAvL3RoaXMuaGlnaF93YXRlciA9IDA7CiAgICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmUKICAgICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuCiAgICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlbgogICAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay4KICAgICAqLwogIH0KCgogIGNvbnN0IGRlZmxhdGVSZXNldEtlZXAgPSAoc3RybSkgPT4gewoKICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SJDIpOwogICAgfQoKICAgIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7CiAgICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjsKCiAgICBjb25zdCBzID0gc3RybS5zdGF0ZTsKICAgIHMucGVuZGluZyA9IDA7CiAgICBzLnBlbmRpbmdfb3V0ID0gMDsKCiAgICBpZiAocy53cmFwIDwgMCkgewogICAgICBzLndyYXAgPSAtcy53cmFwOwogICAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqLwogICAgfQogICAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpOwogICAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID8KICAgICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKQogICAgOgogICAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMCkKICAgIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0gkMjsKICAgIF90cl9pbml0KHMpOwogICAgcmV0dXJuIFpfT0skMzsKICB9OwoKCiAgY29uc3QgZGVmbGF0ZVJlc2V0ID0gKHN0cm0pID0+IHsKCiAgICBjb25zdCByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pOwogICAgaWYgKHJldCA9PT0gWl9PSyQzKSB7CiAgICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7CiAgICB9CiAgICByZXR1cm4gcmV0OwogIH07CgoKICBjb25zdCBkZWZsYXRlU2V0SGVhZGVyID0gKHN0cm0sIGhlYWQpID0+IHsKCiAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7IH0KICAgIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7IH0KICAgIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDsKICAgIHJldHVybiBaX09LJDM7CiAgfTsKCgogIGNvbnN0IGRlZmxhdGVJbml0MiA9IChzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpID0+IHsKCiAgICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTAogICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjsKICAgIH0KICAgIGxldCB3cmFwID0gMTsKCiAgICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTiQxKSB7CiAgICAgIGxldmVsID0gNjsKICAgIH0KCiAgICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovCiAgICAgIHdyYXAgPSAwOwogICAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7CiAgICB9CgogICAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7CiAgICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi8KICAgICAgd2luZG93Qml0cyAtPSAxNjsKICAgIH0KCgogICAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEJDIgfHwKICAgICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHwKICAgICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkgewogICAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SJDIpOwogICAgfQoKCiAgICBpZiAod2luZG93Qml0cyA9PT0gOCkgewogICAgICB3aW5kb3dCaXRzID0gOTsKICAgIH0KICAgIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi8KCiAgICBjb25zdCBzID0gbmV3IERlZmxhdGVTdGF0ZSgpOwoKICAgIHN0cm0uc3RhdGUgPSBzOwogICAgcy5zdHJtID0gc3RybTsKCiAgICBzLndyYXAgPSB3cmFwOwogICAgcy5nemhlYWQgPSBudWxsOwogICAgcy53X2JpdHMgPSB3aW5kb3dCaXRzOwogICAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzOwogICAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7CgogICAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7CiAgICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7CiAgICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTsKICAgIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTsKCiAgICBzLndpbmRvdyA9IG5ldyBVaW50OEFycmF5KHMud19zaXplICogMik7CiAgICBzLmhlYWQgPSBuZXcgVWludDE2QXJyYXkocy5oYXNoX3NpemUpOwogICAgcy5wcmV2ID0gbmV3IFVpbnQxNkFycmF5KHMud19zaXplKTsKCiAgICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy4KICAgIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovCgogICAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovCgogICAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7CgogICAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTsKICAgIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5OwogICAgcy5wZW5kaW5nX2J1ZiA9IG5ldyBVaW50OEFycmF5KHMucGVuZGluZ19idWZfc2l6ZSk7CgogICAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApCiAgICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpOwogICAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplOwoKICAgIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTsKICAgIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTsKCiAgICBzLmxldmVsID0gbGV2ZWw7CiAgICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7CiAgICBzLm1ldGhvZCA9IG1ldGhvZDsKCiAgICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pOwogIH07CgogIGNvbnN0IGRlZmxhdGVJbml0ID0gKHN0cm0sIGxldmVsKSA9PiB7CgogICAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCQyLCBNQVhfV0JJVFMkMSwgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZJDEpOwogIH07CgoKICBjb25zdCBkZWZsYXRlJDIgPSAoc3RybSwgZmx1c2gpID0+IHsKCiAgICBsZXQgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5CgogICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8CiAgICAgIGZsdXNoID4gWl9CTE9DSyQxIHx8IGZsdXNoIDwgMCkgewogICAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUiQyKSA6IFpfU1RSRUFNX0VSUk9SJDI7CiAgICB9CgogICAgY29uc3QgcyA9IHN0cm0uc3RhdGU7CgogICAgaWYgKCFzdHJtLm91dHB1dCB8fAogICAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fAogICAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCQzKSkgewogICAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiQxIDogWl9TVFJFQU1fRVJST1IkMik7CiAgICB9CgogICAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovCiAgICBjb25zdCBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7CiAgICBzLmxhc3RfZmx1c2ggPSBmbHVzaDsKCiAgICAvKiBXcml0ZSB0aGUgaGVhZGVyICovCiAgICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHsKCiAgICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXIKICAgICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7CiAgICAgICAgcHV0X2J5dGUocywgMzEpOwogICAgICAgIHB1dF9ieXRlKHMsIDEzOSk7CiAgICAgICAgcHV0X2J5dGUocywgOCk7CiAgICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMCiAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgIHB1dF9ieXRlKHMsIDApOwogICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgIHB1dF9ieXRlKHMsIDApOwogICAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOgogICAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgPwogICAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTsKICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArCiAgICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArCiAgICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICsKICAgICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArCiAgICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpCiAgICAgICAgICApOwogICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpOwogICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTsKICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpOwogICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6CiAgICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/CiAgICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7CiAgICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpOwogICAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYykgewogICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApOwogICAgICAgICAgfQogICAgICAgICAgcy5nemluZGV4ID0gMDsKICAgICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7CiAgICAgICAgfQogICAgICB9CiAgICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXIKICAgICAgewogICAgICAgIGxldCBoZWFkZXIgPSAoWl9ERUZMQVRFRCQyICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4OwogICAgICAgIGxldCBsZXZlbF9mbGFncyA9IC0xOwoKICAgICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikgewogICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwOwogICAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHsKICAgICAgICAgIGxldmVsX2ZsYWdzID0gMTsKICAgICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHsKICAgICAgICAgIGxldmVsX2ZsYWdzID0gMjsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzOwogICAgICAgIH0KICAgICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpOwogICAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfQogICAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7CgogICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpOwoKICAgICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi8KICAgICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgewogICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpOwogICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7CiAgICAgICAgfQogICAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApOwogICAgICB9CiAgICB9CgogIC8vI2lmZGVmIEdaSVAKICAgIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHsKICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHsKICAgICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovCgogICAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkgewogICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7CiAgICAgICAgICBzLmd6aW5kZXgrKzsKICAgICAgICB9CiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgfQogICAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkgewogICAgICAgICAgcy5nemluZGV4ID0gMDsKICAgICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZWxzZSB7CiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFOwogICAgICB9CiAgICB9CiAgICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHsKICAgICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykgewogICAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi8KICAgICAgICAvL2ludCB2YWw7CgogICAgICAgIGRvIHsKICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICB2YWwgPSAxOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZwogICAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7CiAgICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFsID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7CiAgICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTsKCiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgfQogICAgICAgIGlmICh2YWwgPT09IDApIHsKICAgICAgICAgIHMuZ3ppbmRleCA9IDA7CiAgICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7CiAgICAgICAgfQogICAgICB9CiAgICAgIGVsc2UgewogICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTsKICAgICAgfQogICAgfQogICAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7CiAgICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHsKICAgICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovCiAgICAgICAgLy9pbnQgdmFsOwoKICAgICAgICBkbyB7CiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgdmFsID0gMTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmcKICAgICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkgewogICAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhbCA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICBwdXRfYnl0ZShzLCB2YWwpOwogICAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7CgogICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgIH0KICAgICAgICBpZiAodmFsID09PSAwKSB7CiAgICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7CiAgICAgICAgfQogICAgICB9CiAgICAgIGVsc2UgewogICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTsKICAgICAgfQogICAgfQogICAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7CiAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7CiAgICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgfQogICAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpOwogICAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTsKICAgICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApOwogICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgIH0KICAgICAgfQogICAgICBlbHNlIHsKICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgIH0KICAgIH0KICAvLyNlbmRpZgoKICAgIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi8KICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHsKICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aAogICAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kCiAgICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sCiAgICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2UKICAgICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6CiAgICAgICAgICovCiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgcmV0dXJuIFpfT0skMzsKICAgICAgfQoKICAgICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlCiAgICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwCiAgICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi4KICAgICAgICovCiAgICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmCiAgICAgIGZsdXNoICE9PSBaX0ZJTklTSCQzKSB7CiAgICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IkMSk7CiAgICB9CgogICAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi8KICAgIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHsKICAgICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUiQxKTsKICAgIH0KCiAgICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuCiAgICAgKi8KICAgIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8CiAgICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCQyICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7CiAgICAgIGxldCBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6CiAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDoKICAgICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpOwoKICAgICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkgewogICAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFOwogICAgICB9CiAgICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7CiAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqLwogICAgICAgIH0KICAgICAgICByZXR1cm4gWl9PSyQzOwogICAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGwKICAgICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZQogICAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhbgogICAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvCiAgICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0CiAgICAgICAgICogb25lIGVtcHR5IGJsb2NrLgogICAgICAgICAqLwogICAgICB9CiAgICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkgewogICAgICAgICAgX3RyX2FsaWduKHMpOwogICAgICAgIH0KICAgICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSyQxKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqLwoKICAgICAgICAgIF90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpOwogICAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWQKICAgICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuCiAgICAgICAgICAgKi8KICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIJDEpIHsKICAgICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovCiAgICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTsKCiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqLwogICAgICAgICAgcmV0dXJuIFpfT0skMzsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsICJidWcyIik7CiAgICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcigiYnVnMiIpO30KCiAgICBpZiAoZmx1c2ggIT09IFpfRklOSVNIJDMpIHsgcmV0dXJuIFpfT0skMzsgfQogICAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQkMzsgfQoKICAgIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovCiAgICBpZiAocy53cmFwID09PSAyKSB7CiAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTsKICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTsKICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7CiAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpOwogICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7CiAgICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7CiAgICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpOwogICAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTsKICAgIH0KICAgIGVsc2UKICAgIHsKICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpOwogICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTsKICAgIH0KCiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpbgogICAgICogdG8gZmx1c2ggdGhlIHJlc3QuCiAgICAgKi8KICAgIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH0KICAgIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi8KICAgIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LJDMgOiBaX1NUUkVBTV9FTkQkMzsKICB9OwoKCiAgY29uc3QgZGVmbGF0ZUVuZCA9IChzdHJtKSA9PiB7CgogICAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHsKICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7CiAgICB9CgogICAgY29uc3Qgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7CiAgICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmCiAgICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiYKICAgICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmCiAgICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJgogICAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiYKICAgICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmCiAgICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFCiAgICApIHsKICAgICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUiQyKTsKICAgIH0KCiAgICBzdHJtLnN0YXRlID0gbnVsbDsKCiAgICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUiQyKSA6IFpfT0skMzsKICB9OwoKCiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGUKICAgKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuCiAgICovCiAgY29uc3QgZGVmbGF0ZVNldERpY3Rpb25hcnkgPSAoc3RybSwgZGljdGlvbmFyeSkgPT4gewoKICAgIGxldCBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7CgogICAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHsKICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7CiAgICB9CgogICAgY29uc3QgcyA9IHN0cm0uc3RhdGU7CiAgICBjb25zdCB3cmFwID0gcy53cmFwOwoKICAgIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkgewogICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjsKICAgIH0KCiAgICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi8KICAgIGlmICh3cmFwID09PSAxKSB7CiAgICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqLwogICAgICBzdHJtLmFkbGVyID0gYWRsZXIzMl8xKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApOwogICAgfQoKICAgIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovCgogICAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovCiAgICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkgewogICAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovCiAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovCiAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApOwogICAgICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgfQogICAgICAvKiB1c2UgdGhlIHRhaWwgKi8KICAgICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTsKICAgICAgbGV0IHRtcERpY3QgPSBuZXcgVWludDhBcnJheShzLndfc2l6ZSk7CiAgICAgIHRtcERpY3Quc2V0KGRpY3Rpb25hcnkuc3ViYXJyYXkoZGljdExlbmd0aCAtIHMud19zaXplLCBkaWN0TGVuZ3RoKSwgMCk7CiAgICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0OwogICAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7CiAgICB9CiAgICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqLwogICAgY29uc3QgYXZhaWwgPSBzdHJtLmF2YWlsX2luOwogICAgY29uc3QgbmV4dCA9IHN0cm0ubmV4dF9pbjsKICAgIGNvbnN0IGlucHV0ID0gc3RybS5pbnB1dDsKICAgIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoOwogICAgc3RybS5uZXh0X2luID0gMDsKICAgIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5OwogICAgZmlsbF93aW5kb3cocyk7CiAgICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgIGxldCBzdHIgPSBzLnN0cnN0YXJ0OwogICAgICBsZXQgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpOwogICAgICBkbyB7CiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqLwogICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKTsKCiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKCiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyOwogICAgICAgIHN0cisrOwogICAgICB9IHdoaWxlICgtLW4pOwogICAgICBzLnN0cnN0YXJ0ID0gc3RyOwogICAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgIGZpbGxfd2luZG93KHMpOwogICAgfQogICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDsKICAgIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0OwogICAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDsKICAgIHMubG9va2FoZWFkID0gMDsKICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgc3RybS5pbnB1dCA9IGlucHV0OwogICAgc3RybS5hdmFpbF9pbiA9IGF2YWlsOwogICAgcy53cmFwID0gd3JhcDsKICAgIHJldHVybiBaX09LJDM7CiAgfTsKCgogIHZhciBkZWZsYXRlSW5pdF8xID0gZGVmbGF0ZUluaXQ7CiAgdmFyIGRlZmxhdGVJbml0Ml8xID0gZGVmbGF0ZUluaXQyOwogIHZhciBkZWZsYXRlUmVzZXRfMSA9IGRlZmxhdGVSZXNldDsKICB2YXIgZGVmbGF0ZVJlc2V0S2VlcF8xID0gZGVmbGF0ZVJlc2V0S2VlcDsKICB2YXIgZGVmbGF0ZVNldEhlYWRlcl8xID0gZGVmbGF0ZVNldEhlYWRlcjsKICB2YXIgZGVmbGF0ZV8yJDEgPSBkZWZsYXRlJDI7CiAgdmFyIGRlZmxhdGVFbmRfMSA9IGRlZmxhdGVFbmQ7CiAgdmFyIGRlZmxhdGVTZXREaWN0aW9uYXJ5XzEgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTsKICB2YXIgZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7CgogIC8qIE5vdCBpbXBsZW1lbnRlZAogIG1vZHVsZS5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDsKICBtb2R1bGUuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5OwogIG1vZHVsZS5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zOwogIG1vZHVsZS5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7CiAgbW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lOwogIG1vZHVsZS5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7CiAgKi8KCiAgdmFyIGRlZmxhdGVfMSQyID0gewogIAlkZWZsYXRlSW5pdDogZGVmbGF0ZUluaXRfMSwKICAJZGVmbGF0ZUluaXQyOiBkZWZsYXRlSW5pdDJfMSwKICAJZGVmbGF0ZVJlc2V0OiBkZWZsYXRlUmVzZXRfMSwKICAJZGVmbGF0ZVJlc2V0S2VlcDogZGVmbGF0ZVJlc2V0S2VlcF8xLAogIAlkZWZsYXRlU2V0SGVhZGVyOiBkZWZsYXRlU2V0SGVhZGVyXzEsCiAgCWRlZmxhdGU6IGRlZmxhdGVfMiQxLAogIAlkZWZsYXRlRW5kOiBkZWZsYXRlRW5kXzEsCiAgCWRlZmxhdGVTZXREaWN0aW9uYXJ5OiBkZWZsYXRlU2V0RGljdGlvbmFyeV8xLAogIAlkZWZsYXRlSW5mbzogZGVmbGF0ZUluZm8KICB9OwoKICBjb25zdCBfaGFzID0gKG9iaiwga2V5KSA9PiB7CiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTsKICB9OwoKICB2YXIgYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7CiAgICBjb25zdCBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkgewogICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7CiAgICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9CgogICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG5vbi1vYmplY3QnKTsKICAgICAgfQoKICAgICAgZm9yIChjb25zdCBwIGluIHNvdXJjZSkgewogICAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHsKICAgICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gb2JqOwogIH07CgoKICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuCiAgdmFyIGZsYXR0ZW5DaHVua3MgPSAoY2h1bmtzKSA9PiB7CiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGgKICAgIGxldCBsZW4gPSAwOwoKICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDsKICAgIH0KCiAgICAvLyBqb2luIGNodW5rcwogICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTsKCiAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgbGV0IGNodW5rID0gY2h1bmtzW2ldOwogICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpOwogICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoOwogICAgfQoKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKCiAgdmFyIGNvbW1vbiA9IHsKICAJYXNzaWduOiBhc3NpZ24sCiAgCWZsYXR0ZW5DaHVua3M6IGZsYXR0ZW5DaHVua3MKICB9OwoKICAvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzCgoKICAvLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uCiAgLy8KICAvLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMgogIC8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmkKICAvLwogIGxldCBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTsKCiAgdHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfQoKCiAgLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSkKICAvLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUywKICAvLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmYKICBjb25zdCBfdXRmOGxlbiA9IG5ldyBVaW50OEFycmF5KDI1Nik7CiAgZm9yIChsZXQgcSA9IDA7IHEgPCAyNTY7IHErKykgewogICAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7CiAgfQogIF91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydAoKCiAgLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKQogIHZhciBzdHJpbmcyYnVmID0gKHN0cikgPT4gewogICAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyAmJiBUZXh0RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlKSB7CiAgICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTsKICAgIH0KCiAgICBsZXQgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDsKCiAgICAvLyBjb3VudCBiaW5hcnkgc2l6ZQogICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykgewogICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpOwogICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7CiAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpOwogICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHsKICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApOwogICAgICAgICAgbV9wb3MrKzsKICAgICAgICB9CiAgICAgIH0KICAgICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDsKICAgIH0KCiAgICAvLyBhbGxvY2F0ZSBidWZmZXIKICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1Zl9sZW4pOwoKICAgIC8vIGNvbnZlcnQKICAgIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHsKICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTsKICAgICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkgewogICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTsKICAgICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7CiAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTsKICAgICAgICAgIG1fcG9zKys7CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChjIDwgMHg4MCkgewogICAgICAgIC8qIG9uZSBieXRlICovCiAgICAgICAgYnVmW2krK10gPSBjOwogICAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkgewogICAgICAgIC8qIHR3byBieXRlcyAqLwogICAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTsKICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpOwogICAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7CiAgICAgICAgLyogdGhyZWUgYnl0ZXMgKi8KICAgICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpOwogICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7CiAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvKiBmb3VyIGJ5dGVzICovCiAgICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTsKICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTsKICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpOwogICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gYnVmOwogIH07CgogIC8vIEhlbHBlcgogIGNvbnN0IGJ1ZjJiaW5zdHJpbmcgPSAoYnVmLCBsZW4pID0+IHsKICAgIC8vIE9uIENocm9tZSwgdGhlIGFyZ3VtZW50cyBpbiBhIGZ1bmN0aW9uIGNhbGwgdGhhdCBhcmUgYWxsb3dlZCBpcyBgNjU1MzRgLgogICAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiB0aGF0LCB3ZSBjYW4gdXNlIHRoaXMgb3B0aW1pemF0aW9uLAogICAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgdGFrZSBhIHNsb3dlciBwYXRoLgogICAgaWYgKGxlbiA8IDY1NTM0KSB7CiAgICAgIGlmIChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgewogICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1Zi5sZW5ndGggPT09IGxlbiA/IGJ1ZiA6IGJ1Zi5zdWJhcnJheSgwLCBsZW4pKTsKICAgICAgfQogICAgfQoKICAgIGxldCByZXN1bHQgPSAnJzsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfTsKCgogIC8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nCiAgdmFyIGJ1ZjJzdHJpbmcgPSAoYnVmLCBtYXgpID0+IHsKICAgIGNvbnN0IGxlbiA9IG1heCB8fCBidWYubGVuZ3RoOwoKICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgPT09ICdmdW5jdGlvbicgJiYgVGV4dERlY29kZXIucHJvdG90eXBlLmRlY29kZSkgewogICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1Zi5zdWJhcnJheSgwLCBtYXgpKTsKICAgIH0KCiAgICBsZXQgaSwgb3V0OwoKICAgIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcikKICAgIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvcgogICAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS4KICAgIGNvbnN0IHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpOwoKICAgIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47KSB7CiAgICAgIGxldCBjID0gYnVmW2krK107CiAgICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWkKICAgICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9CgogICAgICBsZXQgY19sZW4gPSBfdXRmOGxlbltjXTsKICAgICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzCiAgICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH0KCiAgICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZQogICAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7CiAgICAgIC8vIGpvaW4gdGhlIHJlc3QKICAgICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7CiAgICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7CiAgICAgICAgY19sZW4tLTsKICAgICAgfQoKICAgICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nPwogICAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH0KCiAgICAgIGlmIChjIDwgMHgxMDAwMCkgewogICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYyAtPSAweDEwMDAwOwogICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7CiAgICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTsKICB9OwoKCiAgLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlciwKICAvLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlCiAgLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy4KICAvLwogIC8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheQogIC8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpOwogIHZhciB1dGY4Ym9yZGVyID0gKGJ1ZiwgbWF4KSA9PiB7CgogICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7CiAgICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9CgogICAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kCiAgICBsZXQgcG9zID0gbWF4IC0gMTsKICAgIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfQoKICAgIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSwKICAgIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LgogICAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfQoKICAgIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLAogICAgLy8gcmV0dXJuIG1heCB0b28uCiAgICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH0KCiAgICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7CiAgfTsKCiAgdmFyIHN0cmluZ3MgPSB7CiAgCXN0cmluZzJidWY6IHN0cmluZzJidWYsCiAgCWJ1ZjJzdHJpbmc6IGJ1ZjJzdHJpbmcsCiAgCXV0Zjhib3JkZXI6IHV0Zjhib3JkZXIKICB9OwoKICAvLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXIKICAvLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpbgogIC8vCiAgLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQKICAvLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMKICAvLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLgogIC8vCiAgLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsCiAgLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdAogIC8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczoKICAvLwogIC8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90CiAgLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZQogIC8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlCiAgLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLgogIC8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlCiAgLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuCiAgLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4KCiAgZnVuY3Rpb24gWlN0cmVhbSgpIHsKICAgIC8qIG5leHQgaW5wdXQgYnl0ZSAqLwogICAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnMKICAgIHRoaXMubmV4dF9pbiA9IDA7CiAgICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovCiAgICB0aGlzLmF2YWlsX2luID0gMDsKICAgIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqLwogICAgdGhpcy50b3RhbF9pbiA9IDA7CiAgICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi8KICAgIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVycwogICAgdGhpcy5uZXh0X291dCA9IDA7CiAgICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi8KICAgIHRoaXMuYXZhaWxfb3V0ID0gMDsKICAgIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovCiAgICB0aGlzLnRvdGFsX291dCA9IDA7CiAgICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi8KICAgIHRoaXMubXNnID0gJycvKlpfTlVMTCovOwogICAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovCiAgICB0aGlzLnN0YXRlID0gbnVsbDsKICAgIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi8KICAgIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87CiAgICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqLwogICAgdGhpcy5hZGxlciA9IDA7CiAgfQoKICB2YXIgenN0cmVhbSA9IFpTdHJlYW07CgogIGNvbnN0IHRvU3RyaW5nJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nOwoKICAvKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qLwogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovCgogIGNvbnN0IHsKICAgIFpfTk9fRkxVU0g6IFpfTk9fRkxVU0gkMSwgWl9TWU5DX0ZMVVNILCBaX0ZVTExfRkxVU0gsIFpfRklOSVNIOiBaX0ZJTklTSCQyLAogICAgWl9PSzogWl9PSyQyLCBaX1NUUkVBTV9FTkQ6IFpfU1RSRUFNX0VORCQyLAogICAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OLAogICAgWl9ERUZBVUxUX1NUUkFURUdZLAogICAgWl9ERUZMQVRFRDogWl9ERUZMQVRFRCQxCiAgfSA9IGNvbnN0YW50cyQyOwoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qLwoKCiAgLyoqCiAgICogY2xhc3MgRGVmbGF0ZQogICAqCiAgICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZAogICAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSwKICAgKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uCiAgICoqLwoKICAvKiBpbnRlcm5hbAogICAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5CiAgICoKICAgKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbRGVmbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi4KICAgKiovCgogIC8qKgogICAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXkKICAgKgogICAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV0KICAgKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rCiAgICogKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pLgogICAqKi8KCiAgLyoqCiAgICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyCiAgICoKICAgKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuCiAgICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzCiAgICogYXJlIHBvc3NpYmxlIG9ubHkgb24gd3Jvbmcgb3B0aW9ucyBvciBiYWQgYG9uRGF0YWAgLyBgb25FbmRgCiAgICogY3VzdG9tIGhhbmRsZXJzLgogICAqKi8KCiAgLyoqCiAgICogRGVmbGF0ZS5tc2cgLT4gU3RyaW5nCiAgICoKICAgKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMAogICAqKi8KCgogIC8qKgogICAqIG5ldyBEZWZsYXRlKG9wdGlvbnMpCiAgICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy4KICAgKgogICAqIENyZWF0ZXMgbmV3IGRlZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvbgogICAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOgogICAqCiAgICogLSBgbGV2ZWxgCiAgICogLSBgd2luZG93Qml0c2AKICAgKiAtIGBtZW1MZXZlbGAKICAgKiAtIGBzdHJhdGVneWAKICAgKiAtIGBkaWN0aW9uYXJ5YAogICAqCiAgICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKQogICAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLgogICAqCiAgICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6CiAgICoKICAgKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KQogICAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGRlZmxhdGUKICAgKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyCiAgICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXAKICAgKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQKICAgKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wCiAgICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGUKICAgKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpCiAgICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZykKICAgKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZykKICAgKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWQKICAgKgogICAqICMjIyMjIEV4YW1wbGU6CiAgICoKICAgKiBgYGBqYXZhc2NyaXB0CiAgICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKQogICAqICAgLCBjaHVuazEgPSBuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKQogICAqICAgLCBjaHVuazIgPSBuZXcgVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTsKICAgKgogICAqIGNvbnN0IGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTsKICAgKgogICAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTsKICAgKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVuawogICAqCiAgICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH0KICAgKgogICAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTsKICAgKiBgYGAKICAgKiovCiAgZnVuY3Rpb24gRGVmbGF0ZSQxKG9wdGlvbnMpIHsKICAgIHRoaXMub3B0aW9ucyA9IGNvbW1vbi5hc3NpZ24oewogICAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLAogICAgICBtZXRob2Q6IFpfREVGTEFURUQkMSwKICAgICAgY2h1bmtTaXplOiAxNjM4NCwKICAgICAgd2luZG93Qml0czogMTUsCiAgICAgIG1lbUxldmVsOiA4LAogICAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZCiAgICB9LCBvcHRpb25zIHx8IHt9KTsKCiAgICBsZXQgb3B0ID0gdGhpcy5vcHRpb25zOwoKICAgIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7CiAgICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzOwogICAgfQoKICAgIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkgewogICAgICBvcHQud2luZG93Qml0cyArPSAxNjsKICAgIH0KCiAgICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spCiAgICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZQogICAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxscwogICAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGEKCiAgICB0aGlzLnN0cm0gPSBuZXcgenN0cmVhbSgpOwogICAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7CgogICAgbGV0IHN0YXR1cyA9IGRlZmxhdGVfMSQyLmRlZmxhdGVJbml0MigKICAgICAgdGhpcy5zdHJtLAogICAgICBvcHQubGV2ZWwsCiAgICAgIG9wdC5tZXRob2QsCiAgICAgIG9wdC53aW5kb3dCaXRzLAogICAgICBvcHQubWVtTGV2ZWwsCiAgICAgIG9wdC5zdHJhdGVneQogICAgKTsKCiAgICBpZiAoc3RhdHVzICE9PSBaX09LJDIpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pOwogICAgfQoKICAgIGlmIChvcHQuaGVhZGVyKSB7CiAgICAgIGRlZmxhdGVfMSQyLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTsKICAgIH0KCiAgICBpZiAob3B0LmRpY3Rpb25hcnkpIHsKICAgICAgbGV0IGRpY3Q7CiAgICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWQKICAgICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHsKICAgICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LgogICAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpOwogICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nJDEuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHsKICAgICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpOwogICAgICB9IGVsc2UgewogICAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTsKICAgICAgfQoKICAgICAgc3RhdHVzID0gZGVmbGF0ZV8xJDIuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTsKCiAgICAgIGlmIChzdGF0dXMgIT09IFpfT0skMikgewogICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTsKICAgICAgfQoKICAgICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlOwogICAgfQogIH0KCiAgLyoqCiAgICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBmbHVzaF9tb2RlXSkgLT4gQm9vbGVhbgogICAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhLiBTdHJpbmdzIHdpbGwgYmUKICAgKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuCiAgICogLSBmbHVzaF9tb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLgogICAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC4KICAgKgogICAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoCiAgICogbmV3IGNvbXByZXNzZWQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QKICAgKiBoYXZlIGBmbHVzaF9tb2RlYCBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcKICAgKiBidWZmZXJzIGFuZCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dLgogICAqCiAgICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLgogICAqCiAgICogIyMjIyMgRXhhbXBsZQogICAqCiAgICogYGBgamF2YXNjcmlwdAogICAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3MKICAgKiAuLi4KICAgKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVuawogICAqIGBgYAogICAqKi8KICBEZWZsYXRlJDEucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmx1c2hfbW9kZSkgewogICAgY29uc3Qgc3RybSA9IHRoaXMuc3RybTsKICAgIGNvbnN0IGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7CiAgICBsZXQgc3RhdHVzLCBfZmx1c2hfbW9kZTsKCiAgICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH0KCiAgICBpZiAoZmx1c2hfbW9kZSA9PT0gfn5mbHVzaF9tb2RlKSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGU7CiAgICBlbHNlIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIJDIgOiBaX05PX0ZMVVNIJDE7CgogICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZAogICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgewogICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LgogICAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpOwogICAgfSBlbHNlIGlmICh0b1N0cmluZyQxLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHsKICAgICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpOwogICAgfSBlbHNlIHsKICAgICAgc3RybS5pbnB1dCA9IGRhdGE7CiAgICB9CgogICAgc3RybS5uZXh0X2luID0gMDsKICAgIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDsKCiAgICBmb3IgKDs7KSB7CiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtTaXplKTsKICAgICAgICBzdHJtLm5leHRfb3V0ID0gMDsKICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTsKICAgICAgfQoKICAgICAgLy8gTWFrZSBzdXJlIGF2YWlsX291dCA+IDYgdG8gYXZvaWQgcmVwZWF0aW5nIG1hcmtlcnMKICAgICAgaWYgKChfZmx1c2hfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIIHx8IF9mbHVzaF9tb2RlID09PSBaX0ZVTExfRkxVU0gpICYmIHN0cm0uYXZhaWxfb3V0IDw9IDYpIHsKICAgICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7CiAgICAgICAgc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgIGNvbnRpbnVlOwogICAgICB9CgogICAgICBzdGF0dXMgPSBkZWZsYXRlXzEkMi5kZWZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTsKCiAgICAgIC8vIEVuZGVkID0+IGZsdXNoIGFuZCBmaW5pc2gKICAgICAgaWYgKHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EJDIpIHsKICAgICAgICBpZiAoc3RybS5uZXh0X291dCA+IDApIHsKICAgICAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTsKICAgICAgICB9CiAgICAgICAgc3RhdHVzID0gZGVmbGF0ZV8xJDIuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pOwogICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICByZXR1cm4gc3RhdHVzID09PSBaX09LJDI7CiAgICAgIH0KCiAgICAgIC8vIEZsdXNoIGlmIG91dCBidWZmZXIgZnVsbAogICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dCk7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KCiAgICAgIC8vIEZsdXNoIGlmIHJlcXVlc3RlZCBhbmQgaGFzIGRhdGEKICAgICAgaWYgKF9mbHVzaF9tb2RlID4gMCAmJiBzdHJtLm5leHRfb3V0ID4gMCkgewogICAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTsKICAgICAgICBzdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KCiAgICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwKSBicmVhazsKICAgIH0KCiAgICByZXR1cm4gdHJ1ZTsKICB9OwoKCiAgLyoqCiAgICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWQKICAgKiAtIGNodW5rIChVaW50OEFycmF5KTogb3V0cHV0IGRhdGEuCiAgICoKICAgKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZQogICAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuCiAgICoqLwogIERlZmxhdGUkMS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7CiAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTsKICB9OwoKCiAgLyoqCiAgICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWQKICAgKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsCiAgICogICBvdGhlciBpZiBub3QuCiAgICoKICAgKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpcwogICAqIGNvbXBsZXRlIChaX0ZJTklTSCkuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsCiAgICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy4KICAgKiovCiAgRGVmbGF0ZSQxLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHsKICAgIC8vIE9uIHN1Y2Nlc3MgLSBqb2luCiAgICBpZiAoc3RhdHVzID09PSBaX09LJDIpIHsKICAgICAgdGhpcy5yZXN1bHQgPSBjb21tb24uZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7CiAgICB9CiAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgdGhpcy5lcnIgPSBzdGF0dXM7CiAgICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7CiAgfTsKCiAgLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyCiAgLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW4KICAvLwogIC8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkCiAgLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzCiAgLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4KICAvLwogIC8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLAogIC8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQKICAvLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6CiAgLy8KICAvLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdAogIC8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUKICAvLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZQogIC8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4KICAvLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZQogIC8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLgogIC8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uCgogIC8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qcwogIGNvbnN0IEJBRCQxID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi8KICBjb25zdCBUWVBFJDEgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovCgogIC8qCiAgICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZwogICAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpcwogICAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuCiAgICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvcgogICAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGUKICAgICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS4KCiAgICAgRW50cnkgYXNzdW1wdGlvbnM6CgogICAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOCiAgICAgICAgICBzdHJtLmF2YWlsX2luID49IDYKICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OAogICAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXQKICAgICAgICAgIHN0YXRlLmJpdHMgPCA4CgogICAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6CgogICAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0CiAgICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9jawogICAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGEKCiAgICAgTm90ZXM6CgogICAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZQogICAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLAogICAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuCiAgICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWQKICAgICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLgoKICAgICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4CiAgICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpCiAgICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yCiAgICAgICAgb3V0cHV0IHNwYWNlLgogICAqLwogIHZhciBpbmZmYXN0ID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7CiAgICBsZXQgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqLwogICAgbGV0IGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqLwogICAgbGV0IF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovCiAgICBsZXQgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqLwogICAgbGV0IGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqLwogIC8vI2lmZGVmIElORkxBVEVfU1RSSUNUCiAgICBsZXQgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovCiAgLy8jZW5kaWYKICAgIGxldCB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi8KICAgIGxldCB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovCiAgICBsZXQgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovCiAgICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29scwogICAgbGV0IHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqLwogICAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqLwogICAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqLwogICAgbGV0IGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqLwogICAgbGV0IGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi8KICAgIGxldCBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi8KICAgIGxldCBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqLwogICAgbGV0IGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqLwogICAgbGV0IG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqLwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovCiAgICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi8KICAgIGxldCBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqLwogICAgbGV0IGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqLwogICAgbGV0IGZyb21fc291cmNlOwoKCiAgICBsZXQgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVycwoKICAgIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovCiAgICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAvL2hlcmUgPSBzdGF0ZS5oZXJlOwogICAgX2luID0gc3RybS5uZXh0X2luOwogICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7CiAgICBfb3V0ID0gc3RybS5uZXh0X291dDsKICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTsKICAgIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpOwogIC8vI2lmZGVmIElORkxBVEVfU1RSSUNUCiAgICBkbWF4ID0gc3RhdGUuZG1heDsKICAvLyNlbmRpZgogICAgd3NpemUgPSBzdGF0ZS53c2l6ZTsKICAgIHdoYXZlID0gc3RhdGUud2hhdmU7CiAgICB3bmV4dCA9IHN0YXRlLnduZXh0OwogICAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7CiAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgIGJpdHMgPSBzdGF0ZS5iaXRzOwogICAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlOwogICAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTsKICAgIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxOwogICAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxOwoKCiAgICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2gKICAgICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovCgogICAgdG9wOgogICAgZG8gewogICAgICBpZiAoYml0cyA8IDE1KSB7CiAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICBiaXRzICs9IDg7CiAgICAgIH0KCiAgICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdOwoKICAgICAgZG9sZW46CiAgICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb24KICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLzsKICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87CiAgICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovCiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgPwogICAgICAgICAgLy8gICAgICAgICJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xuIiA6CiAgICAgICAgICAvLyAgICAgICAgImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcbiIsIGhlcmUudmFsKSk7CiAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87CiAgICAgICAgfQogICAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqLwogICAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLzsKICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovCiAgICAgICAgICBpZiAob3ApIHsKICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpOwogICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICB9CiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XG4iLCBsZW4pKTsKICAgICAgICAgIGlmIChiaXRzIDwgMTUpIHsKICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICB9CiAgICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTsKCiAgICAgICAgICBkb2Rpc3Q6CiAgICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uCiAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovOwogICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLzsKCiAgICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi8KICAgICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLzsKICAgICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovCiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7CiAgLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1QKICAgICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHsKICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJzsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTsKICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICB9CiAgLy8jZW5kaWYKICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcbiIsIGRpc3QpKTsKICAgICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi8KICAgICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovCiAgICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqLwogICAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHsKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxOwogICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgICAgfQoKICAvLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLAogIC8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHkKICAvLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlIKICAvLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHsKICAvLyAgICAgICAgICAgICAgICAgIGRvIHsKICAvLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwOwogIC8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pOwogIC8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wOwogIC8vICAgICAgICAgICAgICAgIH0KICAvLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTsKICAvLyAgICAgICAgICAgICAgICBkbyB7CiAgLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7CiAgLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTsKICAvLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHsKICAvLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAvLyAgICAgICAgICAgICAgICAgIGRvIHsKICAvLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAvLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTsKICAvLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDsKICAvLyAgICAgICAgICAgICAgICB9CiAgLy8jZW5kaWYKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXgKICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7CiAgICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi8KICAgICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wOwogICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovCiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovCiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi8KICAgICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7CiAgICAgICAgICAgICAgICAgIG9wIC09IHduZXh0OwogICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqLwogICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7CiAgICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovCiAgICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0OwogICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovCiAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqLwogICAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7CiAgICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi8KICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi8KICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHsKICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgbGVuIC09IDM7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHsKICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovCiAgICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi8KICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgbGVuIC09IDM7CiAgICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTsKICAgICAgICAgICAgICAgIGlmIChsZW4pIHsKICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHsKICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqLwogICAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldOwogICAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnOwogICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTsKICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgImNvbnRpbnVlIgogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqLwogICAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07CiAgICAgICAgICBjb250aW51ZSBkb2xlbjsKICAgICAgICB9CiAgICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqLwogICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsICJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xuIikpOwogICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEUkMTsKICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnOwogICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxOwogICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgIH0KCiAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSAiY29udGludWUiCiAgICAgIH0KICAgIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7CgogICAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovCiAgICBsZW4gPSBiaXRzID4+IDM7CiAgICBfaW4gLT0gbGVuOwogICAgYml0cyAtPSBsZW4gPDwgMzsKICAgIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxOwoKICAgIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovCiAgICBzdHJtLm5leHRfaW4gPSBfaW47CiAgICBzdHJtLm5leHRfb3V0ID0gX291dDsKICAgIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTsKICAgIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpOwogICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgIHJldHVybjsKICB9OwoKICAvLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXIKICAvLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpbgogIC8vCiAgLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQKICAvLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMKICAvLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLgogIC8vCiAgLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsCiAgLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdAogIC8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczoKICAvLwogIC8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90CiAgLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZQogIC8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlCiAgLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLgogIC8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlCiAgLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuCiAgLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4KCiAgY29uc3QgTUFYQklUUyA9IDE1OwogIGNvbnN0IEVOT1VHSF9MRU5TJDEgPSA4NTI7CiAgY29uc3QgRU5PVUdIX0RJU1RTJDEgPSA1OTI7CiAgLy9jb25zdCBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTsKCiAgY29uc3QgQ09ERVMkMSA9IDA7CiAgY29uc3QgTEVOUyQxID0gMTsKICBjb25zdCBESVNUUyQxID0gMjsKCiAgY29uc3QgbGJhc2UgPSBuZXcgVWludDE2QXJyYXkoWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqLwogICAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSwKICAgIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwCiAgXSk7CgogIGNvbnN0IGxleHQgPSBuZXcgVWludDhBcnJheShbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqLwogICAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsCiAgICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4CiAgXSk7CgogIGNvbnN0IGRiYXNlID0gbmV3IFVpbnQxNkFycmF5KFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqLwogICAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLAogICAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LAogICAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMAogIF0pOwoKICBjb25zdCBkZXh0ID0gbmV3IFVpbnQ4QXJyYXkoWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqLwogICAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsCiAgICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNywKICAgIDI4LCAyOCwgMjksIDI5LCA2NCwgNjQKICBdKTsKCiAgY29uc3QgaW5mbGF0ZV90YWJsZSA9ICh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKSA9PgogIHsKICAgIGNvbnN0IGJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi8KCiAgICBsZXQgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqLwogICAgbGV0IHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovCiAgICBsZXQgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi8KICAgIGxldCByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovCiAgICBsZXQgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqLwogICAgbGV0IGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqLwogICAgbGV0IGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqLwogICAgbGV0IHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi8KICAgIGxldCBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqLwogICAgbGV0IGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovCiAgICBsZXQgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovCiAgICBsZXQgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi8KICAgIGxldCBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqLwogICAgbGV0IG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovCiAgICBsZXQgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqLwogICAgbGV0IGJhc2VfaW5kZXggPSAwOwogIC8vICBsZXQgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovCiAgICBsZXQgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi8KICAgIGNvbnN0IGNvdW50ID0gbmV3IFVpbnQxNkFycmF5KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovCiAgICBjb25zdCBvZmZzID0gbmV3IFVpbnQxNkFycmF5KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovCiAgICBsZXQgZXh0cmEgPSBudWxsOwogICAgbGV0IGV4dHJhX2luZGV4ID0gMDsKCiAgICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsKCiAgICAvKgogICAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGUKICAgICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGUKICAgICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZQogICAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyCiAgICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0cwogICAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyCiAgICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGgKICAgICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzCiAgICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZQogICAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzCiAgICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy4KCiAgICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW4KICAgICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLgogICAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0CiAgICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS4KCiAgICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLAogICAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZQogICAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZAogICAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieQogICAgIHRoZSBjYWxsZXIuCgogICAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmcKICAgICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnkKICAgICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZAogICAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZQogICAgIGRlY29kaW5nIHRhYmxlcy4KICAgICAqLwoKICAgIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqLwogICAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgY291bnRbbGVuXSA9IDA7CiAgICB9CiAgICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykgewogICAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrOwogICAgfQoKICAgIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovCiAgICByb290ID0gYml0czsKICAgIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7CiAgICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9CiAgICB9CiAgICBpZiAocm9vdCA+IG1heCkgewogICAgICByb290ID0gbWF4OwogICAgfQogICAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi8KICAgICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovCiAgICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTsKICAgICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDsKICAgICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDsKCgogICAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7CiAgICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7CiAgICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOwogICAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwOwoKICAgICAgb3B0cy5iaXRzID0gMTsKICAgICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovCiAgICB9CiAgICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHsKICAgICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH0KICAgIH0KICAgIGlmIChyb290IDwgbWluKSB7CiAgICAgIHJvb3QgPSBtaW47CiAgICB9CgogICAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovCiAgICBsZWZ0ID0gMTsKICAgIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7CiAgICAgIGxlZnQgPDw9IDE7CiAgICAgIGxlZnQgLT0gY291bnRbbGVuXTsKICAgICAgaWYgKGxlZnQgPCAwKSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi8KICAgIH0KICAgIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMkMSB8fCBtYXggIT09IDEpKSB7CiAgICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi8KICAgIH0KCiAgICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqLwogICAgb2Zmc1sxXSA9IDA7CiAgICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7CiAgICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dOwogICAgfQoKICAgIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi8KICAgIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7CiAgICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7CiAgICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltOwogICAgICB9CiAgICB9CgogICAgLyoKICAgICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmcKICAgICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZgogICAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcAogICAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VyciwKICAgICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvCiAgICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuCgogICAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHMKICAgICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleAogICAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhCiAgICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzCiAgICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLgoKICAgICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZQogICAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoCiAgICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmUKICAgICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuCgogICAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlCiAgICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdAogICAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW4KICAgICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oCiAgICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uCgogICAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW4KICAgICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzCiAgICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxscwogICAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy4KICAgICAqLwoKICAgIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovCiAgICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCwKICAgIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjgKICAgIGlmICh0eXBlID09PSBDT0RFUyQxKSB7CiAgICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqLwogICAgICBlbmQgPSAxOTsKCiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMkMSkgewogICAgICBiYXNlID0gbGJhc2U7CiAgICAgIGJhc2VfaW5kZXggLT0gMjU3OwogICAgICBleHRyYSA9IGxleHQ7CiAgICAgIGV4dHJhX2luZGV4IC09IDI1NzsKICAgICAgZW5kID0gMjU2OwoKICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqLwogICAgICBiYXNlID0gZGJhc2U7CiAgICAgIGV4dHJhID0gZGV4dDsKICAgICAgZW5kID0gLTE7CiAgICB9CgogICAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovCiAgICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqLwogICAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovCiAgICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi8KICAgIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqLwogICAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqLwogICAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi8KICAgIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovCiAgICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovCiAgICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqLwoKICAgIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqLwogICAgaWYgKCh0eXBlID09PSBMRU5TJDEgJiYgdXNlZCA+IEVOT1VHSF9MRU5TJDEpIHx8CiAgICAgICh0eXBlID09PSBESVNUUyQxICYmIHVzZWQgPiBFTk9VR0hfRElTVFMkMSkpIHsKICAgICAgcmV0dXJuIDE7CiAgICB9CgogICAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqLwogICAgZm9yICg7OykgewogICAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi8KICAgICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDsKICAgICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkgewogICAgICAgIGhlcmVfb3AgPSAwOwogICAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dOwogICAgICB9CiAgICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkgewogICAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07CiAgICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dOwogICAgICB9CiAgICAgIGVsc2UgewogICAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqLwogICAgICAgIGhlcmVfdmFsID0gMDsKICAgICAgfQoKICAgICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi8KICAgICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApOwogICAgICBmaWxsID0gMSA8PCBjdXJyOwogICAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqLwogICAgICBkbyB7CiAgICAgICAgZmlsbCAtPSBpbmNyOwogICAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDsKICAgICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7CgogICAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqLwogICAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7CiAgICAgIHdoaWxlIChodWZmICYgaW5jcikgewogICAgICAgIGluY3IgPj49IDE7CiAgICAgIH0KICAgICAgaWYgKGluY3IgIT09IDApIHsKICAgICAgICBodWZmICY9IGluY3IgLSAxOwogICAgICAgIGh1ZmYgKz0gaW5jcjsKICAgICAgfSBlbHNlIHsKICAgICAgICBodWZmID0gMDsKICAgICAgfQoKICAgICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovCiAgICAgIHN5bSsrOwogICAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7CiAgICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9CiAgICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTsKICAgICAgfQoKICAgICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovCiAgICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykgewogICAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqLwogICAgICAgIGlmIChkcm9wID09PSAwKSB7CiAgICAgICAgICBkcm9wID0gcm9vdDsKICAgICAgICB9CgogICAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi8KICAgICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi8KCiAgICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovCiAgICAgICAgY3VyciA9IGxlbiAtIGRyb3A7CiAgICAgICAgbGVmdCA9IDEgPDwgY3VycjsKICAgICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHsKICAgICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdOwogICAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfQogICAgICAgICAgY3VycisrOwogICAgICAgICAgbGVmdCA8PD0gMTsKICAgICAgICB9CgogICAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi8KICAgICAgICB1c2VkICs9IDEgPDwgY3VycjsKICAgICAgICBpZiAoKHR5cGUgPT09IExFTlMkMSAmJiB1c2VkID4gRU5PVUdIX0xFTlMkMSkgfHwKICAgICAgICAgICh0eXBlID09PSBESVNUUyQxICYmIHVzZWQgPiBFTk9VR0hfRElTVFMkMSkpIHsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KCiAgICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi8KICAgICAgICBsb3cgPSBodWZmICYgbWFzazsKICAgICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyOwogICAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7CiAgICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqLwogICAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDsKICAgICAgfQogICAgfQoKICAgIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlCiAgICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGUKICAgICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovCiAgICBpZiAoaHVmZiAhPT0gMCkgewogICAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi8KICAgICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7CiAgICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7CiAgICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDsKICAgIH0KCiAgICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi8KICAgIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkOwogICAgb3B0cy5iaXRzID0gcm9vdDsKICAgIHJldHVybiAwOwogIH07CgoKICB2YXIgaW5mdHJlZXMgPSBpbmZsYXRlX3RhYmxlOwoKICAvLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXIKICAvLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpbgogIC8vCiAgLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQKICAvLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMKICAvLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLgogIC8vCiAgLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsCiAgLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdAogIC8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczoKICAvLwogIC8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90CiAgLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZQogIC8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlCiAgLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLgogIC8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlCiAgLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuCiAgLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4KCgoKCgoKICBjb25zdCBDT0RFUyA9IDA7CiAgY29uc3QgTEVOUyA9IDE7CiAgY29uc3QgRElTVFMgPSAyOwoKICAvKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qLwogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovCgogIGNvbnN0IHsKICAgIFpfRklOSVNIOiBaX0ZJTklTSCQxLCBaX0JMT0NLLCBaX1RSRUVTLAogICAgWl9PSzogWl9PSyQxLCBaX1NUUkVBTV9FTkQ6IFpfU1RSRUFNX0VORCQxLCBaX05FRURfRElDVDogWl9ORUVEX0RJQ1QkMSwgWl9TVFJFQU1fRVJST1I6IFpfU1RSRUFNX0VSUk9SJDEsIFpfREFUQV9FUlJPUjogWl9EQVRBX0VSUk9SJDEsIFpfTUVNX0VSUk9SOiBaX01FTV9FUlJPUiQxLCBaX0JVRl9FUlJPUiwKICAgIFpfREVGTEFURUQKICB9ID0gY29uc3RhbnRzJDI7CgoKICAvKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qLwogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovCgoKICBjb25zdCAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovCiAgY29uc3QgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovCiAgY29uc3QgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqLwogIGNvbnN0ICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi8KICBjb25zdCAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqLwogIGNvbnN0ICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi8KICBjb25zdCAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi8KICBjb25zdCAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovCiAgY29uc3QgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovCiAgY29uc3QgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi8KICBjb25zdCAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovCiAgY29uc3QgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovCiAgY29uc3QgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovCiAgY29uc3QgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqLwogIGNvbnN0ICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi8KICBjb25zdCAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovCiAgY29uc3QgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi8KICBjb25zdCAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqLwogIGNvbnN0ICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovCiAgY29uc3QgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi8KICBjb25zdCAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovCiAgY29uc3QgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi8KICBjb25zdCAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovCiAgY29uc3QgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqLwogIGNvbnN0ICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqLwogIGNvbnN0ICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovCiAgY29uc3QgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqLwogIGNvbnN0ICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqLwogIGNvbnN0ICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqLwogIGNvbnN0ICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovCiAgY29uc3QgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovCiAgY29uc3QgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqLwoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qLwoKCgogIGNvbnN0IEVOT1VHSF9MRU5TID0gODUyOwogIGNvbnN0IEVOT1VHSF9ESVNUUyA9IDU5MjsKICAvL2NvbnN0IEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTsKCiAgY29uc3QgTUFYX1dCSVRTID0gMTU7CiAgLyogMzJLIExaNzcgd2luZG93ICovCiAgY29uc3QgREVGX1dCSVRTID0gTUFYX1dCSVRTOwoKCiAgY29uc3QgenN3YXAzMiA9IChxKSA9PiB7CgogICAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArCiAgICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICsKICAgICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArCiAgICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7CiAgfTsKCgogIGZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHsKICAgIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovCiAgICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi8KICAgIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovCiAgICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovCiAgICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqLwogICAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovCiAgICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi8KICAgIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi8KICAgIC8vIFRPRE86IG1heSBiZSB7fQogICAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi8KCiAgICAvKiBzbGlkaW5nIHdpbmRvdyAqLwogICAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovCiAgICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovCiAgICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqLwogICAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqLwogICAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovCgogICAgLyogYml0IGFjY3VtdWxhdG9yICovCiAgICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovCiAgICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gImluIiAqLwoKICAgIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovCiAgICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovCiAgICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovCgogICAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovCiAgICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi8KCiAgICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqLwogICAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovCiAgICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi8KICAgIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovCiAgICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi8KCiAgICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovCiAgICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqLwogICAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovCiAgICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqLwogICAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovCiAgICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqLwoKICAgIHRoaXMubGVucyA9IG5ldyBVaW50MTZBcnJheSgzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovCiAgICB0aGlzLndvcmsgPSBuZXcgVWludDE2QXJyYXkoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovCgogICAgLyoKICAgICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseQogICAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2RlcwogICAgKi8KICAgIC8vdGhpcy5jb2RlcyA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqLwogICAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqLwogICAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqLwogICAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqLwogICAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqLwogICAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi8KICB9CgoKICBjb25zdCBpbmZsYXRlUmVzZXRLZWVwID0gKHN0cm0pID0+IHsKCiAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH0KICAgIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTsKICAgIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDsKICAgIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi8KICAgIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi8KICAgICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxOwogICAgfQogICAgc3RhdGUubW9kZSA9IEhFQUQ7CiAgICBzdGF0ZS5sYXN0ID0gMDsKICAgIHN0YXRlLmhhdmVkaWN0ID0gMDsKICAgIHN0YXRlLmRtYXggPSAzMjc2ODsKICAgIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLzsKICAgIHN0YXRlLmhvbGQgPSAwOwogICAgc3RhdGUuYml0cyA9IDA7CiAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlczsKICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgSW50MzJBcnJheShFTk9VR0hfTEVOUyk7CiAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgSW50MzJBcnJheShFTk9VR0hfRElTVFMpOwoKICAgIHN0YXRlLnNhbmUgPSAxOwogICAgc3RhdGUuYmFjayA9IC0xOwogICAgLy9UcmFjZXYoKHN0ZGVyciwgImluZmxhdGU6IHJlc2V0XG4iKSk7CiAgICByZXR1cm4gWl9PSyQxOwogIH07CgoKICBjb25zdCBpbmZsYXRlUmVzZXQgPSAoc3RybSkgPT4gewoKICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfQogICAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgc3RhdGUud3NpemUgPSAwOwogICAgc3RhdGUud2hhdmUgPSAwOwogICAgc3RhdGUud25leHQgPSAwOwogICAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7CgogIH07CgoKICBjb25zdCBpbmZsYXRlUmVzZXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHsKICAgIGxldCB3cmFwOwoKICAgIC8qIGdldCB0aGUgc3RhdGUgKi8KICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfQogICAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlOwoKICAgIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi8KICAgIGlmICh3aW5kb3dCaXRzIDwgMCkgewogICAgICB3cmFwID0gMDsKICAgICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzOwogICAgfQogICAgZWxzZSB7CiAgICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7CiAgICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHsKICAgICAgICB3aW5kb3dCaXRzICY9IDE1OwogICAgICB9CiAgICB9CgogICAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovCiAgICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkgewogICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsKICAgIH0KICAgIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHsKICAgICAgc3RhdGUud2luZG93ID0gbnVsbDsKICAgIH0KCiAgICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovCiAgICBzdGF0ZS53cmFwID0gd3JhcDsKICAgIHN0YXRlLndiaXRzID0gd2luZG93Qml0czsKICAgIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7CiAgfTsKCgogIGNvbnN0IGluZmxhdGVJbml0MiA9IChzdHJtLCB3aW5kb3dCaXRzKSA9PiB7CgogICAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9CiAgICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi8KCiAgICBjb25zdCBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTsKCiAgICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7CiAgICAvL1RyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogYWxsb2NhdGVkXG4iKSk7CiAgICBzdHJtLnN0YXRlID0gc3RhdGU7CiAgICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLzsKICAgIGNvbnN0IHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7CiAgICBpZiAocmV0ICE9PSBaX09LJDEpIHsKICAgICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovOwogICAgfQogICAgcmV0dXJuIHJldDsKICB9OwoKCiAgY29uc3QgaW5mbGF0ZUluaXQgPSAoc3RybSkgPT4gewoKICAgIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTsKICB9OwoKCiAgLyoKICAgUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0bwogICBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguCiAgIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGUKICAgZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZAogICB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpbgogICBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmUKICAgdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpbgogICBtYXkgbm90IGJlIHRocmVhZC1zYWZlLgogICAqLwogIGxldCB2aXJnaW4gPSB0cnVlOwoKICBsZXQgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZQoKCiAgY29uc3QgZml4ZWR0YWJsZXMgPSAoc3RhdGUpID0+IHsKCiAgICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqLwogICAgaWYgKHZpcmdpbikgewogICAgICBsZW5maXggPSBuZXcgSW50MzJBcnJheSg1MTIpOwogICAgICBkaXN0Zml4ID0gbmV3IEludDMyQXJyYXkoMzIpOwoKICAgICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi8KICAgICAgbGV0IHN5bSA9IDA7CiAgICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9CiAgICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9CiAgICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9CiAgICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9CgogICAgICBpbmZ0cmVlcyhMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pOwoKICAgICAgLyogZGlzdGFuY2UgdGFibGUgKi8KICAgICAgc3ltID0gMDsKICAgICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfQoKICAgICAgaW5mdHJlZXMoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTsKCiAgICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovCiAgICAgIHZpcmdpbiA9IGZhbHNlOwogICAgfQoKICAgIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7CiAgICBzdGF0ZS5sZW5iaXRzID0gOTsKICAgIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDsKICAgIHN0YXRlLmRpc3RiaXRzID0gNTsKICB9OwoKCiAgLyoKICAgVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZQogICByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkCiAgIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXMKICAgaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LgogICBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeQogICBpcyBsb2FkZWQuCgogICBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkCiAgIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3cKICAgdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2YKICAgb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLgogICBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLgogICAqLwogIGNvbnN0IHVwZGF0ZXdpbmRvdyA9IChzdHJtLCBzcmMsIGVuZCwgY29weSkgPT4gewoKICAgIGxldCBkaXN0OwogICAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlOwoKICAgIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi8KICAgIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHsKICAgICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzOwogICAgICBzdGF0ZS53bmV4dCA9IDA7CiAgICAgIHN0YXRlLndoYXZlID0gMDsKCiAgICAgIHN0YXRlLndpbmRvdyA9IG5ldyBVaW50OEFycmF5KHN0YXRlLndzaXplKTsKICAgIH0KCiAgICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi8KICAgIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7CiAgICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIHN0YXRlLndzaXplLCBlbmQpLCAwKTsKICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplOwogICAgfQogICAgZWxzZSB7CiAgICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0OwogICAgICBpZiAoZGlzdCA+IGNvcHkpIHsKICAgICAgICBkaXN0ID0gY29weTsKICAgICAgfQogICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7CiAgICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIGNvcHksIGVuZCAtIGNvcHkgKyBkaXN0KSwgc3RhdGUud25leHQpOwogICAgICBjb3B5IC09IGRpc3Q7CiAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpOwogICAgICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIGNvcHksIGVuZCksIDApOwogICAgICAgIHN0YXRlLnduZXh0ID0gY29weTsKICAgICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplOwogICAgICB9CiAgICAgIGVsc2UgewogICAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7CiAgICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH0KICAgICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9CiAgICAgIH0KICAgIH0KICAgIHJldHVybiAwOwogIH07CgoKICBjb25zdCBpbmZsYXRlJDIgPSAoc3RybSwgZmx1c2gpID0+IHsKCiAgICBsZXQgc3RhdGU7CiAgICBsZXQgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnMKICAgIGxldCBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovCiAgICBsZXQgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi8KICAgIGxldCBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqLwogICAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi8KICAgIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi8KICAgIGxldCBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovCiAgICBsZXQgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovCiAgICBsZXQgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovCiAgICBsZXQgZnJvbV9zb3VyY2U7CiAgICBsZXQgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqLwogICAgbGV0IGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkICJoZXJlIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKQogICAgLy9sZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovCiAgICBsZXQgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgImxhc3QiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpCiAgICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqLwogICAgbGV0IHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovCiAgICBjb25zdCBoYnVmID0gbmV3IFVpbnQ4QXJyYXkoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovCiAgICBsZXQgb3B0czsKCiAgICBsZXQgbjsgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIGZvciBORUVEX0JJVFMKCiAgICBjb25zdCBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqLwogICAgICBuZXcgVWludDhBcnJheShbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXSk7CgoKICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHwKICAgICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHsKICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7CiAgICB9CgogICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovCgoKICAgIC8vLS0tIExPQUQoKSAtLS0KICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7CiAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDsKICAgIG5leHQgPSBzdHJtLm5leHRfaW47CiAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICBoYXZlID0gc3RybS5hdmFpbF9pbjsKICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAvLy0tLQoKICAgIF9pbiA9IGhhdmU7CiAgICBfb3V0ID0gbGVmdDsKICAgIHJldCA9IFpfT0skMTsKCiAgICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uCiAgICBmb3IgKDs7KSB7CiAgICAgIHN3aXRjaCAoc3RhdGUubW9kZSkgewogICAgICAgIGNhc2UgSEVBRDoKICAgICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOwogICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgfQogICAgICAgICAgLy89PT0vLwogICAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqLwogICAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87CiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpOwogICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7CiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmOwogICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAvLz09PS8vCgogICAgICAgICAgICAvLz09PSBJTklUQklUUygpOwogICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqLwogICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovCiAgICAgICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHsKICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy8KICAgICAgICAgIGhvbGQgPj4+PSA0OwogICAgICAgICAgYml0cyAtPSA0OwogICAgICAgICAgLy8tLS0vLwogICAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODsKICAgICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkgewogICAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjsKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7CiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnOwogICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICAvLyAhISEgcGFrbyBwYXRjaC4gRm9yY2UgdXNlIGBvcHRpb25zLndpbmRvd0JpdHNgIGlmIHBhc3NlZC4KICAgICAgICAgIC8vIFJlcXVpcmVkIHRvIGFsd2F5cyB1c2UgbWF4IHdpbmRvdyBzaXplIGJ5IGRlZmF1bHQuCiAgICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBzdGF0ZS53Yml0czsKICAgICAgICAgIC8vc3RhdGUuZG1heCA9IDEgPDwgbGVuOwoKICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXG4iKSk7CiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87CiAgICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTsKICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7CiAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgLy89PT0vLwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSBGTEFHUzoKICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi8KICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgIH0KICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDsKICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7CiAgICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHsKICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7CiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjsKICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7CiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIH0KICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7CiAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgLy89PT0vLwogICAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgY2FzZSBUSU1FOgogICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqLwogICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgfQogICAgICAgICAgLy89PT0vLwogICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgewogICAgICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKQogICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7CiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmOwogICAgICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7CiAgICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjsKICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTsKICAgICAgICAgICAgLy89PT0KICAgICAgICAgIH0KICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7CiAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgLy89PT0vLwogICAgICAgICAgc3RhdGUubW9kZSA9IE9TOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgT1M6CiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovCiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICB9CiAgICAgICAgICAvLz09PS8vCiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7CiAgICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgewogICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTsKICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmOwogICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjsKICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTsKICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgfQogICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTsKICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAvLz09PS8vCiAgICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgY2FzZSBFWExFTjoKICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkgewogICAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovCiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDsKICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7CiAgICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7CiAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmOwogICAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmOwogICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7CiAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgfQogICAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgY2FzZSBFWFRSQToKICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkgewogICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH0KICAgICAgICAgICAgaWYgKGNvcHkpIHsKICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHsKICAgICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVudCBwcm9jZXNzaW5nIGxhdGVyCiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgVWludDhBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLnNldCgKICAgICAgICAgICAgICAgICAgaW5wdXQuc3ViYXJyYXkoCiAgICAgICAgICAgICAgICAgICAgbmV4dCwKICAgICAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzCiAgICAgICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2sKICAgICAgICAgICAgICAgICAgICBuZXh0ICsgY29weQogICAgICAgICAgICAgICAgICApLAogICAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqLwogICAgICAgICAgICAgICAgICBsZW4KICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCwKICAgICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggPwogICAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgewogICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICBuZXh0ICs9IGNvcHk7CiAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgIH0KICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIE5BTUU6CiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHsKICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgIGNvcHkgPSAwOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzPwogICAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdOwogICAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovCiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmCiAgICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHsKICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpOwoKICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7CiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGF2ZSAtPSBjb3B5OwogICAgICAgICAgICBuZXh0ICs9IGNvcHk7CiAgICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSAwOwogICAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgY2FzZSBDT01NRU5UOgogICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7CiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICBjb3B5ID0gMDsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdOwogICAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovCiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmCiAgICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHsKICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpOwogICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHsKICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgSENSQzoKICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgewogICAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovCiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHsKICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJzsKICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7CiAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpOwogICAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSBESUNUSUQ6CiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovCiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7CiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICB9CiAgICAgICAgICAvLz09PS8vCiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpOwogICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTsKICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAvLz09PS8vCiAgICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIERJQ1Q6CiAgICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHsKICAgICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLQogICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0OwogICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7CiAgICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlOwogICAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgICAgIC8vLS0tCiAgICAgICAgICAgIHJldHVybiBaX05FRURfRElDVCQxOwogICAgICAgICAgfQogICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovOwogICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgY2FzZSBUWVBFOgogICAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgVFlQRURPOgogICAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHsKICAgICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLwogICAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7CiAgICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7CiAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqLwogICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7CiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICB9CiAgICAgICAgICAvLz09PS8vCiAgICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovOwogICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy8KICAgICAgICAgIGhvbGQgPj4+PSAxOwogICAgICAgICAgYml0cyAtPSAxOwogICAgICAgICAgLy8tLS0vLwoKICAgICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7CiAgICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqLwogICAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcbiIsCiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyAiIChsYXN0KSIgOiAiIikpOwogICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovCiAgICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpOwogICAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xuIiwKICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/ICIgKGxhc3QpIiA6ICIiKSk7CiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqLwogICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgewogICAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy8KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgLy8tLS0vLwogICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqLwogICAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXG4iLAogICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gIiAobGFzdCkiIDogIiIpKTsKICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnOwogICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICB9CiAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vLwogICAgICAgICAgaG9sZCA+Pj49IDI7CiAgICAgICAgICBiaXRzIC09IDI7CiAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlIFNUT1JFRDoKICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqLwogICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3OwogICAgICAgICAgYml0cyAtPSBiaXRzICYgNzsKICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi8KICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgIH0KICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJzsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmOwogICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcbiIsCiAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7CiAgICAgICAgICAvLz09PSBJTklUQklUUygpOwogICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXzsKICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIENPUFlfOgogICAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgY2FzZSBDT1BZOgogICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfQogICAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH0KICAgICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tCiAgICAgICAgICAgIG91dHB1dC5zZXQoaW5wdXQuc3ViYXJyYXkobmV4dCwgbmV4dCArIGNvcHkpLCBwdXQpOwogICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICBsZWZ0IC09IGNvcHk7CiAgICAgICAgICAgIHB1dCArPSBjb3B5OwogICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxuIikpOwogICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlIFRBQkxFOgogICAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqLwogICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkgewogICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgfQogICAgICAgICAgLy89PT0vLwogICAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NzsKICAgICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vCiAgICAgICAgICBob2xkID4+Pj0gNTsKICAgICAgICAgIGJpdHMgLT0gNTsKICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTsKICAgICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vCiAgICAgICAgICBob2xkID4+Pj0gNTsKICAgICAgICAgIGJpdHMgLT0gNTsKICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDsKICAgICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vCiAgICAgICAgICBob2xkID4+Pj0gNDsKICAgICAgICAgIGJpdHMgLT0gNDsKICAgICAgICAgIC8vLS0tLy8KICAvLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkQKICAgICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHsKICAgICAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnOwogICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAvLyNlbmRpZgogICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXG4iKSk7CiAgICAgICAgICBzdGF0ZS5oYXZlID0gMDsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgTEVOTEVOUzoKICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHsKICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7CiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7CiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vCiAgICAgICAgICAgIGhvbGQgPj4+PSAzOwogICAgICAgICAgICBiaXRzIC09IDM7CiAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLgogICAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7CiAgICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0OwogICAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlCiAgICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluOwogICAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7CgogICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9OwogICAgICAgICAgcmV0ID0gaW5mdHJlZXMoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTsKICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7CgogICAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnOwogICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcbiIpKTsKICAgICAgICAgIHN0YXRlLmhhdmUgPSAwOwogICAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgQ09ERUxFTlM6CiAgICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkgewogICAgICAgICAgICBmb3IgKDs7KSB7CiAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqLwogICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjsKICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7CgogICAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9CiAgICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vLwogICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgLy8tLS0vLwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7CiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vLwogICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgLy8tLS0vLwogICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHsKICAgICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpOwogICAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy8KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdOwogICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTsKICAgICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vCiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7CiAgICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTsKICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzOwogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvLz09PS8vCiAgICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vCiAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTsKICAgICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vCiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMzsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMzsKICAgICAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTsKICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3OwogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvLz09PS8vCiAgICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vCiAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7CiAgICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vLwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7CiAgICAgICAgICAgICAgICBiaXRzIC09IDc7CiAgICAgICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkgewogICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovCiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9CgogICAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovCiAgICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7CiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHMKICAgICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmgKICAgICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi8KICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5OwoKICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTsKICAgICAgICAgIHJldCA9IGluZnRyZWVzKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC4KICAgICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4OwogICAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0czsKICAgICAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0OwoKICAgICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JzsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2OwogICAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTsKICAgICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZQogICAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluOwogICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTsKICAgICAgICAgIHJldCA9IGluZnRyZWVzKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC4KICAgICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4OwogICAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7CgogICAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnOwogICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xuJykpOwogICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87CiAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgY2FzZSBMRU5fOgogICAgICAgICAgc3RhdGUubW9kZSA9IExFTjsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIExFTjoKICAgICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHsKICAgICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLQogICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0OwogICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7CiAgICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlOwogICAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgICAgIC8vLS0tCiAgICAgICAgICAgIGluZmZhc3Qoc3RybSwgX291dCk7CiAgICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS0KICAgICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDsKICAgICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7CiAgICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDsKICAgICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjsKICAgICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjsKICAgICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7CiAgICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzOwogICAgICAgICAgICAvLy0tLQoKICAgICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsKICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5iYWNrID0gMDsKICAgICAgICAgIGZvciAoOzspIHsKICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovCiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7CiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjsKCiAgICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfQogICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vCiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgIH0KICAgICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHsKICAgICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzOwogICAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDsKICAgICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDsKICAgICAgICAgICAgZm9yICg7OykgewogICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICsKICAgICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07CiAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmOwogICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjsKCiAgICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH0KICAgICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vCiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vLwogICAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzOwogICAgICAgICAgICBiaXRzIC09IGxhc3RfYml0czsKICAgICAgICAgICAgLy8tLS0vLwogICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0czsKICAgICAgICAgIH0KICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy8KICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzOwogICAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7CiAgICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkgewogICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgPwogICAgICAgICAgICAvLyAgICAgICAgImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXG4iIDoKICAgICAgICAgICAgLy8gICAgICAgICJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XG4iLCBoZXJlLnZhbCkpOwogICAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChoZXJlX29wICYgMzIpIHsKICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsICJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xuIikpOwogICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChoZXJlX29wICYgNjQpIHsKICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJzsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgY2FzZSBMRU5FWFQ6CiAgICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHsKICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpOwogICAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLzsKICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vCiAgICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgLy8tLS0vLwogICAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhOwogICAgICAgICAgfQogICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsICJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxuIiwgc3RhdGUubGVuZ3RoKSk7CiAgICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIERJU1Q6CiAgICAgICAgICBmb3IgKDs7KSB7CiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi8KICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjsKICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmOwoKICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH0KICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vLwogICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICB9CiAgICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkgewogICAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7CiAgICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wOwogICAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsOwogICAgICAgICAgICBmb3IgKDs7KSB7CiAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICsKICAgICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07CiAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmOwogICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjsKCiAgICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH0KICAgICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vCiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vLwogICAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzOwogICAgICAgICAgICBiaXRzIC09IGxhc3RfYml0czsKICAgICAgICAgICAgLy8tLS0vLwogICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0czsKICAgICAgICAgIH0KICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy8KICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzOwogICAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnOwogICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsOwogICAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgRElTVEVYVDoKICAgICAgICAgIGlmIChzdGF0ZS5leHRyYSkgewogICAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7CiAgICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLz09PS8vCiAgICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovOwogICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy8KICAgICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhOwogICAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7CiAgICAgICAgICB9CiAgLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1QKICAgICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7CiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJzsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgLy8jZW5kaWYKICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCAiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxuIiwgc3RhdGUub2Zmc2V0KSk7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgY2FzZSBNQVRDSDoKICAgICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0OwogICAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovCiAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5OwogICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7CiAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHsKICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJzsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cywKICAvLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5CiAgLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSCiAgLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgImluZmxhdGUuYyB0b28gZmFyXG4iKSk7CiAgLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTsKICAvLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9CiAgLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9CiAgLy8gICAgICAgICAgbGVmdCAtPSBjb3B5OwogIC8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5OwogIC8vICAgICAgICAgIGRvIHsKICAvLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwOwogIC8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7CiAgLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9CiAgLy8gICAgICAgICAgYnJlYWs7CiAgLy8jZW5kaWYKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7CiAgICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDsKICAgICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfQogICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdzsKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi8KICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7CiAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH0KICAgICAgICAgIGxlZnQgLT0gY29weTsKICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5OwogICAgICAgICAgZG8gewogICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7CiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH0KICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgTElUOgogICAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgbGVmdC0tOwogICAgICAgICAgc3RhdGUubW9kZSA9IExFTjsKICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgQ0hFQ0s6CiAgICAgICAgICBpZiAoc3RhdGUud3JhcCkgewogICAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7CiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkCiAgICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgICAgX291dCAtPSBsZWZ0OwogICAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0OwogICAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0OwogICAgICAgICAgICBpZiAoX291dCkgewogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9CiAgICAgICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqLwogICAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTsKCiAgICAgICAgICAgIH0KICAgICAgICAgICAgX291dCA9IGxlZnQ7CiAgICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vCiAgICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7CiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snOwogICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTsKICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAvLz09PS8vCiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxuIikpOwogICAgICAgICAgfQogICAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIExFTkdUSDoKICAgICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7CiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsKICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHsKICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJzsKICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7CiAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXG4iKSk7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIERPTkU6CiAgICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQkMTsKICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICBjYXNlIEJBRDoKICAgICAgICAgIHJldCA9IFpfREFUQV9FUlJPUiQxOwogICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgIGNhc2UgTUVNOgogICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SJDE7CiAgICAgICAgY2FzZSBTWU5DOgogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsKICAgICAgfQogICAgfQoKICAgIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yICJnb3RvIGluZl9sZWF2ZSIsIGVtdWxhdGVkIHZpYSAiYnJlYWsgaW5mX2xlYXZlIgoKICAgIC8qCiAgICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS4KICAgICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXIKICAgICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLgogICAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLgogICAgICovCgogICAgLy8tLS0gUkVTVE9SRSgpIC0tLQogICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAvLy0tLQoKICAgIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJgogICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCQxKSkpIHsKICAgICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkgOwogICAgfQogICAgX2luIC09IHN0cm0uYXZhaWxfaW47CiAgICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0OwogICAgc3RybS50b3RhbF9pbiArPSBfaW47CiAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0OwogICAgc3RhdGUudG90YWwgKz0gX291dDsKICAgIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHsKICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqLwogICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7CiAgICB9CiAgICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgKwogICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArCiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApOwogICAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCQxKSAmJiByZXQgPT09IFpfT0skMSkgewogICAgICByZXQgPSBaX0JVRl9FUlJPUjsKICAgIH0KICAgIHJldHVybiByZXQ7CiAgfTsKCgogIGNvbnN0IGluZmxhdGVFbmQgPSAoc3RybSkgPT4gewoKICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7CiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOwogICAgfQoKICAgIGxldCBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICBpZiAoc3RhdGUud2luZG93KSB7CiAgICAgIHN0YXRlLndpbmRvdyA9IG51bGw7CiAgICB9CiAgICBzdHJtLnN0YXRlID0gbnVsbDsKICAgIHJldHVybiBaX09LJDE7CiAgfTsKCgogIGNvbnN0IGluZmxhdGVHZXRIZWFkZXIgPSAoc3RybSwgaGVhZCkgPT4gewoKICAgIC8qIGNoZWNrIHN0YXRlICovCiAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH0KICAgIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTsKICAgIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9CgogICAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovCiAgICBzdGF0ZS5oZWFkID0gaGVhZDsKICAgIGhlYWQuZG9uZSA9IGZhbHNlOwogICAgcmV0dXJuIFpfT0skMTsKICB9OwoKCiAgY29uc3QgaW5mbGF0ZVNldERpY3Rpb25hcnkgPSAoc3RybSwgZGljdGlvbmFyeSkgPT4gewogICAgY29uc3QgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoOwoKICAgIGxldCBzdGF0ZTsKICAgIGxldCBkaWN0aWQ7CiAgICBsZXQgcmV0OwoKICAgIC8qIGNoZWNrIHN0YXRlICovCiAgICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfQogICAgc3RhdGUgPSBzdHJtLnN0YXRlOwoKICAgIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHsKICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7CiAgICB9CgogICAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovCiAgICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkgewogICAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi8KICAgICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqLwogICAgICBkaWN0aWQgPSBhZGxlcjMyXzEoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTsKICAgICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHsKICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SJDE7CiAgICAgIH0KICAgIH0KICAgIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlCiAgICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqLwogICAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpOwogICAgaWYgKHJldCkgewogICAgICBzdGF0ZS5tb2RlID0gTUVNOwogICAgICByZXR1cm4gWl9NRU1fRVJST1IkMTsKICAgIH0KICAgIHN0YXRlLmhhdmVkaWN0ID0gMTsKICAgIC8vIFRyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxuIikpOwogICAgcmV0dXJuIFpfT0skMTsKICB9OwoKCiAgdmFyIGluZmxhdGVSZXNldF8xID0gaW5mbGF0ZVJlc2V0OwogIHZhciBpbmZsYXRlUmVzZXQyXzEgPSBpbmZsYXRlUmVzZXQyOwogIHZhciBpbmZsYXRlUmVzZXRLZWVwXzEgPSBpbmZsYXRlUmVzZXRLZWVwOwogIHZhciBpbmZsYXRlSW5pdF8xID0gaW5mbGF0ZUluaXQ7CiAgdmFyIGluZmxhdGVJbml0Ml8xID0gaW5mbGF0ZUluaXQyOwogIHZhciBpbmZsYXRlXzIkMSA9IGluZmxhdGUkMjsKICB2YXIgaW5mbGF0ZUVuZF8xID0gaW5mbGF0ZUVuZDsKICB2YXIgaW5mbGF0ZUdldEhlYWRlcl8xID0gaW5mbGF0ZUdldEhlYWRlcjsKICB2YXIgaW5mbGF0ZVNldERpY3Rpb25hcnlfMSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5OwogIHZhciBpbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJzsKCiAgLyogTm90IGltcGxlbWVudGVkCiAgbW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTsKICBtb2R1bGUuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5OwogIG1vZHVsZS5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7CiAgbW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lOwogIG1vZHVsZS5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7CiAgbW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7CiAgbW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7CiAgKi8KCiAgdmFyIGluZmxhdGVfMSQyID0gewogIAlpbmZsYXRlUmVzZXQ6IGluZmxhdGVSZXNldF8xLAogIAlpbmZsYXRlUmVzZXQyOiBpbmZsYXRlUmVzZXQyXzEsCiAgCWluZmxhdGVSZXNldEtlZXA6IGluZmxhdGVSZXNldEtlZXBfMSwKICAJaW5mbGF0ZUluaXQ6IGluZmxhdGVJbml0XzEsCiAgCWluZmxhdGVJbml0MjogaW5mbGF0ZUluaXQyXzEsCiAgCWluZmxhdGU6IGluZmxhdGVfMiQxLAogIAlpbmZsYXRlRW5kOiBpbmZsYXRlRW5kXzEsCiAgCWluZmxhdGVHZXRIZWFkZXI6IGluZmxhdGVHZXRIZWFkZXJfMSwKICAJaW5mbGF0ZVNldERpY3Rpb25hcnk6IGluZmxhdGVTZXREaWN0aW9uYXJ5XzEsCiAgCWluZmxhdGVJbmZvOiBpbmZsYXRlSW5mbwogIH07CgogIC8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlcgogIC8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luCiAgLy8KICAvLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZAogIC8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcwogIC8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuCiAgLy8KICAvLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwKICAvLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0CiAgLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOgogIC8vCiAgLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QKICAvLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlCiAgLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUKICAvLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuCiAgLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUKICAvLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4KICAvLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLgoKICBmdW5jdGlvbiBHWmhlYWRlcigpIHsKICAgIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi8KICAgIHRoaXMudGV4dCAgICAgICA9IDA7CiAgICAvKiBtb2RpZmljYXRpb24gdGltZSAqLwogICAgdGhpcy50aW1lICAgICAgID0gMDsKICAgIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovCiAgICB0aGlzLnhmbGFncyAgICAgPSAwOwogICAgLyogb3BlcmF0aW5nIHN5c3RlbSAqLwogICAgdGhpcy5vcyAgICAgICAgID0gMDsKICAgIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi8KICAgIHRoaXMuZXh0cmEgICAgICA9IG51bGw7CiAgICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi8KICAgIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLAogICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zCgogICAgLy8KICAgIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkKICAgIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlcwogICAgLy8KCiAgICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqLwogICAgLy8gdGhpcy5leHRyYV9tYXggID0gMDsKICAgIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi8KICAgIHRoaXMubmFtZSAgICAgICA9ICcnOwogICAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqLwogICAgLy8gdGhpcy5uYW1lX21heCAgID0gMDsKICAgIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovCiAgICB0aGlzLmNvbW1lbnQgICAgPSAnJzsKICAgIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi8KICAgIC8vIHRoaXMuY29tbV9tYXggICA9IDA7CiAgICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqLwogICAgdGhpcy5oY3JjICAgICAgID0gMDsKICAgIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi8KICAgIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlOwogIH0KCiAgdmFyIGd6aGVhZGVyID0gR1poZWFkZXI7CgogIGNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzsKCiAgLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki8KICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qLwoKICBjb25zdCB7CiAgICBaX05PX0ZMVVNILCBaX0ZJTklTSCwKICAgIFpfT0ssIFpfU1RSRUFNX0VORCwgWl9ORUVEX0RJQ1QsIFpfU1RSRUFNX0VSUk9SLCBaX0RBVEFfRVJST1IsIFpfTUVNX0VSUk9SCiAgfSA9IGNvbnN0YW50cyQyOwoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qLwoKCiAgLyoqCiAgICogY2xhc3MgSW5mbGF0ZQogICAqCiAgICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZAogICAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXQogICAqIGFuZCBbW2luZmxhdGVSYXddXS4KICAgKiovCgogIC8qIGludGVybmFsCiAgICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXkKICAgKgogICAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLgogICAqKi8KCiAgLyoqCiAgICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxTdHJpbmcKICAgKgogICAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXQogICAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmsKICAgKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkuCiAgICoqLwoKICAvKioKICAgKiBJbmZsYXRlLmVyciAtPiBOdW1iZXIKICAgKgogICAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy4KICAgKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS4KICAgKiovCgogIC8qKgogICAqIEluZmxhdGUubXNnIC0+IFN0cmluZwogICAqCiAgICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDAKICAgKiovCgoKICAvKioKICAgKiBuZXcgSW5mbGF0ZShvcHRpb25zKQogICAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuCiAgICoKICAgKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb24KICAgKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczoKICAgKgogICAqIC0gYHdpbmRvd0JpdHNgCiAgICogLSBgZGljdGlvbmFyeWAKICAgKgogICAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZCkKICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS4KICAgKgogICAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOgogICAqCiAgICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdCkKICAgKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlCiAgICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkCiAgICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwKICAgKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LgogICAqCiAgICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhCiAgICogd3JhcHBlciBoZWFkZXIuCiAgICoKICAgKiAjIyMjIyBFeGFtcGxlOgogICAqCiAgICogYGBgamF2YXNjcmlwdAogICAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJykKICAgKiBjb25zdCBjaHVuazEgPSBuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKQogICAqIGNvbnN0IGNodW5rMiA9IG5ldyBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pOwogICAqCiAgICogY29uc3QgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pOwogICAqCiAgICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpOwogICAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rCiAgICoKICAgKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfQogICAqCiAgICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpOwogICAqIGBgYAogICAqKi8KICBmdW5jdGlvbiBJbmZsYXRlJDEob3B0aW9ucykgewogICAgdGhpcy5vcHRpb25zID0gY29tbW9uLmFzc2lnbih7CiAgICAgIGNodW5rU2l6ZTogMTAyNCAqIDY0LAogICAgICB3aW5kb3dCaXRzOiAxNSwKICAgICAgdG86ICcnCiAgICB9LCBvcHRpb25zIHx8IHt9KTsKCiAgICBjb25zdCBvcHQgPSB0aGlzLm9wdGlvbnM7CgogICAgLy8gRm9yY2Ugd2luZG93IHNpemUgZm9yIGByYXdgIGRhdGEsIGlmIG5vdCBzZXQgZGlyZWN0bHksCiAgICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LgogICAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkgewogICAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0czsKICAgICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9CiAgICB9CgogICAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZQogICAgaWYgKChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikgJiYKICAgICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkgewogICAgICBvcHQud2luZG93Qml0cyArPSAzMjsKICAgIH0KCiAgICAvLyBHemlwIGhlYWRlciBoYXMgbm8gaW5mbyBhYm91dCB3aW5kb3dzIHNpemUsIHdlIGNhbiBkbyBhdXRvZGV0ZWN0IG9ubHkKICAgIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZQogICAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHsKICAgICAgLy8gYml0IDMgKDE2KSAtPiBnemlwcGVkIGRhdGEKICAgICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZQogICAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7CiAgICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7CiAgICAgIH0KICAgIH0KCiAgICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spCiAgICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZQogICAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxscwogICAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGEKCiAgICB0aGlzLnN0cm0gICA9IG5ldyB6c3RyZWFtKCk7CiAgICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDsKCiAgICBsZXQgc3RhdHVzICA9IGluZmxhdGVfMSQyLmluZmxhdGVJbml0MigKICAgICAgdGhpcy5zdHJtLAogICAgICBvcHQud2luZG93Qml0cwogICAgKTsKCiAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTsKICAgIH0KCiAgICB0aGlzLmhlYWRlciA9IG5ldyBnemhlYWRlcigpOwoKICAgIGluZmxhdGVfMSQyLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7CgogICAgLy8gU2V0dXAgZGljdGlvbmFyeQogICAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7CiAgICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWQKICAgICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHsKICAgICAgICBvcHQuZGljdGlvbmFyeSA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7CiAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHsKICAgICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgfQogICAgICBpZiAob3B0LnJhdykgeyAvL0luIHJhdyBtb2RlIHdlIG5lZWQgdG8gc2V0IHRoZSBkaWN0aW9uYXJ5IGVhcmx5CiAgICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7CiAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0KCiAgLyoqCiAgICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBmbHVzaF9tb2RlXSkgLT4gQm9vbGVhbgogICAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcik6IGlucHV0IGRhdGEKICAgKiAtIGZsdXNoX21vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUKICAgKiAgIGZsdXNoIG1vZGVzLiBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwKICAgKiAgIGB0cnVlYCBtZWFucyBaX0ZJTklTSC4KICAgKgogICAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoCiAgICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIElmIGVuZCBvZiBzdHJlYW0gZGV0ZWN0ZWQsCiAgICogW1tJbmZsYXRlI29uRW5kXV0gd2lsbCBiZSBjYWxsZWQuCiAgICoKICAgKiBgZmx1c2hfbW9kZWAgaXMgbm90IG5lZWRlZCBmb3Igbm9ybWFsIG9wZXJhdGlvbiwgYmVjYXVzZSBlbmQgb2Ygc3RyZWFtCiAgICogZGV0ZWN0ZWQgYXV0b21hdGljYWxseS4gWW91IG1heSB0cnkgdG8gdXNlIGl0IGZvciBhZHZhbmNlZCB0aGluZ3MsIGJ1dAogICAqIHRoaXMgZnVuY3Rpb25hbGl0eSB3YXMgbm90IHRlc3RlZC4KICAgKgogICAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS4KICAgKgogICAqICMjIyMjIEV4YW1wbGUKICAgKgogICAqIGBgYGphdmFzY3JpcHQKICAgKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzCiAgICogLi4uCiAgICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmsKICAgKiBgYGAKICAgKiovCiAgSW5mbGF0ZSQxLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZsdXNoX21vZGUpIHsKICAgIGNvbnN0IHN0cm0gPSB0aGlzLnN0cm07CiAgICBjb25zdCBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgY29uc3QgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5OwogICAgbGV0IHN0YXR1cywgX2ZsdXNoX21vZGUsIGxhc3RfYXZhaWxfb3V0OwoKICAgIGlmICh0aGlzLmVuZGVkKSByZXR1cm4gZmFsc2U7CgogICAgaWYgKGZsdXNoX21vZGUgPT09IH5+Zmx1c2hfbW9kZSkgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlOwogICAgZWxzZSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7CgogICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZAogICAgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHsKICAgICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpOwogICAgfSBlbHNlIHsKICAgICAgc3RybS5pbnB1dCA9IGRhdGE7CiAgICB9CgogICAgc3RybS5uZXh0X2luID0gMDsKICAgIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDsKCiAgICBmb3IgKDs7KSB7CiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtTaXplKTsKICAgICAgICBzdHJtLm5leHRfb3V0ID0gMDsKICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTsKICAgICAgfQoKICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7CgogICAgICBpZiAoc3RhdHVzID09PSBaX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7CiAgICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSk7CgogICAgICAgIGlmIChzdGF0dXMgPT09IFpfT0spIHsKICAgICAgICAgIHN0YXR1cyA9IGluZmxhdGVfMSQyLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpOwogICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBaX0RBVEFfRVJST1IpIHsKICAgICAgICAgIC8vIFJlcGxhY2UgY29kZSB3aXRoIG1vcmUgdmVyYm9zZQogICAgICAgICAgc3RhdHVzID0gWl9ORUVEX0RJQ1Q7CiAgICAgICAgfQogICAgICB9CgogICAgICAvLyBTa2lwIHNueWMgbWFya2VycyBpZiBtb3JlIGRhdGEgZm9sbG93cyBhbmQgbm90IHJhdyBtb2RlCiAgICAgIHdoaWxlIChzdHJtLmF2YWlsX2luID4gMCAmJgogICAgICAgICAgICAgc3RhdHVzID09PSBaX1NUUkVBTV9FTkQgJiYKICAgICAgICAgICAgIHN0cm0uc3RhdGUud3JhcCA+IDAgJiYKICAgICAgICAgICAgIGRhdGFbc3RybS5uZXh0X2luXSAhPT0gMCkKICAgICAgewogICAgICAgIGluZmxhdGVfMSQyLmluZmxhdGVSZXNldChzdHJtKTsKICAgICAgICBzdGF0dXMgPSBpbmZsYXRlXzEkMi5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTsKICAgICAgfQoKICAgICAgc3dpdGNoIChzdGF0dXMpIHsKICAgICAgICBjYXNlIFpfU1RSRUFNX0VSUk9SOgogICAgICAgIGNhc2UgWl9EQVRBX0VSUk9SOgogICAgICAgIGNhc2UgWl9ORUVEX0RJQ1Q6CiAgICAgICAgY2FzZSBaX01FTV9FUlJPUjoKICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlOwogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICAvLyBSZW1lbWJlciByZWFsIGBhdmFpbF9vdXRgIHZhbHVlLCBiZWNhdXNlIHdlIG1heSBwYXRjaCBvdXQgYnVmZmVyIGNvbnRlbnQKICAgICAgLy8gdG8gYWxpZ24gdXRmOCBzdHJpbmdzIGJvdW5kYXJpZXMuCiAgICAgIGxhc3RfYXZhaWxfb3V0ID0gc3RybS5hdmFpbF9vdXQ7CgogICAgICBpZiAoc3RybS5uZXh0X291dCkgewogICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IFpfU1RSRUFNX0VORCkgewoKICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7CgogICAgICAgICAgICBsZXQgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7CgogICAgICAgICAgICBsZXQgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4OwogICAgICAgICAgICBsZXQgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7CgogICAgICAgICAgICAvLyBtb3ZlIHRhaWwgJiByZWFsaWduIGNvdW50ZXJzCiAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsOwogICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7CiAgICAgICAgICAgIGlmICh0YWlsKSBzdHJtLm91dHB1dC5zZXQoc3RybS5vdXRwdXQuc3ViYXJyYXkobmV4dF9vdXRfdXRmOCwgbmV4dF9vdXRfdXRmOCArIHRhaWwpLCAwKTsKCiAgICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpOwoKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0Lmxlbmd0aCA9PT0gc3RybS5uZXh0X291dCA/IHN0cm0ub3V0cHV0IDogc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgLy8gTXVzdCByZXBlYXQgaXRlcmF0aW9uIGlmIG91dCBidWZmZXIgaXMgZnVsbAogICAgICBpZiAoc3RhdHVzID09PSBaX09LICYmIGxhc3RfYXZhaWxfb3V0ID09PSAwKSBjb250aW51ZTsKCiAgICAgIC8vIEZpbmFsaXplIGlmIGVuZCBvZiBzdHJlYW0gcmVhY2hlZC4KICAgICAgaWYgKHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EKSB7CiAgICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pOwogICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQoKICAgICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDApIGJyZWFrOwogICAgfQoKICAgIHJldHVybiB0cnVlOwogIH07CgoKICAvKioKICAgKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZAogICAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsCiAgICogICBlYWNoIGNodW5rIHdpbGwgYmUgc3RyaW5nLgogICAqCiAgICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWUKICAgKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLgogICAqKi8KICBJbmZsYXRlJDEucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykgewogICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7CiAgfTsKCgogIC8qKgogICAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkCiAgICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLAogICAqICAgb3RoZXIgaWYgbm90LgogICAqCiAgICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpcwogICAqIGNvbXBsZXRlIChaX0ZJTklTSCkuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsCiAgICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy4KICAgKiovCiAgSW5mbGF0ZSQxLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHsKICAgIC8vIE9uIHN1Y2Nlc3MgLSBqb2luCiAgICBpZiAoc3RhdHVzID09PSBaX09LKSB7CiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7CiAgICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLnJlc3VsdCA9IGNvbW1vbi5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTsKICAgICAgfQogICAgfQogICAgdGhpcy5jaHVua3MgPSBbXTsKICAgIHRoaXMuZXJyID0gc3RhdHVzOwogICAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnOwogIH07CgoKICAvKioKICAgKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmcKICAgKiAtIGRhdGEgKFVpbnQ4QXJyYXkpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuCiAgICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy4KICAgKgogICAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdAogICAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlCiAgICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLgogICAqCiAgICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOgogICAqCiAgICogLSB3aW5kb3dCaXRzCiAgICoKICAgKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpCiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uCiAgICoKICAgKiBTdWdhciAob3B0aW9ucyk6CiAgICoKICAgKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5CiAgICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuCiAgICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkCiAgICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwKICAgKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LgogICAqCiAgICoKICAgKiAjIyMjIyBFeGFtcGxlOgogICAqCiAgICogYGBgamF2YXNjcmlwdAogICAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJyk7CiAgICogY29uc3QgaW5wdXQgPSBwYWtvLmRlZmxhdGUobmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSkpOwogICAqIGxldCBvdXRwdXQ7CiAgICoKICAgKiB0cnkgewogICAqICAgb3V0cHV0ID0gcGFrby5pbmZsYXRlKGlucHV0KTsKICAgKiB9IGNhdGNoIChlcnIpIHsKICAgKiAgIGNvbnNvbGUubG9nKGVycik7CiAgICogfQogICAqIGBgYAogICAqKi8KICBmdW5jdGlvbiBpbmZsYXRlJDEoaW5wdXQsIG9wdGlvbnMpIHsKICAgIGNvbnN0IGluZmxhdG9yID0gbmV3IEluZmxhdGUkMShvcHRpb25zKTsKCiAgICBpbmZsYXRvci5wdXNoKGlucHV0KTsKCiAgICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KQogICAgaWYgKGluZmxhdG9yLmVycikgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1lc3NhZ2VzW2luZmxhdG9yLmVycl07CgogICAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDsKICB9CgoKICAvKioKICAgKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmcKICAgKiAtIGRhdGEgKFVpbnQ4QXJyYXkpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuCiAgICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy4KICAgKgogICAqIFRoZSBzYW1lIGFzIFtbaW5mbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyCiAgICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLgogICAqKi8KICBmdW5jdGlvbiBpbmZsYXRlUmF3JDEoaW5wdXQsIG9wdGlvbnMpIHsKICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgb3B0aW9ucy5yYXcgPSB0cnVlOwogICAgcmV0dXJuIGluZmxhdGUkMShpbnB1dCwgb3B0aW9ucyk7CiAgfQoKCiAgLyoqCiAgICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmcKICAgKiAtIGRhdGEgKFVpbnQ4QXJyYXkpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuCiAgICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy4KICAgKgogICAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0CiAgICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLgogICAqKi8KCgogIHZhciBJbmZsYXRlXzEkMSA9IEluZmxhdGUkMTsKICB2YXIgaW5mbGF0ZV8yID0gaW5mbGF0ZSQxOwogIHZhciBpbmZsYXRlUmF3XzEkMSA9IGluZmxhdGVSYXckMTsKICB2YXIgdW5nemlwJDEgPSBpbmZsYXRlJDE7CiAgdmFyIGNvbnN0YW50cyA9IGNvbnN0YW50cyQyOwoKICB2YXIgaW5mbGF0ZV8xJDEgPSB7CiAgCUluZmxhdGU6IEluZmxhdGVfMSQxLAogIAlpbmZsYXRlOiBpbmZsYXRlXzIsCiAgCWluZmxhdGVSYXc6IGluZmxhdGVSYXdfMSQxLAogIAl1bmd6aXA6IHVuZ3ppcCQxLAogIAljb25zdGFudHM6IGNvbnN0YW50cwogIH07CgogIGNvbnN0IHsgSW5mbGF0ZSwgaW5mbGF0ZSwgaW5mbGF0ZVJhdywgdW5nemlwIH0gPSBpbmZsYXRlXzEkMTsKICB2YXIgaW5mbGF0ZV8xID0gaW5mbGF0ZTsKCiAgY2xhc3MgRGVmbGF0ZURlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7CiAgICBkZWNvZGVCbG9jayhidWZmZXIpIHsKICAgICAgcmV0dXJuIGluZmxhdGVfMShuZXcgVWludDhBcnJheShidWZmZXIpKS5idWZmZXI7CiAgICB9CiAgfQoKICBjbGFzcyBQYWNrYml0c0RlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7CiAgICBkZWNvZGVCbG9jayhidWZmZXIpIHsKICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTsKICAgICAgY29uc3Qgb3V0ID0gW107CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5ieXRlTGVuZ3RoOyArK2kpIHsKICAgICAgICBsZXQgaGVhZGVyID0gZGF0YVZpZXcuZ2V0SW50OChpKTsKICAgICAgICBpZiAoaGVhZGVyIDwgMCkgewogICAgICAgICAgY29uc3QgbmV4dCA9IGRhdGFWaWV3LmdldFVpbnQ4KGkgKyAxKTsKICAgICAgICAgIGhlYWRlciA9IC1oZWFkZXI7CiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBoZWFkZXI7ICsraikgewogICAgICAgICAgICBvdXQucHVzaChuZXh0KTsKICAgICAgICAgIH0KICAgICAgICAgIGkgKz0gMTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gaGVhZGVyOyArK2opIHsKICAgICAgICAgICAgb3V0LnB1c2goZGF0YVZpZXcuZ2V0VWludDgoaSArIGogKyAxKSk7CiAgICAgICAgICB9CiAgICAgICAgICBpICs9IGhlYWRlciArIDE7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShvdXQpLmJ1ZmZlcjsKICAgIH0KICB9CgogIHZhciBMZXJjRGVjb2RlID0ge2V4cG9ydHM6IHt9fTsKCiAgLyoganNoaW50IGZvcmluOiBmYWxzZSwgYml0d2lzZTogZmFsc2UgKi8KCiAgKGZ1bmN0aW9uIChtb2R1bGUpIHsKICAvKgogIENvcHlyaWdodCAyMDE1LTIwMTggRXNyaQoKICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgogIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoKICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgogIEEgY29weSBvZiB0aGUgbGljZW5zZSBhbmQgYWRkaXRpb25hbCBub3RpY2VzIGFyZSBsb2NhdGVkIHdpdGggdGhlCiAgc291cmNlIGRpc3RyaWJ1dGlvbiBhdDoKCiAgaHR0cDovL2dpdGh1Yi5jb20vRXNyaS9sZXJjLwoKICBDb250cmlidXRvcnM6ICBKb2hhbm5lcyBTY2htaWQsIChMRVJDIHYxKQogICAgICAgICAgICAgICAgIENoYXlhbmlrYSBLaGF0dWEsIChMRVJDIHYxKQogICAgICAgICAgICAgICAgIFdlbnh1ZSBKdSAoTEVSQyB2MSwgdjIueCkKICAqLwoKICAvKiBDb3B5cmlnaHQgMjAxNS0yMDE4IEVzcmkuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAgQHByZXNlcnZlICovCgogIC8qKgogICAqIGEgbW9kdWxlIGZvciBkZWNvZGluZyBMRVJDIGJsb2JzCiAgICogQG1vZHVsZSBMZXJjCiAgICovCiAgKGZ1bmN0aW9uKCkgewogICAgLy90aGUgb3JpZ2luYWwgTGVyY0RlY29kZSBmb3IgVmVyc2lvbiAxCiAgICB2YXIgTGVyY0RlY29kZSA9IChmdW5jdGlvbigpIHsKCiAgICAgIC8vIFdBUk5JTkc6IFRoaXMgZGVjb2RlciB2ZXJzaW9uIGNhbiBvbmx5IHJlYWQgb2xkIHZlcnNpb24gMSBMZXJjIGJsb2JzLiBVc2Ugd2l0aCBjYXV0aW9uLgoKICAgICAgLy8gTm90ZTogY3VycmVudGx5LCB0aGlzIG1vZHVsZSBvbmx5IGhhcyBhbiBpbXBsZW1lbnRhdGlvbiBmb3IgZGVjb2RpbmcgTEVSQyBkYXRhLCBub3QgZW5jb2RpbmcuIFRoZSBuYW1lIG9mCiAgICAgIC8vIHRoZSBjbGFzcyB3YXMgY2hvc2VuIHRvIGJlIGZ1dHVyZSBwcm9vZi4KCiAgICAgIHZhciBDbnRaSW1hZ2UgPSB7fTsKCiAgICAgIENudFpJbWFnZS5kZWZhdWx0Tm9EYXRhVmFsdWUgPSAtMy40MDI3OTk5Mzg3OTAxNDg0ZSszODsgLy8gc21hbGxlc3QgRmxvYXQzMiB2YWx1ZQoKICAgICAgLyoqCiAgICAgICAqIERlY29kZSBhIExFUkMgYnl0ZSBzdHJlYW0gYW5kIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBhbmQgc29tZSByZXF1aXJlZCBhbmQgb3B0aW9uYWwKICAgICAgICogaW5mb3JtYXRpb24gYWJvdXQgaXQsIHN1Y2ggYXMgdGhlIGltYWdlJ3Mgd2lkdGggYW5kIGhlaWdodC4KICAgICAgICoKICAgICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gaW5wdXQgVGhlIExFUkMgaW5wdXQgYnl0ZSBzdHJlYW0KICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBEZWNvZGluZyBvcHRpb25zLCBjb250YWluaW5nIGFueSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6CiAgICAgICAqIEBjb25maWcge251bWJlcn0gW2lucHV0T2Zmc2V0ID0gMF0KICAgICAgICogICAgICAgIFNraXAgdGhlIGZpcnN0IGlucHV0T2Zmc2V0IGJ5dGVzIG9mIHRoZSBpbnB1dCBieXRlIHN0cmVhbS4gQSB2YWxpZCBMRVJDIGZpbGUgaXMgZXhwZWN0ZWQgYXQgdGhhdCBwb3NpdGlvbi4KICAgICAgICogQGNvbmZpZyB7VWludDhBcnJheX0gW2VuY29kZWRNYXNrID0gbnVsbF0KICAgICAgICogICAgICAgIElmIHNwZWNpZmllZCwgdGhlIGRlY29kZXIgd2lsbCBub3QgcmVhZCBtYXNrIGluZm9ybWF0aW9uIGZyb20gdGhlIGlucHV0IGFuZCB1c2UgdGhlIHNwZWNpZmllZCBlbmNvZGVkCiAgICAgICAqICAgICAgICBtYXNrIGRhdGEgaW5zdGVhZC4gTWFzayBoZWFkZXIvZGF0YSBtdXN0IG5vdCBiZSBwcmVzZW50IGluIHRoZSBMRVJDIGJ5dGUgc3RyZWFtIGluIHRoaXMgY2FzZS4KICAgICAgICogQGNvbmZpZyB7bnVtYmVyfSBbbm9EYXRhVmFsdWUgPSBMZXJjQ29kZS5kZWZhdWx0Tm9EYXRhVmFsdWVdCiAgICAgICAqICAgICAgICBQaXhlbCB2YWx1ZSB0byB1c2UgZm9yIG1hc2tlZCBwaXhlbHMuCiAgICAgICAqIEBjb25maWcge0FycmF5QnVmZmVyVmlld3xBcnJheX0gW3BpeGVsVHlwZSA9IEZsb2F0MzJBcnJheV0KICAgICAgICogICAgICAgIFRoZSBkZXNpcmVkIHR5cGUgb2YgdGhlIHBpeGVsRGF0YSBhcnJheSBpbiB0aGUgcmV0dXJuIHZhbHVlLiBOb3RlIHRoYXQgaXQgaXMgdGhlIGNhbGxlcidzIHJlc3BvbnNpYmlsaXR5IHRvCiAgICAgICAqICAgICAgICBwcm92aWRlIGFuIGFwcHJvcHJpYXRlIG5vRGF0YVZhbHVlIGlmIHRoZSBkZWZhdWx0IHBpeGVsVHlwZSBpcyBvdmVycmlkZGVuLgogICAgICAgKiBAY29uZmlnIHtib29sZWFufSBbcmV0dXJuTWFzayA9IGZhbHNlXQogICAgICAgKiAgICAgICAgSWYgdHJ1ZSwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGNvbnRhaW4gYSBtYXNrRGF0YSBwcm9wZXJ0eSBvZiB0eXBlIFVpbnQ4QXJyYXkgd2hpY2ggaGFzIG9uZSBlbGVtZW50IHBlcgogICAgICAgKiAgICAgICAgcGl4ZWwsIHRoZSB2YWx1ZSBvZiB3aGljaCBpcyAxIG9yIDAgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhhdCBwaXhlbCdzIGRhdGEgaXMgcHJlc2VudCBvciBtYXNrZWQuIElmIHRoZQogICAgICAgKiAgICAgICAgaW5wdXQgTEVSQyBkYXRhIGRvZXMgbm90IGNvbnRhaW4gYSBtYXNrLCBtYXNrRGF0YSB3aWxsIG5vdCBiZSByZXR1cm5lZC4KICAgICAgICogQGNvbmZpZyB7Ym9vbGVhbn0gW3JldHVybkVuY29kZWRNYXNrID0gZmFsc2VdCiAgICAgICAqICAgICAgICBJZiB0cnVlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgY29udGFpbiBhIGVuY29kZWRNYXNrRGF0YSBwcm9wZXJ0eSwgd2hpY2ggY2FuIGJlIHBhc3NlZCBpbnRvIGVuY29kZSgpIGFzCiAgICAgICAqICAgICAgICBlbmNvZGVkTWFzay4KICAgICAgICogQGNvbmZpZyB7Ym9vbGVhbn0gW3JldHVybkZpbGVJbmZvID0gZmFsc2VdCiAgICAgICAqICAgICAgICBJZiB0cnVlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgaGF2ZSBhIGZpbGVJbmZvIHByb3BlcnR5IHRoYXQgY29udGFpbnMgbWV0YWRhdGEgb2J0YWluZWQgZnJvbSB0aGUKICAgICAgICogICAgICAgIExFUkMgaGVhZGVycyBhbmQgdGhlIGRlY29kaW5nIHByb2Nlc3MuCiAgICAgICAqIEBjb25maWcge2Jvb2xlYW59IFtjb21wdXRlVXNlZEJpdERlcHRocyA9IGZhbHNlXQogICAgICAgKiAgICAgICAgSWYgdHJ1ZSwgdGhlIGZpbGVJbmZvIHByb3BlcnR5IGluIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBjb250YWluIHRoZSBzZXQgb2YgYWxsIGJsb2NrIGJpdCBkZXB0aHMKICAgICAgICogICAgICAgIGVuY291bnRlcmVkIGR1cmluZyBkZWNvZGluZy4gV2lsbCBvbmx5IGhhdmUgYW4gZWZmZWN0IGlmIHJldHVybkZpbGVJbmZvIG9wdGlvbiBpcyB0cnVlLgogICAgICAgKiBAcmV0dXJucyB7e3dpZHRoLCBoZWlnaHQsIHBpeGVsRGF0YSwgbWluVmFsdWUsIG1heFZhbHVlLCBub0RhdGFWYWx1ZSwgbWFza0RhdGEsIGVuY29kZWRNYXNrRGF0YSwgZmlsZUluZm99fQogICAgICAgKi8KICAgICAgQ250WkltYWdlLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CgogICAgICAgIHZhciBza2lwTWFzayA9IG9wdGlvbnMuZW5jb2RlZE1hc2tEYXRhIHx8IChvcHRpb25zLmVuY29kZWRNYXNrRGF0YSA9PT0gbnVsbCk7CiAgICAgICAgdmFyIHBhcnNlZERhdGEgPSBwYXJzZShpbnB1dCwgb3B0aW9ucy5pbnB1dE9mZnNldCB8fCAwLCBza2lwTWFzayk7CgogICAgICAgIHZhciBub0RhdGFWYWx1ZSA9IChvcHRpb25zLm5vRGF0YVZhbHVlICE9PSBudWxsKSA/IG9wdGlvbnMubm9EYXRhVmFsdWUgOiBDbnRaSW1hZ2UuZGVmYXVsdE5vRGF0YVZhbHVlOwoKICAgICAgICB2YXIgdW5jb21wcmVzc2VkRGF0YSA9IHVuY29tcHJlc3NQaXhlbFZhbHVlcyhwYXJzZWREYXRhLCBvcHRpb25zLnBpeGVsVHlwZSB8fCBGbG9hdDMyQXJyYXksCiAgICAgICAgICBvcHRpb25zLmVuY29kZWRNYXNrRGF0YSwgbm9EYXRhVmFsdWUsIG9wdGlvbnMucmV0dXJuTWFzayk7CgogICAgICAgIHZhciByZXN1bHQgPSB7CiAgICAgICAgICB3aWR0aDogcGFyc2VkRGF0YS53aWR0aCwKICAgICAgICAgIGhlaWdodDogcGFyc2VkRGF0YS5oZWlnaHQsCiAgICAgICAgICBwaXhlbERhdGE6IHVuY29tcHJlc3NlZERhdGEucmVzdWx0UGl4ZWxzLAogICAgICAgICAgbWluVmFsdWU6IHVuY29tcHJlc3NlZERhdGEubWluVmFsdWUsCiAgICAgICAgICBtYXhWYWx1ZTogcGFyc2VkRGF0YS5waXhlbHMubWF4VmFsdWUsCiAgICAgICAgICBub0RhdGFWYWx1ZTogbm9EYXRhVmFsdWUKICAgICAgICB9OwoKICAgICAgICBpZiAodW5jb21wcmVzc2VkRGF0YS5yZXN1bHRNYXNrKSB7CiAgICAgICAgICByZXN1bHQubWFza0RhdGEgPSB1bmNvbXByZXNzZWREYXRhLnJlc3VsdE1hc2s7CiAgICAgICAgfQoKICAgICAgICBpZiAob3B0aW9ucy5yZXR1cm5FbmNvZGVkTWFzayAmJiBwYXJzZWREYXRhLm1hc2spIHsKICAgICAgICAgIHJlc3VsdC5lbmNvZGVkTWFza0RhdGEgPSBwYXJzZWREYXRhLm1hc2suYml0c2V0ID8gcGFyc2VkRGF0YS5tYXNrLmJpdHNldCA6IG51bGw7CiAgICAgICAgfQoKICAgICAgICBpZiAob3B0aW9ucy5yZXR1cm5GaWxlSW5mbykgewogICAgICAgICAgcmVzdWx0LmZpbGVJbmZvID0gZm9ybWF0RmlsZUluZm8ocGFyc2VkRGF0YSk7CiAgICAgICAgICBpZiAob3B0aW9ucy5jb21wdXRlVXNlZEJpdERlcHRocykgewogICAgICAgICAgICByZXN1bHQuZmlsZUluZm8uYml0RGVwdGhzID0gY29tcHV0ZVVzZWRCaXREZXB0aHMocGFyc2VkRGF0YSk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9OwoKICAgICAgdmFyIHVuY29tcHJlc3NQaXhlbFZhbHVlcyA9IGZ1bmN0aW9uKGRhdGEsIFR5cGVkQXJyYXlDbGFzcywgbWFza0JpdHNldCwgbm9EYXRhVmFsdWUsIHN0b3JlRGVjb2RlZE1hc2spIHsKICAgICAgICB2YXIgYmxvY2tJZHggPSAwOwogICAgICAgIHZhciBudW1YID0gZGF0YS5waXhlbHMubnVtQmxvY2tzWDsKICAgICAgICB2YXIgbnVtWSA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1k7CiAgICAgICAgdmFyIGJsb2NrV2lkdGggPSBNYXRoLmZsb29yKGRhdGEud2lkdGggLyBudW1YKTsKICAgICAgICB2YXIgYmxvY2tIZWlnaHQgPSBNYXRoLmZsb29yKGRhdGEuaGVpZ2h0IC8gbnVtWSk7CiAgICAgICAgdmFyIHNjYWxlID0gMiAqIGRhdGEubWF4WkVycm9yOwogICAgICAgIHZhciBtaW5WYWx1ZSA9IE51bWJlci5NQVhfVkFMVUUsIGN1cnJlbnRWYWx1ZTsKICAgICAgICBtYXNrQml0c2V0ID0gbWFza0JpdHNldCB8fCAoKGRhdGEubWFzaykgPyBkYXRhLm1hc2suYml0c2V0IDogbnVsbCk7CgogICAgICAgIHZhciByZXN1bHRQaXhlbHMsIHJlc3VsdE1hc2s7CiAgICAgICAgcmVzdWx0UGl4ZWxzID0gbmV3IFR5cGVkQXJyYXlDbGFzcyhkYXRhLndpZHRoICogZGF0YS5oZWlnaHQpOwogICAgICAgIGlmIChzdG9yZURlY29kZWRNYXNrICYmIG1hc2tCaXRzZXQpIHsKICAgICAgICAgIHJlc3VsdE1hc2sgPSBuZXcgVWludDhBcnJheShkYXRhLndpZHRoICogZGF0YS5oZWlnaHQpOwogICAgICAgIH0KICAgICAgICB2YXIgYmxvY2tEYXRhQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShibG9ja1dpZHRoICogYmxvY2tIZWlnaHQpOwoKICAgICAgICB2YXIgeHgsIHl5OwogICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDw9IG51bVk7IHkrKykgewogICAgICAgICAgdmFyIHRoaXNCbG9ja0hlaWdodCA9ICh5ICE9PSBudW1ZKSA/IGJsb2NrSGVpZ2h0IDogKGRhdGEuaGVpZ2h0ICUgbnVtWSk7CiAgICAgICAgICBpZiAodGhpc0Jsb2NrSGVpZ2h0ID09PSAwKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPD0gbnVtWDsgeCsrKSB7CiAgICAgICAgICAgIHZhciB0aGlzQmxvY2tXaWR0aCA9ICh4ICE9PSBudW1YKSA/IGJsb2NrV2lkdGggOiAoZGF0YS53aWR0aCAlIG51bVgpOwogICAgICAgICAgICBpZiAodGhpc0Jsb2NrV2lkdGggPT09IDApIHsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmFyIG91dFB0ciA9IHkgKiBkYXRhLndpZHRoICogYmxvY2tIZWlnaHQgKyB4ICogYmxvY2tXaWR0aDsKICAgICAgICAgICAgdmFyIG91dFN0cmlkZSA9IGRhdGEud2lkdGggLSB0aGlzQmxvY2tXaWR0aDsKCiAgICAgICAgICAgIHZhciBibG9jayA9IGRhdGEucGl4ZWxzLmJsb2Nrc1tibG9ja0lkeF07CgogICAgICAgICAgICB2YXIgYmxvY2tEYXRhLCBibG9ja1B0ciwgY29uc3RWYWx1ZTsKICAgICAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nIDwgMikgewogICAgICAgICAgICAgIC8vIGJsb2NrIGlzIGVpdGhlciB1bmNvbXByZXNzZWQgb3IgYml0LXN0dWZmZWQgKGVuY29kaW5ncyAwIGFuZCAxKQogICAgICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMCkgewogICAgICAgICAgICAgICAgLy8gYmxvY2sgaXMgdW5jb21wcmVzc2VkCiAgICAgICAgICAgICAgICBibG9ja0RhdGEgPSBibG9jay5yYXdEYXRhOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAvLyBibG9jayBpcyBiaXQtc3R1ZmZlZAogICAgICAgICAgICAgICAgdW5zdHVmZihibG9jay5zdHVmZmVkRGF0YSwgYmxvY2suYml0c1BlclBpeGVsLCBibG9jay5udW1WYWxpZFBpeGVscywgYmxvY2sub2Zmc2V0LCBzY2FsZSwgYmxvY2tEYXRhQnVmZmVyLCBkYXRhLnBpeGVscy5tYXhWYWx1ZSk7CiAgICAgICAgICAgICAgICBibG9ja0RhdGEgPSBibG9ja0RhdGFCdWZmZXI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJsb2NrUHRyID0gMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmIChibG9jay5lbmNvZGluZyA9PT0gMikgewogICAgICAgICAgICAgIC8vIGJsb2NrIGlzIGFsbCAwCiAgICAgICAgICAgICAgY29uc3RWYWx1ZSA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgLy8gYmxvY2sgaGFzIGNvbnN0YW50IHZhbHVlIChlbmNvZGluZyA9PT0gMykKICAgICAgICAgICAgICBjb25zdFZhbHVlID0gYmxvY2sub2Zmc2V0OwogICAgICAgICAgICB9CgogICAgICAgICAgICB2YXIgbWFza0J5dGU7CiAgICAgICAgICAgIGlmIChtYXNrQml0c2V0KSB7CiAgICAgICAgICAgICAgZm9yICh5eSA9IDA7IHl5IDwgdGhpc0Jsb2NrSGVpZ2h0OyB5eSsrKSB7CiAgICAgICAgICAgICAgICBpZiAob3V0UHRyICYgNykgewogICAgICAgICAgICAgICAgICAvLwogICAgICAgICAgICAgICAgICBtYXNrQnl0ZSA9IG1hc2tCaXRzZXRbb3V0UHRyID4+IDNdOwogICAgICAgICAgICAgICAgICBtYXNrQnl0ZSA8PD0gb3V0UHRyICYgNzsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZvciAoeHggPSAwOyB4eCA8IHRoaXNCbG9ja1dpZHRoOyB4eCsrKSB7CiAgICAgICAgICAgICAgICAgIGlmICghKG91dFB0ciAmIDcpKSB7CiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZCBuZXh0IGJ5dGUgZnJvbSBtYXNrCiAgICAgICAgICAgICAgICAgICAgbWFza0J5dGUgPSBtYXNrQml0c2V0W291dFB0ciA+PiAzXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAobWFza0J5dGUgJiAxMjgpIHsKICAgICAgICAgICAgICAgICAgICAvLyBwaXhlbCBkYXRhIHByZXNlbnQKICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0TWFzaykgewogICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWFza1tvdXRQdHJdID0gMTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gKGJsb2NrLmVuY29kaW5nIDwgMikgPyBibG9ja0RhdGFbYmxvY2tQdHIrK10gOiBjb25zdFZhbHVlOwogICAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gbWluVmFsdWUgPiBjdXJyZW50VmFsdWUgPyBjdXJyZW50VmFsdWUgOiBtaW5WYWx1ZTsKICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gY3VycmVudFZhbHVlOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIC8vIHBpeGVsIGRhdGEgbm90IHByZXNlbnQKICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0TWFzaykgewogICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWFza1tvdXRQdHJdID0gMDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IG5vRGF0YVZhbHVlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIG1hc2tCeXRlIDw8PSAxOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgLy8gbWFzayBub3QgcHJlc2VudCwgc2ltcGx5IGNvcHkgYmxvY2sgb3ZlcgogICAgICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA8IDIpIHsKICAgICAgICAgICAgICAgIC8vIGR1cGxpY2F0aW5nIHRoaXMgY29kZSBibG9jayBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucwogICAgICAgICAgICAgICAgLy8gYmxvY2tEYXRhIGNhc2U6CiAgICAgICAgICAgICAgICBmb3IgKHl5ID0gMDsgeXkgPCB0aGlzQmxvY2tIZWlnaHQ7IHl5KyspIHsKICAgICAgICAgICAgICAgICAgZm9yICh4eCA9IDA7IHh4IDwgdGhpc0Jsb2NrV2lkdGg7IHh4KyspIHsKICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBibG9ja0RhdGFbYmxvY2tQdHIrK107CiAgICAgICAgICAgICAgICAgICAgbWluVmFsdWUgPSBtaW5WYWx1ZSA+IGN1cnJlbnRWYWx1ZSA/IGN1cnJlbnRWYWx1ZSA6IG1pblZhbHVlOwogICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHIrK10gPSBjdXJyZW50VmFsdWU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAvLyBjb25zdFZhbHVlIGNhc2U6CiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IG1pblZhbHVlID4gY29uc3RWYWx1ZSA/IGNvbnN0VmFsdWUgOiBtaW5WYWx1ZTsKICAgICAgICAgICAgICAgIGZvciAoeXkgPSAwOyB5eSA8IHRoaXNCbG9ja0hlaWdodDsgeXkrKykgewogICAgICAgICAgICAgICAgICBmb3IgKHh4ID0gMDsgeHggPCB0aGlzQmxvY2tXaWR0aDsgeHgrKykgewogICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHIrK10gPSBjb25zdFZhbHVlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICgoYmxvY2suZW5jb2RpbmcgPT09IDEpICYmIChibG9ja1B0ciAhPT0gYmxvY2subnVtVmFsaWRQaXhlbHMpKSB7CiAgICAgICAgICAgICAgdGhyb3cgIkJsb2NrIGFuZCBNYXNrIGRvIG5vdCBtYXRjaCI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYmxvY2tJZHgrKzsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIHJldHVybiB7CiAgICAgICAgICByZXN1bHRQaXhlbHM6IHJlc3VsdFBpeGVscywKICAgICAgICAgIHJlc3VsdE1hc2s6IHJlc3VsdE1hc2ssCiAgICAgICAgICBtaW5WYWx1ZTogbWluVmFsdWUKICAgICAgICB9OwogICAgICB9OwoKICAgICAgdmFyIGZvcm1hdEZpbGVJbmZvID0gZnVuY3Rpb24oZGF0YSkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICAiZmlsZUlkZW50aWZpZXJTdHJpbmciOiBkYXRhLmZpbGVJZGVudGlmaWVyU3RyaW5nLAogICAgICAgICAgImZpbGVWZXJzaW9uIjogZGF0YS5maWxlVmVyc2lvbiwKICAgICAgICAgICJpbWFnZVR5cGUiOiBkYXRhLmltYWdlVHlwZSwKICAgICAgICAgICJoZWlnaHQiOiBkYXRhLmhlaWdodCwKICAgICAgICAgICJ3aWR0aCI6IGRhdGEud2lkdGgsCiAgICAgICAgICAibWF4WkVycm9yIjogZGF0YS5tYXhaRXJyb3IsCiAgICAgICAgICAiZW9mT2Zmc2V0IjogZGF0YS5lb2ZPZmZzZXQsCiAgICAgICAgICAibWFzayI6IGRhdGEubWFzayA/IHsKICAgICAgICAgICAgIm51bUJsb2Nrc1giOiBkYXRhLm1hc2subnVtQmxvY2tzWCwKICAgICAgICAgICAgIm51bUJsb2Nrc1kiOiBkYXRhLm1hc2subnVtQmxvY2tzWSwKICAgICAgICAgICAgIm51bUJ5dGVzIjogZGF0YS5tYXNrLm51bUJ5dGVzLAogICAgICAgICAgICAibWF4VmFsdWUiOiBkYXRhLm1hc2subWF4VmFsdWUKICAgICAgICAgIH0gOiBudWxsLAogICAgICAgICAgInBpeGVscyI6IHsKICAgICAgICAgICAgIm51bUJsb2Nrc1giOiBkYXRhLnBpeGVscy5udW1CbG9ja3NYLAogICAgICAgICAgICAibnVtQmxvY2tzWSI6IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1ksCiAgICAgICAgICAgICJudW1CeXRlcyI6IGRhdGEucGl4ZWxzLm51bUJ5dGVzLAogICAgICAgICAgICAibWF4VmFsdWUiOiBkYXRhLnBpeGVscy5tYXhWYWx1ZSwKICAgICAgICAgICAgIm5vRGF0YVZhbHVlIjogZGF0YS5ub0RhdGFWYWx1ZQogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH07CgogICAgICB2YXIgY29tcHV0ZVVzZWRCaXREZXB0aHMgPSBmdW5jdGlvbihkYXRhKSB7CiAgICAgICAgdmFyIG51bUJsb2NrcyA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1ggKiBkYXRhLnBpeGVscy5udW1CbG9ja3NZOwogICAgICAgIHZhciBiaXREZXB0aHMgPSB7fTsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUJsb2NrczsgaSsrKSB7CiAgICAgICAgICB2YXIgYmxvY2sgPSBkYXRhLnBpeGVscy5ibG9ja3NbaV07CiAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPT09IDApIHsKICAgICAgICAgICAgYml0RGVwdGhzLmZsb2F0MzIgPSB0cnVlOwogICAgICAgICAgfSBlbHNlIGlmIChibG9jay5lbmNvZGluZyA9PT0gMSkgewogICAgICAgICAgICBiaXREZXB0aHNbYmxvY2suYml0c1BlclBpeGVsXSA9IHRydWU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBiaXREZXB0aHNbMF0gPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGJpdERlcHRocyk7CiAgICAgIH07CgogICAgICB2YXIgcGFyc2UgPSBmdW5jdGlvbihpbnB1dCwgZnAsIHNraXBNYXNrKSB7CiAgICAgICAgdmFyIGRhdGEgPSB7fTsKCiAgICAgICAgLy8gRmlsZSBoZWFkZXIKICAgICAgICB2YXIgZmlsZUlkVmlldyA9IG5ldyBVaW50OEFycmF5KGlucHV0LCBmcCwgMTApOwogICAgICAgIGRhdGEuZmlsZUlkZW50aWZpZXJTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGZpbGVJZFZpZXcpOwogICAgICAgIGlmIChkYXRhLmZpbGVJZGVudGlmaWVyU3RyaW5nLnRyaW0oKSAhPT0gIkNudFpJbWFnZSIpIHsKICAgICAgICAgIHRocm93ICJVbmV4cGVjdGVkIGZpbGUgaWRlbnRpZmllciBzdHJpbmc6ICIgKyBkYXRhLmZpbGVJZGVudGlmaWVyU3RyaW5nOwogICAgICAgIH0KICAgICAgICBmcCArPSAxMDsKICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZnAsIDI0KTsKICAgICAgICBkYXRhLmZpbGVWZXJzaW9uID0gdmlldy5nZXRJbnQzMigwLCB0cnVlKTsKICAgICAgICBkYXRhLmltYWdlVHlwZSA9IHZpZXcuZ2V0SW50MzIoNCwgdHJ1ZSk7CiAgICAgICAgZGF0YS5oZWlnaHQgPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTsKICAgICAgICBkYXRhLndpZHRoID0gdmlldy5nZXRVaW50MzIoMTIsIHRydWUpOwogICAgICAgIGRhdGEubWF4WkVycm9yID0gdmlldy5nZXRGbG9hdDY0KDE2LCB0cnVlKTsKICAgICAgICBmcCArPSAyNDsKCiAgICAgICAgLy8gTWFzayBIZWFkZXIKICAgICAgICBpZiAoIXNraXBNYXNrKSB7CiAgICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBmcCwgMTYpOwogICAgICAgICAgZGF0YS5tYXNrID0ge307CiAgICAgICAgICBkYXRhLm1hc2subnVtQmxvY2tzWSA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpOwogICAgICAgICAgZGF0YS5tYXNrLm51bUJsb2Nrc1ggPSB2aWV3LmdldFVpbnQzMig0LCB0cnVlKTsKICAgICAgICAgIGRhdGEubWFzay5udW1CeXRlcyA9IHZpZXcuZ2V0VWludDMyKDgsIHRydWUpOwogICAgICAgICAgZGF0YS5tYXNrLm1heFZhbHVlID0gdmlldy5nZXRGbG9hdDMyKDEyLCB0cnVlKTsKICAgICAgICAgIGZwICs9IDE2OwoKICAgICAgICAgIC8vIE1hc2sgRGF0YQogICAgICAgICAgaWYgKGRhdGEubWFzay5udW1CeXRlcyA+IDApIHsKICAgICAgICAgICAgdmFyIGJpdHNldCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChkYXRhLndpZHRoICogZGF0YS5oZWlnaHQgLyA4KSk7CiAgICAgICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCBkYXRhLm1hc2subnVtQnl0ZXMpOwogICAgICAgICAgICB2YXIgY250ID0gdmlldy5nZXRJbnQxNigwLCB0cnVlKTsKICAgICAgICAgICAgdmFyIGlwID0gMiwgb3AgPSAwOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgaWYgKGNudCA+IDApIHsKICAgICAgICAgICAgICAgIHdoaWxlIChjbnQtLSkgeyBiaXRzZXRbb3ArK10gPSB2aWV3LmdldFVpbnQ4KGlwKyspOyB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHZhciB2YWwgPSB2aWV3LmdldFVpbnQ4KGlwKyspOwogICAgICAgICAgICAgICAgY250ID0gLWNudDsKICAgICAgICAgICAgICAgIHdoaWxlIChjbnQtLSkgeyBiaXRzZXRbb3ArK10gPSB2YWw7IH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY250ID0gdmlldy5nZXRJbnQxNihpcCwgdHJ1ZSk7CiAgICAgICAgICAgICAgaXAgKz0gMjsKICAgICAgICAgICAgfSB3aGlsZSAoaXAgPCBkYXRhLm1hc2subnVtQnl0ZXMpOwogICAgICAgICAgICBpZiAoKGNudCAhPT0gLTMyNzY4KSB8fCAob3AgPCBiaXRzZXQubGVuZ3RoKSkgewogICAgICAgICAgICAgIHRocm93ICJVbmV4cGVjdGVkIGVuZCBvZiBtYXNrIFJMRSBlbmNvZGluZyI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZGF0YS5tYXNrLmJpdHNldCA9IGJpdHNldDsKICAgICAgICAgICAgZnAgKz0gZGF0YS5tYXNrLm51bUJ5dGVzOwogICAgICAgICAgfQogICAgICAgICAgZWxzZSBpZiAoKGRhdGEubWFzay5udW1CeXRlcyB8IGRhdGEubWFzay5udW1CbG9ja3NZIHwgZGF0YS5tYXNrLm1heFZhbHVlKSA9PT0gMCkgeyAgLy8gU3BlY2lhbCBjYXNlLCBhbGwgbm9kYXRhCiAgICAgICAgICAgIGRhdGEubWFzay5iaXRzZXQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwoZGF0YS53aWR0aCAqIGRhdGEuaGVpZ2h0IC8gOCkpOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gUGl4ZWwgSGVhZGVyCiAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZnAsIDE2KTsKICAgICAgICBkYXRhLnBpeGVscyA9IHt9OwogICAgICAgIGRhdGEucGl4ZWxzLm51bUJsb2Nrc1kgPSB2aWV3LmdldFVpbnQzMigwLCB0cnVlKTsKICAgICAgICBkYXRhLnBpeGVscy5udW1CbG9ja3NYID0gdmlldy5nZXRVaW50MzIoNCwgdHJ1ZSk7CiAgICAgICAgZGF0YS5waXhlbHMubnVtQnl0ZXMgPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTsKICAgICAgICBkYXRhLnBpeGVscy5tYXhWYWx1ZSA9IHZpZXcuZ2V0RmxvYXQzMigxMiwgdHJ1ZSk7CiAgICAgICAgZnAgKz0gMTY7CgogICAgICAgIHZhciBudW1CbG9ja3NYID0gZGF0YS5waXhlbHMubnVtQmxvY2tzWDsKICAgICAgICB2YXIgbnVtQmxvY2tzWSA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1k7CiAgICAgICAgLy8gdGhlIG51bWJlciBvZiBibG9ja3Mgc3BlY2lmaWVkIGluIHRoZSBoZWFkZXIgZG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgdGhlIGJsb2NrcyBhdCB0aGUgZW5kIG9mCiAgICAgICAgLy8gZWFjaCByb3cvY29sdW1uIHdpdGggYSBzcGVjaWFsIHdpZHRoL2hlaWdodCB0aGF0IG1ha2UgdGhlIGltYWdlIGNvbXBsZXRlIGluIGNhc2UgdGhlIHdpZHRoIGlzIG5vdAogICAgICAgIC8vIGV2ZW5seSBkaXZpc2libGUgYnkgdGhlIG51bWJlciBvZiBibG9ja3MuCiAgICAgICAgdmFyIGFjdHVhbE51bUJsb2Nrc1ggPSBudW1CbG9ja3NYICsgKChkYXRhLndpZHRoICUgbnVtQmxvY2tzWCkgPiAwID8gMSA6IDApOwogICAgICAgIHZhciBhY3R1YWxOdW1CbG9ja3NZID0gbnVtQmxvY2tzWSArICgoZGF0YS5oZWlnaHQgJSBudW1CbG9ja3NZKSA+IDAgPyAxIDogMCk7CiAgICAgICAgZGF0YS5waXhlbHMuYmxvY2tzID0gbmV3IEFycmF5KGFjdHVhbE51bUJsb2Nrc1ggKiBhY3R1YWxOdW1CbG9ja3NZKTsKICAgICAgICB2YXIgYmxvY2tJID0gMDsKICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBhY3R1YWxOdW1CbG9ja3NZOyBibG9ja1krKykgewogICAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgYWN0dWFsTnVtQmxvY2tzWDsgYmxvY2tYKyspIHsKCiAgICAgICAgICAgIC8vIEJsb2NrCiAgICAgICAgICAgIHZhciBzaXplID0gMDsKICAgICAgICAgICAgdmFyIGJ5dGVzTGVmdCA9IGlucHV0LmJ5dGVMZW5ndGggLSBmcDsKICAgICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZnAsIE1hdGgubWluKDEwLCBieXRlc0xlZnQpKTsKICAgICAgICAgICAgdmFyIGJsb2NrID0ge307CiAgICAgICAgICAgIGRhdGEucGl4ZWxzLmJsb2Nrc1tibG9ja0krK10gPSBibG9jazsKICAgICAgICAgICAgdmFyIGhlYWRlckJ5dGUgPSB2aWV3LmdldFVpbnQ4KDApOyBzaXplKys7CiAgICAgICAgICAgIGJsb2NrLmVuY29kaW5nID0gaGVhZGVyQnl0ZSAmIDYzOwogICAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPiAzKSB7CiAgICAgICAgICAgICAgdGhyb3cgIkludmFsaWQgYmxvY2sgZW5jb2RpbmcgKCIgKyBibG9jay5lbmNvZGluZyArICIpIjsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPT09IDIpIHsKICAgICAgICAgICAgICBmcCsrOwogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICgoaGVhZGVyQnl0ZSAhPT0gMCkgJiYgKGhlYWRlckJ5dGUgIT09IDIpKSB7CiAgICAgICAgICAgICAgaGVhZGVyQnl0ZSA+Pj0gNjsKICAgICAgICAgICAgICBibG9jay5vZmZzZXRUeXBlID0gaGVhZGVyQnl0ZTsKICAgICAgICAgICAgICBpZiAoaGVhZGVyQnl0ZSA9PT0gMikgewogICAgICAgICAgICAgICAgYmxvY2sub2Zmc2V0ID0gdmlldy5nZXRJbnQ4KDEpOyBzaXplKys7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJCeXRlID09PSAxKSB7CiAgICAgICAgICAgICAgICBibG9jay5vZmZzZXQgPSB2aWV3LmdldEludDE2KDEsIHRydWUpOyBzaXplICs9IDI7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJCeXRlID09PSAwKSB7CiAgICAgICAgICAgICAgICBibG9jay5vZmZzZXQgPSB2aWV3LmdldEZsb2F0MzIoMSwgdHJ1ZSk7IHNpemUgKz0gNDsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhyb3cgIkludmFsaWQgYmxvY2sgb2Zmc2V0IHR5cGUiOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nID09PSAxKSB7CiAgICAgICAgICAgICAgICBoZWFkZXJCeXRlID0gdmlldy5nZXRVaW50OChzaXplKTsgc2l6ZSsrOwogICAgICAgICAgICAgICAgYmxvY2suYml0c1BlclBpeGVsID0gaGVhZGVyQnl0ZSAmIDYzOwogICAgICAgICAgICAgICAgaGVhZGVyQnl0ZSA+Pj0gNjsKICAgICAgICAgICAgICAgIGJsb2NrLm51bVZhbGlkUGl4ZWxzVHlwZSA9IGhlYWRlckJ5dGU7CiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyQnl0ZSA9PT0gMikgewogICAgICAgICAgICAgICAgICBibG9jay5udW1WYWxpZFBpeGVscyA9IHZpZXcuZ2V0VWludDgoc2l6ZSk7IHNpemUrKzsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyQnl0ZSA9PT0gMSkgewogICAgICAgICAgICAgICAgICBibG9jay5udW1WYWxpZFBpeGVscyA9IHZpZXcuZ2V0VWludDE2KHNpemUsIHRydWUpOyBzaXplICs9IDI7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlckJ5dGUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgYmxvY2subnVtVmFsaWRQaXhlbHMgPSB2aWV3LmdldFVpbnQzMihzaXplLCB0cnVlKTsgc2l6ZSArPSA0OwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgdGhyb3cgIkludmFsaWQgdmFsaWQgcGl4ZWwgY291bnQgdHlwZSI7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZwICs9IHNpemU7CgogICAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPT09IDMpIHsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmFyIGFycmF5QnVmLCBzdG9yZTg7CiAgICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMCkgewogICAgICAgICAgICAgIHZhciBudW1QaXhlbHMgPSAoZGF0YS5waXhlbHMubnVtQnl0ZXMgLSAxKSAvIDQ7CiAgICAgICAgICAgICAgaWYgKG51bVBpeGVscyAhPT0gTWF0aC5mbG9vcihudW1QaXhlbHMpKSB7CiAgICAgICAgICAgICAgICB0aHJvdyAidW5jb21wcmVzc2VkIGJsb2NrIGhhcyBpbnZhbGlkIGxlbmd0aCI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKG51bVBpeGVscyAqIDQpOwogICAgICAgICAgICAgIHN0b3JlOCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmKTsKICAgICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBmcCwgbnVtUGl4ZWxzICogNCkpOwogICAgICAgICAgICAgIHZhciByYXdEYXRhID0gbmV3IEZsb2F0MzJBcnJheShhcnJheUJ1Zik7CiAgICAgICAgICAgICAgYmxvY2sucmF3RGF0YSA9IHJhd0RhdGE7CiAgICAgICAgICAgICAgZnAgKz0gbnVtUGl4ZWxzICogNDsKICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jay5lbmNvZGluZyA9PT0gMSkgewogICAgICAgICAgICAgIHZhciBkYXRhQnl0ZXMgPSBNYXRoLmNlaWwoYmxvY2subnVtVmFsaWRQaXhlbHMgKiBibG9jay5iaXRzUGVyUGl4ZWwgLyA4KTsKICAgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpOwogICAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKGRhdGFXb3JkcyAqIDQpOwogICAgICAgICAgICAgIHN0b3JlOCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmKTsKICAgICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBmcCwgZGF0YUJ5dGVzKSk7CiAgICAgICAgICAgICAgYmxvY2suc3R1ZmZlZERhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWYpOwogICAgICAgICAgICAgIGZwICs9IGRhdGFCeXRlczsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkYXRhLmVvZk9mZnNldCA9IGZwOwogICAgICAgIHJldHVybiBkYXRhOwogICAgICB9OwoKICAgICAgdmFyIHVuc3R1ZmYgPSBmdW5jdGlvbihzcmMsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBvZmZzZXQsIHNjYWxlLCBkZXN0LCBtYXhWYWx1ZSkgewogICAgICAgIHZhciBiaXRNYXNrID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7CiAgICAgICAgdmFyIGkgPSAwLCBvOwogICAgICAgIHZhciBiaXRzTGVmdCA9IDA7CiAgICAgICAgdmFyIG4sIGJ1ZmZlcjsKICAgICAgICB2YXIgbm1heCA9IE1hdGguY2VpbCgobWF4VmFsdWUgLSBvZmZzZXQpIC8gc2NhbGUpOwogICAgICAgIC8vIGdldCByaWQgb2YgdHJhaWxpbmcgYnl0ZXMgdGhhdCBhcmUgYWxyZWFkeSBwYXJ0IG9mIG5leHQgYmxvY2sKICAgICAgICB2YXIgbnVtSW52YWxpZFRhaWxCeXRlcyA9IHNyYy5sZW5ndGggKiA0IC0gTWF0aC5jZWlsKGJpdHNQZXJQaXhlbCAqIG51bVBpeGVscyAvIDgpOwogICAgICAgIHNyY1tzcmMubGVuZ3RoIC0gMV0gPDw9IDggKiBudW1JbnZhbGlkVGFpbEJ5dGVzOwoKICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHsKICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkgewogICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTsKICAgICAgICAgICAgYml0c0xlZnQgPSAzMjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHsKICAgICAgICAgICAgbiA9IChidWZmZXIgPj4+IChiaXRzTGVmdCAtIGJpdHNQZXJQaXhlbCkpICYgYml0TWFzazsKICAgICAgICAgICAgYml0c0xlZnQgLT0gYml0c1BlclBpeGVsOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTsKICAgICAgICAgICAgbiA9ICgoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzazsKICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107CiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0czsKICAgICAgICAgICAgbiArPSAoYnVmZmVyID4+PiBiaXRzTGVmdCk7CiAgICAgICAgICB9CiAgICAgICAgICAvL3BpeGVsIHZhbHVlcyBtYXkgZXhjZWVkIG1heCBkdWUgdG8gcXVhbnRpemF0aW9uCiAgICAgICAgICBkZXN0W29dID0gbiA8IG5tYXggPyBvZmZzZXQgKyBuICogc2NhbGUgOiBtYXhWYWx1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRlc3Q7CiAgICAgIH07CgogICAgICByZXR1cm4gQ250WkltYWdlOwogICAgfSkoKTsKCiAgICAvL3ZlcnNpb24gMi4gU3VwcG9ydHMgMi4xLCAyLjIsIDIuMwogICAgdmFyIExlcmMyRGVjb2RlID0gKGZ1bmN0aW9uKCkgewogICAgICAvLyBOb3RlOiBjdXJyZW50bHksIHRoaXMgbW9kdWxlIG9ubHkgaGFzIGFuIGltcGxlbWVudGF0aW9uIGZvciBkZWNvZGluZyBMRVJDIGRhdGEsIG5vdCBlbmNvZGluZy4gVGhlIG5hbWUgb2YKICAgICAgLy8gdGhlIGNsYXNzIHdhcyBjaG9zZW4gdG8gYmUgZnV0dXJlIHByb29mLCBmb2xsb3dpbmcgTGVyY0RlY29kZS4KCiAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgogICAgICAqIHByaXZhdGUgc3RhdGljIGNsYXNzIGJpdHN1dGZmZXIgdXNlZCBieSBMZXJjMkRlY29kZQogICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLwogICAgICB2YXIgQml0U3R1ZmZlciA9IHsKICAgICAgICAvL21ldGhvZHMgZW5kaW5nIHdpdGggMiBhcmUgZm9yIHRoZSBuZXcgYnl0ZSBvcmRlciB1c2VkIGJ5IExlcmMyLjMgYW5kIGFib3ZlLgogICAgICAgIC8vb3JpZ2luYWxVbnN0dWZmIGlzIHVzZWQgdG8gdW5wYWNrIEh1ZmZtYW4gY29kZSB0YWJsZS4gY29kZSBpcyBkdXBsaWNhdGVkIHRvIHVuc3R1ZmZ4IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLgogICAgICAgIHVuc3R1ZmY6IGZ1bmN0aW9uKHNyYywgZGVzdCwgYml0c1BlclBpeGVsLCBudW1QaXhlbHMsIGx1dEFyciwgb2Zmc2V0LCBzY2FsZSwgbWF4VmFsdWUpIHsKICAgICAgICAgIHZhciBiaXRNYXNrID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7CiAgICAgICAgICB2YXIgaSA9IDAsIG87CiAgICAgICAgICB2YXIgYml0c0xlZnQgPSAwOwogICAgICAgICAgdmFyIG4sIGJ1ZmZlciwgbWlzc2luZ0JpdHMsIG5tYXg7CgogICAgICAgICAgLy8gZ2V0IHJpZCBvZiB0cmFpbGluZyBieXRlcyB0aGF0IGFyZSBhbHJlYWR5IHBhcnQgb2YgbmV4dCBibG9jawogICAgICAgICAgdmFyIG51bUludmFsaWRUYWlsQnl0ZXMgPSBzcmMubGVuZ3RoICogNCAtIE1hdGguY2VpbChiaXRzUGVyUGl4ZWwgKiBudW1QaXhlbHMgLyA4KTsKICAgICAgICAgIHNyY1tzcmMubGVuZ3RoIC0gMV0gPDw9IDggKiBudW1JbnZhbGlkVGFpbEJ5dGVzOwogICAgICAgICAgaWYgKGx1dEFycikgewogICAgICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHsKICAgICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHsKICAgICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdOwogICAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkgewogICAgICAgICAgICAgICAgbiA9IChidWZmZXIgPj4+IChiaXRzTGVmdCAtIGJpdHNQZXJQaXhlbCkpICYgYml0TWFzazsKICAgICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7CiAgICAgICAgICAgICAgICBuID0gKChidWZmZXIgJiBiaXRNYXNrKSA8PCBtaXNzaW5nQml0cykgJiBiaXRNYXNrOwogICAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107CiAgICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7CiAgICAgICAgICAgICAgICBuICs9IChidWZmZXIgPj4+IGJpdHNMZWZ0KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZGVzdFtvXSA9IGx1dEFycltuXTsvL29mZnNldCArIGx1dEFycltuXSAqIHNjYWxlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgbm1heCA9IE1hdGguY2VpbCgobWF4VmFsdWUgLSBvZmZzZXQpIC8gc2NhbGUpOwogICAgICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHsKICAgICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHsKICAgICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdOwogICAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkgewogICAgICAgICAgICAgICAgbiA9IChidWZmZXIgPj4+IChiaXRzTGVmdCAtIGJpdHNQZXJQaXhlbCkpICYgYml0TWFzazsKICAgICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7CiAgICAgICAgICAgICAgICBuID0gKChidWZmZXIgJiBiaXRNYXNrKSA8PCBtaXNzaW5nQml0cykgJiBiaXRNYXNrOwogICAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107CiAgICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7CiAgICAgICAgICAgICAgICBuICs9IChidWZmZXIgPj4+IGJpdHNMZWZ0KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgLy9waXhlbCB2YWx1ZXMgbWF5IGV4Y2VlZCBtYXggZHVlIHRvIHF1YW50aXphdGlvbgogICAgICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgdW5zdHVmZkxVVDogZnVuY3Rpb24oc3JjLCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscywgb2Zmc2V0LCBzY2FsZSwgbWF4VmFsdWUpIHsKICAgICAgICAgIHZhciBiaXRNYXNrID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7CiAgICAgICAgICB2YXIgaSA9IDAsIG8gPSAwLCBtaXNzaW5nQml0cyA9IDAsIGJpdHNMZWZ0ID0gMCwgbiA9IDA7CiAgICAgICAgICB2YXIgYnVmZmVyOwogICAgICAgICAgdmFyIGRlc3QgPSBbXTsKCiAgICAgICAgICAvLyBnZXQgcmlkIG9mIHRyYWlsaW5nIGJ5dGVzIHRoYXQgYXJlIGFscmVhZHkgcGFydCBvZiBuZXh0IGJsb2NrCiAgICAgICAgICB2YXIgbnVtSW52YWxpZFRhaWxCeXRlcyA9IHNyYy5sZW5ndGggKiA0IC0gTWF0aC5jZWlsKGJpdHNQZXJQaXhlbCAqIG51bVBpeGVscyAvIDgpOwogICAgICAgICAgc3JjW3NyYy5sZW5ndGggLSAxXSA8PD0gOCAqIG51bUludmFsaWRUYWlsQnl0ZXM7CgogICAgICAgICAgdmFyIG5tYXggPSBNYXRoLmNlaWwoKG1heFZhbHVlIC0gb2Zmc2V0KSAvIHNjYWxlKTsKICAgICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykgewogICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHsKICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTsKICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHsKICAgICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gKGJpdHNMZWZ0IC0gYml0c1BlclBpeGVsKSkgJiBiaXRNYXNrOwogICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7CiAgICAgICAgICAgICAgbiA9ICgoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzazsKICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTsKICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7CiAgICAgICAgICAgICAgbiArPSAoYnVmZmVyID4+PiBiaXRzTGVmdCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy9kZXN0LnB1c2gobik7CiAgICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlOwogICAgICAgICAgfQogICAgICAgICAgZGVzdC51bnNoaWZ0KG9mZnNldCk7Ly8xc3Qgb25lCiAgICAgICAgICByZXR1cm4gZGVzdDsKICAgICAgICB9LAoKICAgICAgICB1bnN0dWZmMjogZnVuY3Rpb24oc3JjLCBkZXN0LCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscywgbHV0QXJyLCBvZmZzZXQsIHNjYWxlLCBtYXhWYWx1ZSkgewogICAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTsKICAgICAgICAgIHZhciBpID0gMCwgbzsKICAgICAgICAgIHZhciBiaXRzTGVmdCA9IDAsIGJpdFBvcyA9IDA7CiAgICAgICAgICB2YXIgbiwgYnVmZmVyLCBtaXNzaW5nQml0czsKICAgICAgICAgIGlmIChsdXRBcnIpIHsKICAgICAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7CiAgICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7CiAgICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTsKICAgICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7CiAgICAgICAgICAgICAgICBiaXRQb3MgPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7CiAgICAgICAgICAgICAgICBuID0gKChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrKTsKICAgICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDsKICAgICAgICAgICAgICAgIGJpdFBvcyArPSBiaXRzUGVyUGl4ZWw7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTsKICAgICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzazsKICAgICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdOwogICAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzOwogICAgICAgICAgICAgICAgbiB8PSAoYnVmZmVyICYgKCgxIDw8IG1pc3NpbmdCaXRzKSAtIDEpKSA8PCAoYml0c1BlclBpeGVsIC0gbWlzc2luZ0JpdHMpOwogICAgICAgICAgICAgICAgYml0UG9zID0gbWlzc2luZ0JpdHM7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGRlc3Rbb10gPSBsdXRBcnJbbl07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgewogICAgICAgICAgICB2YXIgbm1heCA9IE1hdGguY2VpbCgobWF4VmFsdWUgLSBvZmZzZXQpIC8gc2NhbGUpOwogICAgICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHsKICAgICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHsKICAgICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdOwogICAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMjsKICAgICAgICAgICAgICAgIGJpdFBvcyA9IDA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHsKICAgICAgICAgICAgICAgIC8vbm8gdW5zaWduZWQgbGVmdCBzaGlmdAogICAgICAgICAgICAgICAgbiA9ICgoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzayk7CiAgICAgICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7CiAgICAgICAgICAgICAgICBiaXRQb3MgKz0gYml0c1BlclBpeGVsOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7CiAgICAgICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2s7Ly8oKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7CiAgICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTsKICAgICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0czsKICAgICAgICAgICAgICAgIG4gfD0gKGJ1ZmZlciAmICgoMSA8PCBtaXNzaW5nQml0cykgLSAxKSkgPDwgKGJpdHNQZXJQaXhlbCAtIG1pc3NpbmdCaXRzKTsKICAgICAgICAgICAgICAgIGJpdFBvcyA9IG1pc3NpbmdCaXRzOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAvL3BpeGVsIHZhbHVlcyBtYXkgZXhjZWVkIG1heCBkdWUgdG8gcXVhbnRpemF0aW9uCiAgICAgICAgICAgICAgZGVzdFtvXSA9IG4gPCBubWF4ID8gb2Zmc2V0ICsgbiAqIHNjYWxlIDogbWF4VmFsdWU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBkZXN0OwogICAgICAgIH0sCgogICAgICAgIHVuc3R1ZmZMVVQyOiBmdW5jdGlvbihzcmMsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBvZmZzZXQsIHNjYWxlLCBtYXhWYWx1ZSkgewogICAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTsKICAgICAgICAgIHZhciBpID0gMCwgbyA9IDAsIG1pc3NpbmdCaXRzID0gMCwgYml0c0xlZnQgPSAwLCBuID0gMCwgYml0UG9zID0gMDsKICAgICAgICAgIHZhciBidWZmZXI7CiAgICAgICAgICB2YXIgZGVzdCA9IFtdOwogICAgICAgICAgdmFyIG5tYXggPSBNYXRoLmNlaWwoKG1heFZhbHVlIC0gb2Zmc2V0KSAvIHNjYWxlKTsKICAgICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykgewogICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHsKICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTsKICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyOwogICAgICAgICAgICAgIGJpdFBvcyA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkgewogICAgICAgICAgICAgIC8vbm8gdW5zaWduZWQgbGVmdCBzaGlmdAogICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2spOwogICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDsKICAgICAgICAgICAgICBiaXRQb3MgKz0gYml0c1BlclBpeGVsOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTsKICAgICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2s7Ly8oKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7CiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107CiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzOwogICAgICAgICAgICAgIG4gfD0gKGJ1ZmZlciAmICgoMSA8PCBtaXNzaW5nQml0cykgLSAxKSkgPDwgKGJpdHNQZXJQaXhlbCAtIG1pc3NpbmdCaXRzKTsKICAgICAgICAgICAgICBiaXRQb3MgPSBtaXNzaW5nQml0czsKICAgICAgICAgICAgfQogICAgICAgICAgICAvL2Rlc3QucHVzaChuKTsKICAgICAgICAgICAgZGVzdFtvXSA9IG4gPCBubWF4ID8gb2Zmc2V0ICsgbiAqIHNjYWxlIDogbWF4VmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgICBkZXN0LnVuc2hpZnQob2Zmc2V0KTsKICAgICAgICAgIHJldHVybiBkZXN0OwogICAgICAgIH0sCgogICAgICAgIG9yaWdpbmFsVW5zdHVmZjogZnVuY3Rpb24oc3JjLCBkZXN0LCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscykgewogICAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTsKICAgICAgICAgIHZhciBpID0gMCwgbzsKICAgICAgICAgIHZhciBiaXRzTGVmdCA9IDA7CiAgICAgICAgICB2YXIgbiwgYnVmZmVyLCBtaXNzaW5nQml0czsKCiAgICAgICAgICAvLyBnZXQgcmlkIG9mIHRyYWlsaW5nIGJ5dGVzIHRoYXQgYXJlIGFscmVhZHkgcGFydCBvZiBuZXh0IGJsb2NrCiAgICAgICAgICB2YXIgbnVtSW52YWxpZFRhaWxCeXRlcyA9IHNyYy5sZW5ndGggKiA0IC0gTWF0aC5jZWlsKGJpdHNQZXJQaXhlbCAqIG51bVBpeGVscyAvIDgpOwogICAgICAgICAgc3JjW3NyYy5sZW5ndGggLSAxXSA8PD0gOCAqIG51bUludmFsaWRUYWlsQnl0ZXM7CgogICAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7CiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkgewogICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdOwogICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkgewogICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiAoYml0c0xlZnQgLSBiaXRzUGVyUGl4ZWwpKSAmIGJpdE1hc2s7CiAgICAgICAgICAgICAgYml0c0xlZnQgLT0gYml0c1BlclBpeGVsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTsKICAgICAgICAgICAgICBuID0gKChidWZmZXIgJiBiaXRNYXNrKSA8PCBtaXNzaW5nQml0cykgJiBiaXRNYXNrOwogICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdOwogICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0czsKICAgICAgICAgICAgICBuICs9IChidWZmZXIgPj4+IGJpdHNMZWZ0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBkZXN0W29dID0gbjsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBkZXN0OwogICAgICAgIH0sCgogICAgICAgIG9yaWdpbmFsVW5zdHVmZjI6IGZ1bmN0aW9uKHNyYywgZGVzdCwgYml0c1BlclBpeGVsLCBudW1QaXhlbHMpIHsKICAgICAgICAgIHZhciBiaXRNYXNrID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7CiAgICAgICAgICB2YXIgaSA9IDAsIG87CiAgICAgICAgICB2YXIgYml0c0xlZnQgPSAwLCBiaXRQb3MgPSAwOwogICAgICAgICAgdmFyIG4sIGJ1ZmZlciwgbWlzc2luZ0JpdHM7CiAgICAgICAgICAvL21pY3JvLW9wdGltaXphdGlvbnMKICAgICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykgewogICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHsKICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTsKICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyOwogICAgICAgICAgICAgIGJpdFBvcyA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkgewogICAgICAgICAgICAgIC8vbm8gdW5zaWduZWQgbGVmdCBzaGlmdAogICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2spOwogICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDsKICAgICAgICAgICAgICBiaXRQb3MgKz0gYml0c1BlclBpeGVsOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTsKICAgICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2s7Ly8oKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7CiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107CiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzOwogICAgICAgICAgICAgIG4gfD0gKGJ1ZmZlciAmICgoMSA8PCBtaXNzaW5nQml0cykgLSAxKSkgPDwgKGJpdHNQZXJQaXhlbCAtIG1pc3NpbmdCaXRzKTsKICAgICAgICAgICAgICBiaXRQb3MgPSBtaXNzaW5nQml0czsKICAgICAgICAgICAgfQogICAgICAgICAgICBkZXN0W29dID0gbjsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBkZXN0OwogICAgICAgIH0KICAgICAgfTsKCiAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgogICAgICAqcHJpdmF0ZSBzdGF0aWMgY2xhc3MgdXNlZCBieSBMZXJjMkRlY29kZQogICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovCiAgICAgIHZhciBMZXJjMkhlbHBlcnMgPSB7CiAgICAgICAgSFVGRk1BTl9MVVRfQklUU19NQVg6IDEyLCAvL3VzZSAyXjEyIGx1dCwgdHJlYXQgaXQgbGlrZSBjb25zdGFudAogICAgICAgIGNvbXB1dGVDaGVja3N1bUZsZXRjaGVyMzI6IGZ1bmN0aW9uKGlucHV0KSB7CgogICAgICAgICAgdmFyIHN1bTEgPSAweGZmZmYsIHN1bTIgPSAweGZmZmY7CiAgICAgICAgICB2YXIgbGVuID0gaW5wdXQubGVuZ3RoOwogICAgICAgICAgdmFyIHdvcmRzID0gTWF0aC5mbG9vcihsZW4gLyAyKTsKICAgICAgICAgIHZhciBpID0gMDsKICAgICAgICAgIHdoaWxlICh3b3JkcykgewogICAgICAgICAgICB2YXIgdGxlbiA9ICh3b3JkcyA+PSAzNTkpID8gMzU5IDogd29yZHM7CiAgICAgICAgICAgIHdvcmRzIC09IHRsZW47CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBzdW0xICs9IChpbnB1dFtpKytdIDw8IDgpOwogICAgICAgICAgICAgIHN1bTIgKz0gc3VtMSArPSBpbnB1dFtpKytdOwogICAgICAgICAgICB9IHdoaWxlICgtLXRsZW4pOwoKICAgICAgICAgICAgc3VtMSA9IChzdW0xICYgMHhmZmZmKSArIChzdW0xID4+PiAxNik7CiAgICAgICAgICAgIHN1bTIgPSAoc3VtMiAmIDB4ZmZmZikgKyAoc3VtMiA+Pj4gMTYpOwogICAgICAgICAgfQoKICAgICAgICAgIC8vIGFkZCB0aGUgc3RyYWdnbGVyIGJ5dGUgaWYgaXQgZXhpc3RzCiAgICAgICAgICBpZiAobGVuICYgMSkgewogICAgICAgICAgICBzdW0yICs9IHN1bTEgKz0gKGlucHV0W2ldIDw8IDgpOwogICAgICAgICAgfQogICAgICAgICAgLy8gc2Vjb25kIHJlZHVjdGlvbiBzdGVwIHRvIHJlZHVjZSBzdW1zIHRvIDE2IGJpdHMKICAgICAgICAgIHN1bTEgPSAoc3VtMSAmIDB4ZmZmZikgKyAoc3VtMSA+Pj4gMTYpOwogICAgICAgICAgc3VtMiA9IChzdW0yICYgMHhmZmZmKSArIChzdW0yID4+PiAxNik7CgogICAgICAgICAgcmV0dXJuIChzdW0yIDw8IDE2IHwgc3VtMSkgPj4+IDA7CiAgICAgICAgfSwKCiAgICAgICAgcmVhZEhlYWRlckluZm86IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7CiAgICAgICAgICB2YXIgcHRyID0gZGF0YS5wdHI7CiAgICAgICAgICB2YXIgZmlsZUlkVmlldyA9IG5ldyBVaW50OEFycmF5KGlucHV0LCBwdHIsIDYpOwogICAgICAgICAgdmFyIGhlYWRlckluZm8gPSB7fTsKICAgICAgICAgIGhlYWRlckluZm8uZmlsZUlkZW50aWZpZXJTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGZpbGVJZFZpZXcpOwogICAgICAgICAgaWYgKGhlYWRlckluZm8uZmlsZUlkZW50aWZpZXJTdHJpbmcubGFzdEluZGV4T2YoIkxlcmMyIiwgMCkgIT09IDApIHsKICAgICAgICAgICAgdGhyb3cgIlVuZXhwZWN0ZWQgZmlsZSBpZGVudGlmaWVyIHN0cmluZyAoZXhwZWN0IExlcmMyICk6ICIgKyBoZWFkZXJJbmZvLmZpbGVJZGVudGlmaWVyU3RyaW5nOwogICAgICAgICAgfQogICAgICAgICAgcHRyICs9IDY7CiAgICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgcHRyLCA4KTsKICAgICAgICAgIHZhciBmaWxlVmVyc2lvbiA9IHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7CiAgICAgICAgICBoZWFkZXJJbmZvLmZpbGVWZXJzaW9uID0gZmlsZVZlcnNpb247CiAgICAgICAgICBwdHIgKz0gNDsKICAgICAgICAgIGlmIChmaWxlVmVyc2lvbiA+PSAzKSB7CiAgICAgICAgICAgIGhlYWRlckluZm8uY2hlY2tzdW0gPSB2aWV3LmdldFVpbnQzMig0LCB0cnVlKTsgLy9ucm93cwogICAgICAgICAgICBwdHIgKz0gNDsKICAgICAgICAgIH0KCiAgICAgICAgICAvL2tleXMgc3RhcnQgZnJvbSBoZXJlCiAgICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBwdHIsIDEyKTsKICAgICAgICAgIGhlYWRlckluZm8uaGVpZ2h0ID0gdmlldy5nZXRVaW50MzIoMCwgdHJ1ZSk7IC8vbnJvd3MKICAgICAgICAgIGhlYWRlckluZm8ud2lkdGggPSB2aWV3LmdldFVpbnQzMig0LCB0cnVlKTsgLy9uY29scwogICAgICAgICAgcHRyICs9IDg7CiAgICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gNCkgewogICAgICAgICAgICBoZWFkZXJJbmZvLm51bURpbXMgPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTsKICAgICAgICAgICAgcHRyICs9IDQ7CiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgaGVhZGVySW5mby5udW1EaW1zID0gMTsKICAgICAgICAgIH0KCiAgICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBwdHIsIDQwKTsKICAgICAgICAgIGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpOwogICAgICAgICAgaGVhZGVySW5mby5taWNyb0Jsb2NrU2l6ZSA9IHZpZXcuZ2V0SW50MzIoNCwgdHJ1ZSk7CiAgICAgICAgICBoZWFkZXJJbmZvLmJsb2JTaXplID0gdmlldy5nZXRJbnQzMig4LCB0cnVlKTsKICAgICAgICAgIGhlYWRlckluZm8uaW1hZ2VUeXBlID0gdmlldy5nZXRJbnQzMigxMiwgdHJ1ZSk7CgogICAgICAgICAgaGVhZGVySW5mby5tYXhaRXJyb3IgPSB2aWV3LmdldEZsb2F0NjQoMTYsIHRydWUpOwogICAgICAgICAgaGVhZGVySW5mby56TWluID0gdmlldy5nZXRGbG9hdDY0KDI0LCB0cnVlKTsKICAgICAgICAgIGhlYWRlckluZm8uek1heCA9IHZpZXcuZ2V0RmxvYXQ2NCgzMiwgdHJ1ZSk7CiAgICAgICAgICBwdHIgKz0gNDA7CiAgICAgICAgICBkYXRhLmhlYWRlckluZm8gPSBoZWFkZXJJbmZvOwogICAgICAgICAgZGF0YS5wdHIgPSBwdHI7CgogICAgICAgICAgdmFyIGNoZWNrc3VtLCBrZXlMZW5ndGg7CiAgICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gMykgewogICAgICAgICAgICBrZXlMZW5ndGggPSBmaWxlVmVyc2lvbiA+PSA0ID8gNTIgOiA0ODsKICAgICAgICAgICAgY2hlY2tzdW0gPSB0aGlzLmNvbXB1dGVDaGVja3N1bUZsZXRjaGVyMzIobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIHB0ciAtIGtleUxlbmd0aCwgaGVhZGVySW5mby5ibG9iU2l6ZSAtIDE0KSk7CiAgICAgICAgICAgIGlmIChjaGVja3N1bSAhPT0gaGVhZGVySW5mby5jaGVja3N1bSkgewogICAgICAgICAgICAgIHRocm93ICJDaGVja3N1bSBmYWlsZWQuIjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSwKCiAgICAgICAgY2hlY2tNaW5NYXhSYW5nZXM6IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7CiAgICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbzsKICAgICAgICAgIHZhciBPdXRQaXhlbFR5cGVBcnJheSA9IHRoaXMuZ2V0RGF0YVR5cGVBcnJheShoZWFkZXJJbmZvLmltYWdlVHlwZSk7CiAgICAgICAgICB2YXIgcmFuZ2VCeXRlcyA9IGhlYWRlckluZm8ubnVtRGltcyAqIHRoaXMuZ2V0RGF0YVR5cGVTaXplKGhlYWRlckluZm8uaW1hZ2VUeXBlKTsKICAgICAgICAgIHZhciBtaW5WYWx1ZXMgPSB0aGlzLnJlYWRTdWJBcnJheShpbnB1dCwgZGF0YS5wdHIsIE91dFBpeGVsVHlwZUFycmF5LCByYW5nZUJ5dGVzKTsKICAgICAgICAgIHZhciBtYXhWYWx1ZXMgPSB0aGlzLnJlYWRTdWJBcnJheShpbnB1dCwgZGF0YS5wdHIgKyByYW5nZUJ5dGVzLCBPdXRQaXhlbFR5cGVBcnJheSwgcmFuZ2VCeXRlcyk7CiAgICAgICAgICBkYXRhLnB0ciArPSAoMiAqIHJhbmdlQnl0ZXMpOwogICAgICAgICAgdmFyIGksIGVxdWFsID0gdHJ1ZTsKICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBoZWFkZXJJbmZvLm51bURpbXM7IGkrKykgewogICAgICAgICAgICBpZiAobWluVmFsdWVzW2ldICE9PSBtYXhWYWx1ZXNbaV0pIHsKICAgICAgICAgICAgICBlcXVhbCA9IGZhbHNlOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBoZWFkZXJJbmZvLm1pblZhbHVlcyA9IG1pblZhbHVlczsKICAgICAgICAgIGhlYWRlckluZm8ubWF4VmFsdWVzID0gbWF4VmFsdWVzOwogICAgICAgICAgcmV0dXJuIGVxdWFsOwogICAgICAgIH0sCgogICAgICAgIHJlYWRTdWJBcnJheTogZnVuY3Rpb24oaW5wdXQsIHB0ciwgT3V0UGl4ZWxUeXBlQXJyYXksIG51bUJ5dGVzKSB7CiAgICAgICAgICB2YXIgcmF3RGF0YTsKICAgICAgICAgIGlmIChPdXRQaXhlbFR5cGVBcnJheSA9PT0gVWludDhBcnJheSkgewogICAgICAgICAgICByYXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQsIHB0ciwgbnVtQnl0ZXMpOwogICAgICAgICAgfQogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIHZhciBhcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihudW1CeXRlcyk7CiAgICAgICAgICAgIHZhciBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7CiAgICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIHB0ciwgbnVtQnl0ZXMpKTsKICAgICAgICAgICAgcmF3RGF0YSA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShhcnJheUJ1Zik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmF3RGF0YTsKICAgICAgICB9LAoKICAgICAgICByZWFkTWFzazogZnVuY3Rpb24oaW5wdXQsIGRhdGEpIHsKICAgICAgICAgIHZhciBwdHIgPSBkYXRhLnB0cjsKICAgICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvOwogICAgICAgICAgdmFyIG51bVBpeGVscyA9IGhlYWRlckluZm8ud2lkdGggKiBoZWFkZXJJbmZvLmhlaWdodDsKICAgICAgICAgIHZhciBudW1WYWxpZFBpeGVsID0gaGVhZGVySW5mby5udW1WYWxpZFBpeGVsOwoKICAgICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBwdHIsIDQpOwogICAgICAgICAgdmFyIG1hc2sgPSB7fTsKICAgICAgICAgIG1hc2subnVtQnl0ZXMgPSB2aWV3LmdldFVpbnQzMigwLCB0cnVlKTsKICAgICAgICAgIHB0ciArPSA0OwoKICAgICAgICAgIC8vIE1hc2sgRGF0YQogICAgICAgICAgaWYgKCgwID09PSBudW1WYWxpZFBpeGVsIHx8IG51bVBpeGVscyA9PT0gbnVtVmFsaWRQaXhlbCkgJiYgMCAhPT0gbWFzay5udW1CeXRlcykgewogICAgICAgICAgICB0aHJvdyAoImludmFsaWQgbWFzayIpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGJpdHNldCwgcmVzdWx0TWFzazsKICAgICAgICAgIGlmIChudW1WYWxpZFBpeGVsID09PSAwKSB7CiAgICAgICAgICAgIGJpdHNldCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChudW1QaXhlbHMgLyA4KSk7CiAgICAgICAgICAgIG1hc2suYml0c2V0ID0gYml0c2V0OwogICAgICAgICAgICByZXN1bHRNYXNrID0gbmV3IFVpbnQ4QXJyYXkobnVtUGl4ZWxzKTsKICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0TWFzayA9IHJlc3VsdE1hc2s7CiAgICAgICAgICAgIHB0ciArPSBtYXNrLm51bUJ5dGVzOwogICAgICAgICAgfS8vID8/Pz8/IGVsc2UgaWYgKGRhdGEubWFzay5udW1CeXRlcyA+IDAgJiYgZGF0YS5tYXNrLm51bUJ5dGVzPCBkYXRhLm51bVZhbGlkUGl4ZWwpIHsKICAgICAgICAgIGVsc2UgaWYgKG1hc2subnVtQnl0ZXMgPiAwKSB7CiAgICAgICAgICAgIGJpdHNldCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChudW1QaXhlbHMgLyA4KSk7CiAgICAgICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIHB0ciwgbWFzay5udW1CeXRlcyk7CiAgICAgICAgICAgIHZhciBjbnQgPSB2aWV3LmdldEludDE2KDAsIHRydWUpOwogICAgICAgICAgICB2YXIgaXAgPSAyLCBvcCA9IDAsIHZhbCA9IDA7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBpZiAoY250ID4gMCkgewogICAgICAgICAgICAgICAgd2hpbGUgKGNudC0tKSB7IGJpdHNldFtvcCsrXSA9IHZpZXcuZ2V0VWludDgoaXArKyk7IH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFsID0gdmlldy5nZXRVaW50OChpcCsrKTsKICAgICAgICAgICAgICAgIGNudCA9IC1jbnQ7CiAgICAgICAgICAgICAgICB3aGlsZSAoY250LS0pIHsgYml0c2V0W29wKytdID0gdmFsOyB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNudCA9IHZpZXcuZ2V0SW50MTYoaXAsIHRydWUpOwogICAgICAgICAgICAgIGlwICs9IDI7CiAgICAgICAgICAgIH0gd2hpbGUgKGlwIDwgbWFzay5udW1CeXRlcyk7CiAgICAgICAgICAgIGlmICgoY250ICE9PSAtMzI3NjgpIHx8IChvcCA8IGJpdHNldC5sZW5ndGgpKSB7CiAgICAgICAgICAgICAgdGhyb3cgIlVuZXhwZWN0ZWQgZW5kIG9mIG1hc2sgUkxFIGVuY29kaW5nIjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmVzdWx0TWFzayA9IG5ldyBVaW50OEFycmF5KG51bVBpeGVscyk7CiAgICAgICAgICAgIHZhciBtYiA9IDAsIGsgPSAwOwoKICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7CiAgICAgICAgICAgICAgaWYgKGsgJiA3KSB7CiAgICAgICAgICAgICAgICBtYiA9IGJpdHNldFtrID4+IDNdOwogICAgICAgICAgICAgICAgbWIgPDw9IGsgJiA3OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIG1iID0gYml0c2V0W2sgPj4gM107CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChtYiAmIDEyOCkgewogICAgICAgICAgICAgICAgcmVzdWx0TWFza1trXSA9IDE7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdE1hc2sgPSByZXN1bHRNYXNrOwoKICAgICAgICAgICAgbWFzay5iaXRzZXQgPSBiaXRzZXQ7CiAgICAgICAgICAgIHB0ciArPSBtYXNrLm51bUJ5dGVzOwogICAgICAgICAgfQogICAgICAgICAgZGF0YS5wdHIgPSBwdHI7CiAgICAgICAgICBkYXRhLm1hc2sgPSBtYXNrOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSwKCiAgICAgICAgcmVhZERhdGFPbmVTd2VlcDogZnVuY3Rpb24oaW5wdXQsIGRhdGEsIE91dFBpeGVsVHlwZUFycmF5KSB7CiAgICAgICAgICB2YXIgcHRyID0gZGF0YS5wdHI7CiAgICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbzsKICAgICAgICAgIHZhciBudW1EaW1zID0gaGVhZGVySW5mby5udW1EaW1zOwogICAgICAgICAgdmFyIG51bVBpeGVscyA9IGhlYWRlckluZm8ud2lkdGggKiBoZWFkZXJJbmZvLmhlaWdodDsKICAgICAgICAgIHZhciBpbWFnZVR5cGUgPSBoZWFkZXJJbmZvLmltYWdlVHlwZTsKICAgICAgICAgIHZhciBudW1CeXRlcyA9IGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCAqIExlcmMySGVscGVycy5nZXREYXRhVHlwZVNpemUoaW1hZ2VUeXBlKSAqIG51bURpbXM7CiAgICAgICAgICAvL2RhdGEucGl4ZWxzLm51bUJ5dGVzID0gbnVtQnl0ZXM7CiAgICAgICAgICB2YXIgcmF3RGF0YTsKICAgICAgICAgIHZhciBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzazsKICAgICAgICAgIGlmIChPdXRQaXhlbFR5cGVBcnJheSA9PT0gVWludDhBcnJheSkgewogICAgICAgICAgICByYXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQsIHB0ciwgbnVtQnl0ZXMpOwogICAgICAgICAgfQogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIHZhciBhcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihudW1CeXRlcyk7CiAgICAgICAgICAgIHZhciBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7CiAgICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIHB0ciwgbnVtQnl0ZXMpKTsKICAgICAgICAgICAgcmF3RGF0YSA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShhcnJheUJ1Zik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocmF3RGF0YS5sZW5ndGggPT09IG51bVBpeGVscyAqIG51bURpbXMpIHsKICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzID0gcmF3RGF0YTsKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgIC8vbWFzawogICAgICAgICAgewogICAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobnVtUGl4ZWxzICogbnVtRGltcyk7CiAgICAgICAgICAgIHZhciB6ID0gMCwgayA9IDAsIGkgPSAwLCBuU3RhcnQgPSAwOwogICAgICAgICAgICBpZiAobnVtRGltcyA+IDEpIHsKICAgICAgICAgICAgICBmb3IgKGk9MDsgaSA8IG51bURpbXM7IGkrKykgewogICAgICAgICAgICAgICAgblN0YXJ0ID0gaSAqIG51bVBpeGVsczsKICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykgewogICAgICAgICAgICAgICAgICBpZiAobWFza1trXSkgewogICAgICAgICAgICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVsc1tuU3RhcnQgKyBrXSA9IHJhd0RhdGFbeisrXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHsKICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7CiAgICAgICAgICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVsc1trXSA9IHJhd0RhdGFbeisrXTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHB0ciArPSBudW1CeXRlczsKICAgICAgICAgIGRhdGEucHRyID0gcHRyOyAgICAgICAvL3JldHVybiBkYXRhOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSwKCiAgICAgICAgcmVhZEh1ZmZtYW5UcmVlOiBmdW5jdGlvbihpbnB1dCwgZGF0YSkgewogICAgICAgICAgdmFyIEJJVFNfTUFYID0gdGhpcy5IVUZGTUFOX0xVVF9CSVRTX01BWDsgLy84IGlzIHNsb3cgZm9yIHRoZSBsYXJnZSB0ZXN0IGltYWdlCiAgICAgICAgICAvL3ZhciBzaXplX21heCA9IDEgPDwgQklUU19NQVg7CiAgICAgICAgICAvKiAqKioqKioqKioqKioqKioqKioqKioqKioKICAgICAgICAgICAqIHJlYWRpbmcgY29kZSB0YWJsZQogICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKiovCiAgICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZGF0YS5wdHIsIDE2KTsKICAgICAgICAgIGRhdGEucHRyICs9IDE2OwogICAgICAgICAgdmFyIHZlcnNpb24gPSB2aWV3LmdldEludDMyKDAsIHRydWUpOwogICAgICAgICAgaWYgKHZlcnNpb24gPCAyKSB7CiAgICAgICAgICAgIHRocm93ICJ1bnN1cHBvcnRlZCBIdWZmbWFuIHZlcnNpb24iOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHNpemUgPSB2aWV3LmdldEludDMyKDQsIHRydWUpOwogICAgICAgICAgdmFyIGkwID0gdmlldy5nZXRJbnQzMig4LCB0cnVlKTsKICAgICAgICAgIHZhciBpMSA9IHZpZXcuZ2V0SW50MzIoMTIsIHRydWUpOwogICAgICAgICAgaWYgKGkwID49IGkxKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBibG9ja0RhdGFCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoaTEgLSBpMCk7CiAgICAgICAgICBMZXJjMkhlbHBlcnMuZGVjb2RlQml0cyhpbnB1dCwgZGF0YSwgYmxvY2tEYXRhQnVmZmVyKTsKICAgICAgICAgIHZhciBjb2RlVGFibGUgPSBbXTsgLy9zaXplCiAgICAgICAgICB2YXIgaSwgaiwgaywgbGVuOwoKICAgICAgICAgIGZvciAoaSA9IGkwOyBpIDwgaTE7IGkrKykgewogICAgICAgICAgICBqID0gaSAtIChpIDwgc2l6ZSA/IDAgOiBzaXplKTsvL3dyYXAgYXJvdW5kCiAgICAgICAgICAgIGNvZGVUYWJsZVtqXSA9IHsgZmlyc3Q6IGJsb2NrRGF0YUJ1ZmZlcltpIC0gaTBdLCBzZWNvbmQ6IG51bGwgfTsKICAgICAgICAgIH0KCiAgICAgICAgICB2YXIgZGF0YUJ5dGVzID0gaW5wdXQuYnl0ZUxlbmd0aCAtIGRhdGEucHRyOwogICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IE1hdGguY2VpbChkYXRhQnl0ZXMgLyA0KTsKICAgICAgICAgIHZhciBhcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihkYXRhV29yZHMgKiA0KTsKICAgICAgICAgIHZhciBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7CiAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBkYXRhLnB0ciwgZGF0YUJ5dGVzKSk7CiAgICAgICAgICB2YXIgc3R1ZmZlZERhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWYpOyAvL211c3Qgc3RhcnQgZnJvbSB4KjQKICAgICAgICAgIHZhciBiaXRQb3MgPSAwLCB3b3JkLCBzcmNQdHIgPSAwOwogICAgICAgICAgd29yZCA9IHN0dWZmZWREYXRhWzBdOwogICAgICAgICAgZm9yIChpID0gaTA7IGkgPCBpMTsgaSsrKSB7CiAgICAgICAgICAgIGogPSBpIC0gKGkgPCBzaXplID8gMCA6IHNpemUpOy8vd3JhcCBhcm91bmQKICAgICAgICAgICAgbGVuID0gY29kZVRhYmxlW2pdLmZpcnN0OwogICAgICAgICAgICBpZiAobGVuID4gMCkgewogICAgICAgICAgICAgIGNvZGVUYWJsZVtqXS5zZWNvbmQgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBsZW4pOwoKICAgICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPj0gbGVuKSB7CiAgICAgICAgICAgICAgICBiaXRQb3MgKz0gbGVuOwogICAgICAgICAgICAgICAgaWYgKGJpdFBvcyA9PT0gMzIpIHsKICAgICAgICAgICAgICAgICAgYml0UG9zID0gMDsKICAgICAgICAgICAgICAgICAgc3JjUHRyKys7CiAgICAgICAgICAgICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIGJpdFBvcyArPSBsZW4gLSAzMjsKICAgICAgICAgICAgICAgIHNyY1B0cisrOwogICAgICAgICAgICAgICAgd29yZCA9IHN0dWZmZWREYXRhW3NyY1B0cl07CiAgICAgICAgICAgICAgICBjb2RlVGFibGVbal0uc2Vjb25kIHw9IHdvcmQgPj4+ICgzMiAtIGJpdFBvcyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CgogICAgICAgICAgLy9maW5pc2hlZCByZWFkaW5nIGNvZGUgdGFibGUKCiAgICAgICAgICAvKiAqKioqKioqKioqKioqKioqKioqKioqKioKICAgICAgICAgICAqIGJ1aWxkaW5nIGx1dAogICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKiovCiAgICAgICAgICB2YXIgbnVtQml0c0xVVCA9IDAsIG51bUJpdHNMVVRRaWNrID0gMDsKICAgICAgICAgIHZhciB0cmVlID0gbmV3IFRyZWVOb2RlKCk7CiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29kZVRhYmxlLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmIChjb2RlVGFibGVbaV0gIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIG51bUJpdHNMVVQgPSBNYXRoLm1heChudW1CaXRzTFVULCBjb2RlVGFibGVbaV0uZmlyc3QpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAobnVtQml0c0xVVCA+PSBCSVRTX01BWCkgewogICAgICAgICAgICBudW1CaXRzTFVUUWljayA9IEJJVFNfTUFYOwogICAgICAgICAgfQogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIG51bUJpdHNMVVRRaWNrID0gbnVtQml0c0xVVDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChudW1CaXRzTFVUID49IDMwKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCJXQVJuaW5nLCBsYXJnZSBOVU0gTFVUIEJJVFMgSVMgIiArIG51bUJpdHNMVVQpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGRlY29kZUx1dCA9IFtdLCBlbnRyeSwgY29kZSwgbnVtRW50cmllcywgamosIGN1cnJlbnRCaXQsIG5vZGU7CiAgICAgICAgICBmb3IgKGkgPSBpMDsgaSA8IGkxOyBpKyspIHsKICAgICAgICAgICAgaiA9IGkgLSAoaSA8IHNpemUgPyAwIDogc2l6ZSk7Ly93cmFwIGFyb3VuZAogICAgICAgICAgICBsZW4gPSBjb2RlVGFibGVbal0uZmlyc3Q7CiAgICAgICAgICAgIGlmIChsZW4gPiAwKSB7CiAgICAgICAgICAgICAgZW50cnkgPSBbbGVuLCBqXTsKICAgICAgICAgICAgICBpZiAobGVuIDw9IG51bUJpdHNMVVRRaWNrKSB7CiAgICAgICAgICAgICAgICBjb2RlID0gY29kZVRhYmxlW2pdLnNlY29uZCA8PCAobnVtQml0c0xVVFFpY2sgLSBsZW4pOwogICAgICAgICAgICAgICAgbnVtRW50cmllcyA9IDEgPDwgKG51bUJpdHNMVVRRaWNrIC0gbGVuKTsKICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1FbnRyaWVzOyBrKyspIHsKICAgICAgICAgICAgICAgICAgZGVjb2RlTHV0W2NvZGUgfCBrXSA9IGVudHJ5OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIC8vYnVpbGQgdHJlZQogICAgICAgICAgICAgICAgY29kZSA9IGNvZGVUYWJsZVtqXS5zZWNvbmQ7CiAgICAgICAgICAgICAgICBub2RlID0gdHJlZTsKICAgICAgICAgICAgICAgIGZvciAoamogPSBsZW4gLSAxOyBqaiA+PSAwOyBqai0tKSB7CiAgICAgICAgICAgICAgICAgIGN1cnJlbnRCaXQgPSBjb2RlID4+PiBqaiAmIDE7IC8vbm8gbGVmdCBzaGlmdCBhcyBsZW5ndGggY291bGQgYmUgMzAsMzEKICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCaXQpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUucmlnaHQpIHsKICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmlnaHQgPSBuZXcgVHJlZU5vZGUoKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlZnQpIHsKICAgICAgICAgICAgICAgICAgICAgIG5vZGUubGVmdCA9IG5ldyBUcmVlTm9kZSgpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChqaiA9PT0gMCAmJiAhbm9kZS52YWwpIHsKICAgICAgICAgICAgICAgICAgICBub2RlLnZhbCA9IGVudHJ5WzFdOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBkZWNvZGVMdXQ6IGRlY29kZUx1dCwKICAgICAgICAgICAgbnVtQml0c0xVVFFpY2s6IG51bUJpdHNMVVRRaWNrLAogICAgICAgICAgICBudW1CaXRzTFVUOiBudW1CaXRzTFVULAogICAgICAgICAgICB0cmVlOiB0cmVlLAogICAgICAgICAgICBzdHVmZmVkRGF0YTogc3R1ZmZlZERhdGEsCiAgICAgICAgICAgIHNyY1B0cjogc3JjUHRyLAogICAgICAgICAgICBiaXRQb3M6IGJpdFBvcwogICAgICAgICAgfTsKICAgICAgICB9LAoKICAgICAgICByZWFkSHVmZm1hbjogZnVuY3Rpb24oaW5wdXQsIGRhdGEsIE91dFBpeGVsVHlwZUFycmF5KSB7CiAgICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbzsKICAgICAgICAgIHZhciBudW1EaW1zID0gaGVhZGVySW5mby5udW1EaW1zOwogICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGEuaGVhZGVySW5mby5oZWlnaHQ7CiAgICAgICAgICB2YXIgd2lkdGggPSBkYXRhLmhlYWRlckluZm8ud2lkdGg7CiAgICAgICAgICB2YXIgbnVtUGl4ZWxzID0gd2lkdGggKiBoZWlnaHQ7CiAgICAgICAgICAvL3ZhciBzaXplX21heCA9IDEgPDwgQklUU19NQVg7CiAgICAgICAgICAvKiAqKioqKioqKioqKioqKioqKioqKioqKioKICAgICAgICAgICAqIHJlYWRpbmcgaHVmZm1hbiBzdHJ1Y3R1cmUgaW5mbwogICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKiovCiAgICAgICAgICB2YXIgaHVmZm1hbkluZm8gPSB0aGlzLnJlYWRIdWZmbWFuVHJlZShpbnB1dCwgZGF0YSk7CiAgICAgICAgICB2YXIgZGVjb2RlTHV0ID0gaHVmZm1hbkluZm8uZGVjb2RlTHV0OwogICAgICAgICAgdmFyIHRyZWUgPSBodWZmbWFuSW5mby50cmVlOwogICAgICAgICAgLy9zdHVmZmVkRGF0YSBpbmNsdWRlcyBodWZmbWFuIGhlYWRlcnMKICAgICAgICAgIHZhciBzdHVmZmVkRGF0YSA9IGh1ZmZtYW5JbmZvLnN0dWZmZWREYXRhOwogICAgICAgICAgdmFyIHNyY1B0ciA9IGh1ZmZtYW5JbmZvLnNyY1B0cjsKICAgICAgICAgIHZhciBiaXRQb3MgPSBodWZmbWFuSW5mby5iaXRQb3M7CiAgICAgICAgICB2YXIgbnVtQml0c0xVVFFpY2sgPSBodWZmbWFuSW5mby5udW1CaXRzTFVUUWljazsKICAgICAgICAgIHZhciBudW1CaXRzTFVUID0gaHVmZm1hbkluZm8ubnVtQml0c0xVVDsKICAgICAgICAgIHZhciBvZmZzZXQgPSBkYXRhLmhlYWRlckluZm8uaW1hZ2VUeXBlID09PSAwID8gMTI4IDogMDsKICAgICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqCiAgICAgICAgICAqICBkZWNvZGUKICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKi8KICAgICAgICAgIHZhciBub2RlLCB2YWwsIGRlbHRhLCBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzaywgdmFsVG1wLCB2YWxUbXBRdWljaywgY3VycmVudEJpdDsKICAgICAgICAgIHZhciBpLCBqLCBrLCBpaTsKICAgICAgICAgIHZhciBwcmV2VmFsID0gMDsKICAgICAgICAgIGlmIChiaXRQb3MgPiAwKSB7CiAgICAgICAgICAgIHNyY1B0cisrOwogICAgICAgICAgICBiaXRQb3MgPSAwOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdOwogICAgICAgICAgdmFyIGRlbHRhRW5jb2RlID0gZGF0YS5lbmNvZGVNb2RlID09PSAxOwogICAgICAgICAgdmFyIHJlc3VsdFBpeGVsc0FsbERpbSA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShudW1QaXhlbHMgKiBudW1EaW1zKTsKICAgICAgICAgIHZhciByZXN1bHRQaXhlbHMgPSByZXN1bHRQaXhlbHNBbGxEaW07CiAgICAgICAgICB2YXIgaURpbTsKICAgICAgICAgIGZvciAoaURpbSA9IDA7IGlEaW0gPCBoZWFkZXJJbmZvLm51bURpbXM7IGlEaW0rKykgewogICAgICAgICAgICBpZiAobnVtRGltcyA+IDEpIHsKICAgICAgICAgICAgICAvL2dldCB0aGUgbWVtIGJsb2NrIG9mIGN1cnJlbnQgZGltZW5zaW9uCiAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KHJlc3VsdFBpeGVsc0FsbERpbS5idWZmZXIsIG51bVBpeGVscyAqIGlEaW0sIG51bVBpeGVscyk7CiAgICAgICAgICAgICAgcHJldlZhbCA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGRhdGEuaGVhZGVySW5mby5udW1WYWxpZFBpeGVsID09PSB3aWR0aCAqIGhlaWdodCkgeyAvL2FsbCB2YWxpZAogICAgICAgICAgICAgIGZvciAoayA9IDAsIGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHsKICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB3aWR0aDsgaisrLCBrKyspIHsKICAgICAgICAgICAgICAgICAgdmFsID0gMDsKICAgICAgICAgICAgICAgICAgdmFsVG1wID0gKHdvcmQgPDwgYml0UG9zKSA+Pj4gKDMyIC0gbnVtQml0c0xVVFFpY2spOwogICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzOwogICAgICAgICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPCBudW1CaXRzTFVUUWljaykgewogICAgICAgICAgICAgICAgICAgIHZhbFRtcCB8PSAoKHN0dWZmZWREYXRhW3NyY1B0ciArIDFdKSA+Pj4gKDY0IC0gYml0UG9zIC0gbnVtQml0c0xVVFFpY2spKTsKICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChkZWNvZGVMdXRbdmFsVG1wUXVpY2tdKSAgICAvLyBpZiB0aGVyZSwgbW92ZSB0aGUgY29ycmVjdCBudW1iZXIgb2YgYml0cyBhbmQgZG9uZQogICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgdmFsID0gZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXVsxXTsKICAgICAgICAgICAgICAgICAgICBiaXRQb3MgKz0gZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXVswXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB2YWxUbXAgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBudW1CaXRzTFVUKTsKICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzOwogICAgICAgICAgICAgICAgICAgIGlmICgzMiAtIGJpdFBvcyA8IG51bUJpdHNMVVQpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcCB8PSAoKHN0dWZmZWREYXRhW3NyY1B0ciArIDFdKSA+Pj4gKDY0IC0gYml0UG9zIC0gbnVtQml0c0xVVCkpOwogICAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0czsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRyZWU7CiAgICAgICAgICAgICAgICAgICAgZm9yIChpaSA9IDA7IGlpIDwgbnVtQml0c0xVVDsgaWkrKykgewogICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IHZhbFRtcCA+Pj4gKG51bUJpdHNMVVQgLSBpaSAtIDEpICYgMTsKICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBjdXJyZW50Qml0ID8gbm9kZS5yaWdodCA6IG5vZGUubGVmdDsKICAgICAgICAgICAgICAgICAgICAgIGlmICghKG5vZGUubGVmdCB8fCBub2RlLnJpZ2h0KSkgewogICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBub2RlLnZhbDsKICAgICAgICAgICAgICAgICAgICAgICAgYml0UG9zID0gYml0UG9zICsgaWkgKyAxOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGlmIChiaXRQb3MgPj0gMzIpIHsKICAgICAgICAgICAgICAgICAgICBiaXRQb3MgLT0gMzI7CiAgICAgICAgICAgICAgICAgICAgc3JjUHRyKys7CiAgICAgICAgICAgICAgICAgICAgd29yZCA9IHN0dWZmZWREYXRhW3NyY1B0cl07CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGRlbHRhID0gdmFsIC0gb2Zmc2V0OwogICAgICAgICAgICAgICAgICBpZiAoZGVsdGFFbmNvZGUpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHByZXZWYWw7ICAgIC8vIHVzZSBvdmVyZmxvdwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID4gMCkgewogICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcmVzdWx0UGl4ZWxzW2sgLSB3aWR0aF07CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcHJldlZhbDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgZGVsdGEgJj0gMHhGRjsgLy9vdmVyZmxvdwogICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhOy8vb3ZlcmZsb3cKICAgICAgICAgICAgICAgICAgICBwcmV2VmFsID0gZGVsdGE7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW2tdID0gZGVsdGE7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7IC8vbm90IGFsbCB2YWxpZCwgdXNlIG1hc2sKICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7CiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgd2lkdGg7IGorKywgaysrKSB7CiAgICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7CiAgICAgICAgICAgICAgICAgICAgdmFsID0gMDsKICAgICAgICAgICAgICAgICAgICB2YWxUbXAgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBudW1CaXRzTFVUUWljayk7CiAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0czsKICAgICAgICAgICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPCBudW1CaXRzTFVUUWljaykgewogICAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUUWljaykpOwogICAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0czsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY29kZUx1dFt2YWxUbXBRdWlja10pICAgIC8vIGlmIHRoZXJlLCBtb3ZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiBiaXRzIGFuZCBkb25lCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgdmFsID0gZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXVsxXTsKICAgICAgICAgICAgICAgICAgICAgIGJpdFBvcyArPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzBdOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVQpOwogICAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0czsKICAgICAgICAgICAgICAgICAgICAgIGlmICgzMiAtIGJpdFBvcyA8IG51bUJpdHNMVVQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUKSk7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBub2RlID0gdHJlZTsKICAgICAgICAgICAgICAgICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IG51bUJpdHNMVVQ7IGlpKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IHZhbFRtcCA+Pj4gKG51bUJpdHNMVVQgLSBpaSAtIDEpICYgMTsKICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnRCaXQgPyBub2RlLnJpZ2h0IDogbm9kZS5sZWZ0OwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShub2RlLmxlZnQgfHwgbm9kZS5yaWdodCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBub2RlLnZhbDsKICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRQb3MgPSBiaXRQb3MgKyBpaSArIDE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIGlmIChiaXRQb3MgPj0gMzIpIHsKICAgICAgICAgICAgICAgICAgICAgIGJpdFBvcyAtPSAzMjsKICAgICAgICAgICAgICAgICAgICAgIHNyY1B0cisrOwogICAgICAgICAgICAgICAgICAgICAgd29yZCA9IHN0dWZmZWREYXRhW3NyY1B0cl07CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IHZhbCAtIG9mZnNldDsKICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFFbmNvZGUpIHsKICAgICAgICAgICAgICAgICAgICAgIGlmIChqID4gMCAmJiBtYXNrW2sgLSAxXSkgewogICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSArPSBwcmV2VmFsOyAgICAvLyB1c2Ugb3ZlcmZsb3cKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPiAwICYmIG1hc2tbayAtIHdpZHRoXSkgewogICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSArPSByZXN1bHRQaXhlbHNbayAtIHdpZHRoXTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSArPSBwcmV2VmFsOwogICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICY9IDB4RkY7IC8vb3ZlcmZsb3cKICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhOy8vb3ZlcmZsb3cKICAgICAgICAgICAgICAgICAgICAgIHByZXZWYWwgPSBkZWx0YTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSBkZWx0YTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZGF0YS5wdHIgPSBkYXRhLnB0ciArIChzcmNQdHIgKyAxKSAqIDQgKyAoYml0UG9zID4gMCA/IDQgOiAwKTsKICAgICAgICAgIH0KICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscyA9IHJlc3VsdFBpeGVsc0FsbERpbTsKICAgICAgICB9LAoKICAgICAgICBkZWNvZGVCaXRzOiBmdW5jdGlvbihpbnB1dCwgZGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBvZmZzZXQsIGlEaW0pIHsKICAgICAgICAgIHsKICAgICAgICAgICAgLy9iaXRzdHVmZiBlbmNvZGluZyBpcyAzCiAgICAgICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvOwogICAgICAgICAgICB2YXIgZmlsZVZlcnNpb24gPSBoZWFkZXJJbmZvLmZpbGVWZXJzaW9uOwogICAgICAgICAgICAvL3ZhciBibG9jayA9IHt9OwogICAgICAgICAgICB2YXIgYmxvY2tQdHIgPSAwOwogICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZGF0YS5wdHIsIDUpOy8vdG8gZG8KICAgICAgICAgICAgdmFyIGhlYWRlckJ5dGUgPSB2aWV3LmdldFVpbnQ4KDApOwogICAgICAgICAgICBibG9ja1B0cisrOwogICAgICAgICAgICB2YXIgYml0czY3ID0gaGVhZGVyQnl0ZSA+PiA2OwogICAgICAgICAgICB2YXIgbiA9IChiaXRzNjcgPT09IDApID8gNCA6IDMgLSBiaXRzNjc7CiAgICAgICAgICAgIHZhciBkb0x1dCA9IChoZWFkZXJCeXRlICYgMzIpID4gMCA/IHRydWUgOiBmYWxzZTsvLzV0aCBiaXQKICAgICAgICAgICAgdmFyIG51bUJpdHMgPSBoZWFkZXJCeXRlICYgMzE7CiAgICAgICAgICAgIHZhciBudW1FbGVtZW50cyA9IDA7CiAgICAgICAgICAgIGlmIChuID09PSAxKSB7CiAgICAgICAgICAgICAgbnVtRWxlbWVudHMgPSB2aWV3LmdldFVpbnQ4KGJsb2NrUHRyKTsgYmxvY2tQdHIrKzsKICAgICAgICAgICAgfSBlbHNlIGlmIChuID09PSAyKSB7CiAgICAgICAgICAgICAgbnVtRWxlbWVudHMgPSB2aWV3LmdldFVpbnQxNihibG9ja1B0ciwgdHJ1ZSk7IGJsb2NrUHRyICs9IDI7CiAgICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gNCkgewogICAgICAgICAgICAgIG51bUVsZW1lbnRzID0gdmlldy5nZXRVaW50MzIoYmxvY2tQdHIsIHRydWUpOyBibG9ja1B0ciArPSA0OwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRocm93ICJJbnZhbGlkIHZhbGlkIHBpeGVsIGNvdW50IHR5cGUiOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vZml4OiBodWZmbWFuIGNvZGVzIGFyZSBiaXQgc3R1ZmZlZCwgYnV0IG5vdCBib3VuZCBieSBkYXRhJ3MgbWF4IHZhbHVlLCBzbyBuZWVkIHRvIHVzZSBvcmlnaW5hbFVuc3R1ZmYKICAgICAgICAgICAgLy9vZmZzZXQgPSBvZmZzZXQgfHwgMDsKICAgICAgICAgICAgdmFyIHNjYWxlID0gMiAqIGhlYWRlckluZm8ubWF4WkVycm9yOwogICAgICAgICAgICB2YXIgc3R1ZmZlZERhdGEsIGFycmF5QnVmLCBzdG9yZTgsIGRhdGFCeXRlcywgZGF0YVdvcmRzOwogICAgICAgICAgICB2YXIgbHV0QXJyLCBsdXREYXRhLCBsdXRCeXRlcywgYml0c1BlclBpeGVsOwogICAgICAgICAgICB2YXIgek1heCA9IGhlYWRlckluZm8ubnVtRGltcyA+IDEgPyBoZWFkZXJJbmZvLm1heFZhbHVlc1tpRGltXSA6IGhlYWRlckluZm8uek1heDsKICAgICAgICAgICAgaWYgKGRvTHV0KSB7CiAgICAgICAgICAgICAgZGF0YS5jb3VudGVyLmx1dCsrOwogICAgICAgICAgICAgIGx1dEJ5dGVzID0gdmlldy5nZXRVaW50OChibG9ja1B0cik7CiAgICAgICAgICAgICAgYmxvY2tQdHIrKzsKICAgICAgICAgICAgICBkYXRhQnl0ZXMgPSBNYXRoLmNlaWwoKGx1dEJ5dGVzIC0gMSkgKiBudW1CaXRzIC8gOCk7CiAgICAgICAgICAgICAgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpOwogICAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKGRhdGFXb3JkcyAqIDQpOwogICAgICAgICAgICAgIHN0b3JlOCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmKTsKCiAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7CiAgICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZGF0YS5wdHIsIGRhdGFCeXRlcykpOwoKICAgICAgICAgICAgICBsdXREYXRhID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmKTsKICAgICAgICAgICAgICBkYXRhLnB0ciArPSBkYXRhQnl0ZXM7CgogICAgICAgICAgICAgIGJpdHNQZXJQaXhlbCA9IDA7CiAgICAgICAgICAgICAgd2hpbGUgKChsdXRCeXRlcyAtIDEpID4+PiBiaXRzUGVyUGl4ZWwpIHsKICAgICAgICAgICAgICAgIGJpdHNQZXJQaXhlbCsrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBkYXRhQnl0ZXMgPSBNYXRoLmNlaWwobnVtRWxlbWVudHMgKiBiaXRzUGVyUGl4ZWwgLyA4KTsKICAgICAgICAgICAgICBkYXRhV29yZHMgPSBNYXRoLmNlaWwoZGF0YUJ5dGVzIC8gNCk7CiAgICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7CiAgICAgICAgICAgICAgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpOwogICAgICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIGRhdGEucHRyLCBkYXRhQnl0ZXMpKTsKICAgICAgICAgICAgICBzdHVmZmVkRGF0YSA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1Zik7CiAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gZGF0YUJ5dGVzOwogICAgICAgICAgICAgIGlmIChmaWxlVmVyc2lvbiA+PSAzKSB7CiAgICAgICAgICAgICAgICBsdXRBcnIgPSBCaXRTdHVmZmVyLnVuc3R1ZmZMVVQyKGx1dERhdGEsIG51bUJpdHMsIGx1dEJ5dGVzIC0gMSwgb2Zmc2V0LCBzY2FsZSwgek1heCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgbHV0QXJyID0gQml0U3R1ZmZlci51bnN0dWZmTFVUKGx1dERhdGEsIG51bUJpdHMsIGx1dEJ5dGVzIC0gMSwgb2Zmc2V0LCBzY2FsZSwgek1heCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIC8vbHV0QXJyLnVuc2hpZnQoMCk7CiAgICAgICAgICAgICAgaWYgKGZpbGVWZXJzaW9uID49IDMpIHsKICAgICAgICAgICAgICAgIC8vQml0U3R1ZmZlci51bnN0dWZmMihibG9jaywgYmxvY2tEYXRhQnVmZmVyLCBoZWFkZXJJbmZvLnpNYXgpOwogICAgICAgICAgICAgICAgQml0U3R1ZmZlci51bnN0dWZmMihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzLCBsdXRBcnIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIEJpdFN0dWZmZXIudW5zdHVmZihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzLCBsdXRBcnIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoImJpdHN0dWZmZXIiKTsKICAgICAgICAgICAgICBkYXRhLmNvdW50ZXIuYml0c3R1ZmZlcisrOwogICAgICAgICAgICAgIGJpdHNQZXJQaXhlbCA9IG51bUJpdHM7CiAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7CiAgICAgICAgICAgICAgaWYgKGJpdHNQZXJQaXhlbCA+IDApIHsKICAgICAgICAgICAgICAgIGRhdGFCeXRlcyA9IE1hdGguY2VpbChudW1FbGVtZW50cyAqIGJpdHNQZXJQaXhlbCAvIDgpOwogICAgICAgICAgICAgICAgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpOwogICAgICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7CiAgICAgICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7CiAgICAgICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBkYXRhLnB0ciwgZGF0YUJ5dGVzKSk7CiAgICAgICAgICAgICAgICBzdHVmZmVkRGF0YSA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1Zik7CiAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSBkYXRhQnl0ZXM7CiAgICAgICAgICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gMykgewogICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09IG51bGwpIHsKICAgICAgICAgICAgICAgICAgICBCaXRTdHVmZmVyLm9yaWdpbmFsVW5zdHVmZjIoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cyk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgQml0U3R1ZmZlci51bnN0dWZmMihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzLCBmYWxzZSwgb2Zmc2V0LCBzY2FsZSwgek1heCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09IG51bGwpIHsKICAgICAgICAgICAgICAgICAgICBCaXRTdHVmZmVyLm9yaWdpbmFsVW5zdHVmZihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBCaXRTdHVmZmVyLnVuc3R1ZmYoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cywgZmFsc2UsIG9mZnNldCwgc2NhbGUsIHpNYXgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CgogICAgICAgIH0sCgogICAgICAgIHJlYWRUaWxlczogZnVuY3Rpb24oaW5wdXQsIGRhdGEsIE91dFBpeGVsVHlwZUFycmF5KSB7CiAgICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbzsKICAgICAgICAgIHZhciB3aWR0aCA9IGhlYWRlckluZm8ud2lkdGg7CiAgICAgICAgICB2YXIgaGVpZ2h0ID0gaGVhZGVySW5mby5oZWlnaHQ7CiAgICAgICAgICB2YXIgbWljcm9CbG9ja1NpemUgPSBoZWFkZXJJbmZvLm1pY3JvQmxvY2tTaXplOwogICAgICAgICAgdmFyIGltYWdlVHlwZSA9IGhlYWRlckluZm8uaW1hZ2VUeXBlOwogICAgICAgICAgdmFyIGRhdGFUeXBlU2l6ZSA9IExlcmMySGVscGVycy5nZXREYXRhVHlwZVNpemUoaW1hZ2VUeXBlKTsKICAgICAgICAgIHZhciBudW1CbG9ja3NYID0gTWF0aC5jZWlsKHdpZHRoIC8gbWljcm9CbG9ja1NpemUpOwogICAgICAgICAgdmFyIG51bUJsb2Nrc1kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gbWljcm9CbG9ja1NpemUpOwogICAgICAgICAgZGF0YS5waXhlbHMubnVtQmxvY2tzWSA9IG51bUJsb2Nrc1k7CiAgICAgICAgICBkYXRhLnBpeGVscy5udW1CbG9ja3NYID0gbnVtQmxvY2tzWDsKICAgICAgICAgIGRhdGEucGl4ZWxzLnB0ciA9IDA7CiAgICAgICAgICB2YXIgcm93ID0gMCwgY29sID0gMCwgYmxvY2tZID0gMCwgYmxvY2tYID0gMCwgdGhpc0Jsb2NrSGVpZ2h0ID0gMCwgdGhpc0Jsb2NrV2lkdGggPSAwLCBieXRlc0xlZnQgPSAwLCBoZWFkZXJCeXRlID0gMCwgYml0czY3ID0gMCwgdGVzdENvZGUgPSAwLCBvdXRQdHIgPSAwLCBvdXRTdHJpZGUgPSAwLCBudW1CeXRlcyA9IDAsIGJ5dGVzbGVmdCA9IDAsIHogPSAwLCBibG9ja1B0ciA9IDA7CiAgICAgICAgICB2YXIgdmlldywgYmxvY2ssIGFycmF5QnVmLCBzdG9yZTgsIHJhd0RhdGE7CiAgICAgICAgICB2YXIgYmxvY2tFbmNvZGluZzsKICAgICAgICAgIHZhciBibG9ja0RhdGFCdWZmZXIgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobWljcm9CbG9ja1NpemUgKiBtaWNyb0Jsb2NrU2l6ZSk7CiAgICAgICAgICB2YXIgbGFzdEJsb2NrSGVpZ2h0ID0gKGhlaWdodCAlIG1pY3JvQmxvY2tTaXplKSB8fCBtaWNyb0Jsb2NrU2l6ZTsKICAgICAgICAgIHZhciBsYXN0QmxvY2tXaWR0aCA9ICh3aWR0aCAlIG1pY3JvQmxvY2tTaXplKSB8fCBtaWNyb0Jsb2NrU2l6ZTsKICAgICAgICAgIHZhciBvZmZzZXRUeXBlLCBvZmZzZXQ7CiAgICAgICAgICB2YXIgbnVtRGltcyA9IGhlYWRlckluZm8ubnVtRGltcywgaURpbTsKICAgICAgICAgIHZhciBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzazsKICAgICAgICAgIHZhciByZXN1bHRQaXhlbHMgPSBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHM7CiAgICAgICAgICBmb3IgKGJsb2NrWSA9IDA7IGJsb2NrWSA8IG51bUJsb2Nrc1k7IGJsb2NrWSsrKSB7CiAgICAgICAgICAgIHRoaXNCbG9ja0hlaWdodCA9IChibG9ja1kgIT09IG51bUJsb2Nrc1kgLSAxKSA/IG1pY3JvQmxvY2tTaXplIDogbGFzdEJsb2NrSGVpZ2h0OwogICAgICAgICAgICBmb3IgKGJsb2NrWCA9IDA7IGJsb2NrWCA8IG51bUJsb2Nrc1g7IGJsb2NrWCsrKSB7CiAgICAgICAgICAgICAgLy9jb25zb2xlLmRlYnVnKCJ5IiArIGJsb2NrWSArICIgeCIgKyBibG9ja1gpOwogICAgICAgICAgICAgIHRoaXNCbG9ja1dpZHRoID0gKGJsb2NrWCAhPT0gbnVtQmxvY2tzWCAtIDEpID8gbWljcm9CbG9ja1NpemUgOiBsYXN0QmxvY2tXaWR0aDsKCiAgICAgICAgICAgICAgb3V0UHRyID0gYmxvY2tZICogd2lkdGggKiBtaWNyb0Jsb2NrU2l6ZSArIGJsb2NrWCAqIG1pY3JvQmxvY2tTaXplOwogICAgICAgICAgICAgIG91dFN0cmlkZSA9IHdpZHRoIC0gdGhpc0Jsb2NrV2lkdGg7CgoKICAgICAgICAgICAgICBmb3IgKGlEaW0gPSAwOyBpRGltIDwgbnVtRGltczsgaURpbSsrKSB7CiAgICAgICAgICAgICAgICBpZiAobnVtRGltcyA+IDEpIHsKICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscy5idWZmZXIsIHdpZHRoICogaGVpZ2h0ICogaURpbSAqIGRhdGFUeXBlU2l6ZSwgd2lkdGggKiBoZWlnaHQpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnl0ZXNMZWZ0ID0gaW5wdXQuYnl0ZUxlbmd0aCAtIGRhdGEucHRyOwogICAgICAgICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZGF0YS5wdHIsIE1hdGgubWluKDEwLCBieXRlc0xlZnQpKTsKICAgICAgICAgICAgICAgIGJsb2NrID0ge307CiAgICAgICAgICAgICAgICBibG9ja1B0ciA9IDA7CiAgICAgICAgICAgICAgICBoZWFkZXJCeXRlID0gdmlldy5nZXRVaW50OCgwKTsKICAgICAgICAgICAgICAgIGJsb2NrUHRyKys7CiAgICAgICAgICAgICAgICBiaXRzNjcgPSAoaGVhZGVyQnl0ZSA+PiA2KSAmIDB4RkY7CiAgICAgICAgICAgICAgICB0ZXN0Q29kZSA9IChoZWFkZXJCeXRlID4+IDIpICYgMTU7ICAgIC8vIHVzZSBiaXRzIDIzNDUgZm9yIGludGVncml0eSBjaGVjawogICAgICAgICAgICAgICAgaWYgKHRlc3RDb2RlICE9PSAoKChibG9ja1ggKiBtaWNyb0Jsb2NrU2l6ZSkgPj4gMykgJiAxNSkpIHsKICAgICAgICAgICAgICAgICAgdGhyb3cgImludGVncml0eSBpc3N1ZSI7CiAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGJsb2NrRW5jb2RpbmcgPSBoZWFkZXJCeXRlICYgMzsKICAgICAgICAgICAgICAgIGlmIChibG9ja0VuY29kaW5nID4gMykgewogICAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjsKICAgICAgICAgICAgICAgICAgdGhyb3cgIkludmFsaWQgYmxvY2sgZW5jb2RpbmcgKCIgKyBibG9ja0VuY29kaW5nICsgIikiOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZSBpZiAoYmxvY2tFbmNvZGluZyA9PT0gMikgeyAvL2NvbnN0YW50IDAKICAgICAgICAgICAgICAgICAgZGF0YS5jb3VudGVyLmNvbnN0YW50Kys7CiAgICAgICAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyOwogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJsb2NrRW5jb2RpbmcgPT09IDApIHsgIC8vdW5jb21wcmVzc2VkCiAgICAgICAgICAgICAgICAgIGRhdGEuY291bnRlci51bmNvbXByZXNzZWQrKzsKICAgICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7CiAgICAgICAgICAgICAgICAgIG51bUJ5dGVzID0gdGhpc0Jsb2NrSGVpZ2h0ICogdGhpc0Jsb2NrV2lkdGggKiBkYXRhVHlwZVNpemU7CiAgICAgICAgICAgICAgICAgIGJ5dGVzbGVmdCA9IGlucHV0LmJ5dGVMZW5ndGggLSBkYXRhLnB0cjsKICAgICAgICAgICAgICAgICAgbnVtQnl0ZXMgPSBudW1CeXRlcyA8IGJ5dGVzbGVmdCA/IG51bUJ5dGVzIDogYnl0ZXNsZWZ0OwogICAgICAgICAgICAgICAgICAvL2JpdCBhbGlnbm1lbnQKICAgICAgICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoKG51bUJ5dGVzICUgZGF0YVR5cGVTaXplKSA9PT0gMCA/IG51bUJ5dGVzIDogKG51bUJ5dGVzICsgZGF0YVR5cGVTaXplIC0gbnVtQnl0ZXMgJSBkYXRhVHlwZVNpemUpKTsKICAgICAgICAgICAgICAgICAgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpOwogICAgICAgICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBkYXRhLnB0ciwgbnVtQnl0ZXMpKTsKICAgICAgICAgICAgICAgICAgcmF3RGF0YSA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShhcnJheUJ1Zik7CiAgICAgICAgICAgICAgICAgIHogPSAwOwogICAgICAgICAgICAgICAgICBpZiAobWFzaykgewogICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykgewogICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tbb3V0UHRyXSkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gcmF3RGF0YVt6KytdOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIG91dFB0cisrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZWxzZSB7Ly9hbGwgdmFsaWQKICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHsKICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHIrK10gPSByYXdEYXRhW3orK107CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSB6ICogZGF0YVR5cGVTaXplOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZSB7IC8vMSBvciAzCiAgICAgICAgICAgICAgICAgIG9mZnNldFR5cGUgPSBMZXJjMkhlbHBlcnMuZ2V0RGF0YVR5cGVVc2VkKGltYWdlVHlwZSwgYml0czY3KTsKICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gTGVyYzJIZWxwZXJzLmdldE9uZVBpeGVsKGJsb2NrLCBibG9ja1B0ciwgb2Zmc2V0VHlwZSwgdmlldyk7CiAgICAgICAgICAgICAgICAgIGJsb2NrUHRyICs9IExlcmMySGVscGVycy5nZXREYXRhVHlwZVNpemUob2Zmc2V0VHlwZSk7CiAgICAgICAgICAgICAgICAgIGlmIChibG9ja0VuY29kaW5nID09PSAzKSAvL2NvbnN0YW50IG9mZnNldCB2YWx1ZQogICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7CiAgICAgICAgICAgICAgICAgICAgZGF0YS5jb3VudGVyLmNvbnN0YW50b2Zmc2V0Kys7CiAgICAgICAgICAgICAgICAgICAgLy95b3UgY2FuIGRlbGV0ZSB0aGUgZm9sbG93aW5nIHJlc3VsdE1hc2sgY2FzZSBpbiBmYXZvciBvZiBwZXJmb3JtYW5jZSBiZWNhdXNlIHZhbCBpcyBjb25zdGFudCBhbmQgdXNlcnMgdXNlIG5vZGF0YSBtYXNrLCBvdGhlcndpc2Ugbm9kYXRhdmFsdWUgcG9zdCBwcm9jZXNzaW5nIGhhbmRsZXMgaXQgdG9vLgogICAgICAgICAgICAgICAgICAgIC8vd2hpbGUgdGhlIGFib3ZlIHN0YXRlbWVudCBpcyB0cnVlLCB3ZSdyZSBub3QgZG9pbmcgaXQgYXMgd2Ugd2FudCB0byBrZWVwIGludmFsaWQgcGl4ZWwgdmFsdWUgYXQgMCByYXRoZXIgdGhhbiBhcmJpdHJhcnkgdmFsdWVzCiAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2spIHsKICAgICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykgewogICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykgewogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrW291dFB0cl0pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gb2Zmc2V0OwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKzsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykgewogICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykgewogICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHIrK10gPSBvZmZzZXQ7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vYml0c3R1ZmYgZW5jb2RpbmcgaXMgMwogICAgICAgICAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyOwogICAgICAgICAgICAgICAgICAgIC8vaGVhdnkgbGlmdGluZwogICAgICAgICAgICAgICAgICAgIExlcmMySGVscGVycy5kZWNvZGVCaXRzKGlucHV0LCBkYXRhLCBibG9ja0RhdGFCdWZmZXIsIG9mZnNldCwgaURpbSk7CiAgICAgICAgICAgICAgICAgICAgYmxvY2tQdHIgPSAwOwogICAgICAgICAgICAgICAgICAgIGlmIChtYXNrKSB7CiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1tvdXRQdHJdKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyXSA9IGJsb2NrRGF0YUJ1ZmZlcltibG9ja1B0cisrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gYmxvY2tEYXRhQnVmZmVyW2Jsb2NrUHRyKytdOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgLyoqKioqKioqKioqKioqKioqCiAgICAgICAgKiAgcHJpdmF0ZSBtZXRob2RzIChoZWxwZXIgbWV0aG9kcykKICAgICAgICAqKioqKioqKioqKioqKioqKi8KCiAgICAgICAgZm9ybWF0RmlsZUluZm86IGZ1bmN0aW9uKGRhdGEpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICJmaWxlSWRlbnRpZmllclN0cmluZyI6IGRhdGEuaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZywKICAgICAgICAgICAgImZpbGVWZXJzaW9uIjogZGF0YS5oZWFkZXJJbmZvLmZpbGVWZXJzaW9uLAogICAgICAgICAgICAiaW1hZ2VUeXBlIjogZGF0YS5oZWFkZXJJbmZvLmltYWdlVHlwZSwKICAgICAgICAgICAgImhlaWdodCI6IGRhdGEuaGVhZGVySW5mby5oZWlnaHQsCiAgICAgICAgICAgICJ3aWR0aCI6IGRhdGEuaGVhZGVySW5mby53aWR0aCwKICAgICAgICAgICAgIm51bVZhbGlkUGl4ZWwiOiBkYXRhLmhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCwKICAgICAgICAgICAgIm1pY3JvQmxvY2tTaXplIjogZGF0YS5oZWFkZXJJbmZvLm1pY3JvQmxvY2tTaXplLAogICAgICAgICAgICAiYmxvYlNpemUiOiBkYXRhLmhlYWRlckluZm8uYmxvYlNpemUsCiAgICAgICAgICAgICJtYXhaRXJyb3IiOiBkYXRhLmhlYWRlckluZm8ubWF4WkVycm9yLAogICAgICAgICAgICAicGl4ZWxUeXBlIjogTGVyYzJIZWxwZXJzLmdldFBpeGVsVHlwZShkYXRhLmhlYWRlckluZm8uaW1hZ2VUeXBlKSwKICAgICAgICAgICAgImVvZk9mZnNldCI6IGRhdGEuZW9mT2Zmc2V0LAogICAgICAgICAgICAibWFzayI6IGRhdGEubWFzayA/IHsKICAgICAgICAgICAgICAibnVtQnl0ZXMiOiBkYXRhLm1hc2subnVtQnl0ZXMKICAgICAgICAgICAgfSA6IG51bGwsCiAgICAgICAgICAgICJwaXhlbHMiOiB7CiAgICAgICAgICAgICAgIm51bUJsb2Nrc1giOiBkYXRhLnBpeGVscy5udW1CbG9ja3NYLAogICAgICAgICAgICAgICJudW1CbG9ja3NZIjogZGF0YS5waXhlbHMubnVtQmxvY2tzWSwKICAgICAgICAgICAgICAvLyJudW1CeXRlcyI6IGRhdGEucGl4ZWxzLm51bUJ5dGVzLAogICAgICAgICAgICAgICJtYXhWYWx1ZSI6IGRhdGEuaGVhZGVySW5mby56TWF4LAogICAgICAgICAgICAgICJtaW5WYWx1ZSI6IGRhdGEuaGVhZGVySW5mby56TWluLAogICAgICAgICAgICAgICJub0RhdGFWYWx1ZSI6IGRhdGEubm9EYXRhVmFsdWUKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICB9LAoKICAgICAgICBjb25zdHJ1Y3RDb25zdGFudFN1cmZhY2U6IGZ1bmN0aW9uKGRhdGEpIHsKICAgICAgICAgIHZhciB2YWwgPSBkYXRhLmhlYWRlckluZm8uek1heDsKICAgICAgICAgIHZhciBudW1EaW1zID0gIGRhdGEuaGVhZGVySW5mby5udW1EaW1zOwogICAgICAgICAgdmFyIG51bVBpeGVscyA9IGRhdGEuaGVhZGVySW5mby5oZWlnaHQgKiBkYXRhLmhlYWRlckluZm8ud2lkdGg7CiAgICAgICAgICB2YXIgbnVtUGl4ZWxBbGxEaW1zID0gbnVtUGl4ZWxzICogbnVtRGltczsKICAgICAgICAgIHZhciBpPTAsIGsgPSAwLCBuU3RhcnQ9MDsKICAgICAgICAgIHZhciBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzazsKICAgICAgICAgIGlmIChtYXNrKSB7CiAgICAgICAgICAgIGlmIChudW1EaW1zID4gMSkgewogICAgICAgICAgICAgIGZvciAoaT0wOyBpIDwgbnVtRGltczsgaSsrKSB7CiAgICAgICAgICAgICAgICBuU3RhcnQgPSBpICogbnVtUGl4ZWxzOwogICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7CiAgICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7CiAgICAgICAgICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzW25TdGFydCArIGtdID0gdmFsOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykgewogICAgICAgICAgICAgICAgaWYgKG1hc2tba10pIHsKICAgICAgICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzW2tdID0gdmFsOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGlmIChkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMuZmlsbCkgewogICAgICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscy5maWxsKHZhbCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsQWxsRGltczsgaysrKSB7CiAgICAgICAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHNba10gPSB2YWw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfSwKCiAgICAgICAgZ2V0RGF0YVR5cGVBcnJheTogZnVuY3Rpb24odCkgewogICAgICAgICAgdmFyIHRwOwogICAgICAgICAgc3dpdGNoICh0KSB7CiAgICAgICAgICAgIGNhc2UgMDogLy9jaGFyCiAgICAgICAgICAgICAgdHAgPSBJbnQ4QXJyYXk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMTogLy9ieXRlCiAgICAgICAgICAgICAgdHAgPSBVaW50OEFycmF5OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDI6IC8vc2hvcnQKICAgICAgICAgICAgICB0cCA9IEludDE2QXJyYXk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMzogLy91c2hvcnQKICAgICAgICAgICAgICB0cCA9IFVpbnQxNkFycmF5OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgdHAgPSBJbnQzMkFycmF5OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgdHAgPSBVaW50MzJBcnJheTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgIHRwID0gRmxvYXQzMkFycmF5OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgdHAgPSBGbG9hdDY0QXJyYXk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgdHAgPSBGbG9hdDMyQXJyYXk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdHA7CiAgICAgICAgfSwKCiAgICAgICAgZ2V0UGl4ZWxUeXBlOiBmdW5jdGlvbih0KSB7CiAgICAgICAgICB2YXIgdHA7CiAgICAgICAgICBzd2l0Y2ggKHQpIHsKICAgICAgICAgICAgY2FzZSAwOiAvL2NoYXIKICAgICAgICAgICAgICB0cCA9ICJTOCI7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMTogLy9ieXRlCiAgICAgICAgICAgICAgdHAgPSAiVTgiOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDI6IC8vc2hvcnQKICAgICAgICAgICAgICB0cCA9ICJTMTYiOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0CiAgICAgICAgICAgICAgdHAgPSAiVTE2IjsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgIHRwID0gIlMzMiI7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICB0cCA9ICJVMzIiOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgdHAgPSAiRjMyIjsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgIHRwID0gIkY2NCI7IC8vbm90IHN1cHBvcnRlZAogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIHRwID0gIkYzMiI7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdHA7CiAgICAgICAgfSwKCiAgICAgICAgaXNWYWxpZFBpeGVsVmFsdWU6IGZ1bmN0aW9uKHQsIHZhbCkgewogICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBpc1ZhbGlkOwogICAgICAgICAgc3dpdGNoICh0KSB7CiAgICAgICAgICAgIGNhc2UgMDogLy9jaGFyCiAgICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAtMTI4ICYmIHZhbCA8PSAxMjc7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMTogLy9ieXRlICAodW5zaWduZWQgY2hhcikKICAgICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IDAgJiYgdmFsIDw9IDI1NTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAyOiAvL3Nob3J0CiAgICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAtMzI3NjggJiYgdmFsIDw9IDMyNzY3OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0CiAgICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAwICYmIHZhbCA8PSA2NTUzNjsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSA0OiAvL2ludCAzMgogICAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gLTIxNDc0ODM2NDggJiYgdmFsIDw9IDIxNDc0ODM2NDc7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgNTogLy91aW5pdCAzMgogICAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gMCAmJiB2YWwgPD0gNDI5NDk2NzI5NjsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gLTMuNDAyNzk5OTM4NzkwMTQ4NGUrMzggJiYgdmFsIDw9IDMuNDAyNzk5OTM4NzkwMTQ4NGUrMzg7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgNzoKICAgICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IDVlLTMyNCAmJiB2YWwgPD0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGlzVmFsaWQ7CiAgICAgICAgfSwKCiAgICAgICAgZ2V0RGF0YVR5cGVTaXplOiBmdW5jdGlvbih0KSB7CiAgICAgICAgICB2YXIgcyA9IDA7CiAgICAgICAgICBzd2l0Y2ggKHQpIHsKICAgICAgICAgICAgY2FzZSAwOiAvL3VieXRlCiAgICAgICAgICAgIGNhc2UgMTogLy9ieXRlCiAgICAgICAgICAgICAgcyA9IDE7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMjogLy9zaG9ydAogICAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0CiAgICAgICAgICAgICAgcyA9IDI7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgcyA9IDQ7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgNzoKICAgICAgICAgICAgICBzID0gODsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBzID0gdDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzOwogICAgICAgIH0sCgogICAgICAgIGdldERhdGFUeXBlVXNlZDogZnVuY3Rpb24oZHQsIHRjKSB7CiAgICAgICAgICB2YXIgdCA9IGR0OwogICAgICAgICAgc3dpdGNoIChkdCkgewogICAgICAgICAgICBjYXNlIDI6IC8vc2hvcnQKICAgICAgICAgICAgY2FzZSA0OiAvL2xvbmcKICAgICAgICAgICAgICB0ID0gZHQgLSB0YzsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAzOiAvL3VzaG9ydAogICAgICAgICAgICBjYXNlIDU6IC8vdWxvbmcKICAgICAgICAgICAgICB0ID0gZHQgLSAyICogdGM7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgNjogLy9mbG9hdAogICAgICAgICAgICAgIGlmICgwID09PSB0YykgewogICAgICAgICAgICAgICAgdCA9IGR0OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlbHNlIGlmICgxID09PSB0YykgewogICAgICAgICAgICAgICAgdCA9IDI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgdCA9IDE7Ly9ieXRlCiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDc6IC8vZG91YmxlCiAgICAgICAgICAgICAgaWYgKDAgPT09IHRjKSB7CiAgICAgICAgICAgICAgICB0ID0gZHQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgdCA9IGR0IC0gMiAqIHRjICsgMTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgdCA9IGR0OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHQ7CiAgICAgICAgfSwKCiAgICAgICAgZ2V0T25lUGl4ZWw6IGZ1bmN0aW9uKGJsb2NrLCBibG9ja1B0ciwgb2Zmc2V0VHlwZSwgdmlldykgewogICAgICAgICAgdmFyIHRlbXAgPSAwOwogICAgICAgICAgc3dpdGNoIChvZmZzZXRUeXBlKSB7CiAgICAgICAgICAgIGNhc2UgMDogLy9jaGFyCiAgICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0SW50OChibG9ja1B0cik7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMTogLy9ieXRlCiAgICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0VWludDgoYmxvY2tQdHIpOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0SW50MTYoYmxvY2tQdHIsIHRydWUpOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0VWludDE2KGJsb2NrUHRyLCB0cnVlKTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldEludDMyKGJsb2NrUHRyLCB0cnVlKTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldFVJbnQzMihibG9ja1B0ciwgdHJ1ZSk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgNjoKICAgICAgICAgICAgICB0ZW1wID0gdmlldy5nZXRGbG9hdDMyKGJsb2NrUHRyLCB0cnVlKTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgIC8vdGVtcCA9IHZpZXcuZ2V0RmxvYXQ2NChibG9ja1B0ciwgdHJ1ZSk7CiAgICAgICAgICAgICAgLy9ibG9ja1B0ciArPSA4OwogICAgICAgICAgICAgIC8vbGVyYzIgZW5jb2RpbmcgZG9lc250IGhhbmRsZSBmbG9hdCA2NCwgZm9yY2UgdG8gZmxvYXQzMj8/PwogICAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldEZsb2F0NjQoYmxvY2tQdHIsIHRydWUpOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIHRocm93ICgidGhlIGRlY29kZXIgZG9lcyBub3QgdW5kZXJzdGFuZCB0aGlzIHBpeGVsIHR5cGUiKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0ZW1wOwogICAgICAgIH0KICAgICAgfTsKCiAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioKICAgICAgKnByaXZhdGUgY2xhc3MgZm9yIGEgdHJlZSBub2RlLiBIdWZmbWFuIGNvZGUgaXMgaW4gTGVyYzJIZWxwZXJzCiAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovCiAgICAgIHZhciBUcmVlTm9kZSA9IGZ1bmN0aW9uKHZhbCwgbGVmdCwgcmlnaHQpIHsKICAgICAgICB0aGlzLnZhbCA9IHZhbDsKICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0OwogICAgICAgIHRoaXMucmlnaHQgPSByaWdodDsKICAgICAgfTsKCiAgICAgIHZhciBMZXJjMkRlY29kZSA9IHsKICAgICAgICAvKgogICAgICAgICogKioqKioqKipyZW1vdmVkIG9wdGlvbnMgY29tcGFyZWQgdG8gTEVSQzEuIFdlIGNhbiBicmluZyBzb21lIG9mIHRoZW0gYmFjayBpZiBuZWVkZWQuCiAgICAgICAgICogcmVtb3ZlZCBwaXhlbCB0eXBlLiBMRVJDMiBpcyB0eXBlZCBhbmQgZG9lc24ndCByZXF1aXJlIHVzZXIgdG8gZ2l2ZSBwaXhlbCB0eXBlCiAgICAgICAgICogY2hhbmdlZCBlbmNvZGVkTWFza0RhdGEgdG8gbWFza0RhdGEuIExFUkMyICdzIGpzIHZlcnNpb24gbWFrZSBpdCBmYXN0ZXIgdG8gdXNlIG1hc2tEYXRhIGRpcmVjdGx5LgogICAgICAgICAqIHJlbW92ZWQgcmV0dXJuTWFzay4gbWFzayBpcyB1c2VkIGJ5IExFUkMyIGludGVybmFsbHkgYW5kIGlzIGNvc3QgZnJlZS4gSW4gY2FzZSBvZiB1c2VyIGlucHV0IG1hc2ssIGl0J3MgcmV0dXJuZWQgYXMgd2VsbCBhbmQgaGFzIG5lZ2xpYmxlIGNvc3QuCiAgICAgICAgICogcmVtb3ZlZCBub2RhdGF2YWx1ZS4gQmVjYXVzZSBMRVJDMiBwaXhlbHMgYXJlIHR5cGVkLCBub2RhdGF2YWx1ZSB3aWxsIHNhY3JpZnkgYSB1c2VmdWwgdmFsdWUgZm9yIG1hbnkgdHlwZXMgKDhiaXQsIDE2Yml0KSBldGMsCiAgICAgICAgICogICAgICAgdXNlciBoYXMgdG8gYmUga25vd2xlZGdhYmxlIGVub3VnaCBhYm91dCByYXN0ZXIgYW5kIHRoZWlyIGRhdGEgdG8gYXZvaWQgdXNhYmlsaXR5IGlzc3Vlcy4gc28gbm9kYXRhIHZhbHVlIGlzIHNpbXBseSByZW1vdmVkIG5vdy4KICAgICAgICAgKiAgICAgICBXZSBjYW4gYWRkIGl0IGJhY2sgbGF0ZXIgaWYgdGhlaXIncyBhIGNsZWFyIHJlcXVpcmVtZW50LgogICAgICAgICAqIHJlbW92ZWQgZW5jb2RlZE1hc2suIFRoaXMgb3B0aW9uIHdhcyBub3QgaW1wbGVtZW50ZWQgaW4gTGVyY0RlY29kZS4gSXQgY2FuIGJlIGRvbmUgYWZ0ZXIgZGVjb2RpbmcgKGxlc3MgZWZmaWNpZW50KQogICAgICAgICAqIHJlbW92ZWQgY29tcHV0ZVVzZWRCaXREZXB0aHMuCiAgICAgICAgICoKICAgICAgICAgKgogICAgICAgICAqIHJlc3BvbnNlIGNoYW5nZXMgY29tcGFyZWQgdG8gTEVSQzEKICAgICAgICAgKiAxLiBlbmNvZGVkTWFza0RhdGEgaXMgbm90IGF2YWlsYWJsZQogICAgICAgICAqIDIuIG5vRGF0YVZhbHVlIGlzIG9wdGlvbmFsIChyZXR1cm5zIG9ubHkgaWYgdXNlcidzIG5vRGF0YVZhbHVlIGlzIHdpdGggaW4gdGhlIHZhbGlkIGRhdGEgdHlwZSByYW5nZSkKICAgICAgICAgKiAzLiBtYXNrRGF0YSBpcyBhbHdheXMgYXZhaWxhYmxlCiAgICAgICAgKi8KICAgICAgICAvKioqKioqKioqKioqKioqKioKICAgICAgICAqICBwdWJsaWMgcHJvcGVydGllcwogICAgICAgICoqKioqKioqKioqKioqKioqKi8KICAgICAgICAvL0hVRkZNQU5fTFVUX0JJVFNfTUFYOiAxMiwgLy91c2UgMl4xMiBsdXQsIG5vdCBjb25maWd1cmFibGUKCiAgICAgICAgLyoqKioqKioqKioqKioqKioqCiAgICAgICAgKiAgcHVibGljIG1ldGhvZHMKICAgICAgICAqKioqKioqKioqKioqKioqKi8KCiAgICAgICAgLyoqCiAgICAgICAgICogRGVjb2RlIGEgTEVSQzIgYnl0ZSBzdHJlYW0gYW5kIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBhbmQgb3B0aW9uYWwgbWV0YWRhdGEuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBpbnB1dCBUaGUgTEVSQyBpbnB1dCBieXRlIHN0cmVhbQogICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBEZWNvZGluZyBvcHRpb25zCiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmlucHV0T2Zmc2V0XSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgaW4gdGhlIGlucHV0IGJ5dGUgc3RyZWFtLiBBIHZhbGlkIExFUkMgZmlsZSBpcyBleHBlY3RlZCBhdCB0aGF0IHBvc2l0aW9uCiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXR1cm5GaWxlSW5mb10gSWYgdHJ1ZSwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgYSBmaWxlSW5mbyBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIG1ldGFkYXRhIG9idGFpbmVkIGZyb20gdGhlIExFUkMgaGVhZGVycyBhbmQgdGhlIGRlY29kaW5nIHByb2Nlc3MKICAgICAgICAgKi8KICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uKC8qYnl0ZSBhcnJheSovIGlucHV0LCAvKm9iamVjdCovIG9wdGlvbnMpIHsKICAgICAgICAgIC8vY3VycmVudGx5IHRoZXJlJ3MgYSBidWcgaW4gdGhlIHNwYXJzZSBhcnJheSwgc28gcGxlYXNlIGRvIG5vdCBzZXQgdG8gZmFsc2UKICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgICAgdmFyIG5vRGF0YVZhbHVlID0gb3B0aW9ucy5ub0RhdGFWYWx1ZTsKCiAgICAgICAgICAvL2luaXRpYWxpemUKICAgICAgICAgIHZhciBpID0gMCwgZGF0YSA9IHt9OwogICAgICAgICAgZGF0YS5wdHIgPSBvcHRpb25zLmlucHV0T2Zmc2V0IHx8IDA7CiAgICAgICAgICBkYXRhLnBpeGVscyA9IHt9OwoKICAgICAgICAgIC8vIEZpbGUgaGVhZGVyCiAgICAgICAgICBpZiAoIUxlcmMySGVscGVycy5yZWFkSGVhZGVySW5mbyhpbnB1dCwgZGF0YSkpIDsKICAgICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvOwogICAgICAgICAgdmFyIGZpbGVWZXJzaW9uID0gaGVhZGVySW5mby5maWxlVmVyc2lvbjsKICAgICAgICAgIHZhciBPdXRQaXhlbFR5cGVBcnJheSA9IExlcmMySGVscGVycy5nZXREYXRhVHlwZUFycmF5KGhlYWRlckluZm8uaW1hZ2VUeXBlKTsKCiAgICAgICAgICAvLyBNYXNrIEhlYWRlcgogICAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRNYXNrKGlucHV0LCBkYXRhKTsKICAgICAgICAgIGlmIChoZWFkZXJJbmZvLm51bVZhbGlkUGl4ZWwgIT09IGhlYWRlckluZm8ud2lkdGggKiBoZWFkZXJJbmZvLmhlaWdodCAmJiAhZGF0YS5waXhlbHMucmVzdWx0TWFzaykgewogICAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRNYXNrID0gb3B0aW9ucy5tYXNrRGF0YTsKICAgICAgICAgIH0KCiAgICAgICAgICB2YXIgbnVtUGl4ZWxzID0gaGVhZGVySW5mby53aWR0aCAqIGhlYWRlckluZm8uaGVpZ2h0OwogICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KG51bVBpeGVscyAqIGhlYWRlckluZm8ubnVtRGltcyk7CgogICAgICAgICAgZGF0YS5jb3VudGVyID0gewogICAgICAgICAgICBvbmVzd2VlcDogMCwKICAgICAgICAgICAgdW5jb21wcmVzc2VkOiAwLAogICAgICAgICAgICBsdXQ6IDAsCiAgICAgICAgICAgIGJpdHN0dWZmZXI6IDAsCiAgICAgICAgICAgIGNvbnN0YW50OiAwLAogICAgICAgICAgICBjb25zdGFudG9mZnNldDogMAogICAgICAgICAgfTsKICAgICAgICAgIGlmIChoZWFkZXJJbmZvLm51bVZhbGlkUGl4ZWwgIT09IDApIHsKICAgICAgICAgICAgLy9ub3QgdGVzdGVkCiAgICAgICAgICAgIGlmIChoZWFkZXJJbmZvLnpNYXggPT09IGhlYWRlckluZm8uek1pbikgLy9jb25zdGFudCBzdXJmYWNlCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICBMZXJjMkhlbHBlcnMuY29uc3RydWN0Q29uc3RhbnRTdXJmYWNlKGRhdGEpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKGZpbGVWZXJzaW9uID49IDQgJiYgTGVyYzJIZWxwZXJzLmNoZWNrTWluTWF4UmFuZ2VzKGlucHV0LCBkYXRhKSkgewogICAgICAgICAgICAgIExlcmMySGVscGVycy5jb25zdHJ1Y3RDb25zdGFudFN1cmZhY2UoZGF0YSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGRhdGEucHRyLCAyKTsKICAgICAgICAgICAgICB2YXIgYlJlYWREYXRhT25lU3dlZXAgPSB2aWV3LmdldFVpbnQ4KDApOwogICAgICAgICAgICAgIGRhdGEucHRyKys7CiAgICAgICAgICAgICAgaWYgKGJSZWFkRGF0YU9uZVN3ZWVwKSB7CiAgICAgICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoIk9uZVN3ZWVwIik7CiAgICAgICAgICAgICAgICBMZXJjMkhlbHBlcnMucmVhZERhdGFPbmVTd2VlcChpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIC8vbGVyYzIuMTogLy9iaXRzdHVmZmluZyArIGx1dAogICAgICAgICAgICAgICAgLy9sZXJjMi4yOiAvL2JpdHN0dWZmaW5nICsgbHV0ICsgaHVmZm1hbgogICAgICAgICAgICAgICAgLy9sZXJjMi4zOiBuZXcgYml0c3R1ZmZlcgogICAgICAgICAgICAgICAgaWYgKGZpbGVWZXJzaW9uID4gMSAmJiBoZWFkZXJJbmZvLmltYWdlVHlwZSA8PSAxICYmIE1hdGguYWJzKGhlYWRlckluZm8ubWF4WkVycm9yIC0gMC41KSA8IDAuMDAwMDEpIHsKICAgICAgICAgICAgICAgICAgLy90aGlzIGlzIDIueCBwbHVzIDggYml0ICh1bnNpZ25lZCBhbmQgc2lnbmVkKSBkYXRhLCBwb3NzaWJsaXR5IG9mIEh1ZmZtYW4KICAgICAgICAgICAgICAgICAgdmFyIGZsYWdIdWZmbWFuID0gdmlldy5nZXRVaW50OCgxKTsKICAgICAgICAgICAgICAgICAgZGF0YS5wdHIrKzsKICAgICAgICAgICAgICAgICAgZGF0YS5lbmNvZGVNb2RlID0gZmxhZ0h1ZmZtYW47CiAgICAgICAgICAgICAgICAgIGlmIChmbGFnSHVmZm1hbiA+IDIgfHwgKGZpbGVWZXJzaW9uIDwgNCAmJiBmbGFnSHVmZm1hbiA+IDEpKSB7CiAgICAgICAgICAgICAgICAgICAgdGhyb3cgIkludmFsaWQgSHVmZm1hbiBmbGFnICIgKyBmbGFnSHVmZm1hbjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoZmxhZ0h1ZmZtYW4pIHsvLzEgLSBkZWx0YSBIdWZmbWFuLCAyIC0gSHVmZm1hbgogICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coIkh1ZmZtYW4iKTsKICAgICAgICAgICAgICAgICAgICBMZXJjMkhlbHBlcnMucmVhZEh1ZmZtYW4oaW5wdXQsIGRhdGEsIE91dFBpeGVsVHlwZUFycmF5KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCJUaWxlcyIpOwogICAgICAgICAgICAgICAgICAgIExlcmMySGVscGVycy5yZWFkVGlsZXMoaW5wdXQsIGRhdGEsIE91dFBpeGVsVHlwZUFycmF5KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZSB7IC8vbGVyYzIueCBub24tOCBiaXQgZGF0YQogICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCJUaWxlcyIpOwogICAgICAgICAgICAgICAgICBMZXJjMkhlbHBlcnMucmVhZFRpbGVzKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CgogICAgICAgICAgZGF0YS5lb2ZPZmZzZXQgPSBkYXRhLnB0cjsKICAgICAgICAgIHZhciBkaWZmOwogICAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRPZmZzZXQpIHsKICAgICAgICAgICAgZGlmZiA9IGRhdGEuaGVhZGVySW5mby5ibG9iU2l6ZSArIG9wdGlvbnMuaW5wdXRPZmZzZXQgLSBkYXRhLnB0cjsKICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID49IDEpIHsKICAgICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoImluY29ycmVjdCBlb2Y6IGRhdGFwdHIgIiArIGRhdGEucHRyICsgIiBvZmZzZXQgIiArIG9wdGlvbnMuaW5wdXRPZmZzZXQgKyAiIGJsb2JzaXplICIgKyBkYXRhLmhlYWRlckluZm8uYmxvYlNpemUgKyAiIGRpZmY6ICIgKyBkaWZmKTsKICAgICAgICAgICAgICBkYXRhLmVvZk9mZnNldCA9IG9wdGlvbnMuaW5wdXRPZmZzZXQgKyBkYXRhLmhlYWRlckluZm8uYmxvYlNpemU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBkaWZmID0gZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplIC0gZGF0YS5wdHI7CiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaWZmKSA+PSAxKSB7CiAgICAgICAgICAgICAgLy9jb25zb2xlLmRlYnVnKCJpbmNvcnJlY3QgZmlyc3QgYmFuZCBlb2Y6IGRhdGFwdHIgIiArIGRhdGEucHRyICsgIiBibG9ic2l6ZSAiICsgZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplICsgIiBkaWZmOiAiICsgZGlmZik7CiAgICAgICAgICAgICAgZGF0YS5lb2ZPZmZzZXQgPSBkYXRhLmhlYWRlckluZm8uYmxvYlNpemU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICB2YXIgcmVzdWx0ID0gewogICAgICAgICAgICB3aWR0aDogaGVhZGVySW5mby53aWR0aCwKICAgICAgICAgICAgaGVpZ2h0OiBoZWFkZXJJbmZvLmhlaWdodCwKICAgICAgICAgICAgcGl4ZWxEYXRhOiBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMsCiAgICAgICAgICAgIG1pblZhbHVlOiBoZWFkZXJJbmZvLnpNaW4sCiAgICAgICAgICAgIG1heFZhbHVlOiBoZWFkZXJJbmZvLnpNYXgsCiAgICAgICAgICAgIHZhbGlkUGl4ZWxDb3VudDogaGVhZGVySW5mby5udW1WYWxpZFBpeGVsLAogICAgICAgICAgICBkaW1Db3VudDogaGVhZGVySW5mby5udW1EaW1zLAogICAgICAgICAgICBkaW1TdGF0czogewogICAgICAgICAgICAgIG1pblZhbHVlczogaGVhZGVySW5mby5taW5WYWx1ZXMsCiAgICAgICAgICAgICAgbWF4VmFsdWVzOiBoZWFkZXJJbmZvLm1heFZhbHVlcwogICAgICAgICAgICB9LAogICAgICAgICAgICBtYXNrRGF0YTogZGF0YS5waXhlbHMucmVzdWx0TWFzawogICAgICAgICAgICAvL25vRGF0YVZhbHVlOiBub0RhdGFWYWx1ZQogICAgICAgICAgfTsKCiAgICAgICAgICAvL3dlIHNob3VsZCByZW1vdmUgdGhpcyBpZiB0aGVyZSdzIG5vIGV4aXN0aW5nIGNsaWVudAogICAgICAgICAgLy9vcHRpb25hbCBub0RhdGFWYWx1ZSBwcm9jZXNzaW5nLCBpdCdzIHVzZXIncyByZXNwb25zaWJsaXR5CiAgICAgICAgICBpZiAoZGF0YS5waXhlbHMucmVzdWx0TWFzayAmJiBMZXJjMkhlbHBlcnMuaXNWYWxpZFBpeGVsVmFsdWUoaGVhZGVySW5mby5pbWFnZVR5cGUsIG5vRGF0YVZhbHVlKSkgewogICAgICAgICAgICB2YXIgbWFzayA9IGRhdGEucGl4ZWxzLnJlc3VsdE1hc2s7CiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1QaXhlbHM7IGkrKykgewogICAgICAgICAgICAgIGlmICghbWFza1tpXSkgewogICAgICAgICAgICAgICAgcmVzdWx0LnBpeGVsRGF0YVtpXSA9IG5vRGF0YVZhbHVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXN1bHQubm9EYXRhVmFsdWUgPSBub0RhdGFWYWx1ZTsKICAgICAgICAgIH0KICAgICAgICAgIGRhdGEubm9EYXRhVmFsdWUgPSBub0RhdGFWYWx1ZTsKICAgICAgICAgIGlmIChvcHRpb25zLnJldHVybkZpbGVJbmZvKSB7CiAgICAgICAgICAgIHJlc3VsdC5maWxlSW5mbyA9IExlcmMySGVscGVycy5mb3JtYXRGaWxlSW5mbyhkYXRhKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfSwKCiAgICAgICAgZ2V0QmFuZENvdW50OiBmdW5jdGlvbigvKmJ5dGUgYXJyYXkqLyBpbnB1dCkgewogICAgICAgICAgdmFyIGNvdW50ID0gMDsKICAgICAgICAgIHZhciBpID0gMDsKICAgICAgICAgIHZhciB0ZW1wID0ge307CiAgICAgICAgICB0ZW1wLnB0ciA9IDA7CiAgICAgICAgICB0ZW1wLnBpeGVscyA9IHt9OwogICAgICAgICAgd2hpbGUgKGkgPCBpbnB1dC5ieXRlTGVuZ3RoIC0gNTgpIHsKICAgICAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRIZWFkZXJJbmZvKGlucHV0LCB0ZW1wKTsKICAgICAgICAgICAgaSArPSB0ZW1wLmhlYWRlckluZm8uYmxvYlNpemU7CiAgICAgICAgICAgIGNvdW50Kys7CiAgICAgICAgICAgIHRlbXAucHRyID0gaTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBjb3VudDsKICAgICAgICB9CiAgICAgIH07CgogICAgICByZXR1cm4gTGVyYzJEZWNvZGU7CiAgICB9KSgpOwoKICAgIHZhciBpc1BsYXRmb3JtTGl0dGxlRW5kaWFuID0gKGZ1bmN0aW9uKCkgewogICAgICB2YXIgYSA9IG5ldyBBcnJheUJ1ZmZlcig0KTsKICAgICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShhKTsKICAgICAgdmFyIGMgPSBuZXcgVWludDMyQXJyYXkoYSk7CiAgICAgIGNbMF0gPSAxOwogICAgICByZXR1cm4gYlswXSA9PT0gMTsKICAgIH0pKCk7CgogICAgdmFyIExlcmMgPSB7CiAgICAgIC8qKioqKioqKioqKip3cmFwcGVyKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8KICAgICAgLyoqCiAgICAgICAqIEEgd3JhcHBlciBmb3IgZGVjb2RpbmcgYm90aCBMRVJDMSBhbmQgTEVSQzIgYnl0ZSBzdHJlYW1zIGNhcGFibGUgb2YgaGFuZGxpbmcgbXVsdGliYW5kIHBpeGVsIGJsb2NrcyBmb3IgdmFyaW91cyBwaXhlbCB0eXBlcy4KICAgICAgICoKICAgICAgICogQGFsaWFzIG1vZHVsZTpMZXJjCiAgICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGlucHV0IFRoZSBMRVJDIGlucHV0IGJ5dGUgc3RyZWFtCiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGRlY29kaW5nIG9wdGlvbnMgYmVsb3cgYXJlIG9wdGlvbmFsLgogICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaW5wdXRPZmZzZXRdIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBpbiB0aGUgaW5wdXQgYnl0ZSBzdHJlYW0uIEEgdmFsaWQgTGVyYyBmaWxlIGlzIGV4cGVjdGVkIGF0IHRoYXQgcG9zaXRpb24uCiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5waXhlbFR5cGVdIChMRVJDMSBvbmx5KSBEZWZhdWx0IHZhbHVlIGlzIEYzMi4gVmFsaWQgcGl4ZWwgdHlwZXMgZm9yIGlucHV0IGFyZSBVOC9TOC9TMTYvVTE2L1MzMi9VMzIvRjMyLgogICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubm9EYXRhVmFsdWVdIChMRVJDMSBvbmx5KS4gSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSByZXR1cm5lZCBtYXNrIGluc3RlYWQgb2Ygc2V0dGluZyB0aGlzIHZhbHVlLgogICAgICAgKiBAcmV0dXJucyB7e3dpZHRoLCBoZWlnaHQsIHBpeGVscywgcGl4ZWxUeXBlLCBtYXNrLCBzdGF0aXN0aWNzfX0KICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggV2lkdGggb2YgZGVjb2RlZCBpbWFnZS4KICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBkZWNvZGVkIGltYWdlLgogICAgICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IHBpeGVscyBbYmFuZDEsIGJhbmQyLCDigKZdIEVhY2ggYmFuZCBpcyBhIHR5cGVkIGFycmF5IG9mIHdpZHRoKmhlaWdodC4KICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gcGl4ZWxUeXBlIFRoZSB0eXBlIG9mIHBpeGVscyByZXByZXNlbnRlZCBpbiB0aGUgb3V0cHV0LgogICAgICAgICAqIEBwcm9wZXJ0eSB7bWFza30gbWFzayBUeXBlZCBhcnJheSB3aXRoIGEgc2l6ZSBvZiB3aWR0aCpoZWlnaHQsIG9yIG51bGwgaWYgYWxsIHBpeGVscyBhcmUgdmFsaWQuCiAgICAgICAgICogQHByb3BlcnR5IHthcnJheX0gc3RhdGlzdGljcyBbc3RhdGlzdGljc19iYW5kMSwgc3RhdGlzdGljc19iYW5kMiwg4oCmXSBFYWNoIGVsZW1lbnQgaXMgYSBzdGF0aXN0aWNzIG9iamVjdCByZXByZXNlbnRpbmcgbWluIGFuZCBtYXggdmFsdWVzCiAgICAgICoqLwogICAgICBkZWNvZGU6IGZ1bmN0aW9uKGVuY29kZWREYXRhLCBvcHRpb25zKSB7CiAgICAgICAgaWYgKCFpc1BsYXRmb3JtTGl0dGxlRW5kaWFuKSB7CiAgICAgICAgICB0aHJvdyAiQmlnIGVuZGlhbiBzeXN0ZW0gaXMgbm90IHN1cHBvcnRlZC4iOwogICAgICAgIH0KICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKICAgICAgICB2YXIgaW5wdXRPZmZzZXQgPSBvcHRpb25zLmlucHV0T2Zmc2V0IHx8IDA7CiAgICAgICAgdmFyIGZpbGVJZFZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkRGF0YSwgaW5wdXRPZmZzZXQsIDEwKTsKICAgICAgICB2YXIgZmlsZUlkZW50aWZpZXJTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGZpbGVJZFZpZXcpOwogICAgICAgIHZhciBsZXJjLCBtYWpvclZlcnNpb247CiAgICAgICAgaWYgKGZpbGVJZGVudGlmaWVyU3RyaW5nLnRyaW0oKSA9PT0gIkNudFpJbWFnZSIpIHsKICAgICAgICAgIGxlcmMgPSBMZXJjRGVjb2RlOwogICAgICAgICAgbWFqb3JWZXJzaW9uID0gMTsKICAgICAgICB9CiAgICAgICAgZWxzZSBpZiAoZmlsZUlkZW50aWZpZXJTdHJpbmcuc3Vic3RyaW5nKDAsIDUpID09PSAiTGVyYzIiKSB7CiAgICAgICAgICBsZXJjID0gTGVyYzJEZWNvZGU7CiAgICAgICAgICBtYWpvclZlcnNpb24gPSAyOwogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgIHRocm93ICJVbmV4cGVjdGVkIGZpbGUgaWRlbnRpZmllciBzdHJpbmc6ICIgKyBmaWxlSWRlbnRpZmllclN0cmluZzsKICAgICAgICB9CgogICAgICAgIHZhciBpUGxhbmUgPSAwLCBlb2YgPSBlbmNvZGVkRGF0YS5ieXRlTGVuZ3RoIC0gMTAsIGVuY29kZWRNYXNrRGF0YSwgYmFuZE1hc2tzID0gW10sIGJhbmRNYXNrLCBtYXNrRGF0YTsKICAgICAgICB2YXIgZGVjb2RlZFBpeGVsQmxvY2sgPSB7CiAgICAgICAgICB3aWR0aDogMCwKICAgICAgICAgIGhlaWdodDogMCwKICAgICAgICAgIHBpeGVsczogW10sCiAgICAgICAgICBwaXhlbFR5cGU6IG9wdGlvbnMucGl4ZWxUeXBlLAogICAgICAgICAgbWFzazogbnVsbCwKICAgICAgICAgIHN0YXRpc3RpY3M6IFtdCiAgICAgICAgfTsKCiAgICAgICAgd2hpbGUgKGlucHV0T2Zmc2V0IDwgZW9mKSB7CiAgICAgICAgICB2YXIgcmVzdWx0ID0gbGVyYy5kZWNvZGUoZW5jb2RlZERhdGEsIHsKICAgICAgICAgICAgaW5wdXRPZmZzZXQ6IGlucHV0T2Zmc2V0LC8vZm9yIGJvdGggbGVyYzEgYW5kIGxlcmMyCiAgICAgICAgICAgIGVuY29kZWRNYXNrRGF0YTogZW5jb2RlZE1hc2tEYXRhLC8vbGVyYzEgb25seQogICAgICAgICAgICBtYXNrRGF0YTogbWFza0RhdGEsLy9sZXJjMiBvbmx5CiAgICAgICAgICAgIHJldHVybk1hc2s6IGlQbGFuZSA9PT0gMCA/IHRydWUgOiBmYWxzZSwvL2xlcmMxIG9ubHkKICAgICAgICAgICAgcmV0dXJuRW5jb2RlZE1hc2s6IGlQbGFuZSA9PT0gMCA/IHRydWUgOiBmYWxzZSwvL2xlcmMxIG9ubHkKICAgICAgICAgICAgcmV0dXJuRmlsZUluZm86IHRydWUsLy9mb3IgYm90aCBsZXJjMSBhbmQgbGVyYzIKICAgICAgICAgICAgcGl4ZWxUeXBlOiBvcHRpb25zLnBpeGVsVHlwZSB8fCBudWxsLC8vbGVyYzEgb25seQogICAgICAgICAgICBub0RhdGFWYWx1ZTogb3B0aW9ucy5ub0RhdGFWYWx1ZSB8fCBudWxsLy9sZXJjMSBvbmx5CiAgICAgICAgICB9KTsKCiAgICAgICAgICBpbnB1dE9mZnNldCA9IHJlc3VsdC5maWxlSW5mby5lb2ZPZmZzZXQ7CiAgICAgICAgICBpZiAoaVBsYW5lID09PSAwKSB7CiAgICAgICAgICAgIGVuY29kZWRNYXNrRGF0YSA9IHJlc3VsdC5lbmNvZGVkTWFza0RhdGE7Ly9sZXJjMQogICAgICAgICAgICBtYXNrRGF0YSA9IHJlc3VsdC5tYXNrRGF0YTsvL2xlcmMyCiAgICAgICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLndpZHRoID0gcmVzdWx0LndpZHRoOwogICAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5oZWlnaHQgPSByZXN1bHQuaGVpZ2h0OwogICAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5kaW1Db3VudCA9IHJlc3VsdC5kaW1Db3VudCB8fCAxOwogICAgICAgICAgICAvL2RlY29kZWRQaXhlbEJsb2NrLmRpbVN0YXRzID0gZGVjb2RlZFBpeGVsQmxvY2suZGltU3RhdHM7CiAgICAgICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLnBpeGVsVHlwZSA9IHJlc3VsdC5waXhlbFR5cGUgfHwgcmVzdWx0LmZpbGVJbmZvLnBpeGVsVHlwZTsKICAgICAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2subWFzayA9IHJlc3VsdC5tYXNrRGF0YTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChtYWpvclZlcnNpb24gPjEgJiYgcmVzdWx0LmZpbGVJbmZvLm1hc2sgJiYgcmVzdWx0LmZpbGVJbmZvLm1hc2subnVtQnl0ZXMgPiAwKSB7CiAgICAgICAgICAgIGJhbmRNYXNrcy5wdXNoKHJlc3VsdC5tYXNrRGF0YSk7CiAgICAgICAgICB9CgogICAgICAgICAgaVBsYW5lKys7CiAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5waXhlbHMucHVzaChyZXN1bHQucGl4ZWxEYXRhKTsKICAgICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLnN0YXRpc3RpY3MucHVzaCh7CiAgICAgICAgICAgIG1pblZhbHVlOiByZXN1bHQubWluVmFsdWUsCiAgICAgICAgICAgIG1heFZhbHVlOiByZXN1bHQubWF4VmFsdWUsCiAgICAgICAgICAgIG5vRGF0YVZhbHVlOiByZXN1bHQubm9EYXRhVmFsdWUsCiAgICAgICAgICAgIGRpbVN0YXRzOiByZXN1bHQuZGltU3RhdHMKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICB2YXIgaSwgaiwgbnVtUGl4ZWxzOwogICAgICAgIGlmIChtYWpvclZlcnNpb24gPiAxICYmIGJhbmRNYXNrcy5sZW5ndGggPiAxKSB7CiAgICAgICAgICBudW1QaXhlbHMgPSBkZWNvZGVkUGl4ZWxCbG9jay53aWR0aCAqIGRlY29kZWRQaXhlbEJsb2NrLmhlaWdodDsKICAgICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLmJhbmRNYXNrcyA9IGJhbmRNYXNrczsKICAgICAgICAgIG1hc2tEYXRhID0gbmV3IFVpbnQ4QXJyYXkobnVtUGl4ZWxzKTsKICAgICAgICAgIG1hc2tEYXRhLnNldChiYW5kTWFza3NbMF0pOwogICAgICAgICAgZm9yIChpID0gMTsgaSA8IGJhbmRNYXNrcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICBiYW5kTWFzayA9IGJhbmRNYXNrc1tpXTsKICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG51bVBpeGVsczsgaisrKSB7CiAgICAgICAgICAgICAgbWFza0RhdGFbal0gPSBtYXNrRGF0YVtqXSAmIGJhbmRNYXNrW2pdOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5tYXNrRGF0YSA9IG1hc2tEYXRhOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGRlY29kZWRQaXhlbEJsb2NrOwogICAgICB9CiAgICB9OwoKICAgIGlmIChtb2R1bGUuZXhwb3J0cykgey8qIGpzaGludCBpZ25vcmU6bGluZSAqLwogICAgICAvL2NvbW1vbkpTIG1vZHVsZSAxLjAvMS4xLzEuMS4xIHN5c3RlbXMsIHN1Y2ggYXMgbm9kZUpTCiAgICAgIC8vaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvTW9kdWxlcwogICAgICBtb2R1bGUuZXhwb3J0cyA9IExlcmM7LyoganNoaW50IGlnbm9yZTpsaW5lICovCiAgICB9CiAgICBlbHNlIHsKICAgICAgLy9hc3NpZ24gdG8gdGhpcywgbW9zdCBsaWtlbHkgd2luZG93CiAgICAgIHRoaXMuTGVyYyA9IExlcmM7CiAgICB9CgogIH0pKCk7CiAgfShMZXJjRGVjb2RlKSk7CgogIHZhciBMZXJjID0gTGVyY0RlY29kZS5leHBvcnRzOwoKICBjb25zdCBmaWVsZFRhZ05hbWVzID0gewogICAgLy8gVElGRiBCYXNlbGluZQogICAgMHgwMTNCOiAnQXJ0aXN0JywKICAgIDB4MDEwMjogJ0JpdHNQZXJTYW1wbGUnLAogICAgMHgwMTA5OiAnQ2VsbExlbmd0aCcsCiAgICAweDAxMDg6ICdDZWxsV2lkdGgnLAogICAgMHgwMTQwOiAnQ29sb3JNYXAnLAogICAgMHgwMTAzOiAnQ29tcHJlc3Npb24nLAogICAgMHg4Mjk4OiAnQ29weXJpZ2h0JywKICAgIDB4MDEzMjogJ0RhdGVUaW1lJywKICAgIDB4MDE1MjogJ0V4dHJhU2FtcGxlcycsCiAgICAweDAxMEE6ICdGaWxsT3JkZXInLAogICAgMHgwMTIxOiAnRnJlZUJ5dGVDb3VudHMnLAogICAgMHgwMTIwOiAnRnJlZU9mZnNldHMnLAogICAgMHgwMTIzOiAnR3JheVJlc3BvbnNlQ3VydmUnLAogICAgMHgwMTIyOiAnR3JheVJlc3BvbnNlVW5pdCcsCiAgICAweDAxM0M6ICdIb3N0Q29tcHV0ZXInLAogICAgMHgwMTBFOiAnSW1hZ2VEZXNjcmlwdGlvbicsCiAgICAweDAxMDE6ICdJbWFnZUxlbmd0aCcsCiAgICAweDAxMDA6ICdJbWFnZVdpZHRoJywKICAgIDB4MDEwRjogJ01ha2UnLAogICAgMHgwMTE5OiAnTWF4U2FtcGxlVmFsdWUnLAogICAgMHgwMTE4OiAnTWluU2FtcGxlVmFsdWUnLAogICAgMHgwMTEwOiAnTW9kZWwnLAogICAgMHgwMEZFOiAnTmV3U3ViZmlsZVR5cGUnLAogICAgMHgwMTEyOiAnT3JpZW50YXRpb24nLAogICAgMHgwMTA2OiAnUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbicsCiAgICAweDAxMUM6ICdQbGFuYXJDb25maWd1cmF0aW9uJywKICAgIDB4MDEyODogJ1Jlc29sdXRpb25Vbml0JywKICAgIDB4MDExNjogJ1Jvd3NQZXJTdHJpcCcsCiAgICAweDAxMTU6ICdTYW1wbGVzUGVyUGl4ZWwnLAogICAgMHgwMTMxOiAnU29mdHdhcmUnLAogICAgMHgwMTE3OiAnU3RyaXBCeXRlQ291bnRzJywKICAgIDB4MDExMTogJ1N0cmlwT2Zmc2V0cycsCiAgICAweDAwRkY6ICdTdWJmaWxlVHlwZScsCiAgICAweDAxMDc6ICdUaHJlc2hob2xkaW5nJywKICAgIDB4MDExQTogJ1hSZXNvbHV0aW9uJywKICAgIDB4MDExQjogJ1lSZXNvbHV0aW9uJywKCiAgICAvLyBUSUZGIEV4dGVuZGVkCiAgICAweDAxNDY6ICdCYWRGYXhMaW5lcycsCiAgICAweDAxNDc6ICdDbGVhbkZheERhdGEnLAogICAgMHgwMTU3OiAnQ2xpcFBhdGgnLAogICAgMHgwMTQ4OiAnQ29uc2VjdXRpdmVCYWRGYXhMaW5lcycsCiAgICAweDAxQjE6ICdEZWNvZGUnLAogICAgMHgwMUIyOiAnRGVmYXVsdEltYWdlQ29sb3InLAogICAgMHgwMTBEOiAnRG9jdW1lbnROYW1lJywKICAgIDB4MDE1MDogJ0RvdFJhbmdlJywKICAgIDB4MDE0MTogJ0hhbGZ0b25lSGludHMnLAogICAgMHgwMTVBOiAnSW5kZXhlZCcsCiAgICAweDAxNUI6ICdKUEVHVGFibGVzJywKICAgIDB4MDExRDogJ1BhZ2VOYW1lJywKICAgIDB4MDEyOTogJ1BhZ2VOdW1iZXInLAogICAgMHgwMTNEOiAnUHJlZGljdG9yJywKICAgIDB4MDEzRjogJ1ByaW1hcnlDaHJvbWF0aWNpdGllcycsCiAgICAweDAyMTQ6ICdSZWZlcmVuY2VCbGFja1doaXRlJywKICAgIDB4MDE1MzogJ1NhbXBsZUZvcm1hdCcsCiAgICAweDAxNTQ6ICdTTWluU2FtcGxlVmFsdWUnLAogICAgMHgwMTU1OiAnU01heFNhbXBsZVZhbHVlJywKICAgIDB4MDIyRjogJ1N0cmlwUm93Q291bnRzJywKICAgIDB4MDE0QTogJ1N1YklGRHMnLAogICAgMHgwMTI0OiAnVDRPcHRpb25zJywKICAgIDB4MDEyNTogJ1Q2T3B0aW9ucycsCiAgICAweDAxNDU6ICdUaWxlQnl0ZUNvdW50cycsCiAgICAweDAxNDM6ICdUaWxlTGVuZ3RoJywKICAgIDB4MDE0NDogJ1RpbGVPZmZzZXRzJywKICAgIDB4MDE0MjogJ1RpbGVXaWR0aCcsCiAgICAweDAxMkQ6ICdUcmFuc2ZlckZ1bmN0aW9uJywKICAgIDB4MDEzRTogJ1doaXRlUG9pbnQnLAogICAgMHgwMTU4OiAnWENsaXBQYXRoVW5pdHMnLAogICAgMHgwMTFFOiAnWFBvc2l0aW9uJywKICAgIDB4MDIxMTogJ1lDYkNyQ29lZmZpY2llbnRzJywKICAgIDB4MDIxMzogJ1lDYkNyUG9zaXRpb25pbmcnLAogICAgMHgwMjEyOiAnWUNiQ3JTdWJTYW1wbGluZycsCiAgICAweDAxNTk6ICdZQ2xpcFBhdGhVbml0cycsCiAgICAweDAxMUY6ICdZUG9zaXRpb24nLAoKICAgIC8vIEVYSUYKICAgIDB4OTIwMjogJ0FwZXJ0dXJlVmFsdWUnLAogICAgMHhBMDAxOiAnQ29sb3JTcGFjZScsCiAgICAweDkwMDQ6ICdEYXRlVGltZURpZ2l0aXplZCcsCiAgICAweDkwMDM6ICdEYXRlVGltZU9yaWdpbmFsJywKICAgIDB4ODc2OTogJ0V4aWYgSUZEJywKICAgIDB4OTAwMDogJ0V4aWZWZXJzaW9uJywKICAgIDB4ODI5QTogJ0V4cG9zdXJlVGltZScsCiAgICAweEEzMDA6ICdGaWxlU291cmNlJywKICAgIDB4OTIwOTogJ0ZsYXNoJywKICAgIDB4QTAwMDogJ0ZsYXNocGl4VmVyc2lvbicsCiAgICAweDgyOUQ6ICdGTnVtYmVyJywKICAgIDB4QTQyMDogJ0ltYWdlVW5pcXVlSUQnLAogICAgMHg5MjA4OiAnTGlnaHRTb3VyY2UnLAogICAgMHg5MjdDOiAnTWFrZXJOb3RlJywKICAgIDB4OTIwMTogJ1NodXR0ZXJTcGVlZFZhbHVlJywKICAgIDB4OTI4NjogJ1VzZXJDb21tZW50JywKCiAgICAvLyBJUFRDCiAgICAweDgzQkI6ICdJUFRDJywKCiAgICAvLyBJQ0MKICAgIDB4ODc3MzogJ0lDQyBQcm9maWxlJywKCiAgICAvLyBYTVAKICAgIDB4MDJCQzogJ1hNUCcsCgogICAgLy8gR0RBTAogICAgMHhBNDgwOiAnR0RBTF9NRVRBREFUQScsCiAgICAweEE0ODE6ICdHREFMX05PREFUQScsCgogICAgLy8gUGhvdG9zaG9wCiAgICAweDg2NDk6ICdQaG90b3Nob3AnLAoKICAgIC8vIEdlb1RpZmYKICAgIDB4ODMwRTogJ01vZGVsUGl4ZWxTY2FsZScsCiAgICAweDg0ODI6ICdNb2RlbFRpZXBvaW50JywKICAgIDB4ODVEODogJ01vZGVsVHJhbnNmb3JtYXRpb24nLAogICAgMHg4N0FGOiAnR2VvS2V5RGlyZWN0b3J5JywKICAgIDB4ODdCMDogJ0dlb0RvdWJsZVBhcmFtcycsCiAgICAweDg3QjE6ICdHZW9Bc2NpaVBhcmFtcycsCgogICAgLy8gTEVSQwogICAgMHhDNUYyOiAnTGVyY1BhcmFtZXRlcnMnLAogIH07CgogIGNvbnN0IGZpZWxkVGFncyA9IHt9OwogIGZvciAoY29uc3Qga2V5IGluIGZpZWxkVGFnTmFtZXMpIHsKICAgIGlmIChmaWVsZFRhZ05hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHsKICAgICAgZmllbGRUYWdzW2ZpZWxkVGFnTmFtZXNba2V5XV0gPSBwYXJzZUludChrZXksIDEwKTsKICAgIH0KICB9CgogIFsKICAgIGZpZWxkVGFncy5CaXRzUGVyU2FtcGxlLAogICAgZmllbGRUYWdzLkV4dHJhU2FtcGxlcywKICAgIGZpZWxkVGFncy5TYW1wbGVGb3JtYXQsCiAgICBmaWVsZFRhZ3MuU3RyaXBCeXRlQ291bnRzLAogICAgZmllbGRUYWdzLlN0cmlwT2Zmc2V0cywKICAgIGZpZWxkVGFncy5TdHJpcFJvd0NvdW50cywKICAgIGZpZWxkVGFncy5UaWxlQnl0ZUNvdW50cywKICAgIGZpZWxkVGFncy5UaWxlT2Zmc2V0cywKICAgIGZpZWxkVGFncy5TdWJJRkRzLAogIF07CgogIGNvbnN0IGZpZWxkVHlwZU5hbWVzID0gewogICAgMHgwMDAxOiAnQllURScsCiAgICAweDAwMDI6ICdBU0NJSScsCiAgICAweDAwMDM6ICdTSE9SVCcsCiAgICAweDAwMDQ6ICdMT05HJywKICAgIDB4MDAwNTogJ1JBVElPTkFMJywKICAgIDB4MDAwNjogJ1NCWVRFJywKICAgIDB4MDAwNzogJ1VOREVGSU5FRCcsCiAgICAweDAwMDg6ICdTU0hPUlQnLAogICAgMHgwMDA5OiAnU0xPTkcnLAogICAgMHgwMDBBOiAnU1JBVElPTkFMJywKICAgIDB4MDAwQjogJ0ZMT0FUJywKICAgIDB4MDAwQzogJ0RPVUJMRScsCiAgICAvLyBJRkQgb2Zmc2V0LCBzdWdnZXN0ZWQgYnkgaHR0cHM6Ly9vd2wucGh5LnF1ZWVuc3UuY2EvfnBoaWwvZXhpZnRvb2wvc3RhbmRhcmRzLmh0bWwKICAgIDB4MDAwRDogJ0lGRCcsCiAgICAvLyBpbnRyb2R1Y2VkIGJ5IEJpZ1RJRkYKICAgIDB4MDAxMDogJ0xPTkc4JywKICAgIDB4MDAxMTogJ1NMT05HOCcsCiAgICAweDAwMTI6ICdJRkQ4JywKICB9OwoKICBjb25zdCBmaWVsZFR5cGVzID0ge307CiAgZm9yIChjb25zdCBrZXkgaW4gZmllbGRUeXBlTmFtZXMpIHsKICAgIGlmIChmaWVsZFR5cGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7CiAgICAgIGZpZWxkVHlwZXNbZmllbGRUeXBlTmFtZXNba2V5XV0gPSBwYXJzZUludChrZXksIDEwKTsKICAgIH0KICB9CgogIGNvbnN0IExlcmNQYXJhbWV0ZXJzID0gewogICAgVmVyc2lvbjogMCwKICAgIEFkZENvbXByZXNzaW9uOiAxLAogIH07CgogIGNvbnN0IExlcmNBZGRDb21wcmVzc2lvbiA9IHsKICAgIE5vbmU6IDAsCiAgICBEZWZsYXRlOiAxLAogIH07CgoKICBjb25zdCBnZW9LZXlOYW1lcyA9IHsKICAgIDEwMjQ6ICdHVE1vZGVsVHlwZUdlb0tleScsCiAgICAxMDI1OiAnR1RSYXN0ZXJUeXBlR2VvS2V5JywKICAgIDEwMjY6ICdHVENpdGF0aW9uR2VvS2V5JywKICAgIDIwNDg6ICdHZW9ncmFwaGljVHlwZUdlb0tleScsCiAgICAyMDQ5OiAnR2VvZ0NpdGF0aW9uR2VvS2V5JywKICAgIDIwNTA6ICdHZW9nR2VvZGV0aWNEYXR1bUdlb0tleScsCiAgICAyMDUxOiAnR2VvZ1ByaW1lTWVyaWRpYW5HZW9LZXknLAogICAgMjA1MjogJ0dlb2dMaW5lYXJVbml0c0dlb0tleScsCiAgICAyMDUzOiAnR2VvZ0xpbmVhclVuaXRTaXplR2VvS2V5JywKICAgIDIwNTQ6ICdHZW9nQW5ndWxhclVuaXRzR2VvS2V5JywKICAgIDIwNTU6ICdHZW9nQW5ndWxhclVuaXRTaXplR2VvS2V5JywKICAgIDIwNTY6ICdHZW9nRWxsaXBzb2lkR2VvS2V5JywKICAgIDIwNTc6ICdHZW9nU2VtaU1ham9yQXhpc0dlb0tleScsCiAgICAyMDU4OiAnR2VvZ1NlbWlNaW5vckF4aXNHZW9LZXknLAogICAgMjA1OTogJ0dlb2dJbnZGbGF0dGVuaW5nR2VvS2V5JywKICAgIDIwNjA6ICdHZW9nQXppbXV0aFVuaXRzR2VvS2V5JywKICAgIDIwNjE6ICdHZW9nUHJpbWVNZXJpZGlhbkxvbmdHZW9LZXknLAogICAgMjA2MjogJ0dlb2dUT1dHUzg0R2VvS2V5JywKICAgIDMwNzI6ICdQcm9qZWN0ZWRDU1R5cGVHZW9LZXknLAogICAgMzA3MzogJ1BDU0NpdGF0aW9uR2VvS2V5JywKICAgIDMwNzQ6ICdQcm9qZWN0aW9uR2VvS2V5JywKICAgIDMwNzU6ICdQcm9qQ29vcmRUcmFuc0dlb0tleScsCiAgICAzMDc2OiAnUHJvakxpbmVhclVuaXRzR2VvS2V5JywKICAgIDMwNzc6ICdQcm9qTGluZWFyVW5pdFNpemVHZW9LZXknLAogICAgMzA3ODogJ1Byb2pTdGRQYXJhbGxlbDFHZW9LZXknLAogICAgMzA3OTogJ1Byb2pTdGRQYXJhbGxlbDJHZW9LZXknLAogICAgMzA4MDogJ1Byb2pOYXRPcmlnaW5Mb25nR2VvS2V5JywKICAgIDMwODE6ICdQcm9qTmF0T3JpZ2luTGF0R2VvS2V5JywKICAgIDMwODI6ICdQcm9qRmFsc2VFYXN0aW5nR2VvS2V5JywKICAgIDMwODM6ICdQcm9qRmFsc2VOb3J0aGluZ0dlb0tleScsCiAgICAzMDg0OiAnUHJvakZhbHNlT3JpZ2luTG9uZ0dlb0tleScsCiAgICAzMDg1OiAnUHJvakZhbHNlT3JpZ2luTGF0R2VvS2V5JywKICAgIDMwODY6ICdQcm9qRmFsc2VPcmlnaW5FYXN0aW5nR2VvS2V5JywKICAgIDMwODc6ICdQcm9qRmFsc2VPcmlnaW5Ob3J0aGluZ0dlb0tleScsCiAgICAzMDg4OiAnUHJvakNlbnRlckxvbmdHZW9LZXknLAogICAgMzA4OTogJ1Byb2pDZW50ZXJMYXRHZW9LZXknLAogICAgMzA5MDogJ1Byb2pDZW50ZXJFYXN0aW5nR2VvS2V5JywKICAgIDMwOTE6ICdQcm9qQ2VudGVyTm9ydGhpbmdHZW9LZXknLAogICAgMzA5MjogJ1Byb2pTY2FsZUF0TmF0T3JpZ2luR2VvS2V5JywKICAgIDMwOTM6ICdQcm9qU2NhbGVBdENlbnRlckdlb0tleScsCiAgICAzMDk0OiAnUHJvakF6aW11dGhBbmdsZUdlb0tleScsCiAgICAzMDk1OiAnUHJvalN0cmFpZ2h0VmVydFBvbGVMb25nR2VvS2V5JywKICAgIDMwOTY6ICdQcm9qUmVjdGlmaWVkR3JpZEFuZ2xlR2VvS2V5JywKICAgIDQwOTY6ICdWZXJ0aWNhbENTVHlwZUdlb0tleScsCiAgICA0MDk3OiAnVmVydGljYWxDaXRhdGlvbkdlb0tleScsCiAgICA0MDk4OiAnVmVydGljYWxEYXR1bUdlb0tleScsCiAgICA0MDk5OiAnVmVydGljYWxVbml0c0dlb0tleScsCiAgfTsKCiAgY29uc3QgZ2VvS2V5cyA9IHt9OwogIGZvciAoY29uc3Qga2V5IGluIGdlb0tleU5hbWVzKSB7CiAgICBpZiAoZ2VvS2V5TmFtZXMuaGFzT3duUHJvcGVydHkoa2V5KSkgewogICAgICBnZW9LZXlzW2dlb0tleU5hbWVzW2tleV1dID0gcGFyc2VJbnQoa2V5LCAxMCk7CiAgICB9CiAgfQoKICBjbGFzcyBMZXJjRGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHsKICAgIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnkpIHsKICAgICAgc3VwZXIoKTsKCiAgICAgIHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9IHR5cGVvZiBmaWxlRGlyZWN0b3J5LlBsYW5hckNvbmZpZ3VyYXRpb24gIT09ICd1bmRlZmluZWQnID8gZmlsZURpcmVjdG9yeS5QbGFuYXJDb25maWd1cmF0aW9uIDogMTsKICAgICAgdGhpcy5zYW1wbGVzUGVyUGl4ZWwgPSB0eXBlb2YgZmlsZURpcmVjdG9yeS5TYW1wbGVzUGVyUGl4ZWwgIT09ICd1bmRlZmluZWQnID8gZmlsZURpcmVjdG9yeS5TYW1wbGVzUGVyUGl4ZWwgOiAxOwoKICAgICAgdGhpcy5hZGRDb21wcmVzc2lvbiA9IGZpbGVEaXJlY3RvcnkuTGVyY1BhcmFtZXRlcnNbTGVyY1BhcmFtZXRlcnMuQWRkQ29tcHJlc3Npb25dOwogICAgfQoKICAgIGludGVybGVhdmVQaXhlbHMoYmFuZEludGVybGVhdmVkRGF0YSkgewogICAgICBjb25zdCBwaXhlbEludGVybGVhdmVkRGF0YSA9IG5ldyBiYW5kSW50ZXJsZWF2ZWREYXRhLmNvbnN0cnVjdG9yKGJhbmRJbnRlcmxlYXZlZERhdGEubGVuZ3RoKTsKICAgICAgY29uc3QgbGVuZ3RoUGVyU2FtcGxlID0gYmFuZEludGVybGVhdmVkRGF0YS5sZW5ndGggLyB0aGlzLnNhbXBsZXNQZXJQaXhlbDsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGhQZXJTYW1wbGU7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5zYW1wbGVzUGVyUGl4ZWw7IGorKykgewogICAgICAgICAgcGl4ZWxJbnRlcmxlYXZlZERhdGFbaSAqIHRoaXMuc2FtcGxlc1BlclBpeGVsICsgal0gPSBiYW5kSW50ZXJsZWF2ZWREYXRhW2kgKyBqICogbGVuZ3RoUGVyU2FtcGxlXTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHBpeGVsSW50ZXJsZWF2ZWREYXRhOwogICAgfQoKICAgIGRlY29kZUJsb2NrKGJ1ZmZlcikgewogICAgICBzd2l0Y2ggKHRoaXMuYWRkQ29tcHJlc3Npb24pIHsKICAgICAgICBjYXNlIExlcmNBZGRDb21wcmVzc2lvbi5Ob25lOgogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSBMZXJjQWRkQ29tcHJlc3Npb24uRGVmbGF0ZToKICAgICAgICAgIGJ1ZmZlciA9IGluZmxhdGVfMShuZXcgVWludDhBcnJheShidWZmZXIpKS5idWZmZXI7CiAgICAgICAgICBicmVhazsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBMRVJDIGFkZGl0aW9uYWwgY29tcHJlc3Npb24gbWV0aG9kIGlkZW50aWZpZXI6ICR7dGhpcy5hZGRDb21wcmVzc2lvbn1gKTsKICAgICAgfQoKICAgICAgY29uc3QgbGVyY1Jlc3VsdCA9IExlcmMuZGVjb2RlKGJ1ZmZlcik7CiAgICAgIGNvbnN0IGxlcmNEYXRhID0gbGVyY1Jlc3VsdC5waXhlbHNbMF07IC8vIGFsd2F5cyBiYW5kLWludGVybGVhdmVkCiAgICAgIGNvbnN0IGRlY29kZWREYXRhID0gdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAxID8gdGhpcy5pbnRlcmxlYXZlUGl4ZWxzKGxlcmNEYXRhKSA6IGxlcmNEYXRhOyAvLyB0cmFuc2Zvcm0gdG8gcGl4ZWwtaW50ZXJsZWF2ZWQgaWYgZXhwZWN0ZWQKICAgICAgcmV0dXJuIGRlY29kZWREYXRhLmJ1ZmZlcjsKICAgIH0KICB9CgogIGZ1bmN0aW9uIGdldERlY29kZXIoZmlsZURpcmVjdG9yeSkgewogICAgc3dpdGNoIChmaWxlRGlyZWN0b3J5LkNvbXByZXNzaW9uKSB7CiAgICAgIGNhc2UgdW5kZWZpbmVkOgogICAgICBjYXNlIDE6IC8vIG5vIGNvbXByZXNzaW9uCiAgICAgICAgcmV0dXJuIG5ldyBSYXdEZWNvZGVyKCk7CiAgICAgIGNhc2UgNTogLy8gTFpXCiAgICAgICAgcmV0dXJuIG5ldyBMWldEZWNvZGVyKGZpbGVEaXJlY3RvcnkpOwogICAgICBjYXNlIDY6IC8vIEpQRUcKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29sZCBzdHlsZSBKUEVHIGNvbXByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQuJyk7CiAgICAgIGNhc2UgNzogLy8gSlBFRwogICAgICAgIHJldHVybiBuZXcgSnBlZ0RlY29kZXIoZmlsZURpcmVjdG9yeSk7CiAgICAgIGNhc2UgODogLy8gRGVmbGF0ZSBhcyByZWNvZ25pemVkIGJ5IEFkb2JlCiAgICAgIGNhc2UgMzI5NDY6IC8vIERlZmxhdGUgR0RBTCBkZWZhdWx0CiAgICAgICAgcmV0dXJuIG5ldyBEZWZsYXRlRGVjb2RlcigpOwogICAgICBjYXNlIDMyNzczOiAvLyBwYWNrYml0cwogICAgICAgIHJldHVybiBuZXcgUGFja2JpdHNEZWNvZGVyKCk7CiAgICAgIGNhc2UgMzQ4ODc6IC8vIExFUkMKICAgICAgICByZXR1cm4gbmV3IExlcmNEZWNvZGVyKGZpbGVEaXJlY3RvcnkpOwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QgaWRlbnRpZmllcjogJHtmaWxlRGlyZWN0b3J5LkNvbXByZXNzaW9ufWApOwogICAgfQogIH0KCiAgYXN5bmMgZnVuY3Rpb24gZGVjb2RlKGZpbGVEaXJlY3RvcnksIGJ1ZmZlcikgewogICAgY29uc3QgZGVjb2RlciA9IGdldERlY29kZXIoZmlsZURpcmVjdG9yeSk7CiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZWNvZGVyLmRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpOwogICAgc2VsZi5wb3N0TWVzc2FnZShyZXN1bHQsIFtyZXN1bHRdKTsKICB9CiAgaWYgKHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIikgewogICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgKGV2ZW50KSA9PiB7CiAgICAgIGNvbnN0IFtuYW1lLCAuLi5hcmdzXSA9IGV2ZW50LmRhdGE7CiAgICAgIHN3aXRjaCAobmFtZSkgewogICAgICAgIGNhc2UgImRlY29kZSI6CiAgICAgICAgICBkZWNvZGUoYXJnc1swXSwgYXJnc1sxXSk7CiAgICAgICAgICBicmVhazsKICAgICAgfQogICAgfSk7CiAgfQoKfSkoKTsK";
var blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper() {
  const objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
  try {
    return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
var _a, _b;
var defaultPoolSize = (_b = (_a = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : _a.hardwareConcurrency) != null ? _b : 4;
var Pool = class {
  constructor(size = defaultPoolSize) {
    __publicField(this, "workers");
    __publicField(this, "idleWorkers");
    __publicField(this, "waitQueue");
    __publicField(this, "decoder");
    this.workers = [];
    this.idleWorkers = [];
    this.waitQueue = [];
    this.decoder = null;
    for (let i = 0; i < size; ++i) {
      const w = new WorkerWrapper();
      this.workers.push(w);
      this.idleWorkers.push(w);
    }
  }
  decode(fileDirectory, buffer) {
    return __async(this, null, function* () {
      const currentWorker = yield this.waitForWorker();
      return new Promise((resolve, reject) => {
        currentWorker.onmessage = (event) => {
          this.finishTask(currentWorker);
          resolve(event.data);
        };
        currentWorker.onerror = (error) => {
          this.finishTask(currentWorker);
          reject(error);
        };
        currentWorker.postMessage(["decode", fileDirectory, buffer], [buffer]);
      });
    });
  }
  waitForWorker() {
    return __async(this, null, function* () {
      const idleWorker = this.idleWorkers.pop();
      if (idleWorker) {
        return idleWorker;
      }
      const waiter = {};
      const promise = new Promise((resolve) => {
        waiter.resolve = resolve;
      });
      this.waitQueue.push(waiter);
      return promise;
    });
  }
  finishTask(currentWorker) {
    return __async(this, null, function* () {
      const waiter = this.waitQueue.pop();
      if (waiter) {
        waiter.resolve(currentWorker);
      } else {
        this.idleWorkers.push(currentWorker);
      }
    });
  }
  destroy() {
    for (let i = 0; i < this.workers.length; ++i) {
      this.workers[i].terminate();
    }
  }
};
var PARSER_OPTIONS = {
  attributeNamePrefix: "",
  attrNodeName: "attr",
  parseNodeValue: true,
  parseAttributeValue: true,
  ignoreAttributes: false
};
var parse = (str) => parser.parse(str, PARSER_OPTIONS);
function fromString(str) {
  const res = parse(str);
  if (!res.OME) {
    throw Error("Failed to parse OME-XML metadata.");
  }
  return ensureArray(res.OME.Image).map((img) => {
    const Channels = ensureArray(img.Pixels.Channel).map((c) => {
      if ("Color" in c.attr) {
        return __spreadProps(__spreadValues({}, c.attr), { Color: intToRgba(c.attr.Color) });
      }
      return __spreadValues({}, c.attr);
    });
    const { AquisitionDate = "", Description: Description2 = "" } = img;
    const image = __spreadProps(__spreadValues({}, img.attr), {
      AquisitionDate,
      Description: Description2,
      Pixels: __spreadProps(__spreadValues({}, img.Pixels.attr), {
        Channels
      })
    });
    return __spreadProps(__spreadValues({}, image), {
      format() {
        const { Pixels } = image;
        const sizes = ["X", "Y", "Z"].map((name2) => {
          const size = Pixels[`PhysicalSize${name2}`];
          const unit2 = Pixels[`PhysicalSize${name2}Unit`];
          return size && unit2 ? `${size} ${unit2}` : "-";
        }).join(" x ");
        return {
          "Acquisition Date": image.AquisitionDate,
          "Dimensions (XY)": `${Pixels.SizeX} x ${Pixels.SizeY}`,
          "Pixels Type": Pixels.Type,
          "Pixels Size (XYZ)": sizes,
          "Z-sections/Timepoints": `${Pixels.SizeZ} x ${Pixels.SizeT}`,
          Channels: Pixels.SizeC
        };
      }
    });
  });
}
var TiffPixelSource = class {
  constructor(indexer, dtype, tileSize, shape, labels, meta, pool) {
    __publicField(this, "_indexer");
    this.dtype = dtype;
    this.tileSize = tileSize;
    this.shape = shape;
    this.labels = labels;
    this.meta = meta;
    this.pool = pool;
    this._indexer = indexer;
  }
  getRaster(_0) {
    return __async(this, arguments, function* ({ selection, signal }) {
      const image = yield this._indexer(selection);
      return this._readRasters(image, { signal });
    });
  }
  getTile(_0) {
    return __async(this, arguments, function* ({ x, y, selection, signal }) {
      const { height, width } = this._getTileExtent(x, y);
      const x0 = x * this.tileSize;
      const y0 = y * this.tileSize;
      const window2 = [x0, y0, x0 + width, y0 + height];
      const image = yield this._indexer(selection);
      return this._readRasters(image, { window: window2, width, height, signal });
    });
  }
  _readRasters(image, props) {
    return __async(this, null, function* () {
      var _a2;
      const interleave = isInterleaved(this.shape);
      const raster = yield image.readRasters(__spreadProps(__spreadValues({
        interleave
      }, props), {
        pool: this.pool
      }));
      if ((_a2 = props == null ? void 0 : props.signal) == null ? void 0 : _a2.aborted) {
        throw SIGNAL_ABORTED;
      }
      const data = interleave ? raster : raster[0];
      return {
        data,
        width: raster.width,
        height: raster.height
      };
    });
  }
  _getTileExtent(x, y) {
    const { height: zoomLevelHeight, width: zoomLevelWidth } = getImageSize(this);
    let height = this.tileSize;
    let width = this.tileSize;
    const maxXTileCoord = Math.floor(zoomLevelWidth / this.tileSize);
    const maxYTileCoord = Math.floor(zoomLevelHeight / this.tileSize);
    if (x === maxXTileCoord) {
      width = zoomLevelWidth % this.tileSize;
    }
    if (y === maxYTileCoord) {
      height = zoomLevelHeight % this.tileSize;
    }
    return { height, width };
  }
  onTileError(err) {
    console.error(err);
  }
};
function getOmeLegacyIndexer(tiff, rootMeta) {
  const imgMeta = rootMeta[0];
  const { SizeT, SizeC, SizeZ } = imgMeta.Pixels;
  const ifdIndexer = getOmeIFDIndexer(imgMeta);
  return (sel, pyramidLevel) => {
    const index = ifdIndexer(sel);
    const pyramidIndex = pyramidLevel * SizeZ * SizeT * SizeC;
    return tiff.getImage(index + pyramidIndex);
  };
}
function getOmeSubIFDIndexer(tiff, rootMeta) {
  const imgMeta = rootMeta[0];
  const ifdIndexer = getOmeIFDIndexer(imgMeta);
  const ifdCache = new Map();
  return (sel, pyramidLevel) => __async(this, null, function* () {
    const index = ifdIndexer(sel);
    const baseImage = yield tiff.getImage(index);
    if (pyramidLevel === 0) {
      return baseImage;
    }
    const { SubIFDs } = baseImage.fileDirectory;
    if (!SubIFDs) {
      throw Error("Indexing Error: OME-TIFF is missing SubIFDs.");
    }
    const key = `${sel.t}-${sel.c}-${sel.z}-${pyramidLevel}`;
    if (!ifdCache.has(key)) {
      const subIfdOffset = SubIFDs[pyramidLevel - 1];
      ifdCache.set(key, tiff.parseFileDirectoryAt(subIfdOffset));
    }
    const ifd = yield ifdCache.get(key);
    return new baseImage.constructor(ifd.fileDirectory, ifd.geoKeyDirectory, tiff.dataView, tiff.littleEndian, tiff.cache, tiff.source);
  });
}
function getOmeIFDIndexer(imgMeta) {
  const { SizeC, SizeZ, SizeT, DimensionOrder } = imgMeta.Pixels;
  switch (DimensionOrder) {
    case "XYZCT": {
      return ({ t, c, z }) => t * SizeZ * SizeC + c * SizeZ + z;
    }
    case "XYZTC": {
      return ({ t, c, z }) => c * SizeZ * SizeT + t * SizeZ + z;
    }
    case "XYCTZ": {
      return ({ t, c, z }) => z * SizeC * SizeT + t * SizeC + c;
    }
    case "XYCZT": {
      return ({ t, c, z }) => t * SizeC * SizeZ + z * SizeC + c;
    }
    case "XYTCZ": {
      return ({ t, c, z }) => z * SizeT * SizeC + c * SizeT + t;
    }
    case "XYTZC": {
      return ({ t, c, z }) => c * SizeT * SizeZ + z * SizeT + t;
    }
    default: {
      throw new Error(`Invalid OME-XML DimensionOrder, got ${DimensionOrder}.`);
    }
  }
}
var DTYPE_LOOKUP$1 = {
  uint8: "Uint8",
  uint16: "Uint16",
  uint32: "Uint32",
  float: "Float32",
  double: "Float64",
  int8: "Int8",
  int16: "Int16",
  int32: "Int32"
};
function getOmePixelSourceMeta({ Pixels }) {
  const labels = getLabels(Pixels.DimensionOrder);
  const dims = getDims(labels);
  const shape = Array(labels.length).fill(0);
  shape[dims("t")] = Pixels.SizeT;
  shape[dims("c")] = Pixels.SizeC;
  shape[dims("z")] = Pixels.SizeZ;
  if (Pixels.Interleaved) {
    labels.push("_c");
    shape.push(3);
  }
  const getShape = (level) => {
    const s = [...shape];
    s[dims("x")] = Pixels.SizeX >> level;
    s[dims("y")] = Pixels.SizeY >> level;
    return s;
  };
  if (!(Pixels.Type in DTYPE_LOOKUP$1)) {
    throw Error(`Pixel type ${Pixels.Type} not supported.`);
  }
  const dtype = DTYPE_LOOKUP$1[Pixels.Type];
  if (Pixels.PhysicalSizeX && Pixels.PhysicalSizeY) {
    const physicalSizes = {
      x: {
        size: Pixels.PhysicalSizeX,
        unit: Pixels.PhysicalSizeXUnit
      },
      y: {
        size: Pixels.PhysicalSizeY,
        unit: Pixels.PhysicalSizeYUnit
      }
    };
    if (Pixels.PhysicalSizeZ) {
      physicalSizes.z = {
        size: Pixels.PhysicalSizeZ,
        unit: Pixels.PhysicalSizeZUnit
      };
    }
    return { labels, getShape, physicalSizes, dtype };
  }
  return { labels, getShape, dtype };
}
function guessTileSize$1(image) {
  const tileWidth = image.getTileWidth();
  const tileHeight = image.getTileHeight();
  const size = Math.min(tileWidth, tileHeight);
  return prevPowerOf2(size);
}
function load$2(tiff, pool) {
  return __async(this, null, function* () {
    const firstImage = yield tiff.getImage(0);
    const {
      ImageDescription,
      SubIFDs,
      PhotometricInterpretation: photometricInterpretation
    } = firstImage.fileDirectory;
    const omexml = fromString(ImageDescription);
    let levels;
    let pyramidIndexer;
    if (SubIFDs) {
      levels = SubIFDs.length + 1;
      pyramidIndexer = getOmeSubIFDIndexer(tiff, omexml);
    } else {
      levels = omexml.length;
      pyramidIndexer = getOmeLegacyIndexer(tiff, omexml);
    }
    const imgMeta = omexml[0];
    const { labels, getShape, physicalSizes, dtype } = getOmePixelSourceMeta(imgMeta);
    const tileSize = guessTileSize$1(firstImage);
    const meta = { photometricInterpretation, physicalSizes };
    const data = Array.from({ length: levels }).map((_, resolution) => {
      const shape = getShape(resolution);
      const indexer = (sel) => pyramidIndexer(sel, resolution);
      const source = new TiffPixelSource(indexer, dtype, tileSize, shape, labels, meta, pool);
      return source;
    });
    return {
      data,
      metadata: imgMeta
    };
  });
}
function loadOmeTiff(_0) {
  return __async(this, arguments, function* (source, opts = {}) {
    const { headers, offsets, pool = true } = opts;
    let tiff;
    if (typeof source === "string") {
      tiff = yield fromUrl(source, __spreadProps(__spreadValues({}, headers), { cacheSize: Infinity }));
    } else {
      tiff = yield fromBlob(source);
    }
    if (offsets) {
      tiff = createOffsetsProxy(tiff, offsets);
    }
    checkProxies(tiff);
    return pool ? load$2(tiff, new Pool()) : load$2(tiff);
  });
}
function loadMultiscales(store, path = "") {
  return __async(this, null, function* () {
    const grp = yield openGroup(store, path);
    const rootAttrs = yield grp.attrs.asObject();
    let paths = ["0"];
    if ("multiscales" in rootAttrs) {
      const { datasets } = rootAttrs.multiscales[0];
      paths = datasets.map((d) => d.path);
    }
    const data = paths.map((path2) => grp.getItem(path2));
    return {
      data: yield Promise.all(data),
      rootAttrs
    };
  });
}
function guessTileSize(arr) {
  const interleaved = isInterleaved(arr.shape);
  const [yChunk, xChunk] = arr.chunks.slice(interleaved ? -3 : -2);
  const size = Math.min(yChunk, xChunk);
  return prevPowerOf2(size);
}
function getIndexer(labels) {
  const size = labels.length;
  const dims = getDims(labels);
  return (sel) => {
    if (Array.isArray(sel)) {
      return [...sel];
    }
    const selection = Array(size).fill(0);
    for (const [key, value] of Object.entries(sel)) {
      selection[dims(key)] = value;
    }
    return selection;
  };
}
var DTYPE_LOOKUP = {
  u1: "Uint8",
  u2: "Uint16",
  u4: "Uint32",
  f4: "Float32",
  f8: "Float64",
  i1: "Int8",
  i2: "Int16",
  i4: "Int32"
};
var ZarrPixelSource = class {
  constructor(data, labels, tileSize) {
    __publicField(this, "_data");
    __publicField(this, "_indexer");
    __publicField(this, "_readChunks");
    this.labels = labels;
    this.tileSize = tileSize;
    this._indexer = getIndexer(labels);
    this._data = data;
    const xChunkSize = data.chunks[this._xIndex];
    const yChunkSize = data.chunks[this._xIndex - 1];
    this._readChunks = tileSize === xChunkSize && tileSize === yChunkSize;
  }
  get shape() {
    return this._data.shape;
  }
  get dtype() {
    const suffix = this._data.dtype.slice(1);
    if (!(suffix in DTYPE_LOOKUP)) {
      throw Error(`Zarr dtype not supported, got ${suffix}.`);
    }
    return DTYPE_LOOKUP[suffix];
  }
  get _xIndex() {
    const interleave = isInterleaved(this._data.shape);
    return this._data.shape.length - (interleave ? 2 : 1);
  }
  _chunkIndex(selection, x, y) {
    const sel = this._indexer(selection);
    sel[this._xIndex] = x;
    sel[this._xIndex - 1] = y;
    return sel;
  }
  _getSlices(x, y) {
    const { height, width } = getImageSize(this);
    const [xStart, xStop] = [
      x * this.tileSize,
      Math.min((x + 1) * this.tileSize, width)
    ];
    const [yStart, yStop] = [
      y * this.tileSize,
      Math.min((y + 1) * this.tileSize, height)
    ];
    if (xStart === xStop || yStart === yStop) {
      throw new BoundsCheckError("Tile slice is zero-sized.");
    }
    return [slice(xStart, xStop), slice(yStart, yStop)];
  }
  getRaster(_0) {
    return __async(this, arguments, function* ({ selection }) {
      const sel = this._chunkIndex(selection, null, null);
      const { data, shape } = yield this._data.getRaw(sel);
      const [height, width] = shape;
      return { data, width, height };
    });
  }
  getTile(props) {
    return __async(this, null, function* () {
      const { x, y, selection, signal } = props;
      let res;
      if (this._readChunks) {
        const sel = this._chunkIndex(selection, x, y);
        res = yield this._data.getRawChunk(sel, { storeOptions: { signal } });
      } else {
        const [xSlice, ySlice] = this._getSlices(x, y);
        const sel = this._chunkIndex(selection, xSlice, ySlice);
        res = yield this._data.getRaw(sel);
      }
      const {
        data,
        shape: [height, width]
      } = res;
      return { data, width, height };
    });
  }
  onTileError(err) {
    if (!(err instanceof BoundsCheckError)) {
      throw err;
    }
  }
};
function load(store) {
  return __async(this, null, function* () {
    const { data, rootAttrs } = yield loadMultiscales(store);
    const labels = ["t", "c", "z", "y", "x"];
    const tileSize = guessTileSize(data[0]);
    const pyramid = data.map((arr) => new ZarrPixelSource(arr, labels, tileSize));
    return {
      data: pyramid,
      metadata: rootAttrs
    };
  });
}
function loadOmeZarr(_0) {
  return __async(this, arguments, function* (source, options = {}) {
    const store = new HTTPStore(source, options);
    if ((options == null ? void 0 : options.type) !== "multiscales") {
      throw Error("Only multiscale OME-Zarr is supported.");
    }
    return load(store);
  });
}

// src/components/spatial/constants.js
var GLOBAL_LABELS = ["z", "t"];
var DEFAULT_RASTER_DOMAIN_TYPE = "Min/Max";
var DEFAULT_RASTER_LAYER_PROPS = {
  visible: true,
  colormap: null,
  opacity: 1,
  domainType: DEFAULT_RASTER_DOMAIN_TYPE,
  transparentColor: [0, 0, 0],
  renderingMode: RENDERING_MODES.ADDITIVE,
  use3d: false
};
var DEFAULT_MOLECULES_LAYER = {
  opacity: 1,
  radius: 20,
  visible: true
};
var DEFAULT_CELLS_LAYER = {
  opacity: 1,
  radius: 50,
  visible: true,
  stroked: false
};
var DEFAULT_NEIGHBORHOODS_LAYER = {
  visible: false
};

// src/app/state/coordination.js
var COORDINATION_TYPES = {
  DATASET: "dataset",
  EMBEDDING_TYPE: "embeddingType",
  EMBEDDING_ZOOM: "embeddingZoom",
  EMBEDDING_ROTATION: "embeddingRotation",
  EMBEDDING_TARGET_X: "embeddingTargetX",
  EMBEDDING_TARGET_Y: "embeddingTargetY",
  EMBEDDING_TARGET_Z: "embeddingTargetZ",
  EMBEDDING_CELL_SET_POLYGONS_VISIBLE: "embeddingCellSetPolygonsVisible",
  EMBEDDING_CELL_SET_LABELS_VISIBLE: "embeddingCellSetLabelsVisible",
  EMBEDDING_CELL_SET_LABEL_SIZE: "embeddingCellSetLabelSize",
  EMBEDDING_CELL_RADIUS: "embeddingCellRadius",
  EMBEDDING_CELL_OPACITY: "embeddingCellOpacity",
  EMBEDDING_CELL_RADIUS_MODE: "embeddingCellRadiusMode",
  EMBEDDING_CELL_OPACITY_MODE: "embeddingCellOpacityMode",
  SPATIAL_ZOOM: "spatialZoom",
  SPATIAL_ROTATION: "spatialRotation",
  SPATIAL_TARGET_X: "spatialTargetX",
  SPATIAL_TARGET_Y: "spatialTargetY",
  SPATIAL_TARGET_Z: "spatialTargetZ",
  SPATIAL_ROTATION_X: "spatialRotationX",
  SPATIAL_ROTATION_Y: "spatialRotationY",
  SPATIAL_ROTATION_Z: "spatialRotationZ",
  SPATIAL_ROTATION_ORBIT: "spatialRotationOrbit",
  SPATIAL_ORBIT_AXIS: "spatialOrbitAxis",
  SPATIAL_AXIS_FIXED: "spatialAxisFixed",
  HEATMAP_ZOOM_X: "heatmapZoomX",
  HEATMAP_ZOOM_Y: "heatmapZoomY",
  HEATMAP_TARGET_X: "heatmapTargetX",
  HEATMAP_TARGET_Y: "heatmapTargetY",
  CELL_FILTER: "cellFilter",
  CELL_HIGHLIGHT: "cellHighlight",
  CELL_SET_SELECTION: "cellSetSelection",
  CELL_SET_HIGHLIGHT: "cellSetHighlight",
  CELL_SET_COLOR: "cellSetColor",
  GENE_FILTER: "geneFilter",
  GENE_HIGHLIGHT: "geneHighlight",
  GENE_SELECTION: "geneSelection",
  GENE_EXPRESSION_COLORMAP: "geneExpressionColormap",
  GENE_EXPRESSION_TRANSFORM: "geneExpressionTransform",
  GENE_EXPRESSION_COLORMAP_RANGE: "geneExpressionColormapRange",
  CELL_COLOR_ENCODING: "cellColorEncoding",
  SPATIAL_RASTER_LAYERS: "spatialRasterLayers",
  SPATIAL_CELLS_LAYER: "spatialCellsLayer",
  SPATIAL_MOLECULES_LAYER: "spatialMoleculesLayer",
  SPATIAL_NEIGHBORHOODS_LAYER: "spatialNeighborhoodsLayer",
  GENOMIC_ZOOM_X: "genomicZoomX",
  GENOMIC_ZOOM_Y: "genomicZoomY",
  GENOMIC_TARGET_X: "genomicTargetX",
  GENOMIC_TARGET_Y: "genomicTargetY",
  ADDITIONAL_CELL_SETS: "additionalCellSets",
  MOLECULE_HIGHLIGHT: "moleculeHighlight"
};
var DEFAULT_COORDINATION_VALUES = {
  [COORDINATION_TYPES.EMBEDDING_ZOOM]: null,
  [COORDINATION_TYPES.EMBEDDING_ROTATION]: 0,
  [COORDINATION_TYPES.EMBEDDING_TARGET_X]: null,
  [COORDINATION_TYPES.EMBEDDING_TARGET_Y]: null,
  [COORDINATION_TYPES.EMBEDDING_TARGET_Z]: 0,
  [COORDINATION_TYPES.EMBEDDING_CELL_SET_POLYGONS_VISIBLE]: false,
  [COORDINATION_TYPES.EMBEDDING_CELL_SET_LABELS_VISIBLE]: false,
  [COORDINATION_TYPES.EMBEDDING_CELL_SET_LABEL_SIZE]: 14,
  [COORDINATION_TYPES.EMBEDDING_CELL_RADIUS]: 1,
  [COORDINATION_TYPES.EMBEDDING_CELL_RADIUS_MODE]: "auto",
  [COORDINATION_TYPES.EMBEDDING_CELL_OPACITY]: 1,
  [COORDINATION_TYPES.EMBEDDING_CELL_OPACITY_MODE]: "auto",
  [COORDINATION_TYPES.SPATIAL_ZOOM]: null,
  [COORDINATION_TYPES.SPATIAL_ROTATION]: 0,
  [COORDINATION_TYPES.SPATIAL_TARGET_X]: null,
  [COORDINATION_TYPES.SPATIAL_TARGET_Y]: null,
  [COORDINATION_TYPES.SPATIAL_TARGET_Z]: null,
  [COORDINATION_TYPES.SPATIAL_ROTATION_X]: null,
  [COORDINATION_TYPES.SPATIAL_ROTATION_Y]: null,
  [COORDINATION_TYPES.SPATIAL_ROTATION_Z]: null,
  [COORDINATION_TYPES.SPATIAL_AXIS_FIXED]: false,
  [COORDINATION_TYPES.SPATIAL_ROTATION_ORBIT]: 0,
  [COORDINATION_TYPES.SPATIAL_ORBIT_AXIS]: "Y",
  [COORDINATION_TYPES.SPATIAL_RASTER_LAYERS]: null,
  [COORDINATION_TYPES.SPATIAL_CELLS_LAYER]: null,
  [COORDINATION_TYPES.SPATIAL_MOLECULES_LAYER]: null,
  [COORDINATION_TYPES.SPATIAL_NEIGHBORHOODS_LAYER]: null,
  [COORDINATION_TYPES.HEATMAP_ZOOM_X]: 0,
  [COORDINATION_TYPES.HEATMAP_ZOOM_Y]: 0,
  [COORDINATION_TYPES.HEATMAP_TARGET_X]: 0,
  [COORDINATION_TYPES.HEATMAP_TARGET_Y]: 0,
  [COORDINATION_TYPES.GENE_EXPRESSION_COLORMAP]: "plasma",
  [COORDINATION_TYPES.GENE_EXPRESSION_COLORMAP_RANGE]: [0, 1],
  [COORDINATION_TYPES.GENE_EXPRESSION_TRANSFORM]: null,
  [COORDINATION_TYPES.GENE_FILTER]: null,
  [COORDINATION_TYPES.GENE_HIGHLIGHT]: null,
  [COORDINATION_TYPES.GENE_SELECTION]: null,
  [COORDINATION_TYPES.CELL_FILTER]: null,
  [COORDINATION_TYPES.CELL_HIGHLIGHT]: null,
  [COORDINATION_TYPES.CELL_SET_SELECTION]: null,
  [COORDINATION_TYPES.CELL_SET_HIGHLIGHT]: null,
  [COORDINATION_TYPES.CELL_SET_COLOR]: null,
  [COORDINATION_TYPES.CELL_COLOR_ENCODING]: "cellSetSelection",
  [COORDINATION_TYPES.GENOMIC_ZOOM_X]: 0,
  [COORDINATION_TYPES.GENOMIC_ZOOM_Y]: 0,
  [COORDINATION_TYPES.GENOMIC_TARGET_X]: 15499999995e-1,
  [COORDINATION_TYPES.GENOMIC_TARGET_Y]: 15499999995e-1,
  [COORDINATION_TYPES.ADDITIONAL_CELL_SETS]: null,
  [COORDINATION_TYPES.MOLECULE_HIGHLIGHT]: null
};
var AUTO_INDEPENDENT_COORDINATION_TYPES = [
  COORDINATION_TYPES.HEATMAP_ZOOM_X,
  COORDINATION_TYPES.HEATMAP_ZOOM_Y,
  COORDINATION_TYPES.HEATMAP_TARGET_X,
  COORDINATION_TYPES.HEATMAP_TARGET_Y,
  COORDINATION_TYPES.EMBEDDING_ZOOM,
  COORDINATION_TYPES.EMBEDDING_TARGET_X,
  COORDINATION_TYPES.EMBEDDING_TARGET_Y,
  COORDINATION_TYPES.EMBEDDING_TARGET_Z,
  COORDINATION_TYPES.EMBEDDING_CELL_SET_POLYGONS_VISIBLE,
  COORDINATION_TYPES.EMBEDDING_CELL_SET_LABELS_VISIBLE,
  COORDINATION_TYPES.EMBEDDING_CELL_SET_LABEL_SIZE,
  COORDINATION_TYPES.EMBEDDING_CELL_RADIUS,
  COORDINATION_TYPES.EMBEDDING_CELL_OPACITY
];
var COMPONENT_COORDINATION_TYPES = {
  scatterplot: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.EMBEDDING_TYPE,
    COORDINATION_TYPES.EMBEDDING_ZOOM,
    COORDINATION_TYPES.EMBEDDING_ROTATION,
    COORDINATION_TYPES.EMBEDDING_TARGET_X,
    COORDINATION_TYPES.EMBEDDING_TARGET_Y,
    COORDINATION_TYPES.EMBEDDING_TARGET_Z,
    COORDINATION_TYPES.EMBEDDING_CELL_SET_POLYGONS_VISIBLE,
    COORDINATION_TYPES.EMBEDDING_CELL_SET_LABELS_VISIBLE,
    COORDINATION_TYPES.EMBEDDING_CELL_SET_LABEL_SIZE,
    COORDINATION_TYPES.EMBEDDING_CELL_RADIUS,
    COORDINATION_TYPES.EMBEDDING_CELL_RADIUS_MODE,
    COORDINATION_TYPES.EMBEDDING_CELL_OPACITY,
    COORDINATION_TYPES.EMBEDDING_CELL_OPACITY_MODE,
    COORDINATION_TYPES.CELL_FILTER,
    COORDINATION_TYPES.CELL_HIGHLIGHT,
    COORDINATION_TYPES.CELL_SET_SELECTION,
    COORDINATION_TYPES.CELL_SET_HIGHLIGHT,
    COORDINATION_TYPES.CELL_SET_COLOR,
    COORDINATION_TYPES.GENE_HIGHLIGHT,
    COORDINATION_TYPES.GENE_SELECTION,
    COORDINATION_TYPES.GENE_EXPRESSION_COLORMAP,
    COORDINATION_TYPES.GENE_EXPRESSION_COLORMAP_RANGE,
    COORDINATION_TYPES.CELL_COLOR_ENCODING,
    COORDINATION_TYPES.ADDITIONAL_CELL_SETS
  ],
  spatial: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.SPATIAL_ZOOM,
    COORDINATION_TYPES.SPATIAL_ROTATION,
    COORDINATION_TYPES.SPATIAL_RASTER_LAYERS,
    COORDINATION_TYPES.SPATIAL_CELLS_LAYER,
    COORDINATION_TYPES.SPATIAL_MOLECULES_LAYER,
    COORDINATION_TYPES.SPATIAL_NEIGHBORHOODS_LAYER,
    COORDINATION_TYPES.SPATIAL_TARGET_X,
    COORDINATION_TYPES.SPATIAL_TARGET_Y,
    COORDINATION_TYPES.SPATIAL_TARGET_Z,
    COORDINATION_TYPES.SPATIAL_ROTATION_X,
    COORDINATION_TYPES.SPATIAL_ROTATION_Y,
    COORDINATION_TYPES.SPATIAL_ROTATION_Z,
    COORDINATION_TYPES.SPATIAL_ROTATION_ORBIT,
    COORDINATION_TYPES.SPATIAL_ORBIT_AXIS,
    COORDINATION_TYPES.SPATIAL_AXIS_FIXED,
    COORDINATION_TYPES.CELL_FILTER,
    COORDINATION_TYPES.CELL_HIGHLIGHT,
    COORDINATION_TYPES.CELL_SET_SELECTION,
    COORDINATION_TYPES.CELL_SET_HIGHLIGHT,
    COORDINATION_TYPES.CELL_SET_COLOR,
    COORDINATION_TYPES.GENE_HIGHLIGHT,
    COORDINATION_TYPES.GENE_SELECTION,
    COORDINATION_TYPES.GENE_EXPRESSION_COLORMAP,
    COORDINATION_TYPES.GENE_EXPRESSION_COLORMAP_RANGE,
    COORDINATION_TYPES.CELL_COLOR_ENCODING,
    COORDINATION_TYPES.ADDITIONAL_CELL_SETS,
    COORDINATION_TYPES.MOLECULE_HIGHLIGHT
  ],
  heatmap: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.HEATMAP_ZOOM_X,
    COORDINATION_TYPES.HEATMAP_ZOOM_Y,
    COORDINATION_TYPES.HEATMAP_TARGET_X,
    COORDINATION_TYPES.HEATMAP_TARGET_Y,
    COORDINATION_TYPES.CELL_FILTER,
    COORDINATION_TYPES.CELL_HIGHLIGHT,
    COORDINATION_TYPES.CELL_SET_SELECTION,
    COORDINATION_TYPES.CELL_SET_HIGHLIGHT,
    COORDINATION_TYPES.CELL_SET_COLOR,
    COORDINATION_TYPES.GENE_FILTER,
    COORDINATION_TYPES.GENE_HIGHLIGHT,
    COORDINATION_TYPES.GENE_SELECTION,
    COORDINATION_TYPES.GENE_EXPRESSION_COLORMAP,
    COORDINATION_TYPES.GENE_EXPRESSION_COLORMAP_RANGE,
    COORDINATION_TYPES.CELL_COLOR_ENCODING,
    COORDINATION_TYPES.ADDITIONAL_CELL_SETS
  ],
  cellSets: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.CELL_SET_SELECTION,
    COORDINATION_TYPES.CELL_SET_HIGHLIGHT,
    COORDINATION_TYPES.CELL_SET_COLOR,
    COORDINATION_TYPES.CELL_COLOR_ENCODING,
    COORDINATION_TYPES.ADDITIONAL_CELL_SETS
  ],
  cellSetSizes: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.CELL_SET_SELECTION,
    COORDINATION_TYPES.CELL_SET_HIGHLIGHT,
    COORDINATION_TYPES.CELL_SET_COLOR,
    COORDINATION_TYPES.ADDITIONAL_CELL_SETS
  ],
  cellSetExpression: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.GENE_SELECTION,
    COORDINATION_TYPES.GENE_EXPRESSION_TRANSFORM,
    COORDINATION_TYPES.CELL_SET_SELECTION,
    COORDINATION_TYPES.CELL_SET_HIGHLIGHT,
    COORDINATION_TYPES.CELL_SET_COLOR,
    COORDINATION_TYPES.ADDITIONAL_CELL_SETS
  ],
  status: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.CELL_HIGHLIGHT,
    COORDINATION_TYPES.GENE_HIGHLIGHT,
    COORDINATION_TYPES.CELL_SET_HIGHLIGHT,
    COORDINATION_TYPES.MOLECULE_HIGHLIGHT
  ],
  genes: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.GENE_FILTER,
    COORDINATION_TYPES.GENE_HIGHLIGHT,
    COORDINATION_TYPES.GENE_SELECTION,
    COORDINATION_TYPES.CELL_COLOR_ENCODING
  ],
  expressionHistogram: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.GENE_SELECTION
  ],
  layerController: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.SPATIAL_RASTER_LAYERS,
    COORDINATION_TYPES.SPATIAL_CELLS_LAYER,
    COORDINATION_TYPES.SPATIAL_MOLECULES_LAYER,
    COORDINATION_TYPES.SPATIAL_NEIGHBORHOODS_LAYER,
    COORDINATION_TYPES.SPATIAL_ZOOM,
    COORDINATION_TYPES.SPATIAL_TARGET_X,
    COORDINATION_TYPES.SPATIAL_TARGET_Y,
    COORDINATION_TYPES.SPATIAL_TARGET_Z,
    COORDINATION_TYPES.SPATIAL_ROTATION_X,
    COORDINATION_TYPES.SPATIAL_ROTATION_Y,
    COORDINATION_TYPES.SPATIAL_ROTATION_Z,
    COORDINATION_TYPES.SPATIAL_ROTATION_ORBIT,
    COORDINATION_TYPES.SPATIAL_ORBIT_AXIS
  ],
  higlass: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.GENOMIC_ZOOM_X,
    COORDINATION_TYPES.GENOMIC_ZOOM_Y,
    COORDINATION_TYPES.GENOMIC_TARGET_X,
    COORDINATION_TYPES.GENOMIC_TARGET_Y,
    COORDINATION_TYPES.GENE_FILTER,
    COORDINATION_TYPES.GENE_HIGHLIGHT,
    COORDINATION_TYPES.GENE_SELECTION
  ],
  genomicProfiles: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.GENOMIC_ZOOM_X,
    COORDINATION_TYPES.GENOMIC_ZOOM_Y,
    COORDINATION_TYPES.GENOMIC_TARGET_X,
    COORDINATION_TYPES.GENOMIC_TARGET_Y,
    COORDINATION_TYPES.GENE_FILTER,
    COORDINATION_TYPES.GENE_HIGHLIGHT,
    COORDINATION_TYPES.GENE_SELECTION,
    COORDINATION_TYPES.CELL_SET_SELECTION,
    COORDINATION_TYPES.CELL_SET_HIGHLIGHT,
    COORDINATION_TYPES.CELL_SET_COLOR,
    COORDINATION_TYPES.ADDITIONAL_CELL_SETS
  ],
  description: [
    COORDINATION_TYPES.DATASET,
    COORDINATION_TYPES.SPATIAL_RASTER_LAYERS
  ]
};

// src/components/data-hooks.js
function warn(error, setWarning) {
  setWarning(error.message);
  console.warn(error.message);
  if (error instanceof AbstractLoaderError) {
    error.warnInConsole();
  }
}
function initCoordinationSpace(values, setters, initialValues) {
  if (!values || !setters) {
    return;
  }
  Object.entries(values).forEach(([coordinationType, value]) => {
    const setterName = `set${capitalize(coordinationType)}`;
    const setterFunc = setters[setterName];
    const initialValue = initialValues && initialValues[coordinationType];
    const shouldInit = equal2(initialValue, DEFAULT_COORDINATION_VALUES[coordinationType]);
    if (shouldInit && setterFunc) {
      setterFunc(value);
    }
  });
}
function useDescription(loaders, dataset) {
  const [description2, setDescription] = useState4();
  useEffect2(() => {
    if (!loaders[dataset]) {
      return;
    }
    if (loaders[dataset].description) {
      setDescription(loaders[dataset].description);
    } else {
      setDescription(null);
    }
  }, [loaders, dataset]);
  return [description2];
}
function useCellsData(loaders, dataset, setItemIsReady, addUrl, isRequired, coordinationSetters, initialCoordinationValues) {
  const [cells, setCells] = useState4({});
  const [cellsCount, setCellsCount] = useState4(0);
  const setWarning = useSetWarning();
  useEffect2(() => {
    if (!loaders[dataset]) {
      return;
    }
    if (loaders[dataset].loaders.cells) {
      loaders[dataset].loaders.cells.load().catch((e) => warn(e, setWarning)).then((payload) => {
        if (!payload)
          return;
        const { data, url, coordinationValues } = payload;
        setCells(data);
        setCellsCount(Object.keys(data).length);
        addUrl(url, "Cells");
        const coordinationValuesOrDefault = __spreadValues({
          spatialCellsLayer: DEFAULT_CELLS_LAYER
        }, coordinationValues);
        initCoordinationSpace(coordinationValuesOrDefault, coordinationSetters, initialCoordinationValues);
        setItemIsReady("cells");
      });
    } else {
      setCells({});
      setCellsCount(0);
      if (isRequired) {
        warn(new props(dataset, "cells", null, null), setWarning);
      } else {
        setItemIsReady("cells");
      }
    }
  }, [loaders, dataset]);
  return [cells, cellsCount];
}
function useCellSetsData(loaders, dataset, setItemIsReady, addUrl, isRequired, coordinationSetters, initialCoordinationValues) {
  const [cellSets, setCellSets] = useState4();
  const setWarning = useSetWarning();
  useEffect2(() => {
    if (!loaders[dataset]) {
      return;
    }
    if (loaders[dataset].loaders["cell-sets"]) {
      loaders[dataset].loaders["cell-sets"].load().catch((e) => warn(e, setWarning)).then((payload) => {
        if (!payload)
          return;
        const { data, url, coordinationValues } = payload;
        setCellSets(data);
        addUrl(url, "Cell Sets");
        initCoordinationSpace(coordinationValues, coordinationSetters, initialCoordinationValues);
        setItemIsReady("cell-sets");
      });
    } else {
      setCellSets(null);
      if (isRequired) {
        warn(new LoaderNotFoundError(dataset, "cell-sets", null, null), setWarning);
      } else {
        setItemIsReady("cell-sets");
      }
    }
  }, [loaders, dataset]);
  return [cellSets];
}
function useExpressionMatrixData(loaders, dataset, setItemIsReady, addUrl, isRequired, coordinationSetters, initialCoordinationValues) {
  const [expressionMatrix, setExpressionMatrix] = useState4();
  const setWarning = useSetWarning();
  useEffect2(() => {
    if (!loaders[dataset]) {
      return;
    }
    if (loaders[dataset].loaders["expression-matrix"]) {
      loaders[dataset].loaders["expression-matrix"].load().catch((e) => warn(e, setWarning)).then((payload) => {
        if (!payload)
          return;
        const { data, url, coordinationValues } = payload;
        const [attrs, arr] = data;
        setExpressionMatrix({
          cols: attrs.cols,
          rows: attrs.rows,
          matrix: arr.data
        });
        addUrl(url, "Expression Matrix");
        initCoordinationSpace(coordinationValues, coordinationSetters, initialCoordinationValues);
        setItemIsReady("expression-matrix");
      });
    } else {
      setExpressionMatrix(null);
      if (isRequired) {
        warn(new LoaderNotFoundError(dataset, "expression-matrix", null, null), setWarning);
      } else {
        setItemIsReady("expression-matrix");
      }
    }
  }, [loaders, dataset]);
  return [expressionMatrix];
}
function useGeneSelection(loaders, dataset, setItemIsReady, isRequired, selection, setItemIsNotReady) {
  const [geneData, setGeneData] = useState4();
  const setWarning = useSetWarning();
  useEffect2(() => {
    if (!loaders[dataset]) {
      return;
    }
    if (!selection) {
      setItemIsReady("expression-matrix");
      return;
    }
    const loader = loaders[dataset].loaders["expression-matrix"];
    if (loader) {
      setItemIsNotReady("expression-matrix");
      const implementsGeneSelection = typeof loader.loadGeneSelection === "function";
      if (implementsGeneSelection) {
        loaders[dataset].loaders["expression-matrix"].loadGeneSelection({ selection }).catch((e) => warn(e, setWarning)).then((payload) => {
          if (!payload)
            return;
          const { data } = payload;
          setGeneData(data);
          setItemIsReady("expression-matrix");
        });
      } else {
        loader.load().catch((e) => warn(e, setWarning)).then((payload) => {
          if (!payload)
            return;
          const { data } = payload;
          const [attrs, { data: matrix }] = data;
          const expressionDataForSelection = selection.map((sel) => {
            const geneIndex = attrs.cols.indexOf(sel);
            const numGenes = attrs.cols.length;
            const numCells = attrs.rows.length;
            const expressionData = new Uint8Array(numCells);
            for (let cellIndex = 0; cellIndex < numCells; cellIndex += 1) {
              expressionData[cellIndex] = matrix[cellIndex * numGenes + geneIndex];
            }
            return expressionData;
          });
          setGeneData(expressionDataForSelection);
          setItemIsReady("expression-matrix");
        });
      }
    } else {
      setGeneData(null);
      if (isRequired) {
        warn(new LoaderNotFoundError(dataset, "expression-matrix", null, null), setWarning);
      } else {
        setItemIsReady("expression-matrix");
      }
    }
  }, [loaders, dataset, selection]);
  return [geneData];
}
function useExpressionAttrs(loaders, dataset, setItemIsReady, addUrl, isRequired) {
  const [attrs, setAttrs] = useState4();
  const setWarning = useSetWarning();
  useEffect2(() => {
    if (!loaders[dataset]) {
      return;
    }
    const loader = loaders[dataset].loaders["expression-matrix"];
    if (loader) {
      const implementsLoadAttrs = typeof loader.loadAttrs === "function";
      if (implementsLoadAttrs) {
        loader.loadAttrs().catch((e) => warn(e, setWarning)).then((payload) => {
          if (!payload)
            return;
          const { data, url } = payload;
          setAttrs(data);
          addUrl(url, "Expression Matrix");
          setItemIsReady("expression-matrix");
        });
      } else {
        loader.load().catch((e) => warn(e, setWarning)).then((payload) => {
          if (!payload)
            return;
          const { data, url } = payload;
          setAttrs(data[0]);
          addUrl(url, "Expression Matrix");
          setItemIsReady("expression-matrix");
        });
      }
    } else {
      setAttrs(null);
      if (isRequired) {
        warn(new LoaderNotFoundError(dataset, "expression-matrix", null, null), setWarning);
      } else {
        setItemIsReady("expression-matrix");
      }
    }
  }, [loaders, dataset]);
  return [attrs];
}
function useMoleculesData(loaders, dataset, setItemIsReady, addUrl, isRequired, coordinationSetters, initialCoordinationValues) {
  const [molecules, setMolecules] = useState4();
  const [moleculesCount, setMoleculesCount] = useState4(0);
  const [locationsCount, setLocationsCount] = useState4(0);
  const setWarning = useSetWarning();
  useEffect2(() => {
    if (!loaders[dataset]) {
      return;
    }
    if (loaders[dataset].loaders.molecules) {
      loaders[dataset].loaders.molecules.load().catch((e) => warn(e, setWarning)).then((payload) => {
        if (!payload)
          return;
        const { data, url, coordinationValues } = payload;
        setMolecules(data);
        setMoleculesCount(Object.keys(data).length);
        setLocationsCount(Object.values(data).map((l) => l.length).reduce((a, b) => a + b, 0));
        addUrl(url, "Molecules");
        const coordinationValuesOrDefault = __spreadValues({
          spatialMoleculesLayer: DEFAULT_MOLECULES_LAYER
        }, coordinationValues);
        initCoordinationSpace(coordinationValuesOrDefault, coordinationSetters, initialCoordinationValues);
        setItemIsReady("molecules");
      });
    } else {
      setMolecules({});
      setMoleculesCount(0);
      setLocationsCount(0);
      if (isRequired) {
        warn(new LoaderNotFoundError(dataset, "molecules", null, null), setWarning);
      } else {
        setItemIsReady("molecules");
      }
    }
  }, [loaders, dataset]);
  return [molecules, moleculesCount, locationsCount];
}
function useNeighborhoodsData(loaders, dataset, setItemIsReady, addUrl, isRequired, coordinationSetters, initialCoordinationValues) {
  const [neighborhoods, setNeighborhoods] = useState4();
  const setWarning = useSetWarning();
  useEffect2(() => {
    if (!loaders[dataset]) {
      return;
    }
    if (loaders[dataset].loaders.neighborhoods) {
      loaders[dataset].loaders.neighborhoods.load().catch((e) => warn(e, setWarning)).then((payload) => {
        if (!payload)
          return;
        const { data, url, coordinationValues } = payload;
        setNeighborhoods(data);
        addUrl(url, "Neighborhoods");
        const coordinationValuesOrDefault = __spreadValues({
          spatialNeighborhoodsLayer: DEFAULT_NEIGHBORHOODS_LAYER
        }, coordinationValues);
        initCoordinationSpace(coordinationValuesOrDefault, coordinationSetters, initialCoordinationValues);
        setItemIsReady("neighborhoods");
      });
    } else {
      setNeighborhoods({});
      if (isRequired) {
        warn(new LoaderNotFoundError(dataset, "neighborhoods", null, null), setWarning);
      } else {
        setItemIsReady("neighborhoods");
      }
    }
  }, [loaders, dataset]);
  return [neighborhoods];
}
function useRasterData(loaders, dataset, setItemIsReady, addUrl, isRequired, coordinationSetters, initialCoordinationValues) {
  const [raster, setRaster] = useState4();
  const [imageLayerLoaders, setImageLayerLoaders] = useState4([]);
  const [imageLayerMeta, setImageLayerMeta] = useState4([]);
  const setWarning = useSetWarning();
  useEffect2(() => {
    if (!loaders[dataset]) {
      return;
    }
    if (loaders[dataset].loaders.raster) {
      loaders[dataset].loaders.raster.load().catch((e) => warn(e, setWarning)).then((payload) => {
        if (!payload)
          return;
        const { data, url: urls, coordinationValues } = payload;
        setRaster(data);
        urls.forEach(([url, name2]) => {
          addUrl(url, name2);
        });
        const { loaders: nextImageLoaders, meta: nextImageMeta } = data;
        setImageLayerLoaders(nextImageLoaders);
        setImageLayerMeta(nextImageMeta);
        initCoordinationSpace(coordinationValues, coordinationSetters, initialCoordinationValues);
        setItemIsReady("raster");
      });
    } else {
      setImageLayerLoaders([]);
      setImageLayerMeta([]);
      if (isRequired) {
        warn(new LoaderNotFoundError(dataset, "raster", null, null), setWarning);
      } else {
        setItemIsReady("raster");
      }
    }
  }, [loaders, dataset]);
  return [raster, imageLayerLoaders, imageLayerMeta];
}
function useGenomicProfilesData(loaders, dataset, setItemIsReady, addUrl, isRequired, coordinationSetters, initialCoordinationValues) {
  const [genomicProfilesAttrs, setGenomicProfilesAttrs] = useState4();
  const setWarning = useSetWarning();
  useEffect2(() => {
    if (!loaders[dataset]) {
      return;
    }
    if (loaders[dataset].loaders["genomic-profiles"]) {
      loaders[dataset].loaders["genomic-profiles"].load().catch((e) => warn(e, setWarning)).then((payload) => {
        if (!payload)
          return;
        const { data, url, coordinationValues } = payload;
        setGenomicProfilesAttrs(data);
        addUrl(url);
        initCoordinationSpace(coordinationValues, coordinationSetters, initialCoordinationValues);
        setItemIsReady("genomic-profiles");
      });
    } else {
      setGenomicProfilesAttrs(null);
      if (isRequired) {
        warn(new LoaderNotFoundError(dataset, "genomic-profiles", null, null), setWarning);
      } else {
        setItemIsReady("genomic-profiles");
      }
    }
  }, [loaders, dataset]);
  return [genomicProfilesAttrs];
}

// src/components/sets/cell-set-utils.js
import uuidv4 from "uuid/v4";
import isNil from "lodash/isNil";
import isEqual2 from "lodash/isEqual";
import range3 from "lodash/range";
import { featureCollection as turfFeatureCollection, point as turfPoint } from "@turf/helpers";
import centroid from "@turf/centroid";
import concaveman from "concaveman";

// src/components/sets/utils.js
import tinycolor from "tinycolor2";
import isEqual from "lodash/isEqual";
function callbackOnKeyPress(event, key, callback) {
  if (event.key === key) {
    event.preventDefault();
    callback();
  }
}
function colorArrayToString(rgbArray) {
  return tinycolor({ r: rgbArray[0], g: rgbArray[1], b: rgbArray[2] }).toHexString();
}
function colorStringToArray(colorString) {
  const colorObj = tinycolor(colorString).toRgb();
  return [colorObj.r, colorObj.g, colorObj.b];
}
function getLevelTooltipText(i) {
  if (i === 0)
    return "Color by hierarchy";
  if (i <= 2) {
    const subs = (j) => "sub".repeat(j);
    return `Color by ${subs(i - 1)}cluster`;
  }
  return `Color by cluster level ${i}`;
}
function isEqualOrPrefix(targetPath, testPath) {
  if (targetPath.length <= testPath.length) {
    return isEqual(targetPath, testPath.slice(0, targetPath.length));
  }
  return false;
}
function tryRenamePath(targetPath, testPath, nextTargetPath) {
  if (isEqualOrPrefix(targetPath, testPath)) {
    return [...nextTargetPath, ...testPath.slice(nextTargetPath.length)];
  }
  return testPath;
}
var PATH_SEP = "___";
function pathToKey(path) {
  return path.join(PATH_SEP);
}

// src/components/sets/cell-set-utils.js
function generateKey() {
  return uuidv4();
}
function nodeToSet(currNode) {
  if (!currNode) {
    return [];
  }
  if (!currNode.children) {
    return currNode.set || [];
  }
  return currNode.children.flatMap((c) => nodeToSet(c));
}
function nodeToHeight(currNode, level = 0) {
  if (!currNode.children) {
    return level;
  }
  const newLevel = level + 1;
  const childrenHeights = currNode.children.map((c) => nodeToHeight(c, newLevel));
  return Math.max(...childrenHeights, newLevel);
}
function getNodeLength(currNode) {
  var _a2;
  if (!currNode) {
    return 0;
  }
  if (!currNode.children) {
    return ((_a2 = currNode.set) == null ? void 0 : _a2.length) || 0;
  }
  return currNode.children.reduce((acc, curr) => acc + getNodeLength(curr), 0);
}
function nodeFindNodeByNamePath(node, path, currLevelIndex) {
  const currNodeName = path[currLevelIndex];
  if (node.name === currNodeName) {
    if (currLevelIndex === path.length - 1) {
      return node;
    }
    if (node.children) {
      const foundNodes = node.children.map((child) => nodeFindNodeByNamePath(child, path, currLevelIndex + 1)).filter(Boolean);
      if (foundNodes.length === 1) {
        return foundNodes[0];
      }
    }
  }
  return null;
}
function treeFindNodeByNamePath(currTree, targetNamePath) {
  const foundNodes = currTree.tree.map((levelZeroNode) => nodeFindNodeByNamePath(levelZeroNode, targetNamePath, 0)).filter(Boolean);
  if (foundNodes.length === 1) {
    return foundNodes[0];
  }
  return null;
}
function nodeTransform(node, predicate, transform, transformedPaths, currPath) {
  let newPath;
  if (!currPath) {
    newPath = [node.name];
  } else {
    newPath = [...currPath];
  }
  if (predicate(node, newPath)) {
    transformedPaths.push(newPath);
    return transform(node, newPath);
  }
  if (node.children) {
    return __spreadProps(__spreadValues({}, node), {
      children: node.children.map((child) => nodeTransform(child, predicate, transform, transformedPaths, newPath.concat([child.name])))
    });
  }
  return node;
}
function nodeTransformAll(node, predicate, transform, transformedPaths, currPath) {
  let newPath;
  if (!currPath) {
    newPath = [node.name];
  } else {
    newPath = [...currPath];
  }
  let newNode = node;
  if (predicate(node, newPath)) {
    transformedPaths.push(newPath);
    newNode = transform(node, newPath);
  }
  if (node.children) {
    return __spreadProps(__spreadValues({}, newNode), {
      children: newNode.children.map((child) => nodeTransformAll(child, predicate, transform, transformedPaths, newPath.concat([child.name])))
    });
  }
  return newNode;
}
function nodeAppendChild(currNode, newChild) {
  return __spreadProps(__spreadValues({}, currNode), {
    children: [...currNode.children, newChild]
  });
}
function nodePrependChild(currNode, newChild) {
  return __spreadProps(__spreadValues({}, currNode), {
    children: [newChild, ...currNode.children]
  });
}
function nodeInsertChild(currNode, newChild, insertIndex) {
  const newChildren = Array.from(currNode.children);
  newChildren.splice(insertIndex, 0, newChild);
  return __spreadProps(__spreadValues({}, currNode), {
    children: newChildren
  });
}
function treeToUnion(currTree, checkedPaths) {
  const nodes = checkedPaths.map((path) => treeFindNodeByNamePath(currTree, path));
  const nodeSets = nodes.map((node) => nodeToSet(node).map(([cellId]) => cellId));
  return nodeSets.reduce((a, h) => a.concat(h.filter((hEl) => !a.includes(hEl))), nodeSets[0] || []);
}
function treeToIntersection(currTree, checkedPaths) {
  const nodes = checkedPaths.map((path) => treeFindNodeByNamePath(currTree, path));
  const nodeSets = nodes.map((node) => nodeToSet(node).map(([cellId]) => cellId));
  return nodeSets.reduce((a, h) => h.filter((hEl) => a.includes(hEl)), nodeSets[0] || []);
}
function treeToComplement(currTree, checkedPaths, items2) {
  const primaryUnion = treeToUnion(currTree, checkedPaths);
  return items2.filter((el) => !primaryUnion.includes(el));
}
function nodeToLevelDescendantNamePaths(node, level, prevPath, stopEarly = false) {
  if (!node.children) {
    if (!stopEarly) {
      return null;
    }
    return [[...prevPath, node.name]];
  }
  if (level === 0) {
    return [[...prevPath, node.name]];
  }
  return node.children.flatMap((c) => nodeToLevelDescendantNamePaths(c, level - 1, [...prevPath, node.name], stopEarly)).filter(Boolean);
}
function treeExport(currTree, datatype) {
  return {
    version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,
    datatype,
    tree: currTree.tree
  };
}
function treeExportLevelZeroNode(currTree, nodePath, datatype, cellSetColors, theme) {
  const node = treeFindNodeByNamePath(currTree, nodePath);
  const nodeWithColors = nodeTransformAll(node, () => true, (n, nPath) => {
    var _a2, _b2;
    const nodeColor = (_b2 = (_a2 = cellSetColors == null ? void 0 : cellSetColors.find((c) => isEqual2(c.path, nPath))) == null ? void 0 : _a2.color) != null ? _b2 : getDefaultColor(theme);
    return __spreadProps(__spreadValues({}, n), {
      color: nodeColor.slice(0, 3)
    });
  }, []);
  const treeWithOneLevelZeroNode = __spreadProps(__spreadValues({}, currTree), {
    tree: [nodeWithColors]
  });
  return {
    treeToExport: treeExport(treeWithOneLevelZeroNode, datatype),
    nodeName: node.name
  };
}
function treeExportSet(currTree, nodePath) {
  const node = treeFindNodeByNamePath(currTree, nodePath);
  return { setToExport: nodeToSet(node), nodeName: node.name };
}
function treeInitialize(datatype) {
  return {
    version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,
    datatype,
    tree: []
  };
}
function nodeToRenderProps(node, path, cellSetColor) {
  var _a2;
  const level = path.length - 1;
  return {
    title: node.name,
    nodeKey: pathToKey(path),
    path,
    size: getNodeLength(node),
    color: (_a2 = cellSetColor == null ? void 0 : cellSetColor.find((d) => isEqual2(d.path, path))) == null ? void 0 : _a2.color,
    level,
    isLeaf: (!node.children || node.children.length === 0) && Boolean(node.set),
    height: nodeToHeight(node)
  };
}
function colorMixWithUncertainty(originalColor, p, mixingColor = [128, 128, 128]) {
  return [
    (originalColor[0] - mixingColor[0]) * p + mixingColor[0],
    (originalColor[1] - mixingColor[1]) * p + mixingColor[1],
    (originalColor[2] - mixingColor[2]) * p + mixingColor[2]
  ];
}
function treeToCellColorsBySetNames(currTree, selectedNamePaths, cellSetColor, theme) {
  let cellColorsArray = [];
  selectedNamePaths.forEach((setNamePath) => {
    var _a2;
    const node = treeFindNodeByNamePath(currTree, setNamePath);
    if (node) {
      const nodeSet = nodeToSet(node);
      const nodeColor = ((_a2 = cellSetColor == null ? void 0 : cellSetColor.find((d) => isEqual2(d.path, setNamePath))) == null ? void 0 : _a2.color) || getDefaultColor(theme);
      cellColorsArray = [
        ...cellColorsArray,
        ...nodeSet.map(([cellId, prob]) => [
          cellId,
          isNil(prob) ? nodeColor : colorMixWithUncertainty(nodeColor, prob)
        ])
      ];
    }
  });
  return new Map(cellColorsArray);
}
function treeToObjectsBySetNames(currTree, selectedNamePaths, setColor, theme) {
  var _a2;
  let cellsArray = [];
  for (let i = 0; i < selectedNamePaths.length; i += 1) {
    const setNamePath = selectedNamePaths[i];
    const node = treeFindNodeByNamePath(currTree, setNamePath);
    if (node) {
      const nodeSet = nodeToSet(node);
      const nodeColor = ((_a2 = setColor == null ? void 0 : setColor.find((d) => isEqual2(d.path, setNamePath))) == null ? void 0 : _a2.color) || getDefaultColor(theme);
      cellsArray = cellsArray.concat(nodeSet.map(([cellId]) => ({
        obsId: cellId,
        name: node.name,
        color: nodeColor
      })));
    }
  }
  return cellsArray;
}
function treeToCellPolygonsBySetNames(currTree, cells, mapping, selectedNamePaths, cellSetColor, theme) {
  const cellSetPolygons = [];
  selectedNamePaths.forEach((setNamePath) => {
    var _a2;
    const node = treeFindNodeByNamePath(currTree, setNamePath);
    if (node) {
      const nodeSet = nodeToSet(node);
      const nodeColor = ((_a2 = cellSetColor == null ? void 0 : cellSetColor.find((d) => isEqual2(d.path, setNamePath))) == null ? void 0 : _a2.color) || getDefaultColor(theme);
      const cellPositions = nodeSet.map(([cellId]) => {
        var _a3, _b2;
        return [
          (_a3 = cells[cellId]) == null ? void 0 : _a3.mappings[mapping][0],
          -((_b2 = cells[cellId]) == null ? void 0 : _b2.mappings[mapping][1])
        ];
      }).filter((cell) => cell.every((i) => typeof i === "number"));
      if (cellPositions.length > 2) {
        const points = turfFeatureCollection(cellPositions.map(turfPoint));
        const concavity = Infinity;
        const hullCoords = concaveman(cellPositions, concavity);
        if (hullCoords) {
          const centroidCoords = centroid(points).geometry.coordinates;
          cellSetPolygons.push({
            path: setNamePath,
            name: setNamePath[setNamePath.length - 1],
            hull: hullCoords,
            color: nodeColor,
            centroid: centroidCoords
          });
        }
      }
    }
  });
  return cellSetPolygons;
}
function treeToSetSizesBySetNames(currTree, selectedNamePaths, setColor, theme) {
  const sizes = [];
  selectedNamePaths.forEach((setNamePath) => {
    var _a2;
    const node = treeFindNodeByNamePath(currTree, setNamePath);
    if (node) {
      const nodeSet = nodeToSet(node);
      const nodeColor = ((_a2 = setColor.find((d) => isEqual2(d.path, setNamePath))) == null ? void 0 : _a2.color) || getDefaultColor(theme);
      sizes.push({
        key: generateKey(),
        name: node.name,
        size: nodeSet.length,
        color: nodeColor
      });
    }
  });
  return sizes;
}
function filterNode(node, prevPath, filterPath) {
  if (isEqual2([...prevPath, node.name], filterPath)) {
    return null;
  }
  if (!node.children) {
    return node;
  }
  return __spreadProps(__spreadValues({}, node), {
    children: node.children.map((c) => filterNode(c, [...prevPath, node.name], filterPath)).filter(Boolean)
  });
}
function treeToExpectedCheckedLevel(currTree, checkedPaths) {
  let result = null;
  if (currTree) {
    currTree.tree.forEach((lzn) => {
      const levelZeroPath = [lzn.name];
      const height = nodeToHeight(lzn);
      range3(height).forEach((i) => {
        const levelIndex = i + 1;
        const levelNodePaths = nodeToLevelDescendantNamePaths(lzn, levelIndex, [], true);
        if (isEqual2(levelNodePaths, checkedPaths)) {
          result = { levelZeroPath, levelIndex };
        }
      });
    });
  }
  return result;
}
function treesConflict(cellSets, testCellSets) {
  const paths = [];
  const testPaths = [];
  let hasConflict = false;
  function getPaths(node, prevPath) {
    paths.push([...prevPath, node.name]);
    if (node.children) {
      node.children.forEach((c) => getPaths(c, [...prevPath, node.name]));
    }
  }
  cellSets.tree.forEach((lzn) => getPaths(lzn, []));
  function getTestPaths(node, prevPath) {
    testPaths.push([...prevPath, node.name]);
    if (node.children) {
      node.children.forEach((c) => getPaths(c, [...prevPath, node.name]));
    }
  }
  testCellSets.tree.forEach((lzn) => getTestPaths(lzn, []));
  testPaths.forEach((testPath) => {
    if (paths.find((p) => isEqual2(p, testPath))) {
      hasConflict = true;
    }
  });
  return hasConflict;
}
function initializeCellSetColor(cellSets, cellSetColor) {
  const nextCellSetColor = [...cellSetColor || []];
  const nodeCountPerTreePerLevel = cellSets.tree.map((tree) => Array.from({
    length: nodeToHeight(tree) + 1
  }).fill(0));
  function processNode2(node, prevPath, hierarchyLevel, treeIndex) {
    const index = nodeCountPerTreePerLevel[treeIndex][hierarchyLevel];
    const nodePath = [...prevPath, node.name];
    const nodeColor = nextCellSetColor.find((d) => isEqual2(d.path, nodePath));
    if (!nodeColor) {
      nextCellSetColor.push({
        path: nodePath,
        color: PALETTE[index % PALETTE.length]
      });
    }
    nodeCountPerTreePerLevel[treeIndex][hierarchyLevel] += 1;
    if (node.children) {
      node.children.forEach((c) => processNode2(c, nodePath, hierarchyLevel + 1, treeIndex));
    }
  }
  cellSets.tree.forEach((lzn, treeIndex) => processNode2(lzn, [], 0, treeIndex));
  return nextCellSetColor;
}
function getCellSetPolygons(params) {
  const {
    cells,
    mapping,
    cellSets,
    cellSetSelection,
    cellSetColor,
    theme
  } = params;
  if (cellSetSelection && cellSetSelection.length > 0 && cellSets && cells) {
    return treeToCellPolygonsBySetNames(cellSets, cells, mapping, cellSetSelection, cellSetColor, theme);
  }
  return [];
}

// src/components/interpolate-colors.js
var schemeRdBu = [[103, 0, 31], [178, 24, 43], [214, 96, 77], [244, 165, 130], [253, 219, 199], [247, 247, 247], [209, 229, 240], [146, 197, 222], [67, 147, 195], [33, 102, 172], [5, 48, 97]];
var schemePlasma = [[13, 8, 135], [16, 7, 136], [19, 7, 137], [22, 7, 138], [25, 6, 140], [27, 6, 141], [29, 6, 142], [32, 6, 143], [34, 6, 144], [36, 6, 145], [38, 5, 145], [40, 5, 146], [42, 5, 147], [44, 5, 148], [46, 5, 149], [47, 5, 150], [49, 5, 151], [51, 5, 151], [53, 4, 152], [55, 4, 153], [56, 4, 154], [58, 4, 154], [60, 4, 155], [62, 4, 156], [63, 4, 156], [65, 4, 157], [67, 3, 158], [68, 3, 158], [70, 3, 159], [72, 3, 159], [73, 3, 160], [75, 3, 161], [76, 2, 161], [78, 2, 162], [80, 2, 162], [81, 2, 163], [83, 2, 163], [85, 2, 164], [86, 1, 164], [88, 1, 164], [89, 1, 165], [91, 1, 165], [92, 1, 166], [94, 1, 166], [96, 1, 166], [97, 0, 167], [99, 0, 167], [100, 0, 167], [102, 0, 167], [103, 0, 168], [105, 0, 168], [106, 0, 168], [108, 0, 168], [110, 0, 168], [111, 0, 168], [113, 0, 168], [114, 1, 168], [116, 1, 168], [117, 1, 168], [119, 1, 168], [120, 1, 168], [122, 2, 168], [123, 2, 168], [125, 3, 168], [126, 3, 168], [128, 4, 168], [129, 4, 167], [131, 5, 167], [132, 5, 167], [134, 6, 166], [135, 7, 166], [136, 8, 166], [138, 9, 165], [139, 10, 165], [141, 11, 165], [142, 12, 164], [143, 13, 164], [145, 14, 163], [146, 15, 163], [148, 16, 162], [149, 17, 161], [150, 19, 161], [152, 20, 160], [153, 21, 159], [154, 22, 159], [156, 23, 158], [157, 24, 157], [158, 25, 157], [160, 26, 156], [161, 27, 155], [162, 29, 154], [163, 30, 154], [165, 31, 153], [166, 32, 152], [167, 33, 151], [168, 34, 150], [170, 35, 149], [171, 36, 148], [172, 38, 148], [173, 39, 147], [174, 40, 146], [176, 41, 145], [177, 42, 144], [178, 43, 143], [179, 44, 142], [180, 46, 141], [181, 47, 140], [182, 48, 139], [183, 49, 138], [184, 50, 137], [186, 51, 136], [187, 52, 136], [188, 53, 135], [189, 55, 134], [190, 56, 133], [191, 57, 132], [192, 58, 131], [193, 59, 130], [194, 60, 129], [195, 61, 128], [196, 62, 127], [197, 64, 126], [198, 65, 125], [199, 66, 124], [200, 67, 123], [201, 68, 122], [202, 69, 122], [203, 70, 121], [204, 71, 120], [204, 73, 119], [205, 74, 118], [206, 75, 117], [207, 76, 116], [208, 77, 115], [209, 78, 114], [210, 79, 113], [211, 81, 113], [212, 82, 112], [213, 83, 111], [213, 84, 110], [214, 85, 109], [215, 86, 108], [216, 87, 107], [217, 88, 106], [218, 90, 106], [218, 91, 105], [219, 92, 104], [220, 93, 103], [221, 94, 102], [222, 95, 101], [222, 97, 100], [223, 98, 99], [224, 99, 99], [225, 100, 98], [226, 101, 97], [226, 102, 96], [227, 104, 95], [228, 105, 94], [229, 106, 93], [229, 107, 93], [230, 108, 92], [231, 110, 91], [231, 111, 90], [232, 112, 89], [233, 113, 88], [233, 114, 87], [234, 116, 87], [235, 117, 86], [235, 118, 85], [236, 119, 84], [237, 121, 83], [237, 122, 82], [238, 123, 81], [239, 124, 81], [239, 126, 80], [240, 127, 79], [240, 128, 78], [241, 129, 77], [241, 131, 76], [242, 132, 75], [243, 133, 75], [243, 135, 74], [244, 136, 73], [244, 137, 72], [245, 139, 71], [245, 140, 70], [246, 141, 69], [246, 143, 68], [247, 144, 68], [247, 145, 67], [247, 147, 66], [248, 148, 65], [248, 149, 64], [249, 151, 63], [249, 152, 62], [249, 154, 62], [250, 155, 61], [250, 156, 60], [250, 158, 59], [251, 159, 58], [251, 161, 57], [251, 162, 56], [252, 163, 56], [252, 165, 55], [252, 166, 54], [252, 168, 53], [252, 169, 52], [253, 171, 51], [253, 172, 51], [253, 174, 50], [253, 175, 49], [253, 177, 48], [253, 178, 47], [253, 180, 47], [253, 181, 46], [254, 183, 45], [254, 184, 44], [254, 186, 44], [254, 187, 43], [254, 189, 42], [254, 190, 42], [254, 192, 41], [253, 194, 41], [253, 195, 40], [253, 197, 39], [253, 198, 39], [253, 200, 39], [253, 202, 38], [253, 203, 38], [252, 205, 37], [252, 206, 37], [252, 208, 37], [252, 210, 37], [251, 211, 36], [251, 213, 36], [251, 215, 36], [250, 216, 36], [250, 218, 36], [249, 220, 36], [249, 221, 37], [248, 223, 37], [248, 225, 37], [247, 226, 37], [247, 228, 37], [246, 230, 38], [246, 232, 38], [245, 233, 38], [245, 235, 39], [244, 237, 39], [243, 238, 39], [243, 240, 39], [242, 242, 39], [241, 244, 38], [241, 245, 37], [240, 247, 36], [240, 249, 33]];
function rgbSpline(spline) {
  return (colors) => {
    const n = colors.length;
    let r = new Array(n);
    let g = new Array(n);
    let b = new Array(n);
    let i;
    let color;
    for (i = 0; i < n; ++i) {
      color = [colors[i][0], colors[i][1], colors[i][2]];
      r[i] = color[0] || 0;
      g[i] = color[1] || 0;
      b[i] = color[2] || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    return (t) => [r(t), g(t), b(t)];
  };
}
function basis(values) {
  function innerBasis(t1, v0, v1, v2, v3) {
    const t2 = t1 * t1;
    const t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  const n = values.length - 1;
  return (t) => {
    const i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n);
    const v1 = values[i];
    const v2 = values[i + 1];
    const v0 = i > 0 ? values[i - 1] : 2 * v1 - v2;
    const v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return innerBasis((t - i / n) * n, v0, v1, v2, v3);
  };
}
var interpolateRgbBasis = rgbSpline(basis);
function interpolateSequentialMulti(range10) {
  const n = range10.length;
  return (t) => range10[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
}
var interpolateRdBu = interpolateRgbBasis(schemeRdBu);
var interpolatePlasma = interpolateSequentialMulti(schemePlasma);
function getCellColors(params) {
  const {
    cellColorEncoding,
    expressionData,
    cellSets,
    cellSetSelection,
    cellSetColor,
    expressionDataAttrs,
    theme
  } = params;
  if (cellColorEncoding === "geneSelection" && expressionData && expressionDataAttrs) {
    const geneExpColormap = interpolatePlasma;
    const colors = new Map();
    for (let i = 0; i < expressionData.length; i += 1) {
      const value = expressionData[i];
      const cellColor = geneExpColormap(value / 255);
      colors.set(expressionDataAttrs.rows[i], cellColor);
    }
    return colors;
  }
  if (cellColorEncoding === "cellSetSelection" && cellSetSelection && cellSets) {
    return treeToCellColorsBySetNames(cellSets, cellSetSelection, cellSetColor, theme);
  }
  return new Map();
}

// src/components/heatmap/Heatmap.js
import React6, {
  useRef as useRef4,
  useState as useState5,
  useCallback as useCallback3,
  useMemo as useMemo4,
  useEffect as useEffect3,
  useReducer,
  forwardRef
} from "react";
import uuidv42 from "uuid/v4";
import DeckGL2 from "deck.gl";
import { OrthographicView as OrthographicView2 } from "@deck.gl/core";
import range5 from "lodash/range";
import clamp2 from "lodash/clamp";
import isEqual3 from "lodash/isEqual";
import { max } from "d3-array";

// src/layers/HeatmapCompositeTextLayer.js
import { COORDINATE_SYSTEM as COORDINATE_SYSTEM3, CompositeLayer as CompositeLayer2 } from "@deck.gl/core";
import { TextLayer as TextLayer2 } from "@deck.gl/layers";

// src/layers/heatmap-constants.js
import GL2 from "@luma.gl/constants";
var TILE_SIZE = 2048;
var MIN_ROW_AGG = 1;
var MAX_ROW_AGG = 16;
var COLOR_BAR_SIZE = 20;
var AXIS_LABEL_TEXT_SIZE = 9;
var AXIS_TITLE_TEXT_SIZE = 15;
var AXIS_MIN_SIZE = 10;
var AXIS_MAX_SIZE = 90;
var AXIS_MARGIN = 3;
var THEME_TO_TEXT_COLOR = {
  dark: [224, 224, 224],
  light: [64, 64, 64]
};
var AXIS_FONT_FAMILY = "-apple-system, 'Helvetica Neue', Arial, sans-serif";
var PIXELATED_TEXTURE_PARAMETERS = {
  [GL2.TEXTURE_MIN_FILTER]: GL2.NEAREST,
  [GL2.TEXTURE_MAG_FILTER]: GL2.NEAREST,
  [GL2.TEXTURE_WRAP_S]: GL2.CLAMP_TO_EDGE,
  [GL2.TEXTURE_WRAP_T]: GL2.CLAMP_TO_EDGE
};

// src/layers/HeatmapCompositeTextLayer.js
var HeatmapCompositeTextLayer = class extends CompositeLayer2 {
  _renderAxisTopLayers() {
    const {
      axisTopLabelData,
      matrixLeft,
      width,
      matrixWidth,
      viewWidth,
      theme,
      targetX,
      targetY,
      axisTopTitle,
      cellWidth,
      axisOffsetTop,
      scaleFactor
    } = this.props;
    const showAxisTopLabels = cellWidth >= AXIS_LABEL_TEXT_SIZE;
    const axisLabelTop = targetY + (axisOffsetTop - AXIS_MARGIN) / 2 / scaleFactor;
    return [
      new TextLayer2({
        id: "axisTopLabels",
        coordinateSystem: COORDINATE_SYSTEM3.CARTESIAN,
        data: axisTopLabelData,
        getText: (d) => d[1],
        getPosition: (d) => [matrixLeft + (d[0] + 0.5) / width * matrixWidth, axisLabelTop],
        getTextAnchor: "start",
        getColor: () => THEME_TO_TEXT_COLOR[theme],
        getSize: showAxisTopLabels ? AXIS_LABEL_TEXT_SIZE : 0,
        getAngle: 75,
        fontFamily: AXIS_FONT_FAMILY,
        updateTriggers: {
          getPosition: [axisLabelTop, matrixLeft, matrixWidth, viewWidth],
          getSize: [showAxisTopLabels],
          getColor: [theme]
        }
      }),
      new TextLayer2({
        id: "axisTopTitle",
        coordinateSystem: COORDINATE_SYSTEM3.CARTESIAN,
        data: [{ title: axisTopTitle }],
        getText: (d) => d.title,
        getPosition: [targetX, targetY],
        getTextAnchor: "middle",
        getColor: () => THEME_TO_TEXT_COLOR[theme],
        getSize: !showAxisTopLabels ? AXIS_TITLE_TEXT_SIZE : 0,
        getAngle: 0,
        fontFamily: AXIS_FONT_FAMILY,
        updateTriggers: {
          getSize: [showAxisTopLabels],
          getColor: [theme]
        }
      })
    ];
  }
  _renderAxisLeftLayers() {
    const {
      axisLeftLabelData,
      matrixTop,
      height,
      matrixHeight,
      viewHeight,
      theme,
      axisLeftTitle,
      targetX,
      targetY,
      cellHeight,
      axisOffsetLeft,
      scaleFactor
    } = this.props;
    const showAxisLeftLabels = cellHeight >= AXIS_LABEL_TEXT_SIZE;
    const axisLabelLeft = targetX + (axisOffsetLeft - AXIS_MARGIN) / 2 / scaleFactor;
    return [
      new TextLayer2({
        id: "axisLeftLabels",
        coordinateSystem: COORDINATE_SYSTEM3.CARTESIAN,
        data: axisLeftLabelData,
        getText: (d) => d[1],
        getPosition: (d) => [axisLabelLeft, matrixTop + (d[0] + 0.5) / height * matrixHeight],
        getTextAnchor: "end",
        getColor: () => THEME_TO_TEXT_COLOR[theme],
        getSize: showAxisLeftLabels ? AXIS_LABEL_TEXT_SIZE : 0,
        getAngle: 0,
        fontFamily: AXIS_FONT_FAMILY,
        updateTriggers: {
          getPosition: [axisLabelLeft, matrixTop, matrixHeight, viewHeight],
          getSize: [showAxisLeftLabels],
          getColor: [theme]
        }
      }),
      new TextLayer2({
        id: "axisLeftTitle",
        coordinateSystem: COORDINATE_SYSTEM3.CARTESIAN,
        data: [{ title: axisLeftTitle }],
        getText: (d) => d.title,
        getPosition: [targetX, targetY],
        getTextAnchor: "middle",
        getColor: () => THEME_TO_TEXT_COLOR[theme],
        getSize: !showAxisLeftLabels ? AXIS_TITLE_TEXT_SIZE : 0,
        getAngle: 90,
        fontFamily: AXIS_FONT_FAMILY,
        updateTriggers: {
          getSize: [showAxisLeftLabels],
          getColor: [theme]
        }
      })
    ];
  }
  renderLayers() {
    return [
      this._renderAxisTopLayers(),
      this._renderAxisLeftLayers()
    ];
  }
};
HeatmapCompositeTextLayer.layerName = "HeatmapCompositeTextLayer";

// src/layers/PixelatedBitmapLayer.js
import { BitmapLayer as BitmapLayer2 } from "@deck.gl/layers";
import { CompositeLayer as CompositeLayer3 } from "@deck.gl/core";
var defaultProps2 = __spreadProps(__spreadValues({}, BitmapLayer2.defaultProps), {
  image: { type: "object", value: null, async: true },
  bounds: { type: "array", value: [1, 0, 0, 1], compare: true },
  desaturate: {
    type: "number",
    min: 0,
    max: 1,
    value: 0
  },
  transparentColor: { type: "color", value: [0, 0, 0, 0] },
  tintColor: { type: "color", value: [255, 255, 255] }
});
var PixelatedBitmapLayer = class extends CompositeLayer3 {
  renderLayers() {
    const { image } = this.props;
    return new BitmapLayer2(this.props, {
      id: `${this.props.id}-wrapped`,
      image,
      textureParameters: PIXELATED_TEXTURE_PARAMETERS
    });
  }
};
PixelatedBitmapLayer.layerName = "PixelatedBitmapLayer";
PixelatedBitmapLayer.defaultProps = defaultProps2;

// src/layers/HeatmapBitmapLayer.js
import GL3 from "@luma.gl/constants";
import { _mergeShaders, project32 as project322, picking as picking2 } from "@deck.gl/core";
import { BitmapLayer as BitmapLayer3 } from "@deck.gl/layers";
import { Texture2D as Texture2D2 } from "@luma.gl/core";

// src/layers/constants.js
var GLSL_COLORMAPS = [
  "plasma",
  "viridis",
  "jet"
];
var GLSL_COLORMAP_DEFAULT = "plasma";
var COLORMAP_SHADER_PLACEHOLDER = "COLORMAP_FUNC";

// src/layers/heatmap-bitmap-layer-shaders.js
var vertexShader = "\n#define SHADER_NAME heatmap-bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n";
var fragmentShader = "\n#define SHADER_NAME heatmap-bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec4 rdbu (float x_2865134303) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.0196078431372549,0.0392156862745098,0.6745098039215687,1);\n  const float e1 = 0.35;\n  const vec4 v1 = vec4(0.41568627450980394,0.5372549019607843,0.9686274509803922,1);\n  const float e2 = 0.5;\n  const vec4 v2 = vec4(0.7450980392156863,0.7450980392156863,0.7450980392156863,1);\n  const float e3 = 0.6;\n  const vec4 v3 = vec4(0.8627450980392157,0.6666666666666666,0.5176470588235295,1);\n  const float e4 = 0.7;\n  const vec4 v4 = vec4(0.9019607843137255,0.5686274509803921,0.35294117647058826,1);\n  const float e5 = 1.0;\n  const vec4 v5 = vec4(0.6980392156862745,0.0392156862745098,0.10980392156862745,1);\n  float a0 = smoothstep(e0,e1,x_2865134303);\n  float a1 = smoothstep(e1,e2,x_2865134303);\n  float a2 = smoothstep(e2,e3,x_2865134303);\n  float a3 = smoothstep(e3,e4,x_2865134303);\n  float a4 = smoothstep(e4,e5,x_2865134303);\n  return max(mix(v0,v1,a0)*step(e0,x_2865134303)*step(x_2865134303,e1),\n    max(mix(v1,v2,a1)*step(e1,x_2865134303)*step(x_2865134303,e2),\n    max(mix(v2,v3,a2)*step(e2,x_2865134303)*step(x_2865134303,e3),\n    max(mix(v3,v4,a3)*step(e3,x_2865134303)*step(x_2865134303,e4),mix(v4,v5,a4)*step(e4,x_2865134303)*step(x_2865134303,e5)\n  ))));\n}\n\nvec4 plasma (float x_4113959278) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.050980392156862744,0.03137254901960784,0.5294117647058824,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.29411764705882354,0.011764705882352941,0.6313725490196078,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.49019607843137253,0.011764705882352941,0.6588235294117647,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.6588235294117647,0.13333333333333333,0.5882352941176471,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.796078431372549,0.27450980392156865,0.4745098039215686,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.8980392156862745,0.4196078431372549,0.36470588235294116,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.9725490196078431,0.5803921568627451,0.2549019607843137,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.9921568627450981,0.7647058823529411,0.1568627450980392,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9411764705882353,0.9764705882352941,0.12941176470588237,1);\n  float a0 = smoothstep(e0,e1,x_4113959278);\n  float a1 = smoothstep(e1,e2,x_4113959278);\n  float a2 = smoothstep(e2,e3,x_4113959278);\n  float a3 = smoothstep(e3,e4,x_4113959278);\n  float a4 = smoothstep(e4,e5,x_4113959278);\n  float a5 = smoothstep(e5,e6,x_4113959278);\n  float a6 = smoothstep(e6,e7,x_4113959278);\n  float a7 = smoothstep(e7,e8,x_4113959278);\n  return max(mix(v0,v1,a0)*step(e0,x_4113959278)*step(x_4113959278,e1),\n    max(mix(v1,v2,a1)*step(e1,x_4113959278)*step(x_4113959278,e2),\n    max(mix(v2,v3,a2)*step(e2,x_4113959278)*step(x_4113959278,e3),\n    max(mix(v3,v4,a3)*step(e3,x_4113959278)*step(x_4113959278,e4),\n    max(mix(v4,v5,a4)*step(e4,x_4113959278)*step(x_4113959278,e5),\n    max(mix(v5,v6,a5)*step(e5,x_4113959278)*step(x_4113959278,e6),\n    max(mix(v6,v7,a6)*step(e6,x_4113959278)*step(x_4113959278,e7),mix(v7,v8,a7)*step(e7,x_4113959278)*step(x_4113959278,e8)\n  )))))));\n}\n\nvec4 viridis (float x_1156145534) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.26666666666666666,0.00392156862745098,0.32941176470588235,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.2784313725490196,0.17254901960784313,0.47843137254901963,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.23137254901960785,0.3176470588235294,0.5450980392156862,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.17254901960784313,0.44313725490196076,0.5568627450980392,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.12941176470588237,0.5647058823529412,0.5529411764705883,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.15294117647058825,0.6784313725490196,0.5058823529411764,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.3607843137254902,0.7843137254901961,0.38823529411764707,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.6666666666666666,0.8627450980392157,0.19607843137254902,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9921568627450981,0.9058823529411765,0.1450980392156863,1);\n  float a0 = smoothstep(e0,e1,x_1156145534);\n  float a1 = smoothstep(e1,e2,x_1156145534);\n  float a2 = smoothstep(e2,e3,x_1156145534);\n  float a3 = smoothstep(e3,e4,x_1156145534);\n  float a4 = smoothstep(e4,e5,x_1156145534);\n  float a5 = smoothstep(e5,e6,x_1156145534);\n  float a6 = smoothstep(e6,e7,x_1156145534);\n  float a7 = smoothstep(e7,e8,x_1156145534);\n  return max(mix(v0,v1,a0)*step(e0,x_1156145534)*step(x_1156145534,e1),\n    max(mix(v1,v2,a1)*step(e1,x_1156145534)*step(x_1156145534,e2),\n    max(mix(v2,v3,a2)*step(e2,x_1156145534)*step(x_1156145534,e3),\n    max(mix(v3,v4,a3)*step(e3,x_1156145534)*step(x_1156145534,e4),\n    max(mix(v4,v5,a4)*step(e4,x_1156145534)*step(x_1156145534,e5),\n    max(mix(v5,v6,a5)*step(e5,x_1156145534)*step(x_1156145534,e6),\n    max(mix(v6,v7,a6)*step(e6,x_1156145534)*step(x_1156145534,e7),mix(v7,v8,a7)*step(e7,x_1156145534)*step(x_1156145534,e8)\n  )))))));\n}\n\nvec4 greys (float x_2073311089) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(1,1,1,1);\n  float a0 = smoothstep(e0,e1,x_2073311089);\n  return mix(v0,v1,a0)*step(e0,x_2073311089)*step(x_2073311089,e1);\n}\n\nvec4 magma (float x_2664132035) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0.01568627450980392,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.10980392156862745,0.06274509803921569,0.26666666666666666,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.30980392156862746,0.07058823529411765,0.4823529411764706,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.5058823529411764,0.1450980392156863,0.5058823529411764,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.7098039215686275,0.21176470588235294,0.47843137254901963,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.8980392156862745,0.3137254901960784,0.39215686274509803,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.984313725490196,0.5294117647058824,0.3803921568627451,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.996078431372549,0.7607843137254902,0.5294117647058824,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9882352941176471,0.9921568627450981,0.7490196078431373,1);\n  float a0 = smoothstep(e0,e1,x_2664132035);\n  float a1 = smoothstep(e1,e2,x_2664132035);\n  float a2 = smoothstep(e2,e3,x_2664132035);\n  float a3 = smoothstep(e3,e4,x_2664132035);\n  float a4 = smoothstep(e4,e5,x_2664132035);\n  float a5 = smoothstep(e5,e6,x_2664132035);\n  float a6 = smoothstep(e6,e7,x_2664132035);\n  float a7 = smoothstep(e7,e8,x_2664132035);\n  return max(mix(v0,v1,a0)*step(e0,x_2664132035)*step(x_2664132035,e1),\n    max(mix(v1,v2,a1)*step(e1,x_2664132035)*step(x_2664132035,e2),\n    max(mix(v2,v3,a2)*step(e2,x_2664132035)*step(x_2664132035,e3),\n    max(mix(v3,v4,a3)*step(e3,x_2664132035)*step(x_2664132035,e4),\n    max(mix(v4,v5,a4)*step(e4,x_2664132035)*step(x_2664132035,e5),\n    max(mix(v5,v6,a5)*step(e5,x_2664132035)*step(x_2664132035,e6),\n    max(mix(v6,v7,a6)*step(e6,x_2664132035)*step(x_2664132035,e7),mix(v7,v8,a7)*step(e7,x_2664132035)*step(x_2664132035,e8)\n  )))))));\n}\n\nvec4 jet (float x_2485945205) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0.5137254901960784,1);\n  const float e1 = 0.125;\n  const vec4 v1 = vec4(0,0.23529411764705882,0.6666666666666666,1);\n  const float e2 = 0.375;\n  const vec4 v2 = vec4(0.0196078431372549,1,1,1);\n  const float e3 = 0.625;\n  const vec4 v3 = vec4(1,1,0,1);\n  const float e4 = 0.875;\n  const vec4 v4 = vec4(0.9803921568627451,0,0,1);\n  const float e5 = 1.0;\n  const vec4 v5 = vec4(0.5019607843137255,0,0,1);\n  float a0 = smoothstep(e0,e1,x_2485945205);\n  float a1 = smoothstep(e1,e2,x_2485945205);\n  float a2 = smoothstep(e2,e3,x_2485945205);\n  float a3 = smoothstep(e3,e4,x_2485945205);\n  float a4 = smoothstep(e4,e5,x_2485945205);\n  return max(mix(v0,v1,a0)*step(e0,x_2485945205)*step(x_2485945205,e1),\n    max(mix(v1,v2,a1)*step(e1,x_2485945205)*step(x_2485945205,e2),\n    max(mix(v2,v3,a2)*step(e2,x_2485945205)*step(x_2485945205,e3),\n    max(mix(v3,v4,a3)*step(e3,x_2485945205)*step(x_2485945205,e4),mix(v4,v5,a4)*step(e4,x_2485945205)*step(x_2485945205,e5)\n  ))));\n}\n\nvec4 bone (float x_2693572714) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0,1);\n  const float e1 = 0.376;\n  const vec4 v1 = vec4(0.32941176470588235,0.32941176470588235,0.4549019607843137,1);\n  const float e2 = 0.753;\n  const vec4 v2 = vec4(0.6627450980392157,0.7843137254901961,0.7843137254901961,1);\n  const float e3 = 1.0;\n  const vec4 v3 = vec4(1,1,1,1);\n  float a0 = smoothstep(e0,e1,x_2693572714);\n  float a1 = smoothstep(e1,e2,x_2693572714);\n  float a2 = smoothstep(e2,e3,x_2693572714);\n  return max(mix(v0,v1,a0)*step(e0,x_2693572714)*step(x_2693572714,e1),\n    max(mix(v1,v2,a1)*step(e1,x_2693572714)*step(x_2693572714,e2),mix(v2,v3,a2)*step(e2,x_2693572714)*step(x_2693572714,e3)\n  ));\n}\n\nvec4 copper (float x_2606013778) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0,1);\n  const float e1 = 0.804;\n  const vec4 v1 = vec4(1,0.6274509803921569,0.4,1);\n  const float e2 = 1.0;\n  const vec4 v2 = vec4(1,0.7803921568627451,0.4980392156862745,1);\n  float a0 = smoothstep(e0,e1,x_2606013778);\n  float a1 = smoothstep(e1,e2,x_2606013778);\n  return max(mix(v0,v1,a0)*step(e0,x_2606013778)*step(x_2606013778,e1),mix(v1,v2,a1)*step(e1,x_2606013778)*step(x_2606013778,e2)\n  );\n}\n\nvec4 density (float x_4072297271) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.21176470588235294,0.054901960784313725,0.1411764705882353,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.34901960784313724,0.09019607843137255,0.3137254901960784,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.43137254901960786,0.17647058823529413,0.5176470588235295,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.47058823529411764,0.30196078431372547,0.6980392156862745,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.47058823529411764,0.44313725490196076,0.8352941176470589,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.45098039215686275,0.592156862745098,0.8941176470588236,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.5254901960784314,0.7254901960784313,0.8901960784313725,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.6941176470588235,0.8392156862745098,0.8901960784313725,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9019607843137255,0.9450980392156862,0.9450980392156862,1);\n  float a0 = smoothstep(e0,e1,x_4072297271);\n  float a1 = smoothstep(e1,e2,x_4072297271);\n  float a2 = smoothstep(e2,e3,x_4072297271);\n  float a3 = smoothstep(e3,e4,x_4072297271);\n  float a4 = smoothstep(e4,e5,x_4072297271);\n  float a5 = smoothstep(e5,e6,x_4072297271);\n  float a6 = smoothstep(e6,e7,x_4072297271);\n  float a7 = smoothstep(e7,e8,x_4072297271);\n  return max(mix(v0,v1,a0)*step(e0,x_4072297271)*step(x_4072297271,e1),\n    max(mix(v1,v2,a1)*step(e1,x_4072297271)*step(x_4072297271,e2),\n    max(mix(v2,v3,a2)*step(e2,x_4072297271)*step(x_4072297271,e3),\n    max(mix(v3,v4,a3)*step(e3,x_4072297271)*step(x_4072297271,e4),\n    max(mix(v4,v5,a4)*step(e4,x_4072297271)*step(x_4072297271,e5),\n    max(mix(v5,v6,a5)*step(e5,x_4072297271)*step(x_4072297271,e6),\n    max(mix(v6,v7,a6)*step(e6,x_4072297271)*step(x_4072297271,e7),mix(v7,v8,a7)*step(e7,x_4072297271)*step(x_4072297271,e8)\n  )))))));\n}\n\nvec4 inferno (float x_524681000) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0.01568627450980392,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.12156862745098039,0.047058823529411764,0.2823529411764706,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.3333333333333333,0.058823529411764705,0.42745098039215684,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.5333333333333333,0.13333333333333333,0.41568627450980394,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.7294117647058823,0.21176470588235294,0.3333333333333333,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.8901960784313725,0.34901960784313724,0.2,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.9764705882352941,0.5490196078431373,0.0392156862745098,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.9764705882352941,0.788235294117647,0.19607843137254902,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9882352941176471,1,0.6431372549019608,1);\n  float a0 = smoothstep(e0,e1,x_524681000);\n  float a1 = smoothstep(e1,e2,x_524681000);\n  float a2 = smoothstep(e2,e3,x_524681000);\n  float a3 = smoothstep(e3,e4,x_524681000);\n  float a4 = smoothstep(e4,e5,x_524681000);\n  float a5 = smoothstep(e5,e6,x_524681000);\n  float a6 = smoothstep(e6,e7,x_524681000);\n  float a7 = smoothstep(e7,e8,x_524681000);\n  return max(mix(v0,v1,a0)*step(e0,x_524681000)*step(x_524681000,e1),\n    max(mix(v1,v2,a1)*step(e1,x_524681000)*step(x_524681000,e2),\n    max(mix(v2,v3,a2)*step(e2,x_524681000)*step(x_524681000,e3),\n    max(mix(v3,v4,a3)*step(e3,x_524681000)*step(x_524681000,e4),\n    max(mix(v4,v5,a4)*step(e4,x_524681000)*step(x_524681000,e5),\n    max(mix(v5,v6,a5)*step(e5,x_524681000)*step(x_524681000,e6),\n    max(mix(v6,v7,a6)*step(e6,x_524681000)*step(x_524681000,e7),mix(v7,v8,a7)*step(e7,x_524681000)*step(x_524681000,e8)\n  )))))));\n}\n\nvec4 cool (float x_3050536724) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.49019607843137253,0,0.7019607843137254,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.4549019607843137,0,0.8549019607843137,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.3843137254901961,0.2901960784313726,0.9294117647058824,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.26666666666666666,0.5725490196078431,0.9058823529411765,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0,0.8,0.7725490196078432,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0,0.9686274509803922,0.5725490196078431,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0,1,0.34509803921568627,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.1568627450980392,1,0.03137254901960784,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.5764705882352941,1,0,1);\n  float a0 = smoothstep(e0,e1,x_3050536724);\n  float a1 = smoothstep(e1,e2,x_3050536724);\n  float a2 = smoothstep(e2,e3,x_3050536724);\n  float a3 = smoothstep(e3,e4,x_3050536724);\n  float a4 = smoothstep(e4,e5,x_3050536724);\n  float a5 = smoothstep(e5,e6,x_3050536724);\n  float a6 = smoothstep(e6,e7,x_3050536724);\n  float a7 = smoothstep(e7,e8,x_3050536724);\n  return max(mix(v0,v1,a0)*step(e0,x_3050536724)*step(x_3050536724,e1),\n    max(mix(v1,v2,a1)*step(e1,x_3050536724)*step(x_3050536724,e2),\n    max(mix(v2,v3,a2)*step(e2,x_3050536724)*step(x_3050536724,e3),\n    max(mix(v3,v4,a3)*step(e3,x_3050536724)*step(x_3050536724,e4),\n    max(mix(v4,v5,a4)*step(e4,x_3050536724)*step(x_3050536724,e5),\n    max(mix(v5,v6,a5)*step(e5,x_3050536724)*step(x_3050536724,e6),\n    max(mix(v6,v7,a6)*step(e6,x_3050536724)*step(x_3050536724,e7),mix(v7,v8,a7)*step(e7,x_3050536724)*step(x_3050536724,e8)\n  )))))));\n}\n\nvec4 hot (float x_4009354686) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0,1);\n  const float e1 = 0.3;\n  const vec4 v1 = vec4(0.9019607843137255,0,0,1);\n  const float e2 = 0.6;\n  const vec4 v2 = vec4(1,0.8235294117647058,0,1);\n  const float e3 = 1.0;\n  const vec4 v3 = vec4(1,1,1,1);\n  float a0 = smoothstep(e0,e1,x_4009354686);\n  float a1 = smoothstep(e1,e2,x_4009354686);\n  float a2 = smoothstep(e2,e3,x_4009354686);\n  return max(mix(v0,v1,a0)*step(e0,x_4009354686)*step(x_4009354686,e1),\n    max(mix(v1,v2,a1)*step(e1,x_4009354686)*step(x_4009354686,e2),mix(v2,v3,a2)*step(e2,x_4009354686)*step(x_4009354686,e3)\n  ));\n}\n\nvec4 spring (float x_2270446359) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(1,0,1,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(1,1,0,1);\n  float a0 = smoothstep(e0,e1,x_2270446359);\n  return mix(v0,v1,a0)*step(e0,x_2270446359)*step(x_2270446359,e1);\n}\n\nvec4 summer (float x_1101081466) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0.5019607843137255,0.4,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(1,1,0.4,1);\n  float a0 = smoothstep(e0,e1,x_1101081466);\n  return mix(v0,v1,a0)*step(e0,x_1101081466)*step(x_1101081466,e1);\n}\n\nvec4 autumn (float x_3652770500) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(1,0,0,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(1,1,0,1);\n  float a0 = smoothstep(e0,e1,x_3652770500);\n  return mix(v0,v1,a0)*step(e0,x_3652770500)*step(x_3652770500,e1);\n}\n\nvec4 winter (float x_1155565894) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,1,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(0,1,0.5019607843137255,1);\n  float a0 = smoothstep(e0,e1,x_1155565894);\n  return mix(v0,v1,a0)*step(e0,x_1155565894)*step(x_1155565894,e1);\n}\n\n// The texture (GL.LUMINANCE & Uint8Array).\nuniform sampler2D uBitmapTexture;\n\n// What are the dimensions of the texture (width, height)?\nuniform vec2 uTextureSize;\n\n// How many consecutive pixels should be aggregated together along each axis?\nuniform vec2 uAggSize;\n\n// What are the values of the color scale sliders?\nuniform vec2 uColorScaleRange;\n\n// The texture coordinate, varying (interpolated between values set by the vertex shader).\nvarying vec2 vTexCoord;\n\nvoid main(void) {\n  // Compute 1 pixel in texture coordinates\n  vec2 onePixel = vec2(1.0, 1.0) / uTextureSize;\n  \n  vec2 viewCoord = vec2(floor(vTexCoord.x * uTextureSize.x), floor(vTexCoord.y * uTextureSize.y));\n\n  // Compute (x % aggSizeX, y % aggSizeY).\n  // These values will be the number of values to the left / above the current position to consider.\n  vec2 modAggSize = vec2(-1.0 * mod(viewCoord.x, uAggSize.x), -1.0 * mod(viewCoord.y, uAggSize.y));\n\n  // Take the sum of values along each axis.\n  float intensitySum = 0.0;\n  vec2 offsetPixels = vec2(0.0, 0.0);\n\n  for(int i = 0; i < 16; i++) {\n    // Check to break outer loop early.\n    // Uniforms cannot be used as conditions in GLSL for loops.\n    if(float(i) >= uAggSize.y) {\n      // Done in the y direction.\n      break;\n    }\n\n    offsetPixels = vec2(offsetPixels.x, (modAggSize.y + float(i)) * onePixel.y);\n\n    for(int j = 0; j < 16; j++) {\n      // Check to break inner loop early.\n      // Uniforms cannot be used as conditions in GLSL for loops.\n      if(float(j) >= uAggSize.x) {\n        // Done in the x direction.\n        break;\n      }\n\n      offsetPixels = vec2((modAggSize.x + float(j)) * onePixel.x, offsetPixels.y);\n      intensitySum += texture2D(uBitmapTexture, vTexCoord + offsetPixels).r;\n    }\n  }\n  \n  // Compute the mean value.\n  float intensityMean = intensitySum / (uAggSize.x * uAggSize.y);\n  \n  // Re-scale using the color scale slider values.\n  float scaledIntensityMean = (intensityMean - uColorScaleRange[0]) / max(0.005, (uColorScaleRange[1] - uColorScaleRange[0]));\n\n  gl_FragColor = COLORMAP_FUNC(clamp(scaledIntensityMean, 0.0, 1.0));\n\n  geometry.uv = vTexCoord;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

// src/layers/HeatmapBitmapLayer.js
var defaultProps3 = {
  image: { type: "object", value: null, async: true },
  colormap: { type: "string", value: GLSL_COLORMAP_DEFAULT, compare: true },
  bounds: { type: "array", value: [1, 0, 0, 1], compare: true },
  aggSizeX: { type: "number", value: 8, compare: true },
  aggSizeY: { type: "number", value: 8, compare: true },
  colorScaleLo: { type: "number", value: 0, compare: true },
  colorScaleHi: { type: "number", value: 1, compare: true }
};
var HeatmapBitmapLayer = class extends BitmapLayer3 {
  _getShaders(shaders) {
    this.props.extensions.forEach((extension) => {
      shaders = _mergeShaders(shaders, extension.getShaders.call(this, extension));
    });
    return shaders;
  }
  getShaders() {
    const { colormap } = this.props;
    const fragmentShaderWithColormap = GLSL_COLORMAPS.includes(colormap) ? fragmentShader.replace(COLORMAP_SHADER_PLACEHOLDER, colormap) : fragmentShader.replace(COLORMAP_SHADER_PLACEHOLDER, GLSL_COLORMAP_DEFAULT);
    return this._getShaders({
      vs: vertexShader,
      fs: fragmentShaderWithColormap,
      modules: [project322, picking2]
    });
  }
  updateState(args) {
    var _a2;
    super.updateState(args);
    this.loadTexture(this.props.image);
    const { props, oldProps } = args;
    if (props.colormap !== oldProps.colormap) {
      const { gl } = this.context;
      (_a2 = this.state.model) == null ? void 0 : _a2.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }
  draw(opts) {
    const { uniforms } = opts;
    const { bitmapTexture, model } = this.state;
    const {
      aggSizeX,
      aggSizeY,
      colorScaleLo,
      colorScaleHi
    } = this.props;
    if (bitmapTexture && model) {
      model.setUniforms(Object.assign({}, uniforms, {
        uBitmapTexture: bitmapTexture,
        uTextureSize: [TILE_SIZE, TILE_SIZE],
        uAggSize: [aggSizeX, aggSizeY],
        uColorScaleRange: [colorScaleLo, colorScaleHi]
      })).draw();
    }
  }
  loadTexture(image) {
    const { gl } = this.context;
    if (this.state.bitmapTexture) {
      this.state.bitmapTexture.delete();
    }
    if (image instanceof Texture2D2) {
      this.setState({
        bitmapTexture: image
      });
    } else if (image) {
      this.setState({
        bitmapTexture: new Texture2D2(gl, {
          data: image,
          mipmaps: false,
          parameters: PIXELATED_TEXTURE_PARAMETERS,
          format: GL3.LUMINANCE,
          dataFormat: GL3.LUMINANCE,
          type: GL3.UNSIGNED_BYTE,
          width: TILE_SIZE,
          height: TILE_SIZE
        })
      });
    }
  }
};
HeatmapBitmapLayer.layerName = "HeatmapBitmapLayer";
HeatmapBitmapLayer.defaultProps = defaultProps3;

// src/components/heatmap/utils.js
import clamp from "lodash/clamp";
import range4 from "lodash/range";
function layerFilter({ layer, viewport }) {
  if (viewport.id === "axisLeft") {
    return layer.id.startsWith("axisLeft");
  }
  if (viewport.id === "axisTop") {
    return layer.id.startsWith("axisTop");
  }
  if (viewport.id === "heatmap") {
    return layer.id.startsWith("heatmap");
  }
  if (viewport.id === "colorsLeft") {
    return layer.id.startsWith("colorsLeft");
  }
  if (viewport.id === "colorsTop") {
    return layer.id.startsWith("colorsTop");
  }
  return false;
}
function getAxisSizes(transpose, geneLabelMaxLength, cellLabelMaxLength) {
  const axisOffsetLeft = clamp((transpose ? geneLabelMaxLength : cellLabelMaxLength) * AXIS_LABEL_TEXT_SIZE, AXIS_MIN_SIZE, AXIS_MAX_SIZE);
  const axisOffsetTop = clamp((transpose ? cellLabelMaxLength : geneLabelMaxLength) * AXIS_LABEL_TEXT_SIZE, AXIS_MIN_SIZE, AXIS_MAX_SIZE);
  return [axisOffsetLeft, axisOffsetTop];
}
function mouseToHeatmapPosition(mouseX, mouseY, {
  offsetLeft,
  offsetTop,
  targetX,
  targetY,
  scaleFactor,
  matrixWidth,
  matrixHeight,
  numRows,
  numCols
}) {
  const viewMouseX = mouseX - offsetLeft;
  const viewMouseY = mouseY - offsetTop;
  if (viewMouseX < 0 || viewMouseY < 0) {
    return [null, null];
  }
  const bboxTargetX = targetX * scaleFactor + matrixWidth * scaleFactor / 2;
  const bboxTargetY = targetY * scaleFactor + matrixHeight * scaleFactor / 2;
  const bboxLeft = bboxTargetX - matrixWidth / 2;
  const bboxTop = bboxTargetY - matrixHeight / 2;
  const zoomedOffsetLeft = bboxLeft / (matrixWidth * scaleFactor);
  const zoomedOffsetTop = bboxTop / (matrixHeight * scaleFactor);
  const zoomedViewMouseX = viewMouseX / (matrixWidth * scaleFactor);
  const zoomedViewMouseY = viewMouseY / (matrixHeight * scaleFactor);
  const zoomedMouseX = zoomedOffsetLeft + zoomedViewMouseX;
  const zoomedMouseY = zoomedOffsetTop + zoomedViewMouseY;
  const rowI = Math.floor(zoomedMouseY * numRows);
  const colI = Math.floor(zoomedMouseX * numCols);
  return [colI, rowI];
}
function heatmapToMousePosition(colI, rowI, {
  offsetLeft,
  offsetTop,
  targetX,
  targetY,
  scaleFactor,
  matrixWidth,
  matrixHeight,
  numRows,
  numCols
}) {
  let zoomedMouseY = null;
  let zoomedMouseX = null;
  if (rowI !== null) {
    const minY = -matrixHeight * scaleFactor / 2;
    const maxY = matrixHeight * scaleFactor / 2;
    const totalHeight = maxY - minY;
    const minInViewY = targetY * scaleFactor - matrixHeight / 2;
    const maxInViewY = targetY * scaleFactor + matrixHeight / 2;
    const inViewHeight = maxInViewY - minInViewY;
    const normalizedRowY = (rowI + 0.5) / numRows;
    const globalRowY = minY + normalizedRowY * totalHeight;
    if (minInViewY <= globalRowY && globalRowY <= maxInViewY) {
      zoomedMouseY = offsetTop + (globalRowY - minInViewY) / inViewHeight * matrixHeight;
    }
  }
  if (colI !== null) {
    const minX = -matrixWidth * scaleFactor / 2;
    const maxX = matrixWidth * scaleFactor / 2;
    const totalWidth = maxX - minX;
    const minInViewX = targetX * scaleFactor - matrixWidth / 2;
    const maxInViewX = targetX * scaleFactor + matrixWidth / 2;
    const inViewWidth = maxInViewX - minInViewX;
    const normalizedRowX = (colI + 0.5) / numCols;
    const globalRowX = minX + normalizedRowX * totalWidth;
    if (minInViewX <= globalRowX && globalRowX <= maxInViewX) {
      zoomedMouseX = offsetLeft + (globalRowX - minInViewX) / inViewWidth * matrixWidth;
    }
  }
  return [zoomedMouseX, zoomedMouseY];
}

// inline-worker:/home/runner/work/vitessce/vitessce/src/components/heatmap/heatmap.worker
var encodedJs2 = "KCgpPT57dmFyIGNFPU9iamVjdC5jcmVhdGU7dmFyIFA9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBmRT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciBpRT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgWEU9T2JqZWN0LmdldFByb3RvdHlwZU9mLHNFPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIGFFPUU9PlAoRSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIGpfPXR5cGVvZiByZXF1aXJlIT0idW5kZWZpbmVkIj9yZXF1aXJlOkU9Pnt0aHJvdyBuZXcgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZSBvZiAiJytFKyciIGlzIG5vdCBzdXBwb3J0ZWQnKX07dmFyIEE9KEUsXyk9PigpPT4oX3x8RSgoXz17ZXhwb3J0czp7fX0pLmV4cG9ydHMsXyksXy5leHBvcnRzKTt2YXIgYkU9KEUsXyxSKT0+e2lmKF8mJnR5cGVvZiBfPT0ib2JqZWN0Inx8dHlwZW9mIF89PSJmdW5jdGlvbiIpZm9yKGxldCBUIG9mIGlFKF8pKSFzRS5jYWxsKEUsVCkmJlQhPT0iZGVmYXVsdCImJlAoRSxULHtnZXQ6KCk9Pl9bVF0sZW51bWVyYWJsZTohKFI9ZkUoXyxUKSl8fFIuZW51bWVyYWJsZX0pO3JldHVybiBFfSxzPUU9PmJFKGFFKFAoRSE9bnVsbD9jRShYRShFKSk6e30sImRlZmF1bHQiLEUmJkUuX19lc01vZHVsZSYmImRlZmF1bHQiaW4gRT97Z2V0OigpPT5FLmRlZmF1bHQsZW51bWVyYWJsZTohMH06e3ZhbHVlOkUsZW51bWVyYWJsZTohMH0pKSxFKTt2YXIgYj1BKChoXyxhKT0+e2Z1bmN0aW9uIGRFKEUsXyxSKXtyZXR1cm4gRT09PUUmJihSIT09dm9pZCAwJiYoRT1FPD1SP0U6UiksXyE9PXZvaWQgMCYmKEU9RT49Xz9FOl8pKSxFfWEuZXhwb3J0cz1kRX0pO3ZhciBvPUEoKFFfLGQpPT57ZnVuY3Rpb24gSEUoRSl7dmFyIF89dHlwZW9mIEU7cmV0dXJuIEUhPW51bGwmJihfPT0ib2JqZWN0Inx8Xz09ImZ1bmN0aW9uIil9ZC5leHBvcnRzPUhFfSk7dmFyIFc9QSgod18sSCk9Pnt2YXIgV0U9dHlwZW9mIGdsb2JhbD09Im9iamVjdCImJmdsb2JhbCYmZ2xvYmFsLk9iamVjdD09PU9iamVjdCYmZ2xvYmFsO0guZXhwb3J0cz1XRX0pO3ZhciB1PUEoKGtfLFYpPT57dmFyIFZFPVcoKSx1RT10eXBlb2Ygc2VsZj09Im9iamVjdCImJnNlbGYmJnNlbGYuT2JqZWN0PT09T2JqZWN0JiZzZWxmLFlFPVZFfHx1RXx8RnVuY3Rpb24oInJldHVybiB0aGlzIikoKTtWLmV4cG9ydHM9WUV9KTt2YXIgRz1BKCh2XyxZKT0+e3ZhciBsRT11KCksZ0U9bEUuU3ltYm9sO1kuZXhwb3J0cz1nRX0pO3ZhciBwPUEoKEpfLEspPT57dmFyIGw9RygpLGc9T2JqZWN0LnByb3RvdHlwZSxLRT1nLmhhc093blByb3BlcnR5LHBFPWcudG9TdHJpbmcsbj1sP2wudG9TdHJpbmdUYWc6dm9pZCAwO2Z1bmN0aW9uIG1FKEUpe3ZhciBfPUtFLmNhbGwoRSxuKSxSPUVbbl07dHJ5e0Vbbl09dm9pZCAwO3ZhciBUPSEwfWNhdGNoKHgpe312YXIgTj1wRS5jYWxsKEUpO3JldHVybiBUJiYoXz9FW25dPVI6ZGVsZXRlIEVbbl0pLE59Sy5leHBvcnRzPW1FfSk7dmFyIHk9QSgoJF8sbSk9Pnt2YXIgeUU9T2JqZWN0LnByb3RvdHlwZSxaRT15RS50b1N0cmluZztmdW5jdGlvbiBqRShFKXtyZXR1cm4gWkUuY2FsbChFKX1tLmV4cG9ydHM9akV9KTt2YXIgcj1BKCh6XyxxKT0+e3ZhciBaPUcoKSxxRT1wKCksaEU9eSgpLFFFPSJbb2JqZWN0IE51bGxdIix3RT0iW29iamVjdCBVbmRlZmluZWRdIixqPVo/Wi50b1N0cmluZ1RhZzp2b2lkIDA7ZnVuY3Rpb24ga0UoRSl7cmV0dXJuIEU9PW51bGw/RT09PXZvaWQgMD93RTpRRTpqJiZqIGluIE9iamVjdChFKT9xRShFKTpoRShFKX1xLmV4cG9ydHM9a0V9KTt2YXIgUT1BKChFMCxoKT0+e2Z1bmN0aW9uIHZFKEUpe3JldHVybiBFIT1udWxsJiZ0eXBlb2YgRT09Im9iamVjdCJ9aC5leHBvcnRzPXZFfSk7dmFyIGs9QSgoXzAsdyk9Pnt2YXIgSkU9cigpLCRFPVEoKSx6RT0iW29iamVjdCBTeW1ib2xdIjtmdW5jdGlvbiBFXyhFKXtyZXR1cm4gdHlwZW9mIEU9PSJzeW1ib2wifHwkRShFKSYmSkUoRSk9PXpFfXcuZXhwb3J0cz1FX30pO3ZhciBjPUEoKFIwLCQpPT57dmFyIHY9bygpLF9fPWsoKSxKPTAvMCxSXz0vXlxzK3xccyskL2csVF89L15bLStdMHhbMC05YS1mXSskL2ksQV89L14wYlswMV0rJC9pLHhfPS9eMG9bMC03XSskL2ksTl89cGFyc2VJbnQ7ZnVuY3Rpb24gSV8oRSl7aWYodHlwZW9mIEU9PSJudW1iZXIiKXJldHVybiBFO2lmKF9fKEUpKXJldHVybiBKO2lmKHYoRSkpe3ZhciBfPXR5cGVvZiBFLnZhbHVlT2Y9PSJmdW5jdGlvbiI/RS52YWx1ZU9mKCk6RTtFPXYoXyk/XysiIjpffWlmKHR5cGVvZiBFIT0ic3RyaW5nIilyZXR1cm4gRT09PTA/RTorRTtFPUUucmVwbGFjZShSXywiIik7dmFyIFI9QV8udGVzdChFKTtyZXR1cm4gUnx8eF8udGVzdChFKT9OXyhFLnNsaWNlKDIpLFI/Mjo4KTpUXy50ZXN0KEUpP0o6K0V9JC5leHBvcnRzPUlffSk7dmFyIEVFPUEoKFQwLHopPT57dmFyIFNfPWIoKSxmPWMoKTtmdW5jdGlvbiBPXyhFLF8sUil7cmV0dXJuIFI9PT12b2lkIDAmJihSPV8sXz12b2lkIDApLFIhPT12b2lkIDAmJihSPWYoUiksUj1SPT09Uj9SOjApLF8hPT12b2lkIDAmJihfPWYoXyksXz1fPT09Xz9fOjApLFNfKGYoRSksXyxSKX16LmV4cG9ydHM9T199KTt2YXIgUkU9QSgoQTAsX0UpPT57dmFyIE1fPU1hdGguY2VpbCxGXz1NYXRoLm1heDtmdW5jdGlvbiBDXyhFLF8sUixUKXtmb3IodmFyIE49LTEseD1GXyhNXygoXy1FKS8oUnx8MSkpLDApLE89QXJyYXkoeCk7eC0tOylPW1Q/eDorK05dPUUsRSs9UjtyZXR1cm4gT31fRS5leHBvcnRzPUNffSk7dmFyIEFFPUEoKHgwLFRFKT0+e2Z1bmN0aW9uIGVfKEUsXyl7cmV0dXJuIEU9PT1ffHxFIT09RSYmXyE9PV99VEUuZXhwb3J0cz1lX30pO3ZhciBORT1BKChOMCx4RSk9Pnt2YXIgTF89cigpLEJfPW8oKSxVXz0iW29iamVjdCBBc3luY0Z1bmN0aW9uXSIsRF89IltvYmplY3QgRnVuY3Rpb25dIix0Xz0iW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0iLG5fPSJbb2JqZWN0IFByb3h5XSI7ZnVuY3Rpb24gb18oRSl7aWYoIUJfKEUpKXJldHVybiExO3ZhciBfPUxfKEUpO3JldHVybiBfPT1EX3x8Xz09dF98fF89PVVffHxfPT1uX314RS5leHBvcnRzPW9ffSk7dmFyIFNFPUEoKEkwLElFKT0+e3ZhciBQXz05MDA3MTk5MjU0NzQwOTkxO2Z1bmN0aW9uIEdfKEUpe3JldHVybiB0eXBlb2YgRT09Im51bWJlciImJkU+LTEmJkUlMT09MCYmRTw9UF99SUUuZXhwb3J0cz1HX30pO3ZhciBNRT1BKChTMCxPRSk9Pnt2YXIgcl89TkUoKSxjXz1TRSgpO2Z1bmN0aW9uIGZfKEUpe3JldHVybiBFIT1udWxsJiZjXyhFLmxlbmd0aCkmJiFyXyhFKX1PRS5leHBvcnRzPWZffSk7dmFyIENFPUEoKE8wLEZFKT0+e3ZhciBpXz05MDA3MTk5MjU0NzQwOTkxLFhfPS9eKD86MHxbMS05XVxkKikkLztmdW5jdGlvbiBzXyhFLF8pe3ZhciBSPXR5cGVvZiBFO3JldHVybiBfPV89PW51bGw/aV86XywhIV8mJihSPT0ibnVtYmVyInx8UiE9InN5bWJvbCImJlhfLnRlc3QoRSkpJiZFPi0xJiZFJTE9PTAmJkU8X31GRS5leHBvcnRzPXNffSk7dmFyIExFPUEoKE0wLGVFKT0+e3ZhciBhXz1BRSgpLGJfPU1FKCksZF89Q0UoKSxIXz1vKCk7ZnVuY3Rpb24gV18oRSxfLFIpe2lmKCFIXyhSKSlyZXR1cm4hMTt2YXIgVD10eXBlb2YgXztyZXR1cm4oVD09Im51bWJlciI/Yl8oUikmJmRfKF8sUi5sZW5ndGgpOlQ9PSJzdHJpbmciJiZfIGluIFIpP2FfKFJbX10sRSk6ITF9ZUUuZXhwb3J0cz1XX30pO3ZhciBERT1BKChGMCxVRSk9Pnt2YXIgVl89YygpLEJFPTEvMCx1Xz0xNzk3NjkzMTM0ODYyMzE1N2UyOTI7ZnVuY3Rpb24gWV8oRSl7aWYoIUUpcmV0dXJuIEU9PT0wP0U6MDtpZihFPVZfKEUpLEU9PT1CRXx8RT09PS1CRSl7dmFyIF89RTwwPy0xOjE7cmV0dXJuIF8qdV99cmV0dXJuIEU9PT1FP0U6MH1VRS5leHBvcnRzPVlffSk7dmFyIG5FPUEoKEMwLHRFKT0+e3ZhciBsXz1SRSgpLGdfPUxFKCksaT1ERSgpO2Z1bmN0aW9uIEtfKEUpe3JldHVybiBmdW5jdGlvbihfLFIsVCl7cmV0dXJuIFQmJnR5cGVvZiBUIT0ibnVtYmVyIiYmZ18oXyxSLFQpJiYoUj1UPXZvaWQgMCksXz1pKF8pLFI9PT12b2lkIDA/KFI9XyxfPTApOlI9aShSKSxUPVQ9PT12b2lkIDA/XzxSPzE6LTE6aShUKSxsXyhfLFIsVCxFKX19dEUuZXhwb3J0cz1LX30pO3ZhciBQRT1BKChlMCxvRSk9Pnt2YXIgcF89bkUoKSxtXz1wXygpO29FLmV4cG9ydHM9bV99KTt2YXIgeV89cyhFRSgpKSxYPXMoUEUoKSk7dmFyIFM9e0RFUFRIX0JVRkZFUl9CSVQ6MjU2LFNURU5DSUxfQlVGRkVSX0JJVDoxMDI0LENPTE9SX0JVRkZFUl9CSVQ6MTYzODQsUE9JTlRTOjAsTElORVM6MSxMSU5FX0xPT1A6MixMSU5FX1NUUklQOjMsVFJJQU5HTEVTOjQsVFJJQU5HTEVfU1RSSVA6NSxUUklBTkdMRV9GQU46NixaRVJPOjAsT05FOjEsU1JDX0NPTE9SOjc2OCxPTkVfTUlOVVNfU1JDX0NPTE9SOjc2OSxTUkNfQUxQSEE6NzcwLE9ORV9NSU5VU19TUkNfQUxQSEE6NzcxLERTVF9BTFBIQTo3NzIsT05FX01JTlVTX0RTVF9BTFBIQTo3NzMsRFNUX0NPTE9SOjc3NCxPTkVfTUlOVVNfRFNUX0NPTE9SOjc3NSxTUkNfQUxQSEFfU0FUVVJBVEU6Nzc2LENPTlNUQU5UX0NPTE9SOjMyNzY5LE9ORV9NSU5VU19DT05TVEFOVF9DT0xPUjozMjc3MCxDT05TVEFOVF9BTFBIQTozMjc3MSxPTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEE6MzI3NzIsRlVOQ19BREQ6MzI3NzQsRlVOQ19TVUJUUkFDVDozMjc3OCxGVU5DX1JFVkVSU0VfU1VCVFJBQ1Q6MzI3NzksQkxFTkRfRVFVQVRJT046MzI3NzcsQkxFTkRfRVFVQVRJT05fUkdCOjMyNzc3LEJMRU5EX0VRVUFUSU9OX0FMUEhBOjM0ODc3LEJMRU5EX0RTVF9SR0I6MzI5NjgsQkxFTkRfU1JDX1JHQjozMjk2OSxCTEVORF9EU1RfQUxQSEE6MzI5NzAsQkxFTkRfU1JDX0FMUEhBOjMyOTcxLEJMRU5EX0NPTE9SOjMyNzczLEFSUkFZX0JVRkZFUl9CSU5ESU5HOjM0OTY0LEVMRU1FTlRfQVJSQVlfQlVGRkVSX0JJTkRJTkc6MzQ5NjUsTElORV9XSURUSDoyODQ5LEFMSUFTRURfUE9JTlRfU0laRV9SQU5HRTozMzkwMSxBTElBU0VEX0xJTkVfV0lEVEhfUkFOR0U6MzM5MDIsQ1VMTF9GQUNFX01PREU6Mjg4NSxGUk9OVF9GQUNFOjI4ODYsREVQVEhfUkFOR0U6MjkyOCxERVBUSF9XUklURU1BU0s6MjkzMCxERVBUSF9DTEVBUl9WQUxVRToyOTMxLERFUFRIX0ZVTkM6MjkzMixTVEVOQ0lMX0NMRUFSX1ZBTFVFOjI5NjEsU1RFTkNJTF9GVU5DOjI5NjIsU1RFTkNJTF9GQUlMOjI5NjQsU1RFTkNJTF9QQVNTX0RFUFRIX0ZBSUw6Mjk2NSxTVEVOQ0lMX1BBU1NfREVQVEhfUEFTUzoyOTY2LFNURU5DSUxfUkVGOjI5NjcsU1RFTkNJTF9WQUxVRV9NQVNLOjI5NjMsU1RFTkNJTF9XUklURU1BU0s6Mjk2OCxTVEVOQ0lMX0JBQ0tfRlVOQzozNDgxNixTVEVOQ0lMX0JBQ0tfRkFJTDozNDgxNyxTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9GQUlMOjM0ODE4LFNURU5DSUxfQkFDS19QQVNTX0RFUFRIX1BBU1M6MzQ4MTksU1RFTkNJTF9CQUNLX1JFRjozNjAwMyxTVEVOQ0lMX0JBQ0tfVkFMVUVfTUFTSzozNjAwNCxTVEVOQ0lMX0JBQ0tfV1JJVEVNQVNLOjM2MDA1LFZJRVdQT1JUOjI5NzgsU0NJU1NPUl9CT1g6MzA4OCxDT0xPUl9DTEVBUl9WQUxVRTozMTA2LENPTE9SX1dSSVRFTUFTSzozMTA3LFVOUEFDS19BTElHTk1FTlQ6MzMxNyxQQUNLX0FMSUdOTUVOVDozMzMzLE1BWF9URVhUVVJFX1NJWkU6MzM3OSxNQVhfVklFV1BPUlRfRElNUzozMzg2LFNVQlBJWEVMX0JJVFM6MzQwOCxSRURfQklUUzozNDEwLEdSRUVOX0JJVFM6MzQxMSxCTFVFX0JJVFM6MzQxMixBTFBIQV9CSVRTOjM0MTMsREVQVEhfQklUUzozNDE0LFNURU5DSUxfQklUUzozNDE1LFBPTFlHT05fT0ZGU0VUX1VOSVRTOjEwNzUyLFBPTFlHT05fT0ZGU0VUX0ZBQ1RPUjozMjgyNCxURVhUVVJFX0JJTkRJTkdfMkQ6MzI4NzMsU0FNUExFX0JVRkZFUlM6MzI5MzYsU0FNUExFUzozMjkzNyxTQU1QTEVfQ09WRVJBR0VfVkFMVUU6MzI5MzgsU0FNUExFX0NPVkVSQUdFX0lOVkVSVDozMjkzOSxDT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUzozNDQ2NyxWRU5ET1I6NzkzNixSRU5ERVJFUjo3OTM3LFZFUlNJT046NzkzOCxJTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX1RZUEU6MzU3MzgsSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9GT1JNQVQ6MzU3MzksQlJPV1NFUl9ERUZBVUxUX1dFQkdMOjM3NDQ0LFNUQVRJQ19EUkFXOjM1MDQ0LFNUUkVBTV9EUkFXOjM1MDQwLERZTkFNSUNfRFJBVzozNTA0OCxBUlJBWV9CVUZGRVI6MzQ5NjIsRUxFTUVOVF9BUlJBWV9CVUZGRVI6MzQ5NjMsQlVGRkVSX1NJWkU6MzQ2NjAsQlVGRkVSX1VTQUdFOjM0NjYxLENVUlJFTlRfVkVSVEVYX0FUVFJJQjozNDM0MixWRVJURVhfQVRUUklCX0FSUkFZX0VOQUJMRUQ6MzQzMzgsVkVSVEVYX0FUVFJJQl9BUlJBWV9TSVpFOjM0MzM5LFZFUlRFWF9BVFRSSUJfQVJSQVlfU1RSSURFOjM0MzQwLFZFUlRFWF9BVFRSSUJfQVJSQVlfVFlQRTozNDM0MSxWRVJURVhfQVRUUklCX0FSUkFZX05PUk1BTElaRUQ6MzQ5MjIsVkVSVEVYX0FUVFJJQl9BUlJBWV9QT0lOVEVSOjM0MzczLFZFUlRFWF9BVFRSSUJfQVJSQVlfQlVGRkVSX0JJTkRJTkc6MzQ5NzUsQ1VMTF9GQUNFOjI4ODQsRlJPTlQ6MTAyOCxCQUNLOjEwMjksRlJPTlRfQU5EX0JBQ0s6MTAzMixCTEVORDozMDQyLERFUFRIX1RFU1Q6MjkyOSxESVRIRVI6MzAyNCxQT0xZR09OX09GRlNFVF9GSUxMOjMyODIzLFNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRTozMjkyNixTQU1QTEVfQ09WRVJBR0U6MzI5MjgsU0NJU1NPUl9URVNUOjMwODksU1RFTkNJTF9URVNUOjI5NjAsTk9fRVJST1I6MCxJTlZBTElEX0VOVU06MTI4MCxJTlZBTElEX1ZBTFVFOjEyODEsSU5WQUxJRF9PUEVSQVRJT046MTI4MixPVVRfT0ZfTUVNT1JZOjEyODUsQ09OVEVYVF9MT1NUX1dFQkdMOjM3NDQyLENXOjIzMDQsQ0NXOjIzMDUsRE9OVF9DQVJFOjQzNTIsRkFTVEVTVDo0MzUzLE5JQ0VTVDo0MzU0LEdFTkVSQVRFX01JUE1BUF9ISU5UOjMzMTcwLEJZVEU6NTEyMCxVTlNJR05FRF9CWVRFOjUxMjEsU0hPUlQ6NTEyMixVTlNJR05FRF9TSE9SVDo1MTIzLElOVDo1MTI0LFVOU0lHTkVEX0lOVDo1MTI1LEZMT0FUOjUxMjYsRE9VQkxFOjUxMzAsREVQVEhfQ09NUE9ORU5UOjY0MDIsQUxQSEE6NjQwNixSR0I6NjQwNyxSR0JBOjY0MDgsTFVNSU5BTkNFOjY0MDksTFVNSU5BTkNFX0FMUEhBOjY0MTAsVU5TSUdORURfU0hPUlRfNF80XzRfNDozMjgxOSxVTlNJR05FRF9TSE9SVF81XzVfNV8xOjMyODIwLFVOU0lHTkVEX1NIT1JUXzVfNl81OjMzNjM1LEZSQUdNRU5UX1NIQURFUjozNTYzMixWRVJURVhfU0hBREVSOjM1NjMzLENPTVBJTEVfU1RBVFVTOjM1NzEzLERFTEVURV9TVEFUVVM6MzU3MTIsTElOS19TVEFUVVM6MzU3MTQsVkFMSURBVEVfU1RBVFVTOjM1NzE1LEFUVEFDSEVEX1NIQURFUlM6MzU3MTcsQUNUSVZFX0FUVFJJQlVURVM6MzU3MjEsQUNUSVZFX1VOSUZPUk1TOjM1NzE4LE1BWF9WRVJURVhfQVRUUklCUzozNDkyMSxNQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUzozNjM0NyxNQVhfVkFSWUlOR19WRUNUT1JTOjM2MzQ4LE1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTOjM1NjYxLE1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUzozNTY2MCxNQVhfVEVYVFVSRV9JTUFHRV9VTklUUzozNDkzMCxNQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTOjM2MzQ5LFNIQURFUl9UWVBFOjM1NjYzLFNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTjozNTcyNCxDVVJSRU5UX1BST0dSQU06MzU3MjUsTkVWRVI6NTEyLEFMV0FZUzo1MTksTEVTUzo1MTMsRVFVQUw6NTE0LExFUVVBTDo1MTUsR1JFQVRFUjo1MTYsR0VRVUFMOjUxOCxOT1RFUVVBTDo1MTcsS0VFUDo3NjgwLFJFUExBQ0U6NzY4MSxJTkNSOjc2ODIsREVDUjo3NjgzLElOVkVSVDo1Mzg2LElOQ1JfV1JBUDozNDA1NSxERUNSX1dSQVA6MzQwNTYsTkVBUkVTVDo5NzI4LExJTkVBUjo5NzI5LE5FQVJFU1RfTUlQTUFQX05FQVJFU1Q6OTk4NCxMSU5FQVJfTUlQTUFQX05FQVJFU1Q6OTk4NSxORUFSRVNUX01JUE1BUF9MSU5FQVI6OTk4NixMSU5FQVJfTUlQTUFQX0xJTkVBUjo5OTg3LFRFWFRVUkVfTUFHX0ZJTFRFUjoxMDI0MCxURVhUVVJFX01JTl9GSUxURVI6MTAyNDEsVEVYVFVSRV9XUkFQX1M6MTAyNDIsVEVYVFVSRV9XUkFQX1Q6MTAyNDMsVEVYVFVSRV8yRDozNTUzLFRFWFRVUkU6NTg5MCxURVhUVVJFX0NVQkVfTUFQOjM0MDY3LFRFWFRVUkVfQklORElOR19DVUJFX01BUDozNDA2OCxURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1g6MzQwNjksVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YOjM0MDcwLFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWTozNDA3MSxURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1k6MzQwNzIsVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aOjM0MDczLFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWjozNDA3NCxNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFOjM0MDc2LFRFWFRVUkUwOjMzOTg0LEFDVElWRV9URVhUVVJFOjM0MDE2LFJFUEVBVDoxMDQ5NyxDTEFNUF9UT19FREdFOjMzMDcxLE1JUlJPUkVEX1JFUEVBVDozMzY0OCxURVhUVVJFX1dJRFRIOjQwOTYsVEVYVFVSRV9IRUlHSFQ6NDA5NyxGTE9BVF9WRUMyOjM1NjY0LEZMT0FUX1ZFQzM6MzU2NjUsRkxPQVRfVkVDNDozNTY2NixJTlRfVkVDMjozNTY2NyxJTlRfVkVDMzozNTY2OCxJTlRfVkVDNDozNTY2OSxCT09MOjM1NjcwLEJPT0xfVkVDMjozNTY3MSxCT09MX1ZFQzM6MzU2NzIsQk9PTF9WRUM0OjM1NjczLEZMT0FUX01BVDI6MzU2NzQsRkxPQVRfTUFUMzozNTY3NSxGTE9BVF9NQVQ0OjM1Njc2LFNBTVBMRVJfMkQ6MzU2NzgsU0FNUExFUl9DVUJFOjM1NjgwLExPV19GTE9BVDozNjMzNixNRURJVU1fRkxPQVQ6MzYzMzcsSElHSF9GTE9BVDozNjMzOCxMT1dfSU5UOjM2MzM5LE1FRElVTV9JTlQ6MzYzNDAsSElHSF9JTlQ6MzYzNDEsRlJBTUVCVUZGRVI6MzYxNjAsUkVOREVSQlVGRkVSOjM2MTYxLFJHQkE0OjMyODU0LFJHQjVfQTE6MzI4NTUsUkdCNTY1OjM2MTk0LERFUFRIX0NPTVBPTkVOVDE2OjMzMTg5LFNURU5DSUxfSU5ERVg6NjQwMSxTVEVOQ0lMX0lOREVYODozNjE2OCxERVBUSF9TVEVOQ0lMOjM0MDQxLFJFTkRFUkJVRkZFUl9XSURUSDozNjE2MixSRU5ERVJCVUZGRVJfSEVJR0hUOjM2MTYzLFJFTkRFUkJVRkZFUl9JTlRFUk5BTF9GT1JNQVQ6MzYxNjQsUkVOREVSQlVGRkVSX1JFRF9TSVpFOjM2MTc2LFJFTkRFUkJVRkZFUl9HUkVFTl9TSVpFOjM2MTc3LFJFTkRFUkJVRkZFUl9CTFVFX1NJWkU6MzYxNzgsUkVOREVSQlVGRkVSX0FMUEhBX1NJWkU6MzYxNzksUkVOREVSQlVGRkVSX0RFUFRIX1NJWkU6MzYxODAsUkVOREVSQlVGRkVSX1NURU5DSUxfU0laRTozNjE4MSxGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9UWVBFOjM2MDQ4LEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX05BTUU6MzYwNDksRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xFVkVMOjM2MDUwLEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9DVUJFX01BUF9GQUNFOjM2MDUxLENPTE9SX0FUVEFDSE1FTlQwOjM2MDY0LERFUFRIX0FUVEFDSE1FTlQ6MzYwOTYsU1RFTkNJTF9BVFRBQ0hNRU5UOjM2MTI4LERFUFRIX1NURU5DSUxfQVRUQUNITUVOVDozMzMwNixOT05FOjAsRlJBTUVCVUZGRVJfQ09NUExFVEU6MzYwNTMsRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOjM2MDU0LEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOjM2MDU1LEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzozNjA1NyxGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDozNjA2MSxGUkFNRUJVRkZFUl9CSU5ESU5HOjM2MDA2LFJFTkRFUkJVRkZFUl9CSU5ESU5HOjM2MDA3LFJFQURfRlJBTUVCVUZGRVI6MzYwMDgsRFJBV19GUkFNRUJVRkZFUjozNjAwOSxNQVhfUkVOREVSQlVGRkVSX1NJWkU6MzQwMjQsSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046MTI4NixVTlBBQ0tfRkxJUF9ZX1dFQkdMOjM3NDQwLFVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTDozNzQ0MSxVTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMOjM3NDQzLFJFQURfQlVGRkVSOjMwNzQsVU5QQUNLX1JPV19MRU5HVEg6MzMxNCxVTlBBQ0tfU0tJUF9ST1dTOjMzMTUsVU5QQUNLX1NLSVBfUElYRUxTOjMzMTYsUEFDS19ST1dfTEVOR1RIOjMzMzAsUEFDS19TS0lQX1JPV1M6MzMzMSxQQUNLX1NLSVBfUElYRUxTOjMzMzIsVEVYVFVSRV9CSU5ESU5HXzNEOjMyODc0LFVOUEFDS19TS0lQX0lNQUdFUzozMjg3NyxVTlBBQ0tfSU1BR0VfSEVJR0hUOjMyODc4LE1BWF8zRF9URVhUVVJFX1NJWkU6MzI4ODMsTUFYX0VMRU1FTlRTX1ZFUlRJQ0VTOjMzZTMsTUFYX0VMRU1FTlRTX0lORElDRVM6MzMwMDEsTUFYX1RFWFRVUkVfTE9EX0JJQVM6MzQwNDUsTUFYX0ZSQUdNRU5UX1VOSUZPUk1fQ09NUE9ORU5UUzozNTY1NyxNQVhfVkVSVEVYX1VOSUZPUk1fQ09NUE9ORU5UUzozNTY1OCxNQVhfQVJSQVlfVEVYVFVSRV9MQVlFUlM6MzUwNzEsTUlOX1BST0dSQU1fVEVYRUxfT0ZGU0VUOjM1MDc2LE1BWF9QUk9HUkFNX1RFWEVMX09GRlNFVDozNTA3NyxNQVhfVkFSWUlOR19DT01QT05FTlRTOjM1NjU5LEZSQUdNRU5UX1NIQURFUl9ERVJJVkFUSVZFX0hJTlQ6MzU3MjMsUkFTVEVSSVpFUl9ESVNDQVJEOjM1OTc3LFZFUlRFWF9BUlJBWV9CSU5ESU5HOjM0MjI5LE1BWF9WRVJURVhfT1VUUFVUX0NPTVBPTkVOVFM6MzcxNTQsTUFYX0ZSQUdNRU5UX0lOUFVUX0NPTVBPTkVOVFM6MzcxNTcsTUFYX1NFUlZFUl9XQUlUX1RJTUVPVVQ6MzcxMzcsTUFYX0VMRU1FTlRfSU5ERVg6MzYyMDMsUkVEOjY0MDMsUkdCODozMjg0OSxSR0JBODozMjg1NixSR0IxMF9BMjozMjg1NyxURVhUVVJFXzNEOjMyODc5LFRFWFRVUkVfV1JBUF9SOjMyODgyLFRFWFRVUkVfTUlOX0xPRDozMzA4MixURVhUVVJFX01BWF9MT0Q6MzMwODMsVEVYVFVSRV9CQVNFX0xFVkVMOjMzMDg0LFRFWFRVUkVfTUFYX0xFVkVMOjMzMDg1LFRFWFRVUkVfQ09NUEFSRV9NT0RFOjM0ODkyLFRFWFRVUkVfQ09NUEFSRV9GVU5DOjM0ODkzLFNSR0I6MzU5MDQsU1JHQjg6MzU5MDUsU1JHQjhfQUxQSEE4OjM1OTA3LENPTVBBUkVfUkVGX1RPX1RFWFRVUkU6MzQ4OTQsUkdCQTMyRjozNDgzNixSR0IzMkY6MzQ4MzcsUkdCQTE2RjozNDg0MixSR0IxNkY6MzQ4NDMsVEVYVFVSRV8yRF9BUlJBWTozNTg2NixURVhUVVJFX0JJTkRJTkdfMkRfQVJSQVk6MzU4NjksUjExRl9HMTFGX0IxMEY6MzU4OTgsUkdCOV9FNTozNTkwMSxSR0JBMzJVSTozNjIwOCxSR0IzMlVJOjM2MjA5LFJHQkExNlVJOjM2MjE0LFJHQjE2VUk6MzYyMTUsUkdCQThVSTozNjIyMCxSR0I4VUk6MzYyMjEsUkdCQTMySTozNjIyNixSR0IzMkk6MzYyMjcsUkdCQTE2STozNjIzMixSR0IxNkk6MzYyMzMsUkdCQThJOjM2MjM4LFJHQjhJOjM2MjM5LFJFRF9JTlRFR0VSOjM2MjQ0LFJHQl9JTlRFR0VSOjM2MjQ4LFJHQkFfSU5URUdFUjozNjI0OSxSODozMzMyMSxSRzg6MzMzMjMsUjE2RjozMzMyNSxSMzJGOjMzMzI2LFJHMTZGOjMzMzI3LFJHMzJGOjMzMzI4LFI4STozMzMyOSxSOFVJOjMzMzMwLFIxNkk6MzMzMzEsUjE2VUk6MzMzMzIsUjMySTozMzMzMyxSMzJVSTozMzMzNCxSRzhJOjMzMzM1LFJHOFVJOjMzMzM2LFJHMTZJOjMzMzM3LFJHMTZVSTozMzMzOCxSRzMySTozMzMzOSxSRzMyVUk6MzMzNDAsUjhfU05PUk06MzY3NTYsUkc4X1NOT1JNOjM2NzU3LFJHQjhfU05PUk06MzY3NTgsUkdCQThfU05PUk06MzY3NTksUkdCMTBfQTJVSTozNjk3NSxURVhUVVJFX0lNTVVUQUJMRV9GT1JNQVQ6MzcxNjcsVEVYVFVSRV9JTU1VVEFCTEVfTEVWRUxTOjMzNTAzLFVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVjozMzY0MCxVTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWOjM1ODk5LFVOU0lHTkVEX0lOVF81XzlfOV85X1JFVjozNTkwMixGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVY6MzYyNjksVU5TSUdORURfSU5UXzI0Xzg6MzQwNDIsSEFMRl9GTE9BVDo1MTMxLFJHOjMzMzE5LFJHX0lOVEVHRVI6MzMzMjAsSU5UXzJfMTBfMTBfMTBfUkVWOjM2MjU1LENVUlJFTlRfUVVFUlk6MzQ5MTcsUVVFUllfUkVTVUxUOjM0OTE4LFFVRVJZX1JFU1VMVF9BVkFJTEFCTEU6MzQ5MTksQU5ZX1NBTVBMRVNfUEFTU0VEOjM1ODg3LEFOWV9TQU1QTEVTX1BBU1NFRF9DT05TRVJWQVRJVkU6MzYyMDIsTUFYX0RSQVdfQlVGRkVSUzozNDg1MixEUkFXX0JVRkZFUjA6MzQ4NTMsRFJBV19CVUZGRVIxOjM0ODU0LERSQVdfQlVGRkVSMjozNDg1NSxEUkFXX0JVRkZFUjM6MzQ4NTYsRFJBV19CVUZGRVI0OjM0ODU3LERSQVdfQlVGRkVSNTozNDg1OCxEUkFXX0JVRkZFUjY6MzQ4NTksRFJBV19CVUZGRVI3OjM0ODYwLERSQVdfQlVGRkVSODozNDg2MSxEUkFXX0JVRkZFUjk6MzQ4NjIsRFJBV19CVUZGRVIxMDozNDg2MyxEUkFXX0JVRkZFUjExOjM0ODY0LERSQVdfQlVGRkVSMTI6MzQ4NjUsRFJBV19CVUZGRVIxMzozNDg2NixEUkFXX0JVRkZFUjE0OjM0ODY3LERSQVdfQlVGRkVSMTU6MzQ4NjgsTUFYX0NPTE9SX0FUVEFDSE1FTlRTOjM2MDYzLENPTE9SX0FUVEFDSE1FTlQxOjM2MDY1LENPTE9SX0FUVEFDSE1FTlQyOjM2MDY2LENPTE9SX0FUVEFDSE1FTlQzOjM2MDY3LENPTE9SX0FUVEFDSE1FTlQ0OjM2MDY4LENPTE9SX0FUVEFDSE1FTlQ1OjM2MDY5LENPTE9SX0FUVEFDSE1FTlQ2OjM2MDcwLENPTE9SX0FUVEFDSE1FTlQ3OjM2MDcxLENPTE9SX0FUVEFDSE1FTlQ4OjM2MDcyLENPTE9SX0FUVEFDSE1FTlQ5OjM2MDczLENPTE9SX0FUVEFDSE1FTlQxMDozNjA3NCxDT0xPUl9BVFRBQ0hNRU5UMTE6MzYwNzUsQ09MT1JfQVRUQUNITUVOVDEyOjM2MDc2LENPTE9SX0FUVEFDSE1FTlQxMzozNjA3NyxDT0xPUl9BVFRBQ0hNRU5UMTQ6MzYwNzgsQ09MT1JfQVRUQUNITUVOVDE1OjM2MDc5LFNBTVBMRVJfM0Q6MzU2NzksU0FNUExFUl8yRF9TSEFET1c6MzU2ODIsU0FNUExFUl8yRF9BUlJBWTozNjI4OSxTQU1QTEVSXzJEX0FSUkFZX1NIQURPVzozNjI5MixTQU1QTEVSX0NVQkVfU0hBRE9XOjM2MjkzLElOVF9TQU1QTEVSXzJEOjM2Mjk4LElOVF9TQU1QTEVSXzNEOjM2Mjk5LElOVF9TQU1QTEVSX0NVQkU6MzYzMDAsSU5UX1NBTVBMRVJfMkRfQVJSQVk6MzYzMDMsVU5TSUdORURfSU5UX1NBTVBMRVJfMkQ6MzYzMDYsVU5TSUdORURfSU5UX1NBTVBMRVJfM0Q6MzYzMDcsVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRTozNjMwOCxVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWTozNjMxMSxNQVhfU0FNUExFUzozNjE4MyxTQU1QTEVSX0JJTkRJTkc6MzUwOTcsUElYRUxfUEFDS19CVUZGRVI6MzUwNTEsUElYRUxfVU5QQUNLX0JVRkZFUjozNTA1MixQSVhFTF9QQUNLX0JVRkZFUl9CSU5ESU5HOjM1MDUzLFBJWEVMX1VOUEFDS19CVUZGRVJfQklORElORzozNTA1NSxDT1BZX1JFQURfQlVGRkVSOjM2NjYyLENPUFlfV1JJVEVfQlVGRkVSOjM2NjYzLENPUFlfUkVBRF9CVUZGRVJfQklORElORzozNjY2MixDT1BZX1dSSVRFX0JVRkZFUl9CSU5ESU5HOjM2NjYzLEZMT0FUX01BVDJ4MzozNTY4NSxGTE9BVF9NQVQyeDQ6MzU2ODYsRkxPQVRfTUFUM3gyOjM1Njg3LEZMT0FUX01BVDN4NDozNTY4OCxGTE9BVF9NQVQ0eDI6MzU2ODksRkxPQVRfTUFUNHgzOjM1NjkwLFVOU0lHTkVEX0lOVF9WRUMyOjM2Mjk0LFVOU0lHTkVEX0lOVF9WRUMzOjM2Mjk1LFVOU0lHTkVEX0lOVF9WRUM0OjM2Mjk2LFVOU0lHTkVEX05PUk1BTElaRUQ6MzU4NjMsU0lHTkVEX05PUk1BTElaRUQ6MzY3NjQsVkVSVEVYX0FUVFJJQl9BUlJBWV9JTlRFR0VSOjM1MDY5LFZFUlRFWF9BVFRSSUJfQVJSQVlfRElWSVNPUjozNTA3MCxUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSX01PREU6MzU5NjcsTUFYX1RSQU5TRk9STV9GRUVEQkFDS19TRVBBUkFURV9DT01QT05FTlRTOjM1OTY4LFRSQU5TRk9STV9GRUVEQkFDS19WQVJZSU5HUzozNTk3MSxUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSX1NUQVJUOjM1OTcyLFRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfU0laRTozNTk3MyxUUkFOU0ZPUk1fRkVFREJBQ0tfUFJJTUlUSVZFU19XUklUVEVOOjM1OTc2LE1BWF9UUkFOU0ZPUk1fRkVFREJBQ0tfSU5URVJMRUFWRURfQ09NUE9ORU5UUzozNTk3OCxNQVhfVFJBTlNGT1JNX0ZFRURCQUNLX1NFUEFSQVRFX0FUVFJJQlM6MzU5NzksSU5URVJMRUFWRURfQVRUUklCUzozNTk4MCxTRVBBUkFURV9BVFRSSUJTOjM1OTgxLFRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVI6MzU5ODIsVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUl9CSU5ESU5HOjM1OTgzLFRSQU5TRk9STV9GRUVEQkFDSzozNjM4NixUUkFOU0ZPUk1fRkVFREJBQ0tfUEFVU0VEOjM2Mzg3LFRSQU5TRk9STV9GRUVEQkFDS19BQ1RJVkU6MzYzODgsVFJBTlNGT1JNX0ZFRURCQUNLX0JJTkRJTkc6MzYzODksRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9DT0xPUl9FTkNPRElORzozMzI5NixGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTVBPTkVOVF9UWVBFOjMzMjk3LEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfUkVEX1NJWkU6MzMyOTgsRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9HUkVFTl9TSVpFOjMzMjk5LEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQkxVRV9TSVpFOjMzMzAwLEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQUxQSEFfU0laRTozMzMwMSxGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0RFUFRIX1NJWkU6MzMzMDIsRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9TVEVOQ0lMX1NJWkU6MzMzMDMsRlJBTUVCVUZGRVJfREVGQVVMVDozMzMwNCxERVBUSDI0X1NURU5DSUw4OjM1MDU2LERSQVdfRlJBTUVCVUZGRVJfQklORElORzozNjAwNixSRUFEX0ZSQU1FQlVGRkVSX0JJTkRJTkc6MzYwMTAsUkVOREVSQlVGRkVSX1NBTVBMRVM6MzYwMTEsRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xBWUVSOjM2MDUyLEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTVVMVElTQU1QTEU6MzYxODIsVU5JRk9STV9CVUZGRVI6MzUzNDUsVU5JRk9STV9CVUZGRVJfQklORElORzozNTM2OCxVTklGT1JNX0JVRkZFUl9TVEFSVDozNTM2OSxVTklGT1JNX0JVRkZFUl9TSVpFOjM1MzcwLE1BWF9WRVJURVhfVU5JRk9STV9CTE9DS1M6MzUzNzEsTUFYX0ZSQUdNRU5UX1VOSUZPUk1fQkxPQ0tTOjM1MzczLE1BWF9DT01CSU5FRF9VTklGT1JNX0JMT0NLUzozNTM3NCxNQVhfVU5JRk9STV9CVUZGRVJfQklORElOR1M6MzUzNzUsTUFYX1VOSUZPUk1fQkxPQ0tfU0laRTozNTM3NixNQVhfQ09NQklORURfVkVSVEVYX1VOSUZPUk1fQ09NUE9ORU5UUzozNTM3NyxNQVhfQ09NQklORURfRlJBR01FTlRfVU5JRk9STV9DT01QT05FTlRTOjM1Mzc5LFVOSUZPUk1fQlVGRkVSX09GRlNFVF9BTElHTk1FTlQ6MzUzODAsQUNUSVZFX1VOSUZPUk1fQkxPQ0tTOjM1MzgyLFVOSUZPUk1fVFlQRTozNTM4MyxVTklGT1JNX1NJWkU6MzUzODQsVU5JRk9STV9CTE9DS19JTkRFWDozNTM4NixVTklGT1JNX09GRlNFVDozNTM4NyxVTklGT1JNX0FSUkFZX1NUUklERTozNTM4OCxVTklGT1JNX01BVFJJWF9TVFJJREU6MzUzODksVU5JRk9STV9JU19ST1dfTUFKT1I6MzUzOTAsVU5JRk9STV9CTE9DS19CSU5ESU5HOjM1MzkxLFVOSUZPUk1fQkxPQ0tfREFUQV9TSVpFOjM1MzkyLFVOSUZPUk1fQkxPQ0tfQUNUSVZFX1VOSUZPUk1TOjM1Mzk0LFVOSUZPUk1fQkxPQ0tfQUNUSVZFX1VOSUZPUk1fSU5ESUNFUzozNTM5NSxVTklGT1JNX0JMT0NLX1JFRkVSRU5DRURfQllfVkVSVEVYX1NIQURFUjozNTM5NixVTklGT1JNX0JMT0NLX1JFRkVSRU5DRURfQllfRlJBR01FTlRfU0hBREVSOjM1Mzk4LE9CSkVDVF9UWVBFOjM3MTM4LFNZTkNfQ09ORElUSU9OOjM3MTM5LFNZTkNfU1RBVFVTOjM3MTQwLFNZTkNfRkxBR1M6MzcxNDEsU1lOQ19GRU5DRTozNzE0MixTWU5DX0dQVV9DT01NQU5EU19DT01QTEVURTozNzE0MyxVTlNJR05BTEVEOjM3MTQ0LFNJR05BTEVEOjM3MTQ1LEFMUkVBRFlfU0lHTkFMRUQ6MzcxNDYsVElNRU9VVF9FWFBJUkVEOjM3MTQ3LENPTkRJVElPTl9TQVRJU0ZJRUQ6MzcxNDgsV0FJVF9GQUlMRUQ6MzcxNDksU1lOQ19GTFVTSF9DT01NQU5EU19CSVQ6MSxDT0xPUjo2MTQ0LERFUFRIOjYxNDUsU1RFTkNJTDo2MTQ2LE1JTjozMjc3NSxNQVg6MzI3NzYsREVQVEhfQ09NUE9ORU5UMjQ6MzMxOTAsU1RSRUFNX1JFQUQ6MzUwNDEsU1RSRUFNX0NPUFk6MzUwNDIsU1RBVElDX1JFQUQ6MzUwNDUsU1RBVElDX0NPUFk6MzUwNDYsRFlOQU1JQ19SRUFEOjM1MDQ5LERZTkFNSUNfQ09QWTozNTA1MCxERVBUSF9DT01QT05FTlQzMkY6MzYwMTIsREVQVEgzMkZfU1RFTkNJTDg6MzYwMTMsSU5WQUxJRF9JTkRFWDo0Mjk0OTY3Mjk1LFRJTUVPVVRfSUdOT1JFRDotMSxNQVhfQ0xJRU5UX1dBSVRfVElNRU9VVF9XRUJHTDozNzQ0NyxWRVJURVhfQVRUUklCX0FSUkFZX0RJVklTT1JfQU5HTEU6MzUwNzAsVU5NQVNLRURfVkVORE9SX1dFQkdMOjM3NDQ1LFVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMOjM3NDQ2LE1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVDozNDA0NyxURVhUVVJFX01BWF9BTklTT1RST1BZX0VYVDozNDA0NixDT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUOjMzNzc2LENPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUOjMzNzc3LENPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUOjMzNzc4LENPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUOjMzNzc5LENPTVBSRVNTRURfUjExX0VBQzozNzQ4OCxDT01QUkVTU0VEX1NJR05FRF9SMTFfRUFDOjM3NDg5LENPTVBSRVNTRURfUkcxMV9FQUM6Mzc0OTAsQ09NUFJFU1NFRF9TSUdORURfUkcxMV9FQUM6Mzc0OTEsQ09NUFJFU1NFRF9SR0I4X0VUQzI6Mzc0OTIsQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQzozNzQ5MyxDT01QUkVTU0VEX1NSR0I4X0VUQzI6Mzc0OTQsQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfRVRDMl9FQUM6Mzc0OTUsQ09NUFJFU1NFRF9SR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMjozNzQ5NixDT01QUkVTU0VEX1NSR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMjozNzQ5NyxDT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HOjM1ODQwLENPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HOjM1ODQyLENPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc6MzU4NDEsQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc6MzU4NDMsQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTDozNjE5NixDT01QUkVTU0VEX1JHQl9BVENfV0VCR0w6MzU5ODYsQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTDozNTk4NixDT01QUkVTU0VEX1JHQkFfQVRDX0lOVEVSUE9MQVRFRF9BTFBIQV9XRUJHTDozNDc5OCxVTlNJR05FRF9JTlRfMjRfOF9XRUJHTDozNDA0MixIQUxGX0ZMT0FUX09FUzozNjE5MyxSR0JBMzJGX0VYVDozNDgzNixSR0IzMkZfRVhUOjM0ODM3LEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQ09NUE9ORU5UX1RZUEVfRVhUOjMzMjk3LFVOU0lHTkVEX05PUk1BTElaRURfRVhUOjM1ODYzLE1JTl9FWFQ6MzI3NzUsTUFYX0VYVDozMjc3NixTUkdCX0VYVDozNTkwNCxTUkdCX0FMUEhBX0VYVDozNTkwNixTUkdCOF9BTFBIQThfRVhUOjM1OTA3LEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQ09MT1JfRU5DT0RJTkdfRVhUOjMzMjk2LEZSQUdNRU5UX1NIQURFUl9ERVJJVkFUSVZFX0hJTlRfT0VTOjM1NzIzLENPTE9SX0FUVEFDSE1FTlQwX1dFQkdMOjM2MDY0LENPTE9SX0FUVEFDSE1FTlQxX1dFQkdMOjM2MDY1LENPTE9SX0FUVEFDSE1FTlQyX1dFQkdMOjM2MDY2LENPTE9SX0FUVEFDSE1FTlQzX1dFQkdMOjM2MDY3LENPTE9SX0FUVEFDSE1FTlQ0X1dFQkdMOjM2MDY4LENPTE9SX0FUVEFDSE1FTlQ1X1dFQkdMOjM2MDY5LENPTE9SX0FUVEFDSE1FTlQ2X1dFQkdMOjM2MDcwLENPTE9SX0FUVEFDSE1FTlQ3X1dFQkdMOjM2MDcxLENPTE9SX0FUVEFDSE1FTlQ4X1dFQkdMOjM2MDcyLENPTE9SX0FUVEFDSE1FTlQ5X1dFQkdMOjM2MDczLENPTE9SX0FUVEFDSE1FTlQxMF9XRUJHTDozNjA3NCxDT0xPUl9BVFRBQ0hNRU5UMTFfV0VCR0w6MzYwNzUsQ09MT1JfQVRUQUNITUVOVDEyX1dFQkdMOjM2MDc2LENPTE9SX0FUVEFDSE1FTlQxM19XRUJHTDozNjA3NyxDT0xPUl9BVFRBQ0hNRU5UMTRfV0VCR0w6MzYwNzgsQ09MT1JfQVRUQUNITUVOVDE1X1dFQkdMOjM2MDc5LERSQVdfQlVGRkVSMF9XRUJHTDozNDg1MyxEUkFXX0JVRkZFUjFfV0VCR0w6MzQ4NTQsRFJBV19CVUZGRVIyX1dFQkdMOjM0ODU1LERSQVdfQlVGRkVSM19XRUJHTDozNDg1NixEUkFXX0JVRkZFUjRfV0VCR0w6MzQ4NTcsRFJBV19CVUZGRVI1X1dFQkdMOjM0ODU4LERSQVdfQlVGRkVSNl9XRUJHTDozNDg1OSxEUkFXX0JVRkZFUjdfV0VCR0w6MzQ4NjAsRFJBV19CVUZGRVI4X1dFQkdMOjM0ODYxLERSQVdfQlVGRkVSOV9XRUJHTDozNDg2MixEUkFXX0JVRkZFUjEwX1dFQkdMOjM0ODYzLERSQVdfQlVGRkVSMTFfV0VCR0w6MzQ4NjQsRFJBV19CVUZGRVIxMl9XRUJHTDozNDg2NSxEUkFXX0JVRkZFUjEzX1dFQkdMOjM0ODY2LERSQVdfQlVGRkVSMTRfV0VCR0w6MzQ4NjcsRFJBV19CVUZGRVIxNV9XRUJHTDozNDg2OCxNQVhfQ09MT1JfQVRUQUNITUVOVFNfV0VCR0w6MzYwNjMsTUFYX0RSQVdfQlVGRkVSU19XRUJHTDozNDg1MixWRVJURVhfQVJSQVlfQklORElOR19PRVM6MzQyMjksUVVFUllfQ09VTlRFUl9CSVRTX0VYVDozNDkxNixDVVJSRU5UX1FVRVJZX0VYVDozNDkxNyxRVUVSWV9SRVNVTFRfRVhUOjM0OTE4LFFVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUOjM0OTE5LFRJTUVfRUxBUFNFRF9FWFQ6MzUwMDcsVElNRVNUQU1QX0VYVDozNjM5MixHUFVfRElTSk9JTlRfRVhUOjM2Nzk1fTt2YXIgVTA9e1tTLlRFWFRVUkVfTUlOX0ZJTFRFUl06Uy5ORUFSRVNULFtTLlRFWFRVUkVfTUFHX0ZJTFRFUl06Uy5ORUFSRVNULFtTLlRFWFRVUkVfV1JBUF9TXTpTLkNMQU1QX1RPX0VER0UsW1MuVEVYVFVSRV9XUkFQX1RdOlMuQ0xBTVBfVE9fRURHRX07ZnVuY3Rpb24gR0UoRSx7dGlsZVNpemU6Xyx0aWxlSTpSLHRpbGVKOlQsbnVtQ2VsbHM6TixudW1HZW5lczp4LGNlbGxPcmRlcmluZzpPLGNlbGxzOkN9KXtsZXQgZT1uZXcgVWludDhBcnJheShfKl8pLEwsTSxJLEIsRixVPSgwLFguZGVmYXVsdCkoXyk7cmV0dXJuIFUuZm9yRWFjaChEPT57ST1UKl8rRCxJPE4mJihGPUMuaW5kZXhPZihPW0ldKSxGPj0tMSYmVS5mb3JFYWNoKHQ9PntCPVIqXyt0LE09RVtGKngrQl0sTD0oXy10LTEpKl8rRCxlW0xdPU19KSl9KSxlfWZ1bmN0aW9uIHJFKEUse3RpbGVTaXplOl8sdGlsZUk6Uix0aWxlSjpULG51bUNlbGxzOk4sbnVtR2VuZXM6eCxjZWxsT3JkZXJpbmc6TyxjZWxsczpDfSl7bGV0IGU9bmV3IFVpbnQ4QXJyYXkoXypfKSxMLE0sSSxCLEYsVT0oMCxYLmRlZmF1bHQpKF8pO3JldHVybiBVLmZvckVhY2goRD0+e0k9UipfK0QsSTxOJiYoRj1DLmluZGV4T2YoT1tJXSksRj49LTEmJlUuZm9yRWFjaCh0PT57Qj1UKl8rdCxCPHg/TT1FW0YqeCtCXTpNPTAsTD0oXy1ELTEpKl8rdCxlW0xdPU19KSl9KSxlfWZ1bmN0aW9uIFpfKHtjdXJyOkUsdGlsZUk6Xyx0aWxlSjpSLHRpbGVTaXplOlQsY2VsbE9yZGVyaW5nOk4scm93czp4LGNvbHM6TyxkYXRhOkMsdHJhbnNwb3NlOmV9KXtsZXQgTD1uZXcgVWludDhBcnJheShDKSxNPU8ubGVuZ3RoLEk9Ti5sZW5ndGg7cmV0dXJuW3t0aWxlOihlP0dFOnJFKShMLHt0aWxlU2l6ZTpULHRpbGVJOl8sdGlsZUo6UixudW1DZWxsczpJLG51bUdlbmVzOk0sY2VsbE9yZGVyaW5nOk4sY2VsbHM6eH0pLGJ1ZmZlcjpDLGN1cnI6RX0sW0NdXX1pZih0eXBlb2Ygc2VsZiE9InVuZGVmaW5lZCIpe2xldCBFPXtnZXRUaWxlOlpffTtzZWxmLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLF89Pnt0cnl7bGV0W1IsVF09Xy5kYXRhLFtOLHhdPUVbUl0oVCk7c2VsZi5wb3N0TWVzc2FnZShOLHgpfWNhdGNoKFIpe2NvbnNvbGUud2FybihSKX19KX19KSgpOwo=";
var blob2 = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs2)], { type: "text/javascript;charset=utf-8" });
function heatmap_default() {
  const objURL = blob2 && (window.URL || window.webkitURL).createObjectURL(blob2);
  try {
    return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs2, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}

// src/Pool.js
var defaultPoolSize2 = typeof navigator !== "undefined" ? navigator.hardwareConcurrency || 4 : null;
var Pool2 = class {
  constructor(Worker2) {
    this.workers = [];
    this.idleWorkers = [];
    this.waitQueue = [];
    this.decoder = null;
    for (let i = 0; i < defaultPoolSize2; ++i) {
      const w = new Worker2();
      this.workers.push(w);
      this.idleWorkers.push(w);
    }
  }
  process() {
    return __async(this, null, function* () {
      throw new Error('Pool needs to implement "process" method');
    });
  }
  waitForWorker() {
    return __async(this, null, function* () {
      const idleWorker = this.idleWorkers.pop();
      if (idleWorker) {
        return idleWorker;
      }
      const waiter = {};
      const promise = new Promise((resolve) => {
        waiter.resolve = resolve;
      });
      this.waitQueue.push(waiter);
      return promise;
    });
  }
  finishTask(currentWorker) {
    return __async(this, null, function* () {
      const waiter = this.waitQueue.pop();
      if (waiter) {
        waiter.resolve(currentWorker);
      } else {
        this.idleWorkers.push(currentWorker);
      }
    });
  }
  destroy() {
    for (let i = 0; i < this.workers.length; ++i) {
      this.workers[i].terminate();
    }
  }
};

// src/components/heatmap/HeatmapWorkerPool.js
var HeatmapPool = class extends Pool2 {
  constructor() {
    super(heatmap_default);
  }
  process(args) {
    return __async(this, null, function* () {
      const currentWorker = yield this.waitForWorker();
      return new Promise((resolve, reject) => {
        currentWorker.onmessage = (event) => {
          this.finishTask(currentWorker);
          resolve(event.data);
        };
        currentWorker.onerror = (error) => {
          this.finishTask(currentWorker);
          reject(error);
        };
        currentWorker.postMessage(["getTile", args], [args.data]);
      });
    });
  }
};

// src/components/heatmap/Heatmap.js
var Heatmap = forwardRef((props, deckRef) => {
  const {
    uuid,
    theme,
    viewState: rawViewState,
    setViewState,
    width: viewWidth,
    height: viewHeight,
    expressionMatrix: expression,
    cellColors,
    colormap,
    colormapRange,
    clearPleaseWait,
    setComponentHover,
    setCellHighlight = createDefaultUpdateCellsHover("Heatmap"),
    setGeneHighlight = createDefaultUpdateGenesHover("Heatmap"),
    updateViewInfo = createDefaultUpdateViewInfo("Heatmap"),
    setIsRendering = () => {
    },
    transpose = false,
    variablesTitle = "Genes",
    observationsTitle = "Cells"
  } = props;
  const viewState = __spreadProps(__spreadValues({}, rawViewState), {
    target: transpose ? [rawViewState.target[1], rawViewState.target[0]] : rawViewState.target,
    minZoom: 0
  });
  const axisLeftTitle = transpose ? variablesTitle : observationsTitle;
  const axisTopTitle = transpose ? observationsTitle : variablesTitle;
  const workerPool = useMemo4(() => new HeatmapPool(), []);
  useEffect3(() => {
    if (clearPleaseWait && expression) {
      clearPleaseWait("expression-matrix");
    }
  }, [clearPleaseWait, expression]);
  const tilesRef = useRef4();
  const dataRef = useRef4();
  const [axisLeftLabels, setAxisLeftLabels] = useState5([]);
  const [axisTopLabels, setAxisTopLabels] = useState5([]);
  const [tileIteration, incTileIteration] = useReducer((i) => i + 1, 0);
  const [backlog, setBacklog] = useState5([]);
  useEffect3(() => {
    if (expression && expression.matrix) {
      dataRef.current = copyUint8Array(expression.matrix);
    }
  }, [dataRef, expression]);
  useEffect3(() => {
    if (!expression) {
      return;
    }
    const newCellOrdering = !cellColors || cellColors.size === 0 ? expression.rows : Array.from(cellColors.keys());
    const oldCellOrdering = transpose ? axisTopLabels : axisLeftLabels;
    if (!isEqual3(oldCellOrdering, newCellOrdering)) {
      if (transpose) {
        setAxisTopLabels(newCellOrdering);
      } else {
        setAxisLeftLabels(newCellOrdering);
      }
    }
  }, [expression, cellColors, axisTopLabels, axisLeftLabels, transpose]);
  useEffect3(() => {
    if (!expression) {
      return;
    }
    if (transpose) {
      setAxisLeftLabels(expression.cols);
    } else {
      setAxisTopLabels(expression.cols);
    }
  }, [expression, transpose]);
  const [cellLabelMaxLength, geneLabelMaxLength] = useMemo4(() => {
    if (!expression) {
      return [0, 0];
    }
    return [
      max(expression.rows.map((cellId) => cellId.length)),
      max(expression.cols.map((geneId) => geneId.length))
    ];
  }, [expression]);
  const width = axisTopLabels.length;
  const height = axisLeftLabels.length;
  const [axisOffsetLeft, axisOffsetTop] = getAxisSizes(transpose, geneLabelMaxLength, cellLabelMaxLength);
  const offsetTop = axisOffsetTop + COLOR_BAR_SIZE;
  const offsetLeft = axisOffsetLeft + COLOR_BAR_SIZE;
  const matrixWidth = viewWidth - offsetLeft;
  const matrixHeight = viewHeight - offsetTop;
  const matrixLeft = -matrixWidth / 2;
  const matrixRight = matrixWidth / 2;
  const matrixTop = -matrixHeight / 2;
  const matrixBottom = matrixHeight / 2;
  const xTiles = Math.ceil(width / TILE_SIZE);
  const yTiles = Math.ceil(height / TILE_SIZE);
  const widthRatio = 1 - (TILE_SIZE - width % TILE_SIZE) / (xTiles * TILE_SIZE);
  const heightRatio = 1 - (TILE_SIZE - height % TILE_SIZE) / (yTiles * TILE_SIZE);
  const tileWidth = matrixWidth / widthRatio / xTiles;
  const tileHeight = matrixHeight / heightRatio / yTiles;
  const scaleFactor = __pow(2, viewState.zoom);
  const cellHeight = matrixHeight * scaleFactor / height;
  const cellWidth = matrixWidth * scaleFactor / width;
  const aggSizeX = clamp2(__pow(2, Math.ceil(Math.log2(1 / cellWidth))), MIN_ROW_AGG, MAX_ROW_AGG);
  const aggSizeY = clamp2(__pow(2, Math.ceil(Math.log2(1 / cellHeight))), MIN_ROW_AGG, MAX_ROW_AGG);
  const [targetX, targetY] = viewState.target;
  useEffect3(() => {
    updateViewInfo({
      uuid,
      project: (cellId, geneId) => {
        const colI = transpose ? axisTopLabels.indexOf(cellId) : axisTopLabels.indexOf(geneId);
        const rowI = transpose ? axisLeftLabels.indexOf(geneId) : axisLeftLabels.indexOf(cellId);
        return heatmapToMousePosition(colI, rowI, {
          offsetLeft,
          offsetTop,
          targetX: viewState.target[0],
          targetY: viewState.target[1],
          scaleFactor,
          matrixWidth,
          matrixHeight,
          numRows: height,
          numCols: width
        });
      }
    });
  }, [
    uuid,
    updateViewInfo,
    transpose,
    axisTopLabels,
    axisLeftLabels,
    offsetLeft,
    offsetTop,
    viewState,
    scaleFactor,
    matrixWidth,
    matrixHeight,
    height,
    width
  ]);
  const onViewStateChange = useCallback3(({ viewState: nextViewState }) => {
    const { zoom: nextZoom } = nextViewState;
    const nextScaleFactor = __pow(2, nextZoom);
    const minTargetX = nextZoom === 0 ? 0 : -(matrixRight - matrixRight / nextScaleFactor);
    const maxTargetX = -1 * minTargetX;
    const minTargetY = nextZoom === 0 ? 0 : -(matrixBottom - matrixBottom / nextScaleFactor);
    const maxTargetY = -1 * minTargetY;
    const nextTarget = [
      clamp2(nextViewState.target[0], minTargetX, maxTargetX),
      clamp2(nextViewState.target[1], minTargetY, maxTargetY)
    ];
    setViewState({
      zoom: nextZoom,
      target: transpose ? [nextTarget[1], nextTarget[0]] : nextTarget
    });
  }, [matrixRight, matrixBottom, transpose, setViewState]);
  useEffect3(() => {
    if (!expression) {
      return;
    }
    if (axisTopLabels && axisLeftLabels && xTiles && yTiles) {
      setBacklog((prev) => [...prev, uuidv42()]);
    }
  }, [dataRef, expression, axisTopLabels, axisLeftLabels, xTiles, yTiles]);
  useEffect3(() => {
    if (backlog.length < 1) {
      return;
    }
    const curr = backlog[backlog.length - 1];
    if (dataRef.current && dataRef.current.buffer.byteLength) {
      const { rows, cols, matrix } = expression;
      const promises = range5(yTiles).map((i) => range5(xTiles).map((j) => __async(void 0, null, function* () {
        return workerPool.process({
          curr,
          tileI: i,
          tileJ: j,
          tileSize: TILE_SIZE,
          cellOrdering: transpose ? axisTopLabels : axisLeftLabels,
          rows,
          cols,
          transpose,
          data: matrix.buffer.slice()
        });
      })));
      const process2 = () => __async(void 0, null, function* () {
        const tiles = yield Promise.all(promises.flat());
        tilesRef.current = tiles.map((i) => i.tile);
        incTileIteration();
        dataRef.current = new Uint8Array(tiles[0].buffer);
        const { curr: currWork } = tiles[0];
        setBacklog((prev) => {
          const currIndex = prev.indexOf(currWork);
          return prev.slice(currIndex + 1, prev.length);
        });
      });
      process2();
    }
  }, [axisLeftLabels, axisTopLabels, backlog, expression, transpose, xTiles, yTiles, workerPool]);
  useEffect3(() => {
    setIsRendering(backlog.length > 0);
  }, [backlog, setIsRendering]);
  const heatmapLayers = useMemo4(() => {
    if (!tilesRef.current || backlog.length) {
      return [];
    }
    function getLayer(i, j, tile) {
      return new HeatmapBitmapLayer({
        id: `heatmapLayer-${tileIteration}-${i}-${j}`,
        image: tile,
        bounds: [
          matrixLeft + j * tileWidth,
          matrixTop + i * tileHeight,
          matrixLeft + (j + 1) * tileWidth,
          matrixTop + (i + 1) * tileHeight
        ],
        aggSizeX,
        aggSizeY,
        colormap,
        colorScaleLo: colormapRange[0],
        colorScaleHi: colormapRange[1],
        updateTriggers: {
          image: [axisLeftLabels, axisTopLabels],
          bounds: [tileHeight, tileWidth]
        }
      });
    }
    const layers2 = tilesRef.current.map((tile, index) => getLayer(Math.floor(index / xTiles), index % xTiles, tile));
    return layers2;
  }, [
    backlog,
    tileIteration,
    matrixLeft,
    tileWidth,
    matrixTop,
    tileHeight,
    aggSizeX,
    aggSizeY,
    colormap,
    colormapRange,
    axisLeftLabels,
    axisTopLabels,
    xTiles
  ]);
  const axisTopLabelData = useMemo4(() => axisTopLabels.map((d, i) => [i, d]), [axisTopLabels]);
  const axisLeftLabelData = useMemo4(() => axisLeftLabels.map((d, i) => [i, d]), [axisLeftLabels]);
  const textLayers = [
    new HeatmapCompositeTextLayer({
      targetX,
      targetY,
      scaleFactor,
      axisLeftLabelData,
      matrixTop,
      height,
      matrixHeight,
      cellHeight,
      cellWidth,
      axisTopLabelData,
      matrixLeft,
      width,
      matrixWidth,
      viewHeight,
      viewWidth,
      theme,
      axisLeftTitle,
      axisTopTitle,
      axisOffsetLeft,
      axisOffsetTop
    })
  ];
  const cellColorsTiles = useMemo4(() => {
    if (!cellColors) {
      return null;
    }
    let cellId;
    let offset;
    let color;
    let rowI;
    const cellOrdering = transpose ? axisTopLabels : axisLeftLabels;
    const colorBarTileWidthPx = transpose ? TILE_SIZE : 1;
    const colorBarTileHeightPx = transpose ? 1 : TILE_SIZE;
    const result = range5(transpose ? xTiles : yTiles).map((i) => {
      const tileData = new Uint8ClampedArray(TILE_SIZE * 1 * 4);
      range5(TILE_SIZE).forEach((tileY) => {
        rowI = i * TILE_SIZE + tileY;
        if (rowI < cellOrdering.length) {
          cellId = cellOrdering[rowI];
          color = cellColors.get(cellId);
          offset = (transpose ? tileY : TILE_SIZE - tileY - 1) * 4;
          if (color) {
            const [rValue, gValue, bValue] = color;
            tileData[offset + 0] = rValue;
            tileData[offset + 1] = gValue;
            tileData[offset + 2] = bValue;
            tileData[offset + 3] = 255;
          }
        }
      });
      return new ImageData(tileData, colorBarTileWidthPx, colorBarTileHeightPx);
    });
    return result;
  }, [cellColors, transpose, axisTopLabels, axisLeftLabels, xTiles, yTiles]);
  const cellColorsLayers = useMemo4(() => cellColorsTiles ? cellColorsTiles.map((tile, i) => new PixelatedBitmapLayer({
    id: `${transpose ? "colorsTopLayer" : "colorsLeftLayer"}-${i}-${uuidv42()}`,
    image: tile,
    bounds: transpose ? [
      matrixLeft + i * tileWidth,
      -matrixHeight / 2,
      matrixLeft + (i + 1) * tileWidth,
      matrixHeight / 2
    ] : [
      -matrixWidth / 2,
      matrixTop + i * tileHeight,
      matrixWidth / 2,
      matrixTop + (i + 1) * tileHeight
    ]
  })) : [], [
    cellColorsTiles,
    matrixTop,
    matrixLeft,
    matrixHeight,
    matrixWidth,
    tileWidth,
    tileHeight,
    transpose
  ]);
  const layers = heatmapLayers.concat(textLayers).concat(cellColorsLayers);
  function onHover(info, event) {
    if (!expression) {
      return;
    }
    const { x: mouseX, y: mouseY } = event.offsetCenter;
    const [colI, rowI] = mouseToHeatmapPosition(mouseX, mouseY, {
      offsetLeft,
      offsetTop,
      targetX,
      targetY,
      scaleFactor,
      matrixWidth,
      matrixHeight,
      numRows: height,
      numCols: width
    });
    if (colI === null) {
      if (transpose) {
        setCellHighlight(null);
      } else {
        setGeneHighlight(null);
      }
    }
    if (rowI === null) {
      if (transpose) {
        setGeneHighlight(null);
      } else {
        setCellHighlight(null);
      }
    }
    const obsI = expression.rows.indexOf(transpose ? axisTopLabels[colI] : axisLeftLabels[rowI]);
    const varI = expression.cols.indexOf(transpose ? axisLeftLabels[rowI] : axisTopLabels[colI]);
    const obsId = expression.rows[obsI];
    const varId = expression.cols[varI];
    if (setComponentHover) {
      setComponentHover();
    }
    setCellHighlight(obsId || null);
    setGeneHighlight(varId || null);
  }
  return /* @__PURE__ */ React6.createElement(DeckGL2, {
    id: `deckgl-overlay-${uuid}`,
    ref: deckRef,
    views: [
      new OrthographicView2({
        id: "heatmap",
        controller: true,
        x: offsetLeft,
        y: offsetTop,
        width: matrixWidth,
        height: matrixHeight
      }),
      new OrthographicView2({
        id: "axisLeft",
        controller: false,
        x: transpose ? COLOR_BAR_SIZE : 0,
        y: offsetTop,
        width: axisOffsetLeft,
        height: matrixHeight
      }),
      new OrthographicView2({
        id: "axisTop",
        controller: false,
        x: offsetLeft,
        y: transpose ? 0 : COLOR_BAR_SIZE,
        width: matrixWidth,
        height: axisOffsetTop
      }),
      new OrthographicView2({
        id: "colorsLeft",
        controller: false,
        x: axisOffsetLeft,
        y: offsetTop,
        width: COLOR_BAR_SIZE - AXIS_MARGIN,
        height: matrixHeight
      }),
      new OrthographicView2({
        id: "colorsTop",
        controller: false,
        x: offsetLeft,
        y: axisOffsetTop,
        width: matrixWidth,
        height: COLOR_BAR_SIZE - AXIS_MARGIN
      })
    ],
    layers,
    layerFilter,
    getCursor: (interactionState) => interactionState.isDragging ? "grabbing" : "default",
    glOptions: DEFAULT_GL_OPTIONS,
    onViewStateChange,
    viewState,
    onHover
  });
});
var Heatmap_default = Heatmap;

// src/components/heatmap/HeatmapTooltipSubscriber.js
import React10 from "react";

// src/components/tooltip/Tooltip2D.js
import React8 from "react";

// src/components/tooltip/Tooltip.js
import React7, { useEffect as useEffect4, useRef as useRef5, useState as useState6 } from "react";
import Paper2 from "@material-ui/core/Paper";
import Popper2 from "@material-ui/core/Popper";

// src/components/tooltip/styles.js
import { makeStyles as makeStyles3 } from "@material-ui/core/styles";
var styles2 = makeStyles3(() => ({
  tooltipAnchor: {
    position: "relative",
    width: "0px",
    height: "0px",
    pointerEvents: "none",
    userSelect: "none"
  },
  tooltipContent: {
    opacity: 0.9,
    padding: "5px",
    pointerEvents: "none",
    "& table > tbody > tr > th, & table > tbody > tr > td": {
      fontSize: "80%",
      opacity: 0.8,
      outline: 0,
      padding: "0 2px"
    },
    "& table": {
      borderCollapse: "collapse"
    }
  }
}));

// src/components/tooltip/Tooltip.js
function Tooltip(props) {
  const {
    x,
    y,
    parentWidth,
    parentHeight,
    children
  } = props;
  const ref = useRef5();
  const classes = styles2();
  const [placementX, setPlacementX] = useState6("start");
  const [placementY, setPlacementY] = useState6("bottom");
  const getTooltipContainer = useVitessceContainer(ref);
  useEffect4(() => {
    if (ref && ref.current) {
      const flipX = x > parentWidth / 2;
      const flipY = y > parentHeight / 2;
      setPlacementX(flipX ? "end" : "start");
      setPlacementY(flipY ? "top" : "bottom");
      ref.current.style.left = `${x + (flipX ? -20 : 5)}px`;
      ref.current.style.top = `${y + (flipY ? -20 : 5)}px`;
    }
  }, [x, y, parentWidth, parentHeight]);
  return /* @__PURE__ */ React7.createElement("div", {
    ref,
    className: classes.tooltipAnchor
  }, ref && ref.current ? /* @__PURE__ */ React7.createElement(Popper2, {
    open: true,
    anchorEl: ref.current,
    container: getTooltipContainer,
    transition: true,
    placement: `${placementY}-${placementX}`
  }, /* @__PURE__ */ React7.createElement(Paper2, {
    elevation: 4,
    className: classes.tooltipContent
  }, children)) : null);
}

// src/components/tooltip/Tooltip2D.js
function Tooltip2D(props) {
  const {
    parentUuid,
    sourceUuid,
    x,
    y,
    parentWidth,
    parentHeight,
    children
  } = props;
  if (x < 0 || x > parentWidth || y < 0 || y > parentHeight) {
    return null;
  }
  const isTooltipVisible = parentUuid === sourceUuid;
  const crosshairWidth = 1;
  return /* @__PURE__ */ React8.createElement(React8.Fragment, null, isTooltipVisible ? /* @__PURE__ */ React8.createElement(Tooltip, {
    x,
    y,
    parentWidth,
    parentHeight
  }, children) : /* @__PURE__ */ React8.createElement(React8.Fragment, null, x !== null ? /* @__PURE__ */ React8.createElement("div", {
    className: "cell-emphasis-crosshair",
    style: {
      left: `${x - crosshairWidth / 2}px`,
      top: 0,
      width: `${crosshairWidth}px`,
      height: `${parentHeight}px`
    }
  }) : null, y !== null ? /* @__PURE__ */ React8.createElement("div", {
    className: "cell-emphasis-crosshair",
    style: {
      left: 0,
      top: `${y - crosshairWidth / 2}px`,
      width: `${parentWidth}px`,
      height: `${crosshairWidth}px`
    }
  }) : null));
}

// src/components/tooltip/TooltipContent.js
import React9 from "react";
function TooltipContent(props) {
  const {
    info
  } = props;
  return /* @__PURE__ */ React9.createElement("table", null, /* @__PURE__ */ React9.createElement("tbody", null, Object.entries(info).map(([key, value]) => /* @__PURE__ */ React9.createElement("tr", {
    key
  }, /* @__PURE__ */ React9.createElement("th", null, key), /* @__PURE__ */ React9.createElement("td", null, value)))));
}

// src/components/heatmap/HeatmapTooltipSubscriber.js
function HeatmapTooltipSubscriber(props) {
  const {
    parentUuid,
    width,
    height,
    transpose,
    getCellInfo,
    getGeneInfo,
    cellHighlight,
    geneHighlight
  } = props;
  const sourceUuid = useComponentHover();
  const viewInfo = useComponentViewInfo(parentUuid);
  const [cellInfo, cellCoord] = cellHighlight && getCellInfo ? [
    getCellInfo(cellHighlight),
    viewInfo && viewInfo.project ? viewInfo.project(cellHighlight, null)[transpose ? 0 : 1] : null
  ] : [null, null];
  const [geneInfo, geneCoord] = geneHighlight && getGeneInfo ? [
    getGeneInfo(geneHighlight),
    viewInfo && viewInfo.project ? viewInfo.project(null, geneHighlight)[transpose ? 1 : 0] : null
  ] : [null, null];
  const x = transpose ? cellCoord : geneCoord;
  const y = transpose ? geneCoord : cellCoord;
  return cellInfo || geneInfo ? /* @__PURE__ */ React10.createElement(Tooltip2D, {
    x,
    y,
    parentUuid,
    parentWidth: width,
    parentHeight: height,
    sourceUuid
  }, /* @__PURE__ */ React10.createElement(TooltipContent, {
    info: __spreadValues(__spreadValues({}, geneInfo), cellInfo)
  })) : null;
}

// src/components/heatmap/HeatmapOptions.js
import React13, { useCallback as useCallback4 } from "react";
import debounce2 from "lodash/debounce";
import Slider from "@material-ui/core/Slider";
import TableCell from "@material-ui/core/TableCell";
import TableRow from "@material-ui/core/TableRow";

// src/components/shared-plot-options/styles.js
import { makeStyles as makeStyles4 } from "@material-ui/core/styles";
var useStyles2 = makeStyles4((theme) => ({
  box: {
    boxSizing: "border-box"
  },
  checkbox: {
    padding: "3px",
    color: theme.palette.primaryForeground,
    "&:checked": {
      color: theme.palette.primaryForeground
    },
    "& input": {
      height: "100%"
    }
  },
  slider: {
    color: theme.palette.primaryForeground,
    minWidth: "60px",
    padding: "10px 0 10px 0"
  },
  sliderValueLabel: {
    "& span": {
      "& span": {
        color: theme.palette.primaryBackground
      }
    }
  },
  tableContainer: {
    overflow: "hidden",
    overflowX: "hidden !important"
  },
  labelCell: {
    padding: "2px 8px 2px 16px"
  },
  inputCell: {
    padding: "2px 16px 2px 8px",
    overflow: "visible"
  },
  select: {
    "& select": {
      fontSize: ".875rem"
    }
  },
  selectRoot: {
    padding: 0,
    height: "auto"
  }
}));

// src/components/shared-plot-options/OptionsContainer.js
import React11 from "react";
import Box from "@material-ui/core/Box";
import Table from "@material-ui/core/Table";
import TableBody from "@material-ui/core/TableBody";
import TableContainer from "@material-ui/core/TableContainer";
function OptionsContainer(props) {
  const {
    children
  } = props;
  const classes = useStyles2();
  return /* @__PURE__ */ React11.createElement(Box, {
    className: classes.box
  }, /* @__PURE__ */ React11.createElement(TableContainer, {
    className: classes.tableContainer
  }, /* @__PURE__ */ React11.createElement(Table, {
    className: classes.table,
    size: "small"
  }, /* @__PURE__ */ React11.createElement(TableBody, null, children))));
}

// src/components/shared-plot-options/OptionSelect.js
import React12 from "react";
import Select from "@material-ui/core/Select";
function OptionSelect(props) {
  const { classes: classesProp = {} } = props;
  const classes = useStyles2();
  return /* @__PURE__ */ React12.createElement(Select, __spreadProps(__spreadValues({
    native: true,
    disableUnderline: true
  }, props), {
    classes: __spreadValues({
      root: classes.selectRoot
    }, classesProp)
  }));
}

// src/components/heatmap/HeatmapOptions.js
function HeatmapOptions(props) {
  const {
    geneExpressionColormap,
    setGeneExpressionColormap,
    geneExpressionColormapRange,
    setGeneExpressionColormapRange
  } = props;
  const classes = useStyles2();
  function handleGeneExpressionColormapChange(event) {
    setGeneExpressionColormap(event.target.value);
  }
  function handleColormapRangeChange(event, value) {
    setGeneExpressionColormapRange(value);
  }
  const handleColormapRangeChangeDebounced = useCallback4(debounce2(handleColormapRangeChange, 5, { trailing: true }), [handleColormapRangeChange]);
  return /* @__PURE__ */ React13.createElement(OptionsContainer, null, /* @__PURE__ */ React13.createElement(TableRow, null, /* @__PURE__ */ React13.createElement(TableCell, {
    className: classes.labelCell,
    htmlFor: "gene-expression-colormap-select"
  }, "Gene Expression Colormap"), /* @__PURE__ */ React13.createElement(TableCell, {
    className: classes.inputCell
  }, /* @__PURE__ */ React13.createElement(OptionSelect, {
    className: classes.select,
    value: geneExpressionColormap,
    onChange: handleGeneExpressionColormapChange,
    inputProps: {
      id: "gene-expression-colormap-select"
    }
  }, GLSL_COLORMAPS.map((cmap) => /* @__PURE__ */ React13.createElement("option", {
    key: cmap,
    value: cmap
  }, cmap))))), /* @__PURE__ */ React13.createElement(TableRow, null, /* @__PURE__ */ React13.createElement(TableCell, {
    className: classes.labelCell
  }, "Gene Expression Colormap Range"), /* @__PURE__ */ React13.createElement(TableCell, {
    className: classes.inputCell
  }, /* @__PURE__ */ React13.createElement(Slider, {
    classes: { root: classes.slider, valueLabel: classes.sliderValueLabel },
    value: geneExpressionColormapRange,
    onChange: handleColormapRangeChangeDebounced,
    "aria-labelledby": "gene-expression-colormap-range-slider",
    valueLabelDisplay: "auto",
    step: 5e-3,
    min: 0,
    max: 1
  }))));
}

// src/components/heatmap/HeatmapSubscriber.js
var HEATMAP_DATA_TYPES = ["cells", "cell-sets", "expression-matrix"];
function HeatmapSubscriber(props) {
  const {
    uuid,
    coordinationScopes,
    removeGridComponent,
    theme,
    transpose,
    observationsLabelOverride: observationsLabel = "cell",
    observationsPluralLabelOverride: observationsPluralLabel = `${observationsLabel}s`,
    variablesLabelOverride: variablesLabel = "gene",
    variablesPluralLabelOverride: variablesPluralLabel = `${variablesLabel}s`,
    disableTooltip = false,
    title: title16 = "Heatmap"
  } = props;
  const loaders = useLoaders();
  const setComponentHover = useSetComponentHover();
  const setComponentViewInfo = useSetComponentViewInfo(uuid);
  const [{
    dataset,
    heatmapZoomX: zoomX,
    heatmapTargetX: targetX,
    heatmapTargetY: targetY,
    geneSelection,
    cellHighlight,
    geneHighlight,
    cellSetSelection,
    cellSetColor,
    additionalCellSets,
    geneExpressionColormap,
    geneExpressionColormapRange
  }, {
    setHeatmapZoomX: setZoomX,
    setHeatmapZoomY: setZoomY,
    setHeatmapTargetX: setTargetX,
    setHeatmapTargetY: setTargetY,
    setCellHighlight,
    setGeneHighlight,
    setCellSetSelection,
    setCellSetColor,
    setGeneExpressionColormapRange,
    setGeneExpressionColormap
  }] = useCoordination(COMPONENT_COORDINATION_TYPES.heatmap, coordinationScopes);
  const observationsTitle = capitalize(observationsPluralLabel);
  const variablesTitle = capitalize(variablesPluralLabel);
  const [isRendering, setIsRendering] = useState7(false);
  const [
    isReady,
    setItemIsReady,
    setItemIsNotReady,
    resetReadyItems
  ] = useReady(HEATMAP_DATA_TYPES);
  const [urls, addUrl, resetUrls] = useUrls();
  const [width, height, deckRef] = useDeckCanvasSize();
  useEffect5(() => {
    resetUrls();
    resetReadyItems();
  }, [loaders, dataset]);
  const [cells] = useCellsData(loaders, dataset, setItemIsReady, addUrl, true);
  const [expressionMatrix] = useExpressionMatrixData(loaders, dataset, setItemIsReady, addUrl, true);
  const [cellSets] = useCellSetsData(loaders, dataset, setItemIsReady, addUrl, false, { setCellSetSelection, setCellSetColor }, { cellSetSelection, cellSetColor });
  const mergedCellSets = useMemo5(() => mergeCellSets(cellSets, additionalCellSets), [cellSets, additionalCellSets]);
  const cellColors = useMemo5(() => getCellColors({
    cellColorEncoding: "cellSetSelection",
    geneSelection,
    cellSets: mergedCellSets,
    cellSetSelection,
    cellSetColor,
    expressionDataAttrs: expressionMatrix,
    theme
  }), [
    mergedCellSets,
    geneSelection,
    theme,
    cellSetColor,
    cellSetSelection,
    expressionMatrix
  ]);
  const getCellInfo = useCallback5((cellId) => {
    if (cellId) {
      const cellInfo = cells[cellId];
      return __spreadValues({
        [`${capitalize(observationsLabel)} ID`]: cellId
      }, cellInfo ? cellInfo.factors : {});
    }
    return null;
  }, [cells, observationsLabel]);
  const getGeneInfo = useCallback5((geneId) => {
    if (geneId) {
      return { [`${capitalize(variablesLabel)} ID`]: geneId };
    }
    return null;
  }, [variablesLabel]);
  const cellsCount = expressionMatrix && expressionMatrix.rows ? expressionMatrix.rows.length : 0;
  const genesCount = expressionMatrix && expressionMatrix.cols ? expressionMatrix.cols.length : 0;
  const selectedCount = cellColors.size;
  return /* @__PURE__ */ React14.createElement(TitleInfo, {
    title: title16,
    info: `${cellsCount} ${pluralize(observationsLabel, observationsPluralLabel, cellsCount)} \xD7 ${genesCount} ${pluralize(variablesLabel, variablesPluralLabel, genesCount)},
             with ${selectedCount} ${pluralize(observationsLabel, observationsPluralLabel, selectedCount)} selected`,
    urls,
    theme,
    removeGridComponent,
    isReady: isReady && !isRendering,
    options: /* @__PURE__ */ React14.createElement(HeatmapOptions, {
      geneExpressionColormap,
      setGeneExpressionColormap,
      geneExpressionColormapRange,
      setGeneExpressionColormapRange
    })
  }, /* @__PURE__ */ React14.createElement(Heatmap_default, {
    ref: deckRef,
    transpose,
    viewState: { zoom: zoomX, target: [targetX, targetY] },
    setViewState: ({ zoom, target }) => {
      setZoomX(zoom);
      setZoomY(zoom);
      setTargetX(target[0]);
      setTargetY(target[1]);
    },
    colormapRange: geneExpressionColormapRange,
    setColormapRange: setGeneExpressionColormapRange,
    height,
    width,
    theme,
    uuid,
    expressionMatrix,
    cellColors,
    colormap: geneExpressionColormap,
    setIsRendering,
    setCellHighlight,
    setGeneHighlight,
    setComponentHover: () => {
      setComponentHover(uuid);
    },
    updateViewInfo: setComponentViewInfo,
    observationsTitle,
    variablesTitle
  }), !disableTooltip && /* @__PURE__ */ React14.createElement(HeatmapTooltipSubscriber, {
    parentUuid: uuid,
    width,
    height,
    transpose,
    getCellInfo,
    getGeneInfo,
    cellHighlight,
    geneHighlight
  }));
}

// src/components/spatial/SpatialSubscriber.js
import React24, { useEffect as useEffect6, useMemo as useMemo6, useCallback as useCallback7 } from "react";

// src/components/spatial/Spatial.js
import React20, { forwardRef as forwardRef2 } from "react";
import isEqual5 from "lodash/isEqual";
import { COORDINATE_SYSTEM as COORDINATE_SYSTEM5 } from "@deck.gl/core";
import { PolygonLayer as PolygonLayer2, ScatterplotLayer as ScatterplotLayer2 } from "@deck.gl/layers";
import { Matrix4 as Matrix44 } from "math.gl";

// src/layers/selection-utils.js
import { COORDINATE_SYSTEM as COORDINATE_SYSTEM4 } from "@deck.gl/core";
import { DataFilterExtension } from "@deck.gl/extensions";

// src/layers/SelectionLayer.js
import { CompositeLayer as CompositeLayer4 } from "deck.gl";
import { polygon as turfPolygon, point as turfPoint2 } from "@turf/helpers";
import booleanWithin from "@turf/boolean-within";
import booleanContains from "@turf/boolean-contains";
import booleanOverlap from "@turf/boolean-overlap";
import booleanPointInPolygon from "@turf/boolean-point-in-polygon";
import { ScatterplotLayer } from "@deck.gl/layers";
import { SELECTION_TYPE } from "nebula.gl";
import { EditableGeoJsonLayer } from "@nebula.gl/layers";
import { DrawRectangleMode, DrawPolygonByDraggingMode, ViewMode } from "@nebula.gl/edit-modes";
var EDIT_TYPE_ADD = "addFeature";
var EDIT_TYPE_CLEAR = "clearFeatures";
var ClickableDrawRectangleMode = class extends DrawRectangleMode {
  handleClick(event, props) {
    props.onEdit({ editType: EDIT_TYPE_CLEAR });
  }
};
var ClickableDrawPolygonByDraggingMode = class extends DrawPolygonByDraggingMode {
  handleClick(event, props) {
    props.onEdit({ editType: EDIT_TYPE_CLEAR });
  }
};
var MODE_MAP = {
  [SELECTION_TYPE.RECTANGLE]: ClickableDrawRectangleMode,
  [SELECTION_TYPE.POLYGON]: ClickableDrawPolygonByDraggingMode
};
var defaultProps4 = {
  selectionType: SELECTION_TYPE.RECTANGLE,
  layerIds: [],
  onSelect: () => {
  }
};
var EMPTY_DATA = {
  type: "FeatureCollection",
  features: []
};
var LAYER_ID_GEOJSON = "selection-geojson";
var PASS_THROUGH_PROPS = [
  "lineWidthScale",
  "lineWidthMinPixels",
  "lineWidthMaxPixels",
  "lineWidthUnits",
  "lineJointRounded",
  "lineMiterLimit",
  "pointRadiusScale",
  "pointRadiusMinPixels",
  "pointRadiusMaxPixels",
  "lineDashJustified",
  "getLineColor",
  "getFillColor",
  "getRadius",
  "getLineWidth",
  "getLineDashArray",
  "getTentativeLineDashArray",
  "getTentativeLineColor",
  "getTentativeFillColor",
  "getTentativeLineWidth",
  "editHandlePointRadiusScale",
  "editHandlePointRadiusMinPixels",
  "editHandlePointRadiusMaxPixels",
  "getEditHandlePointColor",
  "getEditHandlePointRadius",
  "modeHandlers"
];
var SelectionLayer = class extends CompositeLayer4 {
  _selectPolygonObjects(coordinates) {
    const {
      onSelect,
      getCellCoords,
      cellsQuadTree,
      flipY
    } = this.props;
    const flippedCoordinates = flipY ? coordinates.map((poly) => poly.map((p) => [p[0], -p[1]])) : coordinates;
    const selectedPolygon = turfPolygon(flippedCoordinates);
    const pickingInfos = [];
    cellsQuadTree.visit((node, x0, y0, x1, y1) => {
      const nodePoints = [[[x0, y0], [x1, y0], [x1, y1], [x0, y1], [x0, y0]]];
      const nodePolygon = turfPolygon(nodePoints);
      const nodePolygonContainsSelectedPolygon = booleanContains(nodePolygon, selectedPolygon);
      const nodePolygonWithinSelectedPolygon = booleanWithin(nodePolygon, selectedPolygon);
      const nodePolygonOverlapsSelectedPolgyon = booleanOverlap(nodePolygon, selectedPolygon);
      if (!nodePolygonContainsSelectedPolygon && !nodePolygonWithinSelectedPolygon && !nodePolygonOverlapsSelectedPolgyon) {
        return true;
      }
      if (node.data && booleanPointInPolygon(turfPoint([].slice.call(getCellCoords(node.data[1]))), selectedPolygon,)
      ) {
        pickingInfos.push(node.data);
      }
      return false;
    });
    onSelect({ pickingInfos });
  }
  renderLayers() {
    const { onSelect } = this.props;
    const mode = MODE_MAP[this.props.selectionType] || ViewMode;
    const inheritedProps = {};
    PASS_THROUGH_PROPS.forEach((p) => {
      if (this.props[p] !== void 0)
        inheritedProps[p] = this.props[p];
    });
    const layers = [
      new EditableGeoJsonLayer(this.getSubLayerProps(__spreadValues({
        id: LAYER_ID_GEOJSON,
        pickable: true,
        mode,
        modeConfig: {
          dragToDraw: true
        },
        selectedFeatureIndexes: [],
        data: EMPTY_DATA,
        onEdit: ({ updatedData, editType }) => {
          if (editType === EDIT_TYPE_ADD) {
            const { coordinates } = updatedData.features[0].geometry;
            this._selectPolygonObjects(coordinates);
          } else if (editType === EDIT_TYPE_CLEAR) {
            onSelect({ pickingInfos: [] });
          }
        },
        _subLayerProps: {
          guides: {
            pointType: "circle",
            _subLayerProps: {
              "points-circle": {
                type: ScatterplotLayer,
                radiusScale: 1,
                stroked: true,
                getLineWidth: 1,
                radiusMinPixels: 1,
                radiusMaxPixels: 3,
                getRadius: 2
              }
            }
          }
        }
      }, inheritedProps)))
    ];
    return layers;
  }
};
SelectionLayer.layerName = "SelectionLayer";
SelectionLayer.defaultProps = defaultProps4;

// src/layers/selection-utils.js
function getBaseLayerId(layerId) {
  return `base-${layerId}`;
}
function getSelectionLayers(tool, zoom, layerId, getCellCoords, updateCellsSelection, cellsQuadTree, flipY = false) {
  if (!tool) {
    return [];
  }
  const cellBaseLayerId = getBaseLayerId(layerId);
  const editHandlePointRadius = 5 / (zoom + 16);
  return [new SelectionLayer({
    id: "selection",
    flipY,
    cellsQuadTree,
    getCellCoords,
    coordinateSystem: COORDINATE_SYSTEM4.CARTESIAN,
    selectionType: tool,
    onSelect: ({ pickingInfos }) => {
      const cellIds = pickingInfos.map((cellObj) => cellObj[0]);
      if (updateCellsSelection) {
        updateCellsSelection(cellIds);
      }
    },
    layerIds: [cellBaseLayerId],
    getTentativeFillColor: () => [255, 255, 255, 95],
    getTentativeLineColor: () => [143, 143, 143, 255],
    getTentativeLineDashArray: () => [7, 4],
    lineWidthMinPixels: 2,
    lineWidthMaxPixels: 2,
    getEditHandlePointColor: () => [255, 255, 255, 255],
    getEditHandlePointRadius: () => editHandlePointRadius,
    editHandlePointRadiusScale: 1,
    editHandlePointRadiusMinPixels: editHandlePointRadius,
    editHandlePointRadiusMaxPixels: 2 * editHandlePointRadius
  })];
}

// src/components/spatial/utils.js
import shortNumber from "short-number";
import isEqual4 from "lodash/isEqual";
import { extent } from "d3-array";
import { Matrix4 as Matrix43 } from "math.gl";
import { divide, compare, unit } from "mathjs";

// src/layers/BitmaskLayer.js
import GL4 from "@luma.gl/constants";
import { project32 as project323, picking as picking3 } from "@deck.gl/core";
import { Texture2D as Texture2D3, isWebGL2 as isWebGL22 } from "@luma.gl/core";

// src/layers/bitmask-layer-shaders.js
var vs3 = "\n#define SHADER_NAME bitmask-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute vec3 instancePickingColors;\n\nvarying vec2 vTexCoord;\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = instancePickingColors;\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vTexCoord = texCoords;\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n";
var fs3 = "\n#define SHADER_NAME bitmask-layer-fragment-shader\nprecision highp float;\n\nvec4 plasma (float x_1306414511) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.050980392156862744,0.03137254901960784,0.5294117647058824,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.29411764705882354,0.011764705882352941,0.6313725490196078,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.49019607843137253,0.011764705882352941,0.6588235294117647,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.6588235294117647,0.13333333333333333,0.5882352941176471,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.796078431372549,0.27450980392156865,0.4745098039215686,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.8980392156862745,0.4196078431372549,0.36470588235294116,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.9725490196078431,0.5803921568627451,0.2549019607843137,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.9921568627450981,0.7647058823529411,0.1568627450980392,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9411764705882353,0.9764705882352941,0.12941176470588237,1);\n  float a0 = smoothstep(e0,e1,x_1306414511);\n  float a1 = smoothstep(e1,e2,x_1306414511);\n  float a2 = smoothstep(e2,e3,x_1306414511);\n  float a3 = smoothstep(e3,e4,x_1306414511);\n  float a4 = smoothstep(e4,e5,x_1306414511);\n  float a5 = smoothstep(e5,e6,x_1306414511);\n  float a6 = smoothstep(e6,e7,x_1306414511);\n  float a7 = smoothstep(e7,e8,x_1306414511);\n  return max(mix(v0,v1,a0)*step(e0,x_1306414511)*step(x_1306414511,e1),\n    max(mix(v1,v2,a1)*step(e1,x_1306414511)*step(x_1306414511,e2),\n    max(mix(v2,v3,a2)*step(e2,x_1306414511)*step(x_1306414511,e3),\n    max(mix(v3,v4,a3)*step(e3,x_1306414511)*step(x_1306414511,e4),\n    max(mix(v4,v5,a4)*step(e4,x_1306414511)*step(x_1306414511,e5),\n    max(mix(v5,v6,a5)*step(e5,x_1306414511)*step(x_1306414511,e6),\n    max(mix(v6,v7,a6)*step(e6,x_1306414511)*step(x_1306414511,e7),mix(v7,v8,a7)*step(e7,x_1306414511)*step(x_1306414511,e8)\n  )))))));\n}\n\nvec4 viridis (float x_1870111103) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.26666666666666666,0.00392156862745098,0.32941176470588235,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.2784313725490196,0.17254901960784313,0.47843137254901963,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.23137254901960785,0.3176470588235294,0.5450980392156862,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.17254901960784313,0.44313725490196076,0.5568627450980392,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.12941176470588237,0.5647058823529412,0.5529411764705883,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.15294117647058825,0.6784313725490196,0.5058823529411764,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.3607843137254902,0.7843137254901961,0.38823529411764707,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.6666666666666666,0.8627450980392157,0.19607843137254902,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9921568627450981,0.9058823529411765,0.1450980392156863,1);\n  float a0 = smoothstep(e0,e1,x_1870111103);\n  float a1 = smoothstep(e1,e2,x_1870111103);\n  float a2 = smoothstep(e2,e3,x_1870111103);\n  float a3 = smoothstep(e3,e4,x_1870111103);\n  float a4 = smoothstep(e4,e5,x_1870111103);\n  float a5 = smoothstep(e5,e6,x_1870111103);\n  float a6 = smoothstep(e6,e7,x_1870111103);\n  float a7 = smoothstep(e7,e8,x_1870111103);\n  return max(mix(v0,v1,a0)*step(e0,x_1870111103)*step(x_1870111103,e1),\n    max(mix(v1,v2,a1)*step(e1,x_1870111103)*step(x_1870111103,e2),\n    max(mix(v2,v3,a2)*step(e2,x_1870111103)*step(x_1870111103,e3),\n    max(mix(v3,v4,a3)*step(e3,x_1870111103)*step(x_1870111103,e4),\n    max(mix(v4,v5,a4)*step(e4,x_1870111103)*step(x_1870111103,e5),\n    max(mix(v5,v6,a5)*step(e5,x_1870111103)*step(x_1870111103,e6),\n    max(mix(v6,v7,a6)*step(e6,x_1870111103)*step(x_1870111103,e7),mix(v7,v8,a7)*step(e7,x_1870111103)*step(x_1870111103,e8)\n  )))))));\n}\n\nvec4 greys (float x_1268378094) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(1,1,1,1);\n  float a0 = smoothstep(e0,e1,x_1268378094);\n  return mix(v0,v1,a0)*step(e0,x_1268378094)*step(x_1268378094,e1);\n}\n\nvec4 magma (float x_2443053725) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0.01568627450980392,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.10980392156862745,0.06274509803921569,0.26666666666666666,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.30980392156862746,0.07058823529411765,0.4823529411764706,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.5058823529411764,0.1450980392156863,0.5058823529411764,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.7098039215686275,0.21176470588235294,0.47843137254901963,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.8980392156862745,0.3137254901960784,0.39215686274509803,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.984313725490196,0.5294117647058824,0.3803921568627451,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.996078431372549,0.7607843137254902,0.5294117647058824,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9882352941176471,0.9921568627450981,0.7490196078431373,1);\n  float a0 = smoothstep(e0,e1,x_2443053725);\n  float a1 = smoothstep(e1,e2,x_2443053725);\n  float a2 = smoothstep(e2,e3,x_2443053725);\n  float a3 = smoothstep(e3,e4,x_2443053725);\n  float a4 = smoothstep(e4,e5,x_2443053725);\n  float a5 = smoothstep(e5,e6,x_2443053725);\n  float a6 = smoothstep(e6,e7,x_2443053725);\n  float a7 = smoothstep(e7,e8,x_2443053725);\n  return max(mix(v0,v1,a0)*step(e0,x_2443053725)*step(x_2443053725,e1),\n    max(mix(v1,v2,a1)*step(e1,x_2443053725)*step(x_2443053725,e2),\n    max(mix(v2,v3,a2)*step(e2,x_2443053725)*step(x_2443053725,e3),\n    max(mix(v3,v4,a3)*step(e3,x_2443053725)*step(x_2443053725,e4),\n    max(mix(v4,v5,a4)*step(e4,x_2443053725)*step(x_2443053725,e5),\n    max(mix(v5,v6,a5)*step(e5,x_2443053725)*step(x_2443053725,e6),\n    max(mix(v6,v7,a6)*step(e6,x_2443053725)*step(x_2443053725,e7),mix(v7,v8,a7)*step(e7,x_2443053725)*step(x_2443053725,e8)\n  )))))));\n}\n\nvec4 jet (float x_623120303) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0.5137254901960784,1);\n  const float e1 = 0.125;\n  const vec4 v1 = vec4(0,0.23529411764705882,0.6666666666666666,1);\n  const float e2 = 0.375;\n  const vec4 v2 = vec4(0.0196078431372549,1,1,1);\n  const float e3 = 0.625;\n  const vec4 v3 = vec4(1,1,0,1);\n  const float e4 = 0.875;\n  const vec4 v4 = vec4(0.9803921568627451,0,0,1);\n  const float e5 = 1.0;\n  const vec4 v5 = vec4(0.5019607843137255,0,0,1);\n  float a0 = smoothstep(e0,e1,x_623120303);\n  float a1 = smoothstep(e1,e2,x_623120303);\n  float a2 = smoothstep(e2,e3,x_623120303);\n  float a3 = smoothstep(e3,e4,x_623120303);\n  float a4 = smoothstep(e4,e5,x_623120303);\n  return max(mix(v0,v1,a0)*step(e0,x_623120303)*step(x_623120303,e1),\n    max(mix(v1,v2,a1)*step(e1,x_623120303)*step(x_623120303,e2),\n    max(mix(v2,v3,a2)*step(e2,x_623120303)*step(x_623120303,e3),\n    max(mix(v3,v4,a3)*step(e3,x_623120303)*step(x_623120303,e4),mix(v4,v5,a4)*step(e4,x_623120303)*step(x_623120303,e5)\n  ))));\n}\n\nvec4 bone (float x_783795047) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0,1);\n  const float e1 = 0.376;\n  const vec4 v1 = vec4(0.32941176470588235,0.32941176470588235,0.4549019607843137,1);\n  const float e2 = 0.753;\n  const vec4 v2 = vec4(0.6627450980392157,0.7843137254901961,0.7843137254901961,1);\n  const float e3 = 1.0;\n  const vec4 v3 = vec4(1,1,1,1);\n  float a0 = smoothstep(e0,e1,x_783795047);\n  float a1 = smoothstep(e1,e2,x_783795047);\n  float a2 = smoothstep(e2,e3,x_783795047);\n  return max(mix(v0,v1,a0)*step(e0,x_783795047)*step(x_783795047,e1),\n    max(mix(v1,v2,a1)*step(e1,x_783795047)*step(x_783795047,e2),mix(v2,v3,a2)*step(e2,x_783795047)*step(x_783795047,e3)\n  ));\n}\n\nvec4 copper (float x_3932431844) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0,1);\n  const float e1 = 0.804;\n  const vec4 v1 = vec4(1,0.6274509803921569,0.4,1);\n  const float e2 = 1.0;\n  const vec4 v2 = vec4(1,0.7803921568627451,0.4980392156862745,1);\n  float a0 = smoothstep(e0,e1,x_3932431844);\n  float a1 = smoothstep(e1,e2,x_3932431844);\n  return max(mix(v0,v1,a0)*step(e0,x_3932431844)*step(x_3932431844,e1),mix(v1,v2,a1)*step(e1,x_3932431844)*step(x_3932431844,e2)\n  );\n}\n\nvec4 density (float x_2921433544) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.21176470588235294,0.054901960784313725,0.1411764705882353,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.34901960784313724,0.09019607843137255,0.3137254901960784,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.43137254901960786,0.17647058823529413,0.5176470588235295,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.47058823529411764,0.30196078431372547,0.6980392156862745,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.47058823529411764,0.44313725490196076,0.8352941176470589,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.45098039215686275,0.592156862745098,0.8941176470588236,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.5254901960784314,0.7254901960784313,0.8901960784313725,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.6941176470588235,0.8392156862745098,0.8901960784313725,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9019607843137255,0.9450980392156862,0.9450980392156862,1);\n  float a0 = smoothstep(e0,e1,x_2921433544);\n  float a1 = smoothstep(e1,e2,x_2921433544);\n  float a2 = smoothstep(e2,e3,x_2921433544);\n  float a3 = smoothstep(e3,e4,x_2921433544);\n  float a4 = smoothstep(e4,e5,x_2921433544);\n  float a5 = smoothstep(e5,e6,x_2921433544);\n  float a6 = smoothstep(e6,e7,x_2921433544);\n  float a7 = smoothstep(e7,e8,x_2921433544);\n  return max(mix(v0,v1,a0)*step(e0,x_2921433544)*step(x_2921433544,e1),\n    max(mix(v1,v2,a1)*step(e1,x_2921433544)*step(x_2921433544,e2),\n    max(mix(v2,v3,a2)*step(e2,x_2921433544)*step(x_2921433544,e3),\n    max(mix(v3,v4,a3)*step(e3,x_2921433544)*step(x_2921433544,e4),\n    max(mix(v4,v5,a4)*step(e4,x_2921433544)*step(x_2921433544,e5),\n    max(mix(v5,v6,a5)*step(e5,x_2921433544)*step(x_2921433544,e6),\n    max(mix(v6,v7,a6)*step(e6,x_2921433544)*step(x_2921433544,e7),mix(v7,v8,a7)*step(e7,x_2921433544)*step(x_2921433544,e8)\n  )))))));\n}\n\nvec4 inferno (float x_1987546174) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0.01568627450980392,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.12156862745098039,0.047058823529411764,0.2823529411764706,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.3333333333333333,0.058823529411764705,0.42745098039215684,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.5333333333333333,0.13333333333333333,0.41568627450980394,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.7294117647058823,0.21176470588235294,0.3333333333333333,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.8901960784313725,0.34901960784313724,0.2,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.9764705882352941,0.5490196078431373,0.0392156862745098,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.9764705882352941,0.788235294117647,0.19607843137254902,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9882352941176471,1,0.6431372549019608,1);\n  float a0 = smoothstep(e0,e1,x_1987546174);\n  float a1 = smoothstep(e1,e2,x_1987546174);\n  float a2 = smoothstep(e2,e3,x_1987546174);\n  float a3 = smoothstep(e3,e4,x_1987546174);\n  float a4 = smoothstep(e4,e5,x_1987546174);\n  float a5 = smoothstep(e5,e6,x_1987546174);\n  float a6 = smoothstep(e6,e7,x_1987546174);\n  float a7 = smoothstep(e7,e8,x_1987546174);\n  return max(mix(v0,v1,a0)*step(e0,x_1987546174)*step(x_1987546174,e1),\n    max(mix(v1,v2,a1)*step(e1,x_1987546174)*step(x_1987546174,e2),\n    max(mix(v2,v3,a2)*step(e2,x_1987546174)*step(x_1987546174,e3),\n    max(mix(v3,v4,a3)*step(e3,x_1987546174)*step(x_1987546174,e4),\n    max(mix(v4,v5,a4)*step(e4,x_1987546174)*step(x_1987546174,e5),\n    max(mix(v5,v6,a5)*step(e5,x_1987546174)*step(x_1987546174,e6),\n    max(mix(v6,v7,a6)*step(e6,x_1987546174)*step(x_1987546174,e7),mix(v7,v8,a7)*step(e7,x_1987546174)*step(x_1987546174,e8)\n  )))))));\n}\n\nvec4 cool (float x_761030515) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.49019607843137253,0,0.7019607843137254,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.4549019607843137,0,0.8549019607843137,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.3843137254901961,0.2901960784313726,0.9294117647058824,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.26666666666666666,0.5725490196078431,0.9058823529411765,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0,0.8,0.7725490196078432,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0,0.9686274509803922,0.5725490196078431,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0,1,0.34509803921568627,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.1568627450980392,1,0.03137254901960784,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.5764705882352941,1,0,1);\n  float a0 = smoothstep(e0,e1,x_761030515);\n  float a1 = smoothstep(e1,e2,x_761030515);\n  float a2 = smoothstep(e2,e3,x_761030515);\n  float a3 = smoothstep(e3,e4,x_761030515);\n  float a4 = smoothstep(e4,e5,x_761030515);\n  float a5 = smoothstep(e5,e6,x_761030515);\n  float a6 = smoothstep(e6,e7,x_761030515);\n  float a7 = smoothstep(e7,e8,x_761030515);\n  return max(mix(v0,v1,a0)*step(e0,x_761030515)*step(x_761030515,e1),\n    max(mix(v1,v2,a1)*step(e1,x_761030515)*step(x_761030515,e2),\n    max(mix(v2,v3,a2)*step(e2,x_761030515)*step(x_761030515,e3),\n    max(mix(v3,v4,a3)*step(e3,x_761030515)*step(x_761030515,e4),\n    max(mix(v4,v5,a4)*step(e4,x_761030515)*step(x_761030515,e5),\n    max(mix(v5,v6,a5)*step(e5,x_761030515)*step(x_761030515,e6),\n    max(mix(v6,v7,a6)*step(e6,x_761030515)*step(x_761030515,e7),mix(v7,v8,a7)*step(e7,x_761030515)*step(x_761030515,e8)\n  )))))));\n}\n\nvec4 hot (float x_180130041) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0,1);\n  const float e1 = 0.3;\n  const vec4 v1 = vec4(0.9019607843137255,0,0,1);\n  const float e2 = 0.6;\n  const vec4 v2 = vec4(1,0.8235294117647058,0,1);\n  const float e3 = 1.0;\n  const vec4 v3 = vec4(1,1,1,1);\n  float a0 = smoothstep(e0,e1,x_180130041);\n  float a1 = smoothstep(e1,e2,x_180130041);\n  float a2 = smoothstep(e2,e3,x_180130041);\n  return max(mix(v0,v1,a0)*step(e0,x_180130041)*step(x_180130041,e1),\n    max(mix(v1,v2,a1)*step(e1,x_180130041)*step(x_180130041,e2),mix(v2,v3,a2)*step(e2,x_180130041)*step(x_180130041,e3)\n  ));\n}\n\nvec4 spring (float x_755571360) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(1,0,1,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(1,1,0,1);\n  float a0 = smoothstep(e0,e1,x_755571360);\n  return mix(v0,v1,a0)*step(e0,x_755571360)*step(x_755571360,e1);\n}\n\nvec4 summer (float x_2651158874) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0.5019607843137255,0.4,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(1,1,0.4,1);\n  float a0 = smoothstep(e0,e1,x_2651158874);\n  return mix(v0,v1,a0)*step(e0,x_2651158874)*step(x_2651158874,e1);\n}\n\nvec4 autumn (float x_626866098) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(1,0,0,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(1,1,0,1);\n  float a0 = smoothstep(e0,e1,x_626866098);\n  return mix(v0,v1,a0)*step(e0,x_626866098)*step(x_626866098,e1);\n}\n\nvec4 winter (float x_2098958741) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,1,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(0,1,0.5019607843137255,1);\n  float a0 = smoothstep(e0,e1,x_2098958741);\n  return mix(v0,v1,a0)*step(e0,x_2098958741)*step(x_2098958741,e1);\n}\n\n// Data (mask) texture\nuniform sampler2D channel0;\nuniform sampler2D channel1;\nuniform sampler2D channel2;\nuniform sampler2D channel3;\nuniform sampler2D channel4;\nuniform sampler2D channel5;\n\n// Color texture\nuniform sampler2D colorTex;\nuniform float colorTexHeight;\nuniform float colorTexWidth;\nuniform float hovered;\n// range\nuniform bool channelsVisible[6];\n\n// Expression mapping\nuniform vec2 uColorScaleRange;\nuniform bool uIsExpressionMode;\nuniform sampler2D expressionTex;\n\n// opacity\nuniform float opacity;\n\nvarying vec2 vTexCoord;\n\nvec4 sampleAndGetColor(sampler2D dataTex, vec2 coord, bool isOn){\n  float sampledData = texture(dataTex, coord).r;\n  vec4 hoveredColor = float(sampledData == hovered && sampledData > 0. && hovered > 0.) * vec4(0., 0., 1., 1.);\n  // Colors are laid out corresponding to ids in row-major order in the texture.  So if width of the texture is 10, and you want ID 25,\n  // you need coordinate (1, 4) (i.e 2 rows down, and 5 columns over indexed from 0 for a total of 25 units covered in row major order).\n  vec2 colorTexCoord = vec2(mod(sampledData, colorTexWidth) / colorTexWidth, floor(sampledData / colorTexWidth) / (colorTexHeight - 1.));\n  float expressionValue = texture(expressionTex, colorTexCoord).r / 255.;\n  float scaledExpressionValue = (expressionValue - uColorScaleRange[0]) / max(0.005, (uColorScaleRange[1] - uColorScaleRange[0]));\n  vec4 sampledColor = float(uIsExpressionMode) * COLORMAP_FUNC(clamp(scaledExpressionValue, 0.0, 1.0)) +  (1. - float(uIsExpressionMode)) * vec4(texture(colorTex, colorTexCoord).rgb, 1.);\n  // Only return a color if the data is non-zero.\n  return max(0., min(sampledData, 1.)) * float(isOn) * (sampledColor + hoveredColor);\n}\n\nvoid main() {\n\n  gl_FragColor = sampleAndGetColor(channel0, vTexCoord, channelsVisible[0]);\n\n  // If the sampled color and the currently stored color (gl_FragColor) are identical, don't blend and use the sampled color,\n  // otherwise just use the currently stored color.  Repeat this for all channels.\n  vec4 sampledColor = sampleAndGetColor(channel1, vTexCoord, channelsVisible[1]);\n  gl_FragColor = (sampledColor == gl_FragColor || sampledColor == vec4(0.)) ? gl_FragColor : sampledColor;\n  sampledColor = sampleAndGetColor(channel2, vTexCoord, channelsVisible[2]);\n  gl_FragColor = (sampledColor == gl_FragColor || sampledColor == vec4(0.)) ? gl_FragColor : sampledColor;\n  sampledColor = sampleAndGetColor(channel3, vTexCoord, channelsVisible[3]);\n  gl_FragColor = (sampledColor == gl_FragColor || sampledColor == vec4(0.)) ? gl_FragColor : sampledColor;\n  sampledColor = sampleAndGetColor(channel4, vTexCoord, channelsVisible[4]);\n  gl_FragColor = (sampledColor == gl_FragColor || sampledColor == vec4(0.)) ? gl_FragColor : sampledColor;\n  sampledColor = sampleAndGetColor(channel5, vTexCoord, channelsVisible[5]);\n  gl_FragColor = (sampledColor == gl_FragColor || sampledColor == vec4(0.)) ? gl_FragColor : sampledColor;\n  // Apply the opacity if there is pixel data, and if the pixel data is empty i.e no segmentation, use 0 opacity.\n  gl_FragColor = vec4(gl_FragColor.rgb, (gl_FragColor.rgb == vec3(0., 0., 0.)) ? 0.0 : opacity);\n\n  geometry.uv = vTexCoord;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

// src/layers/BitmaskLayer.js
function padWithDefault2(arr, defaultValue, padWidth) {
  const newArr = [...arr];
  for (let i = 0; i < padWidth; i += 1) {
    newArr.push(defaultValue);
  }
  return newArr;
}
var defaultProps5 = {
  hoveredCell: { type: "number", value: null, compare: true },
  cellColorData: { type: "object", value: null, compare: true },
  colormap: { type: "string", value: GLSL_COLORMAP_DEFAULT, compare: true },
  expressionData: { type: "object", value: null, compare: true }
};
var BitmaskLayer = class extends XRLayer {
  getShaders() {
    const { colormap } = this.props;
    return {
      fs: fs3,
      vs: vs3,
      modules: [project323, picking3],
      defines: {
        [COLORMAP_SHADER_PLACEHOLDER]: GLSL_COLORMAPS.includes(colormap) ? colormap : GLSL_COLORMAP_DEFAULT
      }
    };
  }
  updateState({ props, oldProps, changeFlags }) {
    super.updateState({ props, oldProps, changeFlags });
    if (props.cellColorData !== oldProps.cellColorData) {
      this.setColorTexture();
    }
    if (props.expressionData !== oldProps.expressionData) {
      const { expressionData, cellTexHeight, cellTexWidth } = this.props;
      const expressionTex = this.dataToTexture(expressionData, cellTexWidth, cellTexHeight);
      this.setState({ expressionTex });
    }
    if (props.colormap !== oldProps.colormap) {
      const { gl } = this.context;
      if (this.state.model) {
        this.state.model.delete();
      }
      this.setState({ model: this._getModel(gl) });
      this.getAttributeManager().invalidateAll();
    }
  }
  setColorTexture() {
    const {
      cellColorData: data,
      cellTexHeight: height,
      cellTexWidth: width
    } = this.props;
    const colorTex = new Texture2D3(this.context.gl, {
      width,
      height,
      data,
      mipmaps: false,
      parameters: {
        [GL4.TEXTURE_MIN_FILTER]: GL4.NEAREST,
        [GL4.TEXTURE_MAG_FILTER]: GL4.NEAREST,
        [GL4.TEXTURE_WRAP_S]: GL4.CLAMP_TO_EDGE,
        [GL4.TEXTURE_WRAP_T]: GL4.CLAMP_TO_EDGE
      },
      format: GL4.RGB,
      dataFormat: GL4.RGB,
      type: GL4.UNSIGNED_BYTE
    });
    this.setState({ colorTex });
  }
  draw(opts) {
    const { uniforms } = opts;
    const {
      channelsVisible,
      hoveredCell,
      colorScaleLo,
      colorScaleHi,
      isExpressionMode
    } = this.props;
    const {
      textures,
      model,
      colorTex,
      expressionTex
    } = this.state;
    if (textures && model && colorTex) {
      model.setUniforms(Object.assign({}, uniforms, __spreadValues({
        hovered: hoveredCell || 0,
        colorTex,
        expressionTex,
        colorTexHeight: colorTex.height,
        colorTexWidth: colorTex.width,
        channelsVisible: padWithDefault2(channelsVisible, false, 6 - channelsVisible.length),
        uColorScaleRange: [colorScaleLo, colorScaleHi],
        uIsExpressionMode: isExpressionMode
      }, textures))).draw();
    }
  }
  dataToTexture(data, width, height) {
    const isWebGL2On = isWebGL22(this.context.gl);
    return new Texture2D3(this.context.gl, {
      width,
      height,
      data: new Float32Array(data),
      mipmaps: false,
      parameters: {
        [GL4.TEXTURE_MIN_FILTER]: GL4.NEAREST,
        [GL4.TEXTURE_MAG_FILTER]: GL4.NEAREST,
        [GL4.TEXTURE_WRAP_S]: GL4.CLAMP_TO_EDGE,
        [GL4.TEXTURE_WRAP_T]: GL4.CLAMP_TO_EDGE
      },
      format: isWebGL2On ? GL4.R32F : GL4.LUMINANCE,
      dataFormat: isWebGL2On ? GL4.RED : GL4.LUMINANCE,
      type: GL4.FLOAT
    });
  }
};
BitmaskLayer.layerName = "BitmaskLayer";
BitmaskLayer.defaultProps = defaultProps5;

// src/components/layer-controller/utils.js
import { Matrix4 as Matrix42 } from "math.gl";
function getSingleSelectionStats2D(_0) {
  return __async(this, arguments, function* ({ loader, selection }) {
    const data = Array.isArray(loader) ? loader[loader.length - 1] : loader;
    const raster = yield data.getRaster({ selection });
    const selectionStats = getChannelStats(raster.data);
    const { domain, contrastLimits: slider } = selectionStats;
    return { domain, slider };
  });
}
function getSingleSelectionStats3D(_0) {
  return __async(this, arguments, function* ({ loader, selection }) {
    const lowResSource = loader[loader.length - 1];
    const { shape, labels } = lowResSource;
    const sizeZ = shape[labels.indexOf("z")] >> loader.length - 1;
    const raster0 = yield lowResSource.getRaster({
      selection: __spreadProps(__spreadValues({}, selection), { z: 0 })
    });
    const rasterMid = yield lowResSource.getRaster({
      selection: __spreadProps(__spreadValues({}, selection), { z: Math.floor(sizeZ / 2) })
    });
    const rasterTop = yield lowResSource.getRaster({
      selection: __spreadProps(__spreadValues({}, selection), { z: Math.max(0, sizeZ - 1) })
    });
    const stats0 = getChannelStats(raster0.data);
    const statsMid = getChannelStats(rasterMid.data);
    const statsTop = getChannelStats(rasterTop.data);
    return {
      domain: [
        Math.min(stats0.domain[0], statsMid.domain[0], statsTop.domain[0]),
        Math.max(stats0.domain[1], statsMid.domain[1], statsTop.domain[1])
      ],
      slider: [
        Math.min(stats0.contrastLimits[0], statsMid.contrastLimits[0], statsTop.contrastLimits[0]),
        Math.max(stats0.contrastLimits[1], statsMid.contrastLimits[1], statsTop.contrastLimits[1])
      ]
    };
  });
}
var getSingleSelectionStats = (_0) => __async(void 0, [_0], function* ({ loader, selection, use3d }) {
  const getStats = use3d ? getSingleSelectionStats3D : getSingleSelectionStats2D;
  return getStats({ loader, selection });
});
var getMultiSelectionStats = (_0) => __async(void 0, [_0], function* ({ loader, selections, use3d }) {
  const stats = yield Promise.all(selections.map((selection) => getSingleSelectionStats({ loader, selection, use3d })));
  const domains = stats.map((stat) => stat.domain);
  const sliders = stats.map((stat) => stat.slider);
  return { domains, sliders };
});
function getPhysicalSizeScalingMatrix2(loader) {
  var _a2, _b2;
  const { x, y, z } = (_b2 = (_a2 = loader == null ? void 0 : loader.meta) == null ? void 0 : _a2.physicalSizes) != null ? _b2 : {};
  if ((x == null ? void 0 : x.size) && (y == null ? void 0 : y.size) && (z == null ? void 0 : z.size)) {
    const min = Math.min(z.size, x.size, y.size);
    const ratio = [x.size / min, y.size / min, z.size / min];
    return new Matrix42().scale(ratio);
  }
  return new Matrix42().identity();
}
function getBoundingCube(loader) {
  const source = Array.isArray(loader) ? loader[0] : loader;
  const { shape, labels } = source;
  const physicalSizeScalingMatrix = getPhysicalSizeScalingMatrix2(source);
  const xSlice = [0, physicalSizeScalingMatrix[0] * shape[labels.indexOf("x")]];
  const ySlice = [0, physicalSizeScalingMatrix[5] * shape[labels.indexOf("y")]];
  const zSlice = [
    0,
    physicalSizeScalingMatrix[10] * shape[labels.indexOf("z")]
  ];
  return [xSlice, ySlice, zSlice];
}
function abbreviateNumber(value) {
  const maxLength = 5;
  let maxNaiveDigits = maxLength;
  if (!Number.isInteger(value)) {
    --maxNaiveDigits;
  }
  if (value < 1) {
    --maxNaiveDigits;
  }
  const naive = Intl.NumberFormat("en-US", {
    maximumSignificantDigits: maxNaiveDigits,
    useGrouping: false
  }).format(value);
  if (naive.length <= maxLength)
    return naive;
  return value.toExponential(0);
}

// src/components/spatial/utils.js
function square(x, y, r) {
  return [[x, y + r], [x + r, y], [x, y - r], [x - r, y]];
}
function getDefaultGlobalSelection(source) {
  const globalIndices = source.labels.filter((dim) => GLOBAL_LABELS.includes(dim));
  const selection = {};
  globalIndices.forEach((dim) => {
    selection[dim] = Math.floor((source.shape[source.labels.indexOf(dim)] || 0) / 2);
  });
  return selection;
}
function buildDefaultSelection(source) {
  const selection = [];
  const globalSelection = getDefaultGlobalSelection(source);
  const firstNonGlobalDimension = source.labels.filter((dim) => !GLOBAL_LABELS.includes(dim) && source.shape[source.labels.indexOf(dim)])[0];
  for (let i = 0; i < Math.min(4, source.shape[source.labels.indexOf(firstNonGlobalDimension)]); i += 1) {
    selection.push(__spreadValues({
      [firstNonGlobalDimension]: i
    }, globalSelection));
  }
  return selection;
}
function isInterleaved2(shape) {
  const lastDimSize = shape[shape.length - 1];
  return lastDimSize === 3 || lastDimSize === 4;
}
function initializeLayerChannels(loader, use3d) {
  return __async(this, null, function* () {
    const result = [];
    const source = getSourceFromLoader(loader);
    let defaultSelection = buildDefaultSelection(source);
    defaultSelection = isInterleaved2(source.shape) ? [__spreadProps(__spreadValues({}, defaultSelection[0]), { c: 0 })] : defaultSelection;
    const stats = yield getMultiSelectionStats({
      loader: loader.data,
      selections: defaultSelection,
      use3d
    });
    const domains = isRgb(loader) ? [[0, 255], [0, 255], [0, 255]] : stats.domains;
    const colors = isRgb(loader) ? [[255, 0, 0], [0, 255, 0], [0, 0, 255]] : null;
    const sliders = isRgb(loader) ? [[0, 255], [0, 255], [0, 255]] : stats.sliders;
    defaultSelection.forEach((selection, i) => {
      const domain = domains[i];
      const slider = sliders[i];
      const channel = {
        selection,
        color: colors ? colors[i] : defaultSelection.length !== 1 ? VIEWER_PALETTE[i] : [255, 255, 255],
        visible: true,
        slider: slider || domain
      };
      result.push(channel);
    });
    return result;
  });
}
function getMetaWithTransformMatrices(imageMeta, imageLoaders) {
  const sources = imageLoaders.map((loader) => getSourceFromLoader(loader));
  if (imageMeta.map((meta) => {
    var _a2, _b2, _c, _d, _e, _f;
    return ((_b2 = (_a2 = meta == null ? void 0 : meta.metadata) == null ? void 0 : _a2.transform) == null ? void 0 : _b2.matrix) || ((_d = (_c = meta == null ? void 0 : meta.metadata) == null ? void 0 : _c.transform) == null ? void 0 : _d.scale) || ((_f = (_e = meta == null ? void 0 : meta.metadata) == null ? void 0 : _e.transform) == null ? void 0 : _f.translate);
  }).some(Boolean) || sources.every((source) => {
    var _a2, _b2, _c, _d;
    return !((_b2 = (_a2 = source.meta) == null ? void 0 : _a2.physicalSizes) == null ? void 0 : _b2.x) || !((_d = (_c = source.meta) == null ? void 0 : _c.physicalSizes) == null ? void 0 : _d.y);
  })) {
    return imageMeta;
  }
  const minPhysicalSize = sources.reduce((acc, source) => {
    var _a2, _b2, _c, _d, _e, _f, _g, _h, _i;
    const hasZPhyscialSize = (_c = (_b2 = (_a2 = source.meta) == null ? void 0 : _a2.physicalSizes) == null ? void 0 : _b2.z) == null ? void 0 : _c.size;
    const sizes = [
      unit(`${(_d = source.meta) == null ? void 0 : _d.physicalSizes.x.size} ${(_e = source.meta) == null ? void 0 : _e.physicalSizes.x.unit}`.replace("\xB5", "u")),
      unit(`${(_f = source.meta) == null ? void 0 : _f.physicalSizes.y.size} ${(_g = source.meta) == null ? void 0 : _g.physicalSizes.y.unit}`.replace("\xB5", "u"))
    ];
    if (hasZPhyscialSize) {
      sizes.push(unit(`${(_h = source.meta) == null ? void 0 : _h.physicalSizes.z.size} ${(_i = source.meta) == null ? void 0 : _i.physicalSizes.z.unit}`.replace("\xB5", "u")));
    }
    acc[0] = acc[0] === void 0 || compare(sizes[0], acc[0]) === -1 ? sizes[0] : acc[0];
    acc[1] = acc[1] === void 0 || compare(sizes[1], acc[1]) === -1 ? sizes[1] : acc[1];
    acc[2] = acc[2] === void 0 || compare(sizes[2], acc[2]) === -1 ? sizes[2] : acc[2];
    return acc;
  }, []);
  const imageMetaWithTransform = imageMeta.map((meta, j) => {
    var _a2, _b2, _c, _d, _e, _f, _g, _h, _i;
    const source = sources[j];
    const hasZPhyscialSize = (_c = (_b2 = (_a2 = source.meta) == null ? void 0 : _a2.physicalSizes) == null ? void 0 : _b2.z) == null ? void 0 : _c.size;
    const sizes = [
      unit(`${(_d = source.meta) == null ? void 0 : _d.physicalSizes.x.size} ${(_e = source.meta) == null ? void 0 : _e.physicalSizes.x.unit}`.replace("\xB5", "u")),
      unit(`${(_f = source.meta) == null ? void 0 : _f.physicalSizes.y.size} ${(_g = source.meta) == null ? void 0 : _g.physicalSizes.y.unit}`.replace("\xB5", "u"))
    ];
    if (hasZPhyscialSize) {
      sizes.push(unit(`${(_h = source.meta) == null ? void 0 : _h.physicalSizes.z.size} ${(_i = source.meta) == null ? void 0 : _i.physicalSizes.z.unit}`.replace("\xB5", "u")));
    }
    const scale = sizes.map((i, k) => divide(i, minPhysicalSize[k]));
    if (!scale[2]) {
      scale[2] = 1;
    }
    if (isEqual4(scale, [1, 1, 1])) {
      return meta;
    }
    const matrix = new Matrix43().scale([...scale]);
    const newMeta = __spreadValues({}, meta);
    newMeta.metadata = __spreadProps(__spreadValues({}, newMeta.metadata), {
      transform: { matrix: matrix.toArray() }
    });
    return newMeta;
  });
  return imageMetaWithTransform;
}
function initializeRasterLayersAndChannels(rasterLayers, rasterRenderLayers, usePhysicalSizeScaling) {
  return __async(this, null, function* () {
    const nextImageLoaders = [];
    let nextImageMetaAndLayers = [];
    const autoImageLayerDefPromises = [];
    const loaders = yield Promise.all(rasterLayers.map((layer) => layer.loaderCreator()));
    for (let i = 0; i < rasterLayers.length; i++) {
      const layer = rasterLayers[i];
      const loader = loaders[i];
      nextImageLoaders[i] = loader;
      nextImageMetaAndLayers[i] = layer;
    }
    if (usePhysicalSizeScaling) {
      nextImageMetaAndLayers = getMetaWithTransformMatrices(nextImageMetaAndLayers, nextImageLoaders);
    }
    if (!rasterRenderLayers) {
      const layerIndex = Math.floor(rasterLayers.length / 2);
      const loader = nextImageLoaders[layerIndex];
      const autoImageLayerDefPromise = initializeLayerChannels(loader).then((channels2) => {
        var _a2, _b2, _c, _d, _e;
        return Promise.resolve(__spreadProps(__spreadValues({
          type: ((_b2 = (_a2 = nextImageMetaAndLayers[layerIndex]) == null ? void 0 : _a2.metadata) == null ? void 0 : _b2.isBitmask) ? "bitmask" : "raster",
          index: layerIndex
        }, DEFAULT_RASTER_LAYER_PROPS), {
          channels: channels2.map((channel, j) => __spreadValues(__spreadValues({}, channel), nextImageMetaAndLayers[layerIndex].channels ? nextImageMetaAndLayers[layerIndex].channels[j] : [])),
          modelMatrix: (_e = (_d = (_c = nextImageMetaAndLayers[layerIndex]) == null ? void 0 : _c.metadata) == null ? void 0 : _d.transform) == null ? void 0 : _e.matrix,
          transparentColor: layerIndex > 0 ? [0, 0, 0] : null
        }));
      });
      autoImageLayerDefPromises.push(autoImageLayerDefPromise);
    } else {
      const globalIndicesOfRenderLayers = rasterRenderLayers.map((imageName) => rasterLayers.findIndex((image) => image.name === imageName));
      for (let i = 0; i < globalIndicesOfRenderLayers.length; i++) {
        const layerIndex = globalIndicesOfRenderLayers[i];
        const loader = nextImageLoaders[layerIndex];
        const autoImageLayerDefPromise = initializeLayerChannels(loader).then((channels2) => {
          var _a2, _b2, _c, _d, _e;
          return Promise.resolve(__spreadProps(__spreadValues({
            type: ((_b2 = (_a2 = nextImageMetaAndLayers[layerIndex]) == null ? void 0 : _a2.metadata) == null ? void 0 : _b2.isBitmask) ? "bitmask" : "raster",
            index: layerIndex
          }, DEFAULT_RASTER_LAYER_PROPS), {
            channels: channels2.map((channel, j) => __spreadValues(__spreadValues({}, channel), nextImageMetaAndLayers[layerIndex].channels ? nextImageMetaAndLayers[layerIndex].channels[j] : [])),
            domainType: "Min/Max",
            modelMatrix: (_e = (_d = (_c = nextImageMetaAndLayers[layerIndex]) == null ? void 0 : _c.metadata) == null ? void 0 : _d.transform) == null ? void 0 : _e.matrix,
            transparentColor: i > 0 ? [0, 0, 0] : null
          }));
        });
        autoImageLayerDefPromises.push(autoImageLayerDefPromise);
      }
    }
    const autoImageLayerDefs = yield Promise.all(autoImageLayerDefPromises);
    return [autoImageLayerDefs, nextImageLoaders, nextImageMetaAndLayers];
  });
}
function makeSpatialSubtitle({
  observationsCount,
  observationsLabel,
  observationsPluralLabel,
  subobservationsCount,
  subobservationsLabel,
  subobservationsPluralLabel,
  locationsCount
}) {
  const parts = [];
  if (subobservationsCount > 0) {
    let part = `${subobservationsCount} ${pluralize(subobservationsLabel, subobservationsPluralLabel, subobservationsCount)}`;
    if (locationsCount > 0) {
      part += ` at ${shortNumber(locationsCount)} locations`;
    }
    parts.push(part);
  }
  if (observationsCount > 0) {
    parts.push(`${observationsCount} ${pluralize(observationsLabel, observationsPluralLabel, observationsCount)}`);
  }
  return parts.join(", ");
}
function getInitialSpatialTargets({
  width,
  height,
  cells,
  imageLayerLoaders,
  useRaster,
  use3d
}) {
  let initialTargetX = -Infinity;
  let initialTargetY = -Infinity;
  let initialTargetZ = -Infinity;
  let initialZoom = -Infinity;
  const zoomBackoff = use3d ? 1.5 : 0.1;
  const cellValues = Object.values(cells);
  if (imageLayerLoaders.length > 0 && useRaster) {
    for (let i = 0; i < imageLayerLoaders.length; i += 1) {
      const viewSize = { height, width };
      const { target, zoom: newViewStateZoom } = getDefaultInitialViewState(imageLayerLoaders[i].data, viewSize, zoomBackoff, use3d);
      if (target[0] > initialTargetX) {
        initialTargetX = target[0];
        initialZoom = newViewStateZoom;
      }
      if (target[1] > initialTargetY) {
        initialTargetY = target[1];
        initialZoom = newViewStateZoom;
      }
      if (target[2] > initialTargetZ) {
        initialTargetZ = target[2];
        initialZoom = newViewStateZoom;
      } else {
        initialTargetZ = null;
      }
    }
  } else if (cellValues.length > 0 && cellValues[0].xy && !useRaster) {
    const cellCoordinates = cellValues.map((c) => c.xy);
    let xExtent = extent(cellCoordinates, (c) => c[0]);
    let yExtent = extent(cellCoordinates, (c) => c[1]);
    let xRange = xExtent[1] - xExtent[0];
    let yRange = yExtent[1] - yExtent[0];
    const getViewExtentFromPolygonExtents = (extents) => [
      Math.min(...extents.map((i) => i[0])),
      Math.max(...extents.map((i) => i[1]))
    ];
    if (xRange === 0) {
      const polygonExtentsX = cellValues.map((cell) => extent(cell.poly, (i) => i[0]));
      xExtent = getViewExtentFromPolygonExtents(polygonExtentsX);
      xRange = xExtent[1] - xExtent[0];
    }
    if (yRange === 0) {
      const polygonExtentsY = cellValues.map((cell) => extent(cell.poly, (i) => i[1]));
      yExtent = getViewExtentFromPolygonExtents(polygonExtentsY);
      yRange = yExtent[1] - yExtent[0];
    }
    initialTargetX = xExtent[0] + xRange / 2;
    initialTargetY = yExtent[0] + yRange / 2;
    initialTargetZ = null;
    initialZoom = Math.log2(Math.min(width / xRange, height / yRange)) - zoomBackoff;
  } else {
    return {
      initialTargetX: null,
      initialTargetY: null,
      initialTargetZ: null,
      initialZoom: null
    };
  }
  return {
    initialTargetX,
    initialTargetY,
    initialZoom,
    initialTargetZ
  };
}
function getLayerLoaderTuple(data, use3d) {
  const loader = Array.isArray(data) && data.length > 1 || !Array.isArray(data) ? data : data[0];
  if (use3d) {
    return [VolumeLayer, Array.isArray(loader) ? loader : [loader]];
  }
  const Layer2 = Array.isArray(data) && data.length > 1 ? MultiscaleImageLayer : ImageLayer;
  return [Layer2, loader];
}
function renderSubBitmaskLayers(props) {
  const {
    bbox: {
      left,
      top,
      right,
      bottom
    },
    x,
    y,
    z
  } = props.tile;
  const {
    data,
    id,
    loader
  } = props;
  if ([left, bottom, right, top].some((v) => v < 0) || !data) {
    return null;
  }
  const base = loader[0];
  const [height, width] = loader[0].shape.slice(-2);
  const bounds = [
    left,
    data.height < base.tileSize ? height : bottom,
    data.width < base.tileSize ? width : right,
    top
  ];
  return new BitmaskLayer(props, {
    channelData: data,
    bounds,
    id: `sub-layer-${bounds}-${id}`,
    tileId: { x, y, z }
  });
}

// src/components/shared-spatial-scatterplot/AbstractSpatialOrScatterplot.js
import React19, { PureComponent as PureComponent2 } from "react";
import DeckGL3, { OrthographicView as OrthographicView3, OrbitView as OrbitView2 } from "deck.gl";

// src/components/shared-spatial-scatterplot/ToolMenu.js
import React18 from "react";
import { SELECTION_TYPE as SELECTION_TYPE2 } from "nebula.gl";

// src/assets/tools/near_me.svg
import {
  createElement
} from "react";
function SvgNearMe(props) {
  return /* @__PURE__ */ createElement("svg", __spreadValues({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24"
  }, props), /* @__PURE__ */ createElement("path", {
    fill: "none",
    d: "M0 0h24v24H0V0z"
  }), /* @__PURE__ */ createElement("path", {
    d: "M21 3L3 10.53v.98l6.84 2.65L12.48 21h.98L21 3z"
  }));
}
var ReactComponent = SvgNearMe;

// src/assets/tools/selection_rectangle.svg
import {
  createElement as createElement2
} from "react";
function SvgSelectionRectangle(props) {
  return /* @__PURE__ */ createElement2("svg", __spreadValues({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24"
  }, props), /* @__PURE__ */ createElement2("path", {
    d: "       M19 19h2v2h-2v-2zm0-2h2v-2h-2v2z       M3 13h2v-2H3v2zm0 4h2v-2H3v2z       m0-8h2V7H3v2zm0-4h2V3H3v2z       m4 0h2V3H7v2zm8 16h2v-2h-2v2z       m-4 0h2v-2h-2v2z       m4 0h2v-2h-2v2z       m-8 0h2v-2H7v2z       m-4 0h2v-2H3v2z       M11 5h2v-2h-2v2z       M15 5h2v-2h-2v2z       M19 5h2v-2h-2v2z       M19 9h2v-2h-2v2z       M19 13h2v-2h-2v2z     "
  }));
}
var ReactComponent2 = SvgSelectionRectangle;

// src/assets/tools/selection_lasso.svg
import {
  createElement as createElement3
} from "react";
function SvgSelectionLasso(props) {
  return /* @__PURE__ */ createElement3("svg", __spreadValues({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24"
  }, props), /* @__PURE__ */ createElement3("g", {
    transform: "translate(0,3)"
  }, /* @__PURE__ */ createElement3("path", {
    style: {
      strokeWidth: 0.343565
    },
    d: "M 23.942314,4.6958443 C 23.446206,1.8868581 19.727461,0 14.687364,0 13.437819,0 12.150138,0.11543779 10.859708,0.34287772 4.1629423,1.5250844 -0.58168816,5.2884937 0.05768601,8.911385 c 0.25355086,1.439193 1.35605049,2.63583 3.04638949,3.461072 -0.2569865,0.387198 -0.4074679,0.826617 -0.4074679,1.29524 0,1.337498 1.1863293,2.457176 2.7639791,2.728248 l -1.3615475,2.333149 c -0.1576963,0.271073 -0.066308,0.61876 0.2047647,0.776457 0.090014,0.05291 0.1886171,0.07799 0.2858459,0.07799 0.1951448,0 0.3851362,-0.100665 0.4912977,-0.281723 l 1.6803757,-2.88148 C 8.41868,16.20561 9.6895264,15.063601 9.6998333,13.683844 c 6.872e-4,-0.0055 0.00137,-0.01065 0.00137,-0.01615 0,-0.02336 -0.00344,-0.04569 -0.00481,-0.06837 1.1292977,-0.0213 2.2847067,-0.130211 3.4435507,-0.334975 6.69711,-1.181863 11.44174,-4.9456164 10.802366,-8.5685077 z M 3.83312,13.667353 c 0,-0.30749 0.1281497,-0.59849 0.3470005,-0.848261 0.1219655,0.04295 0.2456489,0.08383 0.3717372,0.123339 l 1.2234344,2.352045 C 4.6865351,15.149835 3.83312,14.46408 3.83312,13.667353 Z M 7.0141869,15.216144 6.0223152,13.309702 5.4008064,12.114097 c 0.121622,-0.03161 0.2477103,-0.05634 0.3772342,-0.07387 0.1367388,-0.0189 0.2772568,-0.02886 0.420867,-0.02886 0.5067581,0 0.980534,0.11956 1.3701366,0.317454 0.5696305,0.289968 0.9554538,0.750345 0.9904974,1.262944 0.00137,0.02542 0.0055,0.05016 0.0055,0.07593 0,0.698124 -0.6562089,1.310356 -1.5508518,1.548447 z m 5.9185921,-3.126441 c -1.217251,0.214728 -2.429691,0.323982 -3.6060571,0.324669 -0.5765018,-0.911821 -1.7614569,-1.53917 -3.1278143,-1.53917 -0.4717146,0 -0.921441,0.07593 -1.332001,0.211292 -0.3061162,0.100665 -0.5878394,0.237403 -0.8427645,0.39991 C 2.4598914,10.828133 1.4360682,9.8579062 1.2319907,8.7035283 0.72660678,5.8381974 5.2307418,2.5475333 11.067221,1.5175259 c 1.222061,-0.2161023 2.439998,-0.3246688 3.620143,-0.3246688 4.371863,0 7.694479,1.5250844 8.080645,3.7101568 0.505041,2.8653309 -3.998751,6.1566821 -9.83523,7.1866891 z",
    id: "path10"
  })));
}
var ReactComponent3 = SvgSelectionLasso;

// src/components/shared-spatial-scatterplot/ToolMenu.js
function IconButton3(props) {
  const {
    alt,
    onClick,
    isActive,
    children
  } = props;
  const inactive = "btn btn-outline-secondary mr-2 icon";
  const active = `${inactive} active`;
  return /* @__PURE__ */ React18.createElement("button", {
    className: isActive ? active : inactive,
    onClick,
    type: "button",
    title: alt
  }, children);
}
function ToolMenu(props) {
  const {
    setActiveTool,
    activeTool,
    visibleTools = { pan: true, selectRectangle: true, selectLasso: true }
  } = props;
  return /* @__PURE__ */ React18.createElement("div", {
    className: "tool"
  }, visibleTools.pan && /* @__PURE__ */ React18.createElement(IconButton3, {
    alt: "pointer tool",
    onClick: () => setActiveTool(null),
    isActive: activeTool === null
  }, /* @__PURE__ */ React18.createElement(ReactComponent, null)), visibleTools.selectRectangle ? /* @__PURE__ */ React18.createElement(IconButton3, {
    alt: "select rectangle",
    onClick: () => setActiveTool(SELECTION_TYPE2.RECTANGLE),
    isActive: activeTool === SELECTION_TYPE2.RECTANGLE
  }, /* @__PURE__ */ React18.createElement(ReactComponent2, null)) : null, visibleTools.selectLasso ? /* @__PURE__ */ React18.createElement(IconButton3, {
    alt: "select lasso",
    onClick: () => setActiveTool(SELECTION_TYPE2.POLYGON),
    isActive: activeTool === SELECTION_TYPE2.POLYGON
  }, /* @__PURE__ */ React18.createElement(ReactComponent3, null)) : null);
}

// src/components/shared-spatial-scatterplot/cursor.js
var getCursorWithTool = () => "crosshair";
var getCursor = (interactionState) => interactionState.isDragging ? "grabbing" : "default";

// src/components/shared-spatial-scatterplot/AbstractSpatialOrScatterplot.js
var AbstractSpatialOrScatterplot = class extends PureComponent2 {
  constructor(props) {
    super(props);
    this.state = {
      gl: null,
      tool: null
    };
    this.viewport = null;
    this.onViewStateChange = this.onViewStateChange.bind(this);
    this.onInitializeViewInfo = this.onInitializeViewInfo.bind(this);
    this.onWebGLInitialized = this.onWebGLInitialized.bind(this);
    this.onToolChange = this.onToolChange.bind(this);
    this.onHover = this.onHover.bind(this);
  }
  onViewStateChange({ viewState: nextViewState }) {
    const {
      setViewState,
      viewState,
      layers,
      spatialAxisFixed
    } = this.props;
    const use3d = layers == null ? void 0 : layers.some((l) => l.use3d);
    setViewState(__spreadProps(__spreadValues({}, nextViewState), {
      target: spatialAxisFixed && use3d ? viewState.target : nextViewState.target
    }));
  }
  onInitializeViewInfo({ viewport }) {
    this.viewport = viewport;
  }
  onWebGLInitialized(gl) {
    this.setState({ gl });
  }
  onToolChange(tool) {
    const { onToolChange: onToolChangeProp } = this.props;
    this.setState({ tool });
    if (onToolChangeProp) {
      onToolChangeProp(tool);
    }
  }
  getLayers() {
    return [];
  }
  onHover(info) {
    const {
      coordinate,
      sourceLayer: layer,
      tile
    } = info;
    const {
      setCellHighlight,
      cellHighlight,
      setComponentHover,
      layers
    } = this.props;
    const hasBitmask = (layers || []).some((l) => l.type === "bitmask");
    if (!setCellHighlight || !tile) {
      return null;
    }
    if (!layer || !coordinate) {
      if (cellHighlight && hasBitmask) {
        setCellHighlight(null);
      }
      return null;
    }
    const { content, bbox, z } = tile;
    if (!content) {
      if (cellHighlight && hasBitmask) {
        setCellHighlight(null);
      }
      return null;
    }
    const { data, width, height } = content;
    const {
      left,
      right,
      top,
      bottom
    } = bbox;
    const bounds = [
      left,
      data.height < layer.tileSize ? height : bottom,
      data.width < layer.tileSize ? width : right,
      top
    ];
    if (!data) {
      if (cellHighlight && hasBitmask) {
        setCellHighlight(null);
      }
      return null;
    }
    if (layer.id.includes("bitmask")) {
      const layerZoomScale = Math.max(1, __pow(2, Math.round(-z)));
      const dataCoords = [
        Math.floor((coordinate[0] - bounds[0]) / layerZoomScale),
        Math.floor((coordinate[1] - bounds[3]) / layerZoomScale)
      ];
      const coords = dataCoords[1] * width + dataCoords[0];
      const hoverData = data.map((d) => d[coords]);
      const cellId = hoverData.find((i) => i > 0);
      if (cellId !== Number(cellHighlight)) {
        if (setComponentHover) {
          setComponentHover();
        }
        setCellHighlight(cellId ? String(cellId) : null);
      }
    }
  }
  viewInfoDidUpdate(getCellCoords) {
    const { updateViewInfo, cells, uuid } = this.props;
    const { viewport } = this;
    if (updateViewInfo && viewport) {
      updateViewInfo({
        uuid,
        project: (cellId) => {
          const cell = cells[cellId];
          try {
            const [positionX, positionY] = getCellCoords(cell);
            return viewport.project([positionX, positionY]);
          } catch (e) {
            return [null, null];
          }
        }
      });
    }
  }
  componentDidUpdate() {
  }
  render() {
    const {
      deckRef,
      viewState,
      uuid,
      layers: layerProps
    } = this.props;
    const { gl, tool } = this.state;
    const layers = this.getLayers();
    const use3d = (layerProps || []).some((l) => l.use3d);
    const showCellSelectionTools = this.cellsLayer !== null || this.cellsEntries.length && this.cellsEntries[0][1].xy;
    const showPanTool = this.cellsLayer !== null || layerProps.findIndex((l) => l.type === "bitmask" || l.type === "raster") >= 0;
    const useDevicePixels = this.cellsEntries.length < 1e5 && !use3d;
    return /* @__PURE__ */ React19.createElement(React19.Fragment, null, /* @__PURE__ */ React19.createElement(ToolMenu, {
      activeTool: tool,
      setActiveTool: this.onToolChange,
      visibleTools: {
        pan: showPanTool,
        selectRectangle: showCellSelectionTools,
        selectLasso: showCellSelectionTools
      }
    }), /* @__PURE__ */ React19.createElement(DeckGL3, {
      id: `deckgl-overlay-${uuid}`,
      ref: deckRef,
      views: [
        use3d ? new OrbitView2({ id: "orbit", controller: true, orbitAxis: "Y" }) : new OrthographicView3({
          id: "ortho"
        })
      ],
      layers: gl && viewState.target.slice(0, 2).every((i) => typeof i === "number") ? layers : [],
      glOptions: DEFAULT_GL_OPTIONS,
      onWebGLInitialized: this.onWebGLInitialized,
      onViewStateChange: this.onViewStateChange,
      viewState,
      useDevicePixels,
      controller: tool ? { dragPan: false } : true,
      getCursor: tool ? getCursorWithTool : getCursor,
      onHover: this.onHover
    }, this.onInitializeViewInfo));
  }
};

// src/components/shared-spatial-scatterplot/quadtree.js
import { quadtree } from "d3-quadtree";
function createCellsQuadTree(cellsEntries, getCellCoords) {
  if (!cellsEntries || !cellsEntries.length || !getCellCoords(cellsEntries[0][1])) {
    return null;
  }
  const tree = quadtree().x((d) => getCellCoords(d[1])[0]).y((d) => getCellCoords(d[1])[1]).addAll(cellsEntries);
  return tree;
}

// src/layer-extensions/ScaledExpressionExtension/ScaledExpressionExtension.js
import GL5 from "@luma.gl/constants";
import { LayerExtension } from "@deck.gl/core";

// src/layer-extensions/ScaledExpressionExtension/shader-module.js
var vs4 = "\nvec4 plasma (float x_1648624884) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.050980392156862744,0.03137254901960784,0.5294117647058824,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.29411764705882354,0.011764705882352941,0.6313725490196078,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.49019607843137253,0.011764705882352941,0.6588235294117647,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.6588235294117647,0.13333333333333333,0.5882352941176471,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.796078431372549,0.27450980392156865,0.4745098039215686,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.8980392156862745,0.4196078431372549,0.36470588235294116,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.9725490196078431,0.5803921568627451,0.2549019607843137,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.9921568627450981,0.7647058823529411,0.1568627450980392,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9411764705882353,0.9764705882352941,0.12941176470588237,1);\n  float a0 = smoothstep(e0,e1,x_1648624884);\n  float a1 = smoothstep(e1,e2,x_1648624884);\n  float a2 = smoothstep(e2,e3,x_1648624884);\n  float a3 = smoothstep(e3,e4,x_1648624884);\n  float a4 = smoothstep(e4,e5,x_1648624884);\n  float a5 = smoothstep(e5,e6,x_1648624884);\n  float a6 = smoothstep(e6,e7,x_1648624884);\n  float a7 = smoothstep(e7,e8,x_1648624884);\n  return max(mix(v0,v1,a0)*step(e0,x_1648624884)*step(x_1648624884,e1),\n    max(mix(v1,v2,a1)*step(e1,x_1648624884)*step(x_1648624884,e2),\n    max(mix(v2,v3,a2)*step(e2,x_1648624884)*step(x_1648624884,e3),\n    max(mix(v3,v4,a3)*step(e3,x_1648624884)*step(x_1648624884,e4),\n    max(mix(v4,v5,a4)*step(e4,x_1648624884)*step(x_1648624884,e5),\n    max(mix(v5,v6,a5)*step(e5,x_1648624884)*step(x_1648624884,e6),\n    max(mix(v6,v7,a6)*step(e6,x_1648624884)*step(x_1648624884,e7),mix(v7,v8,a7)*step(e7,x_1648624884)*step(x_1648624884,e8)\n  )))))));\n}\n\nvec4 viridis (float x_686877309) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.26666666666666666,0.00392156862745098,0.32941176470588235,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.2784313725490196,0.17254901960784313,0.47843137254901963,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.23137254901960785,0.3176470588235294,0.5450980392156862,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.17254901960784313,0.44313725490196076,0.5568627450980392,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.12941176470588237,0.5647058823529412,0.5529411764705883,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.15294117647058825,0.6784313725490196,0.5058823529411764,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.3607843137254902,0.7843137254901961,0.38823529411764707,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.6666666666666666,0.8627450980392157,0.19607843137254902,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9921568627450981,0.9058823529411765,0.1450980392156863,1);\n  float a0 = smoothstep(e0,e1,x_686877309);\n  float a1 = smoothstep(e1,e2,x_686877309);\n  float a2 = smoothstep(e2,e3,x_686877309);\n  float a3 = smoothstep(e3,e4,x_686877309);\n  float a4 = smoothstep(e4,e5,x_686877309);\n  float a5 = smoothstep(e5,e6,x_686877309);\n  float a6 = smoothstep(e6,e7,x_686877309);\n  float a7 = smoothstep(e7,e8,x_686877309);\n  return max(mix(v0,v1,a0)*step(e0,x_686877309)*step(x_686877309,e1),\n    max(mix(v1,v2,a1)*step(e1,x_686877309)*step(x_686877309,e2),\n    max(mix(v2,v3,a2)*step(e2,x_686877309)*step(x_686877309,e3),\n    max(mix(v3,v4,a3)*step(e3,x_686877309)*step(x_686877309,e4),\n    max(mix(v4,v5,a4)*step(e4,x_686877309)*step(x_686877309,e5),\n    max(mix(v5,v6,a5)*step(e5,x_686877309)*step(x_686877309,e6),\n    max(mix(v6,v7,a6)*step(e6,x_686877309)*step(x_686877309,e7),mix(v7,v8,a7)*step(e7,x_686877309)*step(x_686877309,e8)\n  )))))));\n}\n\nvec4 greys (float x_3692066534) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(1,1,1,1);\n  float a0 = smoothstep(e0,e1,x_3692066534);\n  return mix(v0,v1,a0)*step(e0,x_3692066534)*step(x_3692066534,e1);\n}\n\nvec4 magma (float x_652973032) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0.01568627450980392,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.10980392156862745,0.06274509803921569,0.26666666666666666,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.30980392156862746,0.07058823529411765,0.4823529411764706,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.5058823529411764,0.1450980392156863,0.5058823529411764,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.7098039215686275,0.21176470588235294,0.47843137254901963,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.8980392156862745,0.3137254901960784,0.39215686274509803,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.984313725490196,0.5294117647058824,0.3803921568627451,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.996078431372549,0.7607843137254902,0.5294117647058824,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9882352941176471,0.9921568627450981,0.7490196078431373,1);\n  float a0 = smoothstep(e0,e1,x_652973032);\n  float a1 = smoothstep(e1,e2,x_652973032);\n  float a2 = smoothstep(e2,e3,x_652973032);\n  float a3 = smoothstep(e3,e4,x_652973032);\n  float a4 = smoothstep(e4,e5,x_652973032);\n  float a5 = smoothstep(e5,e6,x_652973032);\n  float a6 = smoothstep(e6,e7,x_652973032);\n  float a7 = smoothstep(e7,e8,x_652973032);\n  return max(mix(v0,v1,a0)*step(e0,x_652973032)*step(x_652973032,e1),\n    max(mix(v1,v2,a1)*step(e1,x_652973032)*step(x_652973032,e2),\n    max(mix(v2,v3,a2)*step(e2,x_652973032)*step(x_652973032,e3),\n    max(mix(v3,v4,a3)*step(e3,x_652973032)*step(x_652973032,e4),\n    max(mix(v4,v5,a4)*step(e4,x_652973032)*step(x_652973032,e5),\n    max(mix(v5,v6,a5)*step(e5,x_652973032)*step(x_652973032,e6),\n    max(mix(v6,v7,a6)*step(e6,x_652973032)*step(x_652973032,e7),mix(v7,v8,a7)*step(e7,x_652973032)*step(x_652973032,e8)\n  )))))));\n}\n\nvec4 jet (float x_799389509) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0.5137254901960784,1);\n  const float e1 = 0.125;\n  const vec4 v1 = vec4(0,0.23529411764705882,0.6666666666666666,1);\n  const float e2 = 0.375;\n  const vec4 v2 = vec4(0.0196078431372549,1,1,1);\n  const float e3 = 0.625;\n  const vec4 v3 = vec4(1,1,0,1);\n  const float e4 = 0.875;\n  const vec4 v4 = vec4(0.9803921568627451,0,0,1);\n  const float e5 = 1.0;\n  const vec4 v5 = vec4(0.5019607843137255,0,0,1);\n  float a0 = smoothstep(e0,e1,x_799389509);\n  float a1 = smoothstep(e1,e2,x_799389509);\n  float a2 = smoothstep(e2,e3,x_799389509);\n  float a3 = smoothstep(e3,e4,x_799389509);\n  float a4 = smoothstep(e4,e5,x_799389509);\n  return max(mix(v0,v1,a0)*step(e0,x_799389509)*step(x_799389509,e1),\n    max(mix(v1,v2,a1)*step(e1,x_799389509)*step(x_799389509,e2),\n    max(mix(v2,v3,a2)*step(e2,x_799389509)*step(x_799389509,e3),\n    max(mix(v3,v4,a3)*step(e3,x_799389509)*step(x_799389509,e4),mix(v4,v5,a4)*step(e4,x_799389509)*step(x_799389509,e5)\n  ))));\n}\n\nvec4 bone (float x_1404936397) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0,1);\n  const float e1 = 0.376;\n  const vec4 v1 = vec4(0.32941176470588235,0.32941176470588235,0.4549019607843137,1);\n  const float e2 = 0.753;\n  const vec4 v2 = vec4(0.6627450980392157,0.7843137254901961,0.7843137254901961,1);\n  const float e3 = 1.0;\n  const vec4 v3 = vec4(1,1,1,1);\n  float a0 = smoothstep(e0,e1,x_1404936397);\n  float a1 = smoothstep(e1,e2,x_1404936397);\n  float a2 = smoothstep(e2,e3,x_1404936397);\n  return max(mix(v0,v1,a0)*step(e0,x_1404936397)*step(x_1404936397,e1),\n    max(mix(v1,v2,a1)*step(e1,x_1404936397)*step(x_1404936397,e2),mix(v2,v3,a2)*step(e2,x_1404936397)*step(x_1404936397,e3)\n  ));\n}\n\nvec4 copper (float x_41650866) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0,1);\n  const float e1 = 0.804;\n  const vec4 v1 = vec4(1,0.6274509803921569,0.4,1);\n  const float e2 = 1.0;\n  const vec4 v2 = vec4(1,0.7803921568627451,0.4980392156862745,1);\n  float a0 = smoothstep(e0,e1,x_41650866);\n  float a1 = smoothstep(e1,e2,x_41650866);\n  return max(mix(v0,v1,a0)*step(e0,x_41650866)*step(x_41650866,e1),mix(v1,v2,a1)*step(e1,x_41650866)*step(x_41650866,e2)\n  );\n}\n\nvec4 density (float x_681601952) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.21176470588235294,0.054901960784313725,0.1411764705882353,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.34901960784313724,0.09019607843137255,0.3137254901960784,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.43137254901960786,0.17647058823529413,0.5176470588235295,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.47058823529411764,0.30196078431372547,0.6980392156862745,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.47058823529411764,0.44313725490196076,0.8352941176470589,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.45098039215686275,0.592156862745098,0.8941176470588236,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.5254901960784314,0.7254901960784313,0.8901960784313725,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.6941176470588235,0.8392156862745098,0.8901960784313725,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9019607843137255,0.9450980392156862,0.9450980392156862,1);\n  float a0 = smoothstep(e0,e1,x_681601952);\n  float a1 = smoothstep(e1,e2,x_681601952);\n  float a2 = smoothstep(e2,e3,x_681601952);\n  float a3 = smoothstep(e3,e4,x_681601952);\n  float a4 = smoothstep(e4,e5,x_681601952);\n  float a5 = smoothstep(e5,e6,x_681601952);\n  float a6 = smoothstep(e6,e7,x_681601952);\n  float a7 = smoothstep(e7,e8,x_681601952);\n  return max(mix(v0,v1,a0)*step(e0,x_681601952)*step(x_681601952,e1),\n    max(mix(v1,v2,a1)*step(e1,x_681601952)*step(x_681601952,e2),\n    max(mix(v2,v3,a2)*step(e2,x_681601952)*step(x_681601952,e3),\n    max(mix(v3,v4,a3)*step(e3,x_681601952)*step(x_681601952,e4),\n    max(mix(v4,v5,a4)*step(e4,x_681601952)*step(x_681601952,e5),\n    max(mix(v5,v6,a5)*step(e5,x_681601952)*step(x_681601952,e6),\n    max(mix(v6,v7,a6)*step(e6,x_681601952)*step(x_681601952,e7),mix(v7,v8,a7)*step(e7,x_681601952)*step(x_681601952,e8)\n  )))))));\n}\n\nvec4 inferno (float x_902288871) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0.01568627450980392,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.12156862745098039,0.047058823529411764,0.2823529411764706,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.3333333333333333,0.058823529411764705,0.42745098039215684,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.5333333333333333,0.13333333333333333,0.41568627450980394,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0.7294117647058823,0.21176470588235294,0.3333333333333333,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0.8901960784313725,0.34901960784313724,0.2,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0.9764705882352941,0.5490196078431373,0.0392156862745098,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.9764705882352941,0.788235294117647,0.19607843137254902,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.9882352941176471,1,0.6431372549019608,1);\n  float a0 = smoothstep(e0,e1,x_902288871);\n  float a1 = smoothstep(e1,e2,x_902288871);\n  float a2 = smoothstep(e2,e3,x_902288871);\n  float a3 = smoothstep(e3,e4,x_902288871);\n  float a4 = smoothstep(e4,e5,x_902288871);\n  float a5 = smoothstep(e5,e6,x_902288871);\n  float a6 = smoothstep(e6,e7,x_902288871);\n  float a7 = smoothstep(e7,e8,x_902288871);\n  return max(mix(v0,v1,a0)*step(e0,x_902288871)*step(x_902288871,e1),\n    max(mix(v1,v2,a1)*step(e1,x_902288871)*step(x_902288871,e2),\n    max(mix(v2,v3,a2)*step(e2,x_902288871)*step(x_902288871,e3),\n    max(mix(v3,v4,a3)*step(e3,x_902288871)*step(x_902288871,e4),\n    max(mix(v4,v5,a4)*step(e4,x_902288871)*step(x_902288871,e5),\n    max(mix(v5,v6,a5)*step(e5,x_902288871)*step(x_902288871,e6),\n    max(mix(v6,v7,a6)*step(e6,x_902288871)*step(x_902288871,e7),mix(v7,v8,a7)*step(e7,x_902288871)*step(x_902288871,e8)\n  )))))));\n}\n\nvec4 cool (float x_2444426143) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0.49019607843137253,0,0.7019607843137254,1);\n  const float e1 = 0.13;\n  const vec4 v1 = vec4(0.4549019607843137,0,0.8549019607843137,1);\n  const float e2 = 0.25;\n  const vec4 v2 = vec4(0.3843137254901961,0.2901960784313726,0.9294117647058824,1);\n  const float e3 = 0.38;\n  const vec4 v3 = vec4(0.26666666666666666,0.5725490196078431,0.9058823529411765,1);\n  const float e4 = 0.5;\n  const vec4 v4 = vec4(0,0.8,0.7725490196078432,1);\n  const float e5 = 0.63;\n  const vec4 v5 = vec4(0,0.9686274509803922,0.5725490196078431,1);\n  const float e6 = 0.75;\n  const vec4 v6 = vec4(0,1,0.34509803921568627,1);\n  const float e7 = 0.88;\n  const vec4 v7 = vec4(0.1568627450980392,1,0.03137254901960784,1);\n  const float e8 = 1.0;\n  const vec4 v8 = vec4(0.5764705882352941,1,0,1);\n  float a0 = smoothstep(e0,e1,x_2444426143);\n  float a1 = smoothstep(e1,e2,x_2444426143);\n  float a2 = smoothstep(e2,e3,x_2444426143);\n  float a3 = smoothstep(e3,e4,x_2444426143);\n  float a4 = smoothstep(e4,e5,x_2444426143);\n  float a5 = smoothstep(e5,e6,x_2444426143);\n  float a6 = smoothstep(e6,e7,x_2444426143);\n  float a7 = smoothstep(e7,e8,x_2444426143);\n  return max(mix(v0,v1,a0)*step(e0,x_2444426143)*step(x_2444426143,e1),\n    max(mix(v1,v2,a1)*step(e1,x_2444426143)*step(x_2444426143,e2),\n    max(mix(v2,v3,a2)*step(e2,x_2444426143)*step(x_2444426143,e3),\n    max(mix(v3,v4,a3)*step(e3,x_2444426143)*step(x_2444426143,e4),\n    max(mix(v4,v5,a4)*step(e4,x_2444426143)*step(x_2444426143,e5),\n    max(mix(v5,v6,a5)*step(e5,x_2444426143)*step(x_2444426143,e6),\n    max(mix(v6,v7,a6)*step(e6,x_2444426143)*step(x_2444426143,e7),mix(v7,v8,a7)*step(e7,x_2444426143)*step(x_2444426143,e8)\n  )))))));\n}\n\nvec4 hot (float x_1123650753) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,0,1);\n  const float e1 = 0.3;\n  const vec4 v1 = vec4(0.9019607843137255,0,0,1);\n  const float e2 = 0.6;\n  const vec4 v2 = vec4(1,0.8235294117647058,0,1);\n  const float e3 = 1.0;\n  const vec4 v3 = vec4(1,1,1,1);\n  float a0 = smoothstep(e0,e1,x_1123650753);\n  float a1 = smoothstep(e1,e2,x_1123650753);\n  float a2 = smoothstep(e2,e3,x_1123650753);\n  return max(mix(v0,v1,a0)*step(e0,x_1123650753)*step(x_1123650753,e1),\n    max(mix(v1,v2,a1)*step(e1,x_1123650753)*step(x_1123650753,e2),mix(v2,v3,a2)*step(e2,x_1123650753)*step(x_1123650753,e3)\n  ));\n}\n\nvec4 spring (float x_3460271019) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(1,0,1,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(1,1,0,1);\n  float a0 = smoothstep(e0,e1,x_3460271019);\n  return mix(v0,v1,a0)*step(e0,x_3460271019)*step(x_3460271019,e1);\n}\n\nvec4 summer (float x_1787574999) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0.5019607843137255,0.4,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(1,1,0.4,1);\n  float a0 = smoothstep(e0,e1,x_1787574999);\n  return mix(v0,v1,a0)*step(e0,x_1787574999)*step(x_1787574999,e1);\n}\n\nvec4 autumn (float x_204634793) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(1,0,0,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(1,1,0,1);\n  float a0 = smoothstep(e0,e1,x_204634793);\n  return mix(v0,v1,a0)*step(e0,x_204634793)*step(x_204634793,e1);\n}\n\nvec4 winter (float x_4071283602) {\n  const float e0 = 0.0;\n  const vec4 v0 = vec4(0,0,1,1);\n  const float e1 = 1.0;\n  const vec4 v1 = vec4(0,1,0.5019607843137255,1);\n  float a0 = smoothstep(e0,e1,x_4071283602);\n  return mix(v0,v1,a0)*step(e0,x_4071283602)*step(x_4071283602,e1);\n}\n\n// Custom attributes for Vitessce:\nattribute float expressionValue;\n\n// Custom uniforms for Vitessce:\nuniform vec2 uColorScaleRange;\nuniform bool uIsExpressionMode;\n\n";
var inject = {
  "vs:DECKGL_FILTER_COLOR": "\n    if(uIsExpressionMode) {\n      float normalizedExpressionValue = expressionValue / 255.0;\n      float scaledExpressionValue = (normalizedExpressionValue - uColorScaleRange[0]) / max(0.005, (uColorScaleRange[1] - uColorScaleRange[0]));\n      color.rgb = COLORMAP_FUNC(clamp(scaledExpressionValue, 0.0, 1.0)).rgb;\n    }\n  "
};
var shader_module_default = {
  name: "scaled-expression",
  vs: vs4,
  inject
};

// src/layer-extensions/ScaledExpressionExtension/ScaledExpressionExtension.js
var defaultProps6 = {
  colormap: { type: "string", value: GLSL_COLORMAP_DEFAULT, compare: true },
  colorScaleLo: { type: "number", value: 0, compare: true },
  colorScaleHi: { type: "number", value: 1, compare: true },
  isExpressionMode: false,
  getExpressionValue: { type: "accessor", value: 0 },
  getSelectionState: { type: "accessor", value: 0 }
};
var ScaledExpressionExtension = class extends LayerExtension {
  getShaders() {
    const { colormap } = this.props;
    return {
      modules: [shader_module_default],
      defines: {
        [COLORMAP_SHADER_PLACEHOLDER]: GLSL_COLORMAPS.includes(colormap) ? colormap : GLSL_COLORMAP_DEFAULT
      }
    };
  }
  updateState({ props, oldProps }) {
    var _a2, _b2, _c, _d;
    if (props.colormap !== oldProps.colormap) {
      const { gl } = this.context;
      if (this.state.model) {
        (_a2 = this.state.model) == null ? void 0 : _a2.delete();
        this.state.model = this._getModel(gl);
      } else {
        if (this.state.models) {
          (_b2 = this.state.models) == null ? void 0 : _b2.forEach((model) => model == null ? void 0 : model.delete());
        }
        if (this.state.topModel) {
          (_c = this.state.topModel) == null ? void 0 : _c.delete();
        }
        if (this.state.sideModel) {
          (_d = this.state.sideModel) == null ? void 0 : _d.delete();
        }
        if (this._getModels) {
          this.setState(this._getModels(this.context.gl));
        }
      }
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        this.getAttributeManager().invalidateAll();
      }
    }
  }
  initializeState() {
    const layer = this.getCurrentLayer();
    if (layer.isComposite) {
      return;
    }
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.add({
        expressionValue: {
          type: GL5.FLOAT,
          size: 1,
          transition: true,
          accessor: "getExpressionValue",
          defaultValue: 1,
          divisor: Object.values(attributeManager.attributes)[0].settings.divisor
        }
      });
    }
  }
  draw() {
    const {
      colorScaleLo,
      colorScaleHi,
      isExpressionMode
    } = this.props;
    const {
      topModel,
      sideModel,
      models,
      model
    } = this.state;
    const uniforms = {
      uColorScaleRange: [colorScaleLo, colorScaleHi],
      uIsExpressionMode: isExpressionMode
    };
    model == null ? void 0 : model.setUniforms(uniforms);
    models == null ? void 0 : models.forEach((m) => m.setUniforms(uniforms));
    topModel == null ? void 0 : topModel.setUniforms(uniforms);
    sideModel == null ? void 0 : sideModel.setUniforms(uniforms);
  }
};
ScaledExpressionExtension.extensionName = "ScaledExpressionExtension";
ScaledExpressionExtension.defaultProps = defaultProps6;

// src/layer-extensions/ScaledExpressionExtension/index.js
var ScaledExpressionExtension_default = ScaledExpressionExtension;

// src/layer-extensions/SelectionExtension/SelectionExtension.js
import GL6 from "@luma.gl/constants";
import { LayerExtension as LayerExtension2 } from "@deck.gl/core";

// src/layer-extensions/SelectionExtension/shader-module.js
var vs5 = "\nattribute float isSelected;\n";
var inject2 = {
  "vs:DECKGL_FILTER_GL_POSITION": "\n    position.z += (1. - isSelected) * .00005; // Add a small z offset for unselected points in the positive direction i.e into the screen.\n  ",
  "fs:#main-start": " // Gets rid of bad border effects (active after deck.gl 8.5): https://github.com/visgl/deck.gl/pull/6081\n    float distToCenterNew = length(unitPosition) * outerRadiusPixels;\n    float inCircleNew = step(distToCenterNew, outerRadiusPixels);\n    if (inCircleNew == 0.0) {\n      discard;\n    }\n  "
};
var shader_module_default2 = {
  name: "selection",
  vs: vs5,
  inject: inject2
};

// src/layer-extensions/SelectionExtension/SelectionExtension.js
var SelectionExtension = class extends LayerExtension2 {
  getShaders() {
    return {
      modules: [shader_module_default2]
    };
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.add({
        isSelected: {
          type: GL6.FLOAT,
          size: 1,
          transition: true,
          accessor: "getCellIsSelected",
          defaultValue: 1,
          divisor: Number(extension.opts.instanced)
        }
      });
    }
  }
};
SelectionExtension.extensionName = "SelectionExtension";

// src/layer-extensions/SelectionExtension/index.js
var SelectionExtension_default = SelectionExtension;

// src/components/spatial/Spatial.js
var CELLS_LAYER_ID = "cells-layer";
var MOLECULES_LAYER_ID = "molecules-layer";
var NEIGHBORHOODS_LAYER_ID = "neighborhoods-layer";
var defaultGetCellCoords = (cell) => cell.xy;
var makeDefaultGetCellPolygon = (radius) => (cellEntry) => {
  var _a2;
  const cell = cellEntry[1];
  return ((_a2 = cell.poly) == null ? void 0 : _a2.length) ? cell.poly : square(cell.xy[0], cell.xy[1], radius);
};
var makeDefaultGetCellColors = (cellColors, theme) => (cellEntry) => {
  const [r, g, b, a] = cellColors && cellColors.get(cellEntry[0]) || getDefaultColor(theme);
  return [r, g, b, 255 * (a || 1)];
};
var makeDefaultGetCellIsSelected = (cellSelection) => {
  if (cellSelection) {
    const cellSelectionSet = new Set(cellSelection);
    return (cellEntry) => cellSelectionSet.has(cellEntry[0]) ? 1 : 0;
  }
  return () => 0;
};
var Spatial = class extends AbstractSpatialOrScatterplot {
  constructor(props) {
    super(props);
    this.cellsEntries = [];
    this.moleculesEntries = [];
    this.cellsQuadTree = null;
    this.cellsLayer = null;
    this.moleculesLayer = null;
    this.neighborhoodsLayer = null;
    this.imageLayers = [];
    this.layerLoaderSelections = {};
    this.randomColorData = {
      data: new Uint8Array(2048 * 2048 * 3).map((_, j) => j < 4 ? 0 : Math.round(255 * Math.random())),
      height: 2048,
      width: 2048
    };
    this.color = __spreadValues({}, this.randomColorData);
    this.expression = {
      data: new Uint8Array(2048 * 2048),
      height: 2048,
      width: 2048
    };
    this.onUpdateCellsData();
    this.onUpdateCellsLayer();
    this.onUpdateMoleculesData();
    this.onUpdateMoleculesLayer();
    this.onUpdateNeighborhoodsData();
    this.onUpdateNeighborhoodsLayer();
    this.onUpdateImages();
  }
  createCellsLayer(layerDef) {
    const {
      radius,
      stroked,
      visible,
      opacity
    } = layerDef;
    const { cellsEntries } = this;
    const {
      theme,
      cellFilter,
      cellSelection,
      setCellHighlight,
      setComponentHover,
      getCellIsSelected = makeDefaultGetCellIsSelected(cellsEntries.length === cellSelection.length ? null : cellSelection),
      cellColors,
      getCellColor = makeDefaultGetCellColors(cellColors, theme),
      getCellPolygon = makeDefaultGetCellPolygon(radius),
      onCellClick,
      lineWidthScale = 10,
      lineWidthMaxPixels = 2,
      geneExpressionColormapRange,
      cellColorEncoding,
      getExpressionValue,
      geneExpressionColormap
    } = this.props;
    const filteredCellsEntries = cellFilter ? cellsEntries.filter((cellEntry) => cellFilter.includes(cellEntry[0])) : cellsEntries;
    const flipYTooltip = true;
    return new PolygonLayer2(__spreadValues({
      id: CELLS_LAYER_ID,
      backgroundColor: [0, 0, 0],
      isSelected: getCellIsSelected,
      getPolygon: getCellPolygon,
      updateTriggers: {
        getLineWidth: [stroked],
        isSelected: cellSelection,
        getExpressionValue,
        getFillColor: [opacity, cellColorEncoding, cellSelection, cellColors],
        getLineColor: [cellColorEncoding, cellSelection, cellColors]
      },
      getFillColor: (cellEntry) => {
        const color = getCellColor(cellEntry);
        color[3] = opacity * 255;
        return color;
      },
      getLineColor: (cellEntry) => {
        const color = getCellColor(cellEntry);
        color[3] = 255;
        return color;
      },
      onClick: (info) => {
        if (onCellClick) {
          onCellClick(info);
        }
      },
      visible,
      getLineWidth: stroked ? 1 : 0,
      lineWidthScale,
      lineWidthMaxPixels,
      getExpressionValue,
      extensions: [new ScaledExpressionExtension_default()],
      colorScaleLo: geneExpressionColormapRange[0],
      colorScaleHi: geneExpressionColormapRange[1],
      isExpressionMode: cellColorEncoding === "geneSelection",
      colormap: geneExpressionColormap
    }, cellLayerDefaultProps(filteredCellsEntries, void 0, setCellHighlight, setComponentHover, flipYTooltip)));
  }
  createMoleculesLayer(layerDef) {
    const {
      setMoleculeHighlight,
      getMoleculeColor = (d) => PALETTE[d[2] % PALETTE.length],
      getMoleculePosition = (d) => [d[0], d[1], 0]
    } = this.props;
    const { moleculesEntries } = this;
    return new ScatterplotLayer2({
      id: MOLECULES_LAYER_ID,
      coordinateSystem: COORDINATE_SYSTEM5.CARTESIAN,
      data: moleculesEntries,
      pickable: true,
      autoHighlight: true,
      radiusMaxPixels: 3,
      opacity: layerDef.opacity,
      visible: layerDef.visible,
      getRadius: layerDef.radius,
      getPosition: getMoleculePosition,
      getLineColor: getMoleculeColor,
      getFillColor: getMoleculeColor,
      onHover: (info) => {
        if (setMoleculeHighlight) {
          if (info.object) {
            setMoleculeHighlight(info.object[3]);
          } else {
            setMoleculeHighlight(null);
          }
        }
      }
    });
  }
  createNeighborhoodsLayer(layerDef) {
    const {
      getNeighborhoodPolygon = (neighborhoodsEntry) => {
        const neighborhood = neighborhoodsEntry[1];
        return neighborhood.poly;
      }
    } = this.props;
    const { neighborhoodsEntries } = this;
    return new PolygonLayer2({
      id: NEIGHBORHOODS_LAYER_ID,
      getPolygon: getNeighborhoodPolygon,
      coordinateSystem: COORDINATE_SYSTEM5.CARTESIAN,
      data: neighborhoodsEntries,
      pickable: true,
      autoHighlight: true,
      stroked: true,
      filled: false,
      getElevation: 0,
      getLineWidth: 10,
      visible: layerDef.visible
    });
  }
  createSelectionLayers() {
    const {
      viewState,
      getCellCoords = defaultGetCellCoords,
      setCellSelection: setCellSelection2
    } = this.props;
    const { tool } = this.state;
    const { cellsQuadTree } = this;
    return getSelectionLayers(tool, viewState.zoom, CELLS_LAYER_ID, getCellCoords, setCellSelection2, cellsQuadTree);
  }
  createScaleBarLayer() {
    const {
      viewState,
      width,
      height,
      imageLayerLoaders = {},
      layers
    } = this.props;
    const use3d = (layers || []).some((i) => i.use3d);
    const loaders = Object.values(imageLayerLoaders);
    if (!viewState || !width || !height || loaders.length < 1)
      return null;
    const loader = loaders[0];
    if (!loader)
      return null;
    const source = getSourceFromLoader(loader);
    if (!source.meta)
      return null;
    const { physicalSizes } = source.meta;
    if (physicalSizes && !use3d) {
      const { x } = physicalSizes;
      const { unit: unit2, size } = x;
      if (unit2 && size) {
        return new ScaleBarLayer({
          id: "scalebar-layer",
          unit: unit2,
          size,
          viewState: __spreadProps(__spreadValues({}, viewState), { width, height })
        });
      }
      return null;
    }
    return null;
  }
  createImageLayer(rawLayerDef, loader, i) {
    const layerDef = __spreadProps(__spreadValues({}, rawLayerDef), {
      channels: rawLayerDef.channels.filter((channel) => channel.selection && channel.color && channel.slider)
    });
    let selections;
    const nextLoaderSelection = layerDef.channels.map((c) => c.selection);
    const prevLoaderSelection = this.layerLoaderSelections[layerDef.index];
    if (isEqual5(prevLoaderSelection, nextLoaderSelection)) {
      selections = prevLoaderSelection;
    } else {
      selections = nextLoaderSelection;
      this.layerLoaderSelections[layerDef.index] = nextLoaderSelection;
    }
    const layerProps = {
      colormap: layerDef.colormap,
      opacity: layerDef.opacity,
      transparentColor: layerDef.transparentColor,
      colors: layerDef.channels.map((c) => c.color),
      sliders: layerDef.channels.map((c) => c.slider),
      resolution: layerDef.resolution,
      renderingMode: layerDef.renderingMode,
      xSlice: layerDef.xSlice,
      ySlice: layerDef.ySlice,
      zSlice: layerDef.zSlice,
      callback: layerDef.callback,
      visibilities: layerDef.channels.map((c) => !layerDef.visible && typeof layerDef.visible === "boolean" ? false : c.visible)
    };
    if (!loader || !layerProps)
      return null;
    const {
      metadata: { transform },
      data
    } = loader;
    let modelMatrix;
    if (transform) {
      const { scale, translate } = transform;
      modelMatrix = new Matrix44().translate([translate.x, translate.y, 0]).scale(scale);
    } else if (layerDef.modelMatrix) {
      modelMatrix = new Matrix44(layerDef.modelMatrix);
    }
    if (rawLayerDef.type === "bitmask") {
      const {
        geneExpressionColormap,
        geneExpressionColormapRange = [0, 1],
        cellColorEncoding
      } = this.props;
      return new MultiscaleImageLayer({
        id: `bitmask-layer-${layerDef.index}-${i}`,
        channelsVisible: layerProps.visibilities,
        opacity: layerProps.opacity,
        modelMatrix,
        hoveredCell: Number(this.props.cellHighlight),
        renderSubLayers: renderSubBitmaskLayers,
        loader: data,
        selections,
        cellColorData: this.color.data,
        cellTexHeight: this.color.height,
        cellTexWidth: this.color.width,
        excludeBackground: true,
        onViewportLoad: layerProps.callback,
        colorScaleLo: geneExpressionColormapRange[0],
        colorScaleHi: geneExpressionColormapRange[1],
        isExpressionMode: cellColorEncoding === "geneSelection",
        colormap: geneExpressionColormap,
        expressionData: this.expression.data
      });
    }
    const [Layer2, layerLoader] = getLayerLoaderTuple(data, layerDef.use3d);
    return new Layer2({
      loader: layerLoader,
      id: `${layerDef.use3d ? "volume" : "image"}-layer-${layerDef.index}-${i}`,
      colors: layerProps.colors,
      contrastLimits: layerProps.sliders,
      selections,
      channelsVisible: layerProps.visibilities,
      opacity: layerProps.opacity,
      colormap: layerProps.colormap,
      modelMatrix,
      transparentColor: layerProps.transparentColor,
      resolution: layerProps.resolution,
      renderingMode: layerProps.renderingMode,
      pickable: false,
      xSlice: layerProps.xSlice,
      ySlice: layerProps.ySlice,
      zSlice: layerProps.zSlice,
      onViewportLoad: layerProps.callback
    });
  }
  createImageLayers() {
    const {
      layers,
      imageLayerLoaders = {},
      rasterLayersCallbacks = []
    } = this.props;
    const use3d = (layers || []).some((i) => i.use3d);
    const use3dIndex = (layers || []).findIndex((i) => i.use3d);
    return (layers || []).filter((layer) => layer.type === "raster" || layer.type === "bitmask").filter((layer) => use3d ? layer.use3d === use3d : true).map((layer, i) => this.createImageLayer(__spreadProps(__spreadValues({}, layer), { callback: rasterLayersCallbacks[use3d ? use3dIndex : i] }), imageLayerLoaders[layer.index], i));
  }
  getLayers() {
    const {
      imageLayers,
      cellsLayer,
      neighborhoodsLayer,
      moleculesLayer
    } = this;
    return [
      ...imageLayers,
      cellsLayer,
      neighborhoodsLayer,
      moleculesLayer,
      this.createScaleBarLayer(),
      ...this.createSelectionLayers()
    ];
  }
  onUpdateCellsData() {
    const { cells = {}, getCellCoords = defaultGetCellCoords } = this.props;
    const cellsEntries = Object.entries(cells);
    this.cellsEntries = cellsEntries;
    this.cellsQuadTree = createCellsQuadTree(cellsEntries, getCellCoords);
  }
  onUpdateCellsLayer() {
    const { layers } = this.props;
    const layerDef = (layers || []).find((layer) => layer.type === "cells");
    if (layerDef) {
      this.cellsLayer = this.createCellsLayer(layerDef);
    } else {
      this.cellsLayer = null;
    }
  }
  onUpdateCellColors() {
    const color = this.randomColorData;
    const { size } = this.props.cellColors;
    if (typeof size === "number") {
      const cellIds = this.props.cellColors.keys();
      color.data = new Uint8Array(color.height * color.width * 3).fill(getDefaultColor(this.props.theme)[0]);
      color.data[0] = 0;
      color.data[1] = 0;
      color.data[2] = 0;
      for (const id of cellIds) {
        if (id > 0) {
          const cellColor = this.props.cellColors.get(id);
          if (cellColor) {
            color.data.set(cellColor.slice(0, 3), Number(id) * 3);
          }
        }
      }
    }
    this.color = color;
  }
  onUpdateExpressionData() {
    var _a2;
    const { expressionData } = this.props;
    if ((_a2 = expressionData[0]) == null ? void 0 : _a2.length) {
      this.expression.data = new Uint8Array(this.expression.height * this.expression.width);
      this.expression.data.set(expressionData[0]);
    }
  }
  onUpdateMoleculesData() {
    const { molecules = {} } = this.props;
    const moleculesEntries = Object.entries(molecules).flatMap(([molecule, coords], index) => coords.map(([x, y]) => [x, y, index, molecule]));
    this.moleculesEntries = moleculesEntries;
  }
  onUpdateMoleculesLayer() {
    const { layers } = this.props;
    const layerDef = (layers || []).find((layer) => layer.type === "molecules");
    if (layerDef) {
      this.moleculesLayer = this.createMoleculesLayer(layerDef);
    } else {
      this.moleculesLayer = null;
    }
  }
  onUpdateNeighborhoodsData() {
    const { neighborhoods = {} } = this.props;
    const neighborhoodsEntries = Object.entries(neighborhoods);
    this.neighborhoodsEntries = neighborhoodsEntries;
  }
  onUpdateNeighborhoodsLayer() {
    const { layers } = this.props;
    const layerDef = (layers || []).find((layer) => layer.type === "neighborhoods");
    if (layerDef) {
      this.neighborhoodsLayer = this.createNeighborhoodsLayer(layerDef);
    } else {
      this.neighborhoodsLayer = null;
    }
  }
  onUpdateImages() {
    this.imageLayers = this.createImageLayers();
  }
  viewInfoDidUpdate() {
    const { getCellCoords = defaultGetCellCoords } = this.props;
    super.viewInfoDidUpdate(getCellCoords);
  }
  componentDidUpdate(prevProps) {
    this.viewInfoDidUpdate();
    const shallowDiff = (propName) => prevProps[propName] !== this.props[propName];
    if (["cells"].some(shallowDiff)) {
      this.onUpdateCellsData();
      this.forceUpdate();
    }
    if ([
      "layers",
      "cells",
      "cellFilter",
      "cellSelection",
      "cellColors",
      "geneExpressionColormapRange",
      "cellColorEncoding",
      "geneExpressionColormap"
    ].some(shallowDiff)) {
      this.onUpdateCellsLayer();
      this.forceUpdate();
    }
    if (["cellColors"].some(shallowDiff)) {
      this.onUpdateCellColors();
      this.forceUpdate();
    }
    if (["expressionData"].some(shallowDiff)) {
      this.onUpdateExpressionData();
      this.forceUpdate();
    }
    if (["molecules"].some(shallowDiff)) {
      this.onUpdateMoleculesData();
      this.forceUpdate();
    }
    if (["layers", "molecules"].some(shallowDiff)) {
      this.onUpdateMoleculesLayer();
      this.forceUpdate();
    }
    if (["neighborhoods"].some(shallowDiff)) {
      this.onUpdateNeighborhoodsData();
      this.forceUpdate();
    }
    if (["layers", "neighborhoods"].some(shallowDiff)) {
      this.onUpdateNeighborhoodsLayer();
      this.forceUpdate();
    }
    if ([
      "layers",
      "imageLayerLoaders",
      "cellColors",
      "cellHighlight",
      "geneExpressionColormapRange",
      "expressionData",
      "rasterLayersCallbacks",
      "geneExpressionColormap"
    ].some(shallowDiff)) {
      this.onUpdateImages();
      this.forceUpdate();
    }
  }
};
var SpatialWrapper = forwardRef2((props, deckRef) => /* @__PURE__ */ React20.createElement(Spatial, __spreadProps(__spreadValues({}, props), {
  deckRef
})));
var Spatial_default = SpatialWrapper;

// src/components/spatial/SpatialOptions.js
import React22, { useCallback as useCallback6 } from "react";
import debounce3 from "lodash/debounce";
import Checkbox from "@material-ui/core/Checkbox";
import TableCell3 from "@material-ui/core/TableCell";
import TableRow3 from "@material-ui/core/TableRow";
import Slider2 from "@material-ui/core/Slider";
import { makeStyles as makeStyles5, createStyles } from "@material-ui/core/styles";

// src/components/shared-plot-options/CellColorEncodingOption.js
import React21 from "react";
import TableCell2 from "@material-ui/core/TableCell";
import TableRow2 from "@material-ui/core/TableRow";
function CellColorEncodingOption(props) {
  const {
    observationsLabel,
    cellColorEncoding,
    setCellColorEncoding
  } = props;
  const classes = useStyles2();
  const observationsLabelNice = capitalize(observationsLabel);
  function handleColorEncodingChange(event) {
    setCellColorEncoding(event.target.value);
  }
  return /* @__PURE__ */ React21.createElement(TableRow2, null, /* @__PURE__ */ React21.createElement(TableCell2, {
    className: classes.labelCell,
    htmlFor: "cell-color-encoding-select"
  }, observationsLabelNice, " Color Encoding"), /* @__PURE__ */ React21.createElement(TableCell2, {
    className: classes.inputCell
  }, /* @__PURE__ */ React21.createElement(OptionSelect, {
    className: classes.select,
    value: cellColorEncoding,
    onChange: handleColorEncodingChange,
    inputProps: {
      id: "cell-color-encoding-select"
    }
  }, /* @__PURE__ */ React21.createElement("option", {
    value: "cellSetSelection"
  }, "Cell Sets"), /* @__PURE__ */ React21.createElement("option", {
    value: "geneSelection"
  }, "Gene Expression"))));
}

// src/components/spatial/SpatialOptions.js
var useToggleStyles = makeStyles5(() => createStyles({
  cameraLabel: {
    padding: "0px 0px 0px 16px"
  },
  box: {
    padding: "0px"
  },
  button: {
    padding: "0px 0px 0px 8px"
  }
}));
var ToggleFixedAxisButton = ({
  setSpatialAxisFixed,
  spatialAxisFixed,
  use3d
}) => {
  const classes = useToggleStyles();
  return /* @__PURE__ */ React22.createElement(TableRow3, null, /* @__PURE__ */ React22.createElement(TableCell3, {
    className: classes.cameraLabel
  }, "Fix Camera Axis"), /* @__PURE__ */ React22.createElement(TableCell3, {
    className: classes.box
  }, /* @__PURE__ */ React22.createElement(Checkbox, {
    onClick: () => setSpatialAxisFixed(!spatialAxisFixed),
    disabled: !use3d,
    checked: Boolean(spatialAxisFixed)
  })));
};
function SpatialOptions(props) {
  const {
    observationsLabel,
    cellColorEncoding,
    setCellColorEncoding,
    setSpatialAxisFixed,
    spatialAxisFixed,
    use3d,
    geneExpressionColormap,
    setGeneExpressionColormap,
    geneExpressionColormapRange,
    setGeneExpressionColormapRange,
    canShowExpressionOptions,
    canShowColorEncodingOption,
    canShow3DOptions
  } = props;
  function handleGeneExpressionColormapChange(event) {
    setGeneExpressionColormap(event.target.value);
  }
  function handleColormapRangeChange(event, value) {
    setGeneExpressionColormapRange(value);
  }
  const handleColormapRangeChangeDebounced = useCallback6(debounce3(handleColormapRangeChange, 5, { trailing: true }), [handleColormapRangeChange]);
  const classes = useStyles2();
  return /* @__PURE__ */ React22.createElement(OptionsContainer, null, canShowColorEncodingOption ? /* @__PURE__ */ React22.createElement(CellColorEncodingOption, {
    observationsLabel,
    cellColorEncoding,
    setCellColorEncoding
  }) : null, canShow3DOptions ? /* @__PURE__ */ React22.createElement(ToggleFixedAxisButton, {
    setSpatialAxisFixed,
    spatialAxisFixed,
    use3d
  }) : null, canShowExpressionOptions ? /* @__PURE__ */ React22.createElement(React22.Fragment, null, /* @__PURE__ */ React22.createElement(TableRow3, null, /* @__PURE__ */ React22.createElement(TableCell3, {
    className: classes.labelCell,
    htmlFor: "gene-expression-colormap-select"
  }, "Gene Expression Colormap"), /* @__PURE__ */ React22.createElement(TableCell3, {
    className: classes.inputCell
  }, /* @__PURE__ */ React22.createElement(OptionSelect, {
    className: classes.select,
    value: geneExpressionColormap,
    onChange: handleGeneExpressionColormapChange,
    inputProps: {
      id: "gene-expression-colormap-select"
    }
  }, GLSL_COLORMAPS.map((cmap) => /* @__PURE__ */ React22.createElement("option", {
    key: cmap,
    value: cmap
  }, cmap))))), /* @__PURE__ */ React22.createElement(TableRow3, null, /* @__PURE__ */ React22.createElement(TableCell3, {
    className: classes.labelCell
  }, "Gene Expression Colormap Range"), /* @__PURE__ */ React22.createElement(TableCell3, {
    className: classes.inputCell
  }, /* @__PURE__ */ React22.createElement(Slider2, {
    classes: { root: classes.slider, valueLabel: classes.sliderValueLabel },
    value: geneExpressionColormapRange,
    onChange: handleColormapRangeChangeDebounced,
    "aria-labelledby": "gene-expression-colormap-range-slider",
    valueLabelDisplay: "auto",
    step: 5e-3,
    min: 0,
    max: 1
  })))) : null);
}

// src/components/spatial/SpatialTooltipSubscriber.js
import React23 from "react";
function SpatialTooltipSubscriber(props) {
  const {
    parentUuid,
    cellHighlight,
    width,
    height,
    getCellInfo
  } = props;
  const sourceUuid = useComponentHover();
  const viewInfo = useComponentViewInfo(parentUuid);
  const [cellInfo, x, y] = cellHighlight && getCellInfo ? [
    getCellInfo(cellHighlight),
    ...viewInfo && viewInfo.project ? viewInfo.project(cellHighlight) : [null, null]
  ] : [null, null, null];
  return cellInfo ? /* @__PURE__ */ React23.createElement(Tooltip2D, {
    x,
    y,
    parentUuid,
    sourceUuid,
    parentWidth: width,
    parentHeight: height
  }, /* @__PURE__ */ React23.createElement(TooltipContent, {
    info: cellInfo
  })) : null;
}

// src/components/spatial/SpatialSubscriber.js
var SPATIAL_DATA_TYPES = [
  "cells",
  "molecules",
  "raster",
  "cell-sets",
  "expression-matrix"
];
function SpatialSubscriber(props) {
  const {
    uuid,
    coordinationScopes,
    removeGridComponent,
    observationsLabelOverride: observationsLabel = "cell",
    observationsPluralLabelOverride: observationsPluralLabel = `${observationsLabel}s`,
    subobservationsLabelOverride: subobservationsLabel = "molecule",
    subobservationsPluralLabelOverride: subobservationsPluralLabel = `${subobservationsLabel}s`,
    theme,
    disableTooltip = false,
    title: title16 = "Spatial",
    disable3d,
    globalDisable3d
  } = props;
  const loaders = useLoaders();
  const setComponentHover = useSetComponentHover();
  const setComponentViewInfo = useSetComponentViewInfo(uuid);
  const [{
    dataset,
    spatialZoom: zoom,
    spatialTargetX: targetX,
    spatialTargetY: targetY,
    spatialTargetZ: targetZ,
    spatialRotationX: rotationX,
    spatialRotationY: rotationY,
    spatialRotationZ: rotationZ,
    spatialRotationOrbit: rotationOrbit,
    spatialOrbitAxis: orbitAxis,
    spatialRasterLayers: rasterLayers,
    spatialCellsLayer: cellsLayer,
    spatialMoleculesLayer: moleculesLayer,
    spatialNeighborhoodsLayer: neighborhoodsLayer,
    cellFilter,
    cellHighlight,
    geneSelection,
    cellSetSelection,
    cellSetColor,
    cellColorEncoding,
    additionalCellSets,
    spatialAxisFixed,
    geneExpressionColormap,
    geneExpressionColormapRange
  }, {
    setSpatialZoom: setZoom,
    setSpatialTargetX: setTargetX,
    setSpatialTargetY: setTargetY,
    setSpatialTargetZ: setTargetZ,
    setSpatialRotationX: setRotationX,
    setSpatialRotationOrbit: setRotationOrbit,
    setSpatialOrbitAxis: setOrbitAxis,
    setSpatialRasterLayers: setRasterLayers,
    setSpatialCellsLayer: setCellsLayer,
    setSpatialMoleculesLayer: setMoleculesLayer,
    setSpatialNeighborhoodsLayer: setNeighborhoodsLayer,
    setCellFilter,
    setCellSetSelection,
    setCellHighlight,
    setCellSetColor,
    setCellColorEncoding,
    setAdditionalCellSets,
    setMoleculeHighlight,
    setSpatialAxisFixed,
    setGeneExpressionColormap,
    setGeneExpressionColormapRange
  }] = useCoordination(COMPONENT_COORDINATION_TYPES.spatial, coordinationScopes);
  const [
    {
      rasterLayersCallbacks
    }
  ] = useAuxiliaryCoordination(COMPONENT_COORDINATION_TYPES.layerController, coordinationScopes);
  const use3d = rasterLayers == null ? void 0 : rasterLayers.some((l) => l.use3d);
  const [urls, addUrl, resetUrls] = useUrls();
  const [
    isReady,
    setItemIsReady,
    setItemIsNotReady,
    resetReadyItems
  ] = useReady(SPATIAL_DATA_TYPES);
  const [width, height, deckRef] = useDeckCanvasSize();
  useEffect6(() => {
    resetUrls();
    resetReadyItems();
  }, [loaders, dataset]);
  const [cells, cellsCount] = useCellsData(loaders, dataset, setItemIsReady, addUrl, false, { setSpatialCellsLayer: setCellsLayer }, { spatialCellsLayer: cellsLayer });
  const [molecules, moleculesCount, locationsCount] = useMoleculesData(loaders, dataset, setItemIsReady, addUrl, false, { setSpatialMoleculesLayer: setMoleculesLayer }, { spatialMoleculesLayer: moleculesLayer });
  const [neighborhoods] = useNeighborhoodsData(loaders, dataset, setItemIsReady, addUrl, false, { setSpatialNeighborhoodsLayer: setNeighborhoodsLayer }, { spatialNeighborhoodsLayer: neighborhoodsLayer });
  const [cellSets] = useCellSetsData(loaders, dataset, setItemIsReady, addUrl, false, { setCellSetSelection, setCellSetColor }, { cellSetSelection, cellSetColor });
  const [expressionData] = useGeneSelection(loaders, dataset, setItemIsReady, false, geneSelection, setItemIsNotReady);
  const [attrs] = useExpressionAttrs(loaders, dataset, setItemIsReady, addUrl, false);
  const [raster, imageLayerLoaders, imageLayerMeta] = useRasterData(loaders, dataset, setItemIsReady, addUrl, false, { setSpatialRasterLayers: setRasterLayers }, { spatialRasterLayers: rasterLayers });
  const layers = useMemo6(() => {
    const canPassInCellsLayer = !imageLayerMeta.some((l) => {
      var _a2;
      return (_a2 = l == null ? void 0 : l.metadata) == null ? void 0 : _a2.isBitmask;
    });
    return [
      ...moleculesLayer ? [__spreadProps(__spreadValues({}, moleculesLayer), { type: "molecules" })] : [],
      ...cellsLayer && canPassInCellsLayer ? [__spreadProps(__spreadValues({}, cellsLayer), { type: "cells" })] : [],
      ...neighborhoodsLayer ? [__spreadProps(__spreadValues({}, neighborhoodsLayer), { type: "neighborhoods" })] : [],
      ...rasterLayers ? rasterLayers.map((l) => __spreadProps(__spreadValues({}, l), { type: l.type && ["raster", "bitmask"].includes(l.type) ? l.type : "raster" })) : []
    ];
  }, [cellsLayer, moleculesLayer, neighborhoodsLayer, rasterLayers, imageLayerMeta]);
  useEffect6(() => {
    if (typeof targetX !== "number" || typeof targetY !== "number") {
      const {
        initialTargetX,
        initialTargetY,
        initialTargetZ,
        initialZoom
      } = getInitialSpatialTargets({
        width,
        height,
        cells,
        imageLayerLoaders,
        useRaster: Boolean(loaders[dataset].loaders.raster),
        use3d
      });
      setTargetX(initialTargetX);
      setTargetY(initialTargetY);
      setTargetZ(initialTargetZ);
      setZoom(initialZoom);
    }
  }, [imageLayerLoaders, cells, targetX, targetY, setTargetX, setTargetY, setZoom, use3d]);
  const mergedCellSets = useMemo6(() => mergeCellSets(cellSets, additionalCellSets), [cellSets, additionalCellSets]);
  const setCellSelectionProp = useCallback7((v) => {
    setCellSelection(v, additionalCellSets, cellSetColor, setCellSetSelection, setAdditionalCellSets, setCellSetColor, setCellColorEncoding);
  }, [
    additionalCellSets,
    cellSetColor,
    setCellColorEncoding,
    setAdditionalCellSets,
    setCellSetColor,
    setCellSetSelection
  ]);
  const cellColors = useMemo6(() => getCellColors({
    cellColorEncoding,
    expressionData: expressionData && expressionData[0],
    geneSelection,
    cellSets: mergedCellSets,
    cellSetSelection,
    cellSetColor,
    expressionDataAttrs: attrs,
    theme
  }), [
    cellColorEncoding,
    geneSelection,
    mergedCellSets,
    theme,
    cellSetColor,
    cellSetSelection,
    expressionData,
    attrs
  ]);
  const shiftedExpressionDataForBitmask = useMemo6(() => {
    const hasBitmask = imageLayerMeta.some((l) => {
      var _a2;
      return (_a2 = l == null ? void 0 : l.metadata) == null ? void 0 : _a2.isBitmask;
    });
    if ((attrs == null ? void 0 : attrs.rows) && expressionData && hasBitmask) {
      const maxId = attrs.rows.reduce((max2, curr) => Math.max(max2, Number(curr)));
      const result = new Uint8Array(maxId + 1);
      for (let i = 0; i < attrs.rows.length; i++) {
        const id = attrs.rows[i];
        result.set(expressionData[0].slice(i, i + 1), Number(id));
      }
      return [result];
    }
    return [new Uint8Array()];
  }, [attrs, expressionData, imageLayerMeta]);
  const cellSelection = useMemo6(() => Array.from(cellColors.keys()), [cellColors]);
  const getCellInfo = (cellId) => {
    const cell = cells[cellId];
    if (cell) {
      return __spreadValues({
        [`${capitalize(observationsLabel)} ID`]: cellId
      }, cell.factors);
    }
    return null;
  };
  const setViewState = ({
    zoom: newZoom,
    target,
    rotationX: newRotationX,
    rotationOrbit: newRotationOrbit,
    orbitAxis: newOrbitAxis
  }) => {
    setZoom(newZoom);
    setTargetX(target[0]);
    setTargetY(target[1]);
    setTargetZ(target[2] || null);
    setRotationX(newRotationX);
    setRotationOrbit(newRotationOrbit);
    setOrbitAxis(newOrbitAxis || null);
  };
  const subtitle = makeSpatialSubtitle({
    observationsCount: cellsCount,
    observationsLabel,
    observationsPluralLabel,
    subobservationsCount: moleculesCount,
    subobservationsLabel,
    subobservationsPluralLabel,
    locationsCount
  });
  const getExpressionValue = useExpressionValueGetter({ attrs, expressionData });
  const hasExpressionData = loaders[dataset].loaders["expression-matrix"];
  const hasCellsData = loaders[dataset].loaders.cells || imageLayerMeta.some((l) => {
    var _a2;
    return (_a2 = l == null ? void 0 : l.metadata) == null ? void 0 : _a2.isBitmask;
  });
  const canLoad3DLayers = imageLayerLoaders.some((loader) => Boolean(Array.from({
    length: loader.data.length
  }).filter((_, res) => canLoadResolution(loader.data, res)).length));
  const canShow3DOptions = canLoad3DLayers && !((disable3d == null ? void 0 : disable3d.length) === imageLayerLoaders.length) && !globalDisable3d;
  return /* @__PURE__ */ React24.createElement(TitleInfo, {
    title: title16,
    info: subtitle,
    isSpatial: true,
    urls,
    theme,
    removeGridComponent,
    isReady,
    options: canShow3DOptions || hasExpressionData ? /* @__PURE__ */ React24.createElement(SpatialOptions, {
      observationsLabel,
      cellColorEncoding,
      setCellColorEncoding,
      setSpatialAxisFixed,
      spatialAxisFixed,
      use3d,
      geneExpressionColormap,
      setGeneExpressionColormap,
      geneExpressionColormapRange,
      setGeneExpressionColormapRange,
      canShowExpressionOptions: hasExpressionData,
      canShowColorEncodingOption: hasCellsData && hasExpressionData,
      canShow3DOptions
    }) : null
  }, /* @__PURE__ */ React24.createElement(Spatial_default, {
    ref: deckRef,
    uuid,
    width,
    height,
    viewState: {
      zoom,
      target: [targetX, targetY, targetZ],
      rotationX,
      rotationY,
      rotationZ,
      rotationOrbit,
      orbitAxis
    },
    setViewState,
    layers,
    cells,
    cellFilter,
    cellSelection,
    cellHighlight,
    cellColors,
    molecules,
    neighborhoods,
    imageLayerLoaders,
    setCellFilter,
    setCellSelection: setCellSelectionProp,
    setCellHighlight,
    setMoleculeHighlight,
    setComponentHover: () => {
      setComponentHover(uuid);
    },
    updateViewInfo: setComponentViewInfo,
    rasterLayersCallbacks,
    spatialAxisFixed,
    geneExpressionColormap,
    geneExpressionColormapRange,
    expressionData: shiftedExpressionDataForBitmask,
    cellColorEncoding,
    getExpressionValue,
    theme
  }), !disableTooltip && /* @__PURE__ */ React24.createElement(SpatialTooltipSubscriber, {
    parentUuid: uuid,
    cellHighlight,
    width,
    height,
    getCellInfo
  }));
}

// src/components/scatterplot/ScatterplotSubscriber.js
import React28, {
  useState as useState8,
  useEffect as useEffect7,
  useCallback as useCallback9,
  useMemo as useMemo7
} from "react";
import { extent as extent2 } from "d3-array";
import isEqual6 from "lodash/isEqual";

// src/components/scatterplot/Scatterplot.js
import React25, { forwardRef as forwardRef3 } from "react";
import { PolygonLayer as PolygonLayer3, TextLayer as TextLayer3, ScatterplotLayer as ScatterplotLayer3 } from "@deck.gl/layers";
import { forceSimulation } from "d3-force";

// src/components/shared-spatial-scatterplot/force-collide-rects.js
import { quadtree as quadtree2 } from "d3-quadtree";
function constant(v) {
  return () => v;
}
function jiggle(v) {
  return v + (Math.random() - 0.5) * 1e-6;
}
function forceCollideRects() {
  let nodes;
  let masses;
  let strength = 1;
  let iterations = 1;
  let sizes;
  let size = constant([0, 0]);
  function xCenter(d) {
    return d.x + d.vx + sizes[d.index][0] / 2;
  }
  function yCenter(d) {
    return d.y + d.vy + sizes[d.index][1] / 2;
  }
  function prepare(quad) {
    if (quad.data) {
      quad.size = sizes[quad.data.index];
    } else {
      quad.size = [0, 0];
      for (let i = 0; i < 4; i++) {
        if (quad[i] && quad[i].size) {
          quad.size[0] = Math.max(quad.size[0], quad[i].size[0]);
          quad.size[1] = Math.max(quad.size[1], quad[i].size[1]);
        }
      }
    }
  }
  function force() {
    let node;
    let nodeSize;
    let nodeMass;
    let xi;
    let yi;
    const tree = quadtree2(nodes, xCenter, yCenter).visitAfter(prepare);
    function apply(quad, x0, y0, x1, y1) {
      const { data } = quad;
      const xSize = (nodeSize[0] + quad.size[0]) / 2;
      const ySize = (nodeSize[1] + quad.size[1]) / 2;
      if (data && data.index > node.index) {
        let x = jiggle(xi - xCenter(data));
        let y = jiggle(yi - yCenter(data));
        const xd = Math.abs(x) - xSize;
        const yd = Math.abs(y) - ySize;
        if (xd < 0 && yd < 0) {
          const l = Math.sqrt(x * x + y * y);
          const m = masses[data.index] / (nodeMass + masses[data.index]);
          if (Math.abs(xd) < Math.abs(yd)) {
            node.vx -= (x *= xd / l * strength) * m;
            data.vx += x * (1 - m);
          } else {
            node.vy -= (y *= yd / l * strength) * m;
            data.vy += y * (1 - m);
          }
        }
        return x0 > xi + xSize || x1 < xi - xSize || y0 > yi + ySize || y1 < yi - ySize;
      }
      return false;
    }
    function iterate() {
      for (let j = 0; j < nodes.length; j++) {
        node = nodes[j];
        nodeSize = sizes[j];
        nodeMass = masses[j];
        xi = xCenter(node);
        yi = yCenter(node);
        tree.visit(apply);
      }
    }
    for (let i = 0; i < iterations; i++) {
      iterate();
    }
  }
  force.initialize = (v) => {
    nodes = v;
    sizes = nodes.map(size);
    masses = sizes.map((d) => d[0] + d[1]);
  };
  force.iterations = (...v) => {
    if (v.length) {
      iterations = +v[0];
      return force;
    }
    return iterations;
  };
  force.strength = (...v) => {
    if (v.length) {
      strength = +v[0];
      return force;
    }
    return strength;
  };
  force.size = (...v) => {
    if (v.length) {
      size = typeof v[0] === "function" ? v[0] : constant(v[0]);
      return force;
    }
    return size;
  };
  return force;
}

// src/components/scatterplot/Scatterplot.js
var CELLS_LAYER_ID2 = "scatterplot";
var LABEL_FONT_FAMILY = "-apple-system, 'Helvetica Neue', Arial, sans-serif";
var NUM_FORCE_SIMULATION_TICKS = 100;
var LABEL_UPDATE_ZOOM_DELTA = 0.25;
var makeDefaultGetCellPosition = (mapping) => (cellEntry) => {
  const { mappings } = cellEntry[1];
  if (!(mapping in mappings)) {
    const available = Object.keys(mappings).map((s) => `"${s}"`).join(", ");
    throw new Error(`Expected to find "${mapping}", but available mappings are: ${available}`);
  }
  const mappedCell = mappings[mapping];
  return [mappedCell[0], -mappedCell[1], 0];
};
var makeDefaultGetCellCoords = (mapping) => (cell) => cell.mappings[mapping];
var makeDefaultGetCellColors2 = (cellColors, theme) => (cellEntry) => {
  const [r, g, b, a] = cellColors && cellColors.get(cellEntry[0]) || getDefaultColor(theme);
  return [r, g, b, 255 * (a || 1)];
};
var Scatterplot = class extends AbstractSpatialOrScatterplot {
  constructor(props) {
    super(props);
    this.cellsEntries = [];
    this.cellsQuadTree = null;
    this.cellsLayer = null;
    this.cellSetsForceSimulation = forceCollideRects();
    this.cellSetsLabelPrevZoom = null;
    this.cellSetsLayers = [];
    this.onUpdateCellsData();
    this.onUpdateCellsLayer();
    this.onUpdateCellSetsLayers();
  }
  createCellsLayer() {
    const { cellsEntries } = this;
    const {
      theme,
      mapping,
      getCellPosition = makeDefaultGetCellPosition(mapping),
      cellRadius = 1,
      cellOpacity = 1,
      cellFilter,
      cellSelection,
      setCellHighlight,
      setComponentHover,
      getCellIsSelected,
      cellColors,
      getCellColor = makeDefaultGetCellColors2(cellColors, theme),
      getExpressionValue,
      onCellClick,
      geneExpressionColormap,
      geneExpressionColormapRange = [0, 1],
      cellColorEncoding
    } = this.props;
    const filteredCellsEntries = cellFilter ? cellsEntries.filter((cellEntry) => cellFilter.includes(cellEntry[0])) : cellsEntries;
    return new ScatterplotLayer3(__spreadProps(__spreadValues({
      id: CELLS_LAYER_ID2,
      backgroundColor: theme === "dark" ? [0, 0, 0] : [241, 241, 241],
      getCellIsSelected,
      opacity: cellOpacity,
      radiusScale: cellRadius,
      radiusMinPixels: 1,
      radiusMaxPixels: 30,
      radiusUnits: "pixels",
      getPosition: getCellPosition,
      getFillColor: getCellColor,
      getLineColor: getCellColor,
      getRadius: 1,
      getExpressionValue,
      getLineWidth: 0,
      extensions: [
        new ScaledExpressionExtension_default(),
        new SelectionExtension_default({ instanced: true })
      ],
      colorScaleLo: geneExpressionColormapRange[0],
      colorScaleHi: geneExpressionColormapRange[1],
      isExpressionMode: cellColorEncoding === "geneSelection",
      colormap: geneExpressionColormap,
      onClick: (info) => {
        if (onCellClick) {
          onCellClick(info);
        }
      },
      updateTriggers: {
        getExpressionValue,
        getFillColor: [cellColorEncoding, cellSelection, cellColors],
        getLineColor: [cellColorEncoding, cellSelection, cellColors],
        getCellIsSelected
      }
    }, cellLayerDefaultProps(filteredCellsEntries, void 0, setCellHighlight, setComponentHover)), {
      stroked: 0
    }));
  }
  createCellSetsLayers() {
    const {
      theme,
      cellSetPolygons,
      viewState,
      cellSetPolygonsVisible,
      cellSetLabelsVisible,
      cellSetLabelSize
    } = this.props;
    const result = [];
    if (cellSetPolygonsVisible) {
      result.push(new PolygonLayer3({
        id: "cell-sets-polygon-layer",
        data: cellSetPolygons,
        stroked: true,
        filled: false,
        wireframe: true,
        lineWidthMaxPixels: 1,
        getPolygon: (d) => d.hull,
        getLineColor: (d) => d.color,
        getLineWidth: 1
      }));
    }
    if (cellSetLabelsVisible) {
      const { zoom } = viewState;
      const nodes = cellSetPolygons.map((p) => ({
        x: p.centroid[0],
        y: p.centroid[1],
        label: p.name
      }));
      const collisionForce = this.cellSetsForceSimulation.size((d) => [
        cellSetLabelSize * 1 / __pow(2, zoom) * 4 * d.label.length,
        cellSetLabelSize * 1 / __pow(2, zoom) * 1.5
      ]);
      forceSimulation().nodes(nodes).force("collision", collisionForce).tick(NUM_FORCE_SIMULATION_TICKS);
      result.push(new TextLayer3({
        id: "cell-sets-text-layer",
        data: nodes,
        getPosition: (d) => [d.x, d.y],
        getText: (d) => d.label,
        getColor: theme === "dark" ? [255, 255, 255] : [0, 0, 0],
        getSize: cellSetLabelSize,
        getAngle: 0,
        getTextAnchor: "middle",
        getAlignmentBaseline: "center",
        fontFamily: LABEL_FONT_FAMILY,
        fontWeight: "normal"
      }));
    }
    return result;
  }
  createSelectionLayers() {
    const {
      viewState,
      mapping,
      getCellCoords = makeDefaultGetCellCoords(mapping),
      setCellSelection: setCellSelection2
    } = this.props;
    const { tool } = this.state;
    const { cellsQuadTree } = this;
    const flipYTooltip = true;
    return getSelectionLayers(tool, viewState.zoom, CELLS_LAYER_ID2, getCellCoords, setCellSelection2, cellsQuadTree, flipYTooltip);
  }
  getLayers() {
    const {
      cellsLayer,
      cellSetsLayers
    } = this;
    return [
      cellsLayer,
      ...cellSetsLayers,
      ...this.createSelectionLayers()
    ];
  }
  onUpdateCellsData() {
    const {
      cells = {},
      mapping,
      getCellCoords = makeDefaultGetCellCoords(mapping)
    } = this.props;
    const cellsEntries = Object.entries(cells);
    this.cellsEntries = cellsEntries;
    this.cellsQuadTree = createCellsQuadTree(cellsEntries, getCellCoords);
  }
  onUpdateCellsLayer() {
    this.cellsLayer = this.createCellsLayer();
  }
  onUpdateCellSetsLayers(onlyViewStateChange) {
    if (onlyViewStateChange) {
      const { viewState, cellSetLabelsVisible } = this.props;
      const { zoom } = viewState;
      const { cellSetsLabelPrevZoom } = this;
      if (cellSetLabelsVisible && (cellSetsLabelPrevZoom === null || Math.abs(cellSetsLabelPrevZoom - zoom) > LABEL_UPDATE_ZOOM_DELTA)) {
        this.cellSetsLayers = this.createCellSetsLayers();
        this.cellSetsLabelPrevZoom = zoom;
      }
    } else {
      this.cellSetsLayers = this.createCellSetsLayers();
    }
  }
  viewInfoDidUpdate() {
    const {
      mapping,
      getCellPosition = makeDefaultGetCellPosition(mapping)
    } = this.props;
    super.viewInfoDidUpdate((cell) => getCellPosition([null, cell]));
  }
  componentDidUpdate(prevProps) {
    this.viewInfoDidUpdate();
    const shallowDiff = (propName) => prevProps[propName] !== this.props[propName];
    if (["cells"].some(shallowDiff)) {
      this.onUpdateCellsData();
      this.forceUpdate();
    }
    if ([
      "cells",
      "cellFilter",
      "cellSelection",
      "cellColors",
      "cellRadius",
      "cellOpacity",
      "cellRadiusMode",
      "geneExpressionColormap",
      "geneExpressionColormapRange",
      "geneSelection",
      "cellColorEncoding"
    ].some(shallowDiff)) {
      this.onUpdateCellsLayer();
      this.forceUpdate();
    }
    if ([
      "cellSetPolygons",
      "cellSetPolygonsVisible",
      "cellSetLabelsVisible",
      "cellSetLabelSize"
    ].some(shallowDiff)) {
      this.onUpdateCellSetsLayers(false);
      this.forceUpdate();
    }
    if (shallowDiff("viewState")) {
      this.onUpdateCellSetsLayers(true);
      this.forceUpdate();
    }
  }
};
var ScatterplotWrapper = forwardRef3((props, deckRef) => /* @__PURE__ */ React25.createElement(Scatterplot, __spreadProps(__spreadValues({}, props), {
  deckRef
})));
var Scatterplot_default = ScatterplotWrapper;

// src/components/scatterplot/ScatterplotTooltipSubscriber.js
import React26 from "react";
function ScatterplotTooltipSubscriber(props) {
  const {
    parentUuid,
    cellHighlight,
    width,
    height,
    getCellInfo
  } = props;
  const sourceUuid = useComponentHover();
  const viewInfo = useComponentViewInfo(parentUuid);
  const [cellInfo, x, y] = cellHighlight && getCellInfo ? [
    getCellInfo(cellHighlight),
    ...viewInfo && viewInfo.project ? viewInfo.project(cellHighlight) : [null, null]
  ] : [null, null, null];
  return cellInfo ? /* @__PURE__ */ React26.createElement(Tooltip2D, {
    x,
    y,
    parentUuid,
    sourceUuid,
    parentWidth: width,
    parentHeight: height
  }, /* @__PURE__ */ React26.createElement(TooltipContent, {
    info: cellInfo
  })) : null;
}

// src/components/scatterplot/ScatterplotOptions.js
import React27, { useCallback as useCallback8 } from "react";
import debounce4 from "lodash/debounce";
import Checkbox2 from "@material-ui/core/Checkbox";
import Slider3 from "@material-ui/core/Slider";
import TableCell4 from "@material-ui/core/TableCell";
import TableRow4 from "@material-ui/core/TableRow";
function ScatterplotOptions(props) {
  const {
    observationsLabel,
    cellRadius,
    setCellRadius,
    cellRadiusMode,
    setCellRadiusMode,
    cellOpacity,
    setCellOpacity,
    cellOpacityMode,
    setCellOpacityMode,
    cellSetLabelsVisible,
    setCellSetLabelsVisible,
    cellSetLabelSize,
    setCellSetLabelSize,
    cellSetPolygonsVisible,
    setCellSetPolygonsVisible,
    cellColorEncoding,
    setCellColorEncoding,
    geneExpressionColormap,
    setGeneExpressionColormap,
    geneExpressionColormapRange,
    setGeneExpressionColormapRange
  } = props;
  const observationsLabelNice = capitalize(observationsLabel);
  const classes = useStyles2();
  function handleCellRadiusModeChange(event) {
    setCellRadiusMode(event.target.value);
  }
  function handleCellOpacityModeChange(event) {
    setCellOpacityMode(event.target.value);
  }
  function handleRadiusChange(event, value) {
    setCellRadius(value);
  }
  function handleOpacityChange(event, value) {
    setCellOpacity(value);
  }
  function handleLabelVisibilityChange(event) {
    setCellSetLabelsVisible(event.target.checked);
  }
  function handleLabelSizeChange(event, value) {
    setCellSetLabelSize(value);
  }
  function handlePolygonVisibilityChange(event) {
    setCellSetPolygonsVisible(event.target.checked);
  }
  function handleGeneExpressionColormapChange(event) {
    setGeneExpressionColormap(event.target.value);
  }
  function handleColormapRangeChange(event, value) {
    setGeneExpressionColormapRange(value);
  }
  const handleColormapRangeChangeDebounced = useCallback8(debounce4(handleColormapRangeChange, 5, { trailing: true }), [handleColormapRangeChange]);
  return /* @__PURE__ */ React27.createElement(OptionsContainer, null, /* @__PURE__ */ React27.createElement(CellColorEncodingOption, {
    observationsLabel,
    cellColorEncoding,
    setCellColorEncoding
  }), /* @__PURE__ */ React27.createElement(TableRow4, null, /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.labelCell
  }, observationsLabelNice, " Set Labels Visible"), /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.inputCell
  }, /* @__PURE__ */ React27.createElement(Checkbox2, {
    className: classes.checkbox,
    checked: cellSetLabelsVisible,
    onChange: handleLabelVisibilityChange,
    name: "scatterplot-option-cell-set-labels",
    color: "default"
  }))), /* @__PURE__ */ React27.createElement(TableRow4, null, /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.labelCell
  }, observationsLabelNice, " Set Label Size"), /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.inputCell
  }, /* @__PURE__ */ React27.createElement(Slider3, {
    disabled: !cellSetLabelsVisible,
    classes: { root: classes.slider, valueLabel: classes.sliderValueLabel },
    value: cellSetLabelSize,
    onChange: handleLabelSizeChange,
    "aria-labelledby": "cell-set-label-size-slider",
    valueLabelDisplay: "auto",
    step: 1,
    min: 8,
    max: 36
  }))), /* @__PURE__ */ React27.createElement(TableRow4, null, /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.labelCell
  }, observationsLabelNice, " Set Polygons Visible"), /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.inputCell
  }, /* @__PURE__ */ React27.createElement(Checkbox2, {
    className: classes.checkbox,
    checked: cellSetPolygonsVisible,
    onChange: handlePolygonVisibilityChange,
    name: "scatterplot-option-cell-set-polygons",
    color: "default"
  }))), /* @__PURE__ */ React27.createElement(TableRow4, null, /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.labelCell,
    htmlFor: "cell-radius-mode-select"
  }, observationsLabelNice, " Radius Mode"), /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.inputCell
  }, /* @__PURE__ */ React27.createElement(OptionSelect, {
    className: classes.select,
    value: cellRadiusMode,
    onChange: handleCellRadiusModeChange,
    inputProps: {
      id: "cell-radius-mode-select"
    }
  }, /* @__PURE__ */ React27.createElement("option", {
    value: "auto"
  }, "Auto"), /* @__PURE__ */ React27.createElement("option", {
    value: "manual"
  }, "Manual")))), /* @__PURE__ */ React27.createElement(TableRow4, null, /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.labelCell
  }, observationsLabelNice, " Radius"), /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.inputCell
  }, /* @__PURE__ */ React27.createElement(Slider3, {
    disabled: cellRadiusMode !== "manual",
    classes: { root: classes.slider, valueLabel: classes.sliderValueLabel },
    value: cellRadius,
    onChange: handleRadiusChange,
    "aria-labelledby": "cell-radius-slider",
    valueLabelDisplay: "auto",
    step: 0.01,
    min: 0.01,
    max: 10
  }))), /* @__PURE__ */ React27.createElement(TableRow4, null, /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.labelCell,
    htmlFor: "cell-opacity-mode-select"
  }, observationsLabelNice, " Opacity Mode"), /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.inputCell
  }, /* @__PURE__ */ React27.createElement(OptionSelect, {
    className: classes.select,
    value: cellOpacityMode,
    onChange: handleCellOpacityModeChange,
    inputProps: {
      id: "cell-opacity-mode-select"
    }
  }, /* @__PURE__ */ React27.createElement("option", {
    value: "auto"
  }, "Auto"), /* @__PURE__ */ React27.createElement("option", {
    value: "manual"
  }, "Manual")))), /* @__PURE__ */ React27.createElement(TableRow4, null, /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.labelCell
  }, observationsLabelNice, " Opacity"), /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.inputCell
  }, /* @__PURE__ */ React27.createElement(Slider3, {
    disabled: cellOpacityMode !== "manual",
    classes: { root: classes.slider, valueLabel: classes.sliderValueLabel },
    value: cellOpacity,
    onChange: handleOpacityChange,
    "aria-labelledby": "cell-opacity-slider",
    valueLabelDisplay: "auto",
    step: 0.05,
    min: 0,
    max: 1
  }))), /* @__PURE__ */ React27.createElement(TableRow4, null, /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.labelCell,
    htmlFor: "gene-expression-colormap-select"
  }, "Gene Expression Colormap"), /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.inputCell
  }, /* @__PURE__ */ React27.createElement(OptionSelect, {
    className: classes.select,
    value: geneExpressionColormap,
    onChange: handleGeneExpressionColormapChange,
    inputProps: {
      id: "gene-expression-colormap-select"
    }
  }, GLSL_COLORMAPS.map((cmap) => /* @__PURE__ */ React27.createElement("option", {
    key: cmap,
    value: cmap
  }, cmap))))), /* @__PURE__ */ React27.createElement(TableRow4, null, /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.labelCell
  }, "Gene Expression Colormap Range"), /* @__PURE__ */ React27.createElement(TableCell4, {
    className: classes.inputCell
  }, /* @__PURE__ */ React27.createElement(Slider3, {
    classes: { root: classes.slider, valueLabel: classes.sliderValueLabel },
    value: geneExpressionColormapRange,
    onChange: handleColormapRangeChangeDebounced,
    "aria-labelledby": "gene-expression-colormap-range-slider",
    valueLabelDisplay: "auto",
    step: 5e-3,
    min: 0,
    max: 1
  }))));
}

// src/components/shared-spatial-scatterplot/dynamic-opacity.js
import { OrthographicView as OrthographicView4 } from "deck.gl";
import clamp3 from "lodash/clamp";
function getPointSizeDevicePixels(devicePixelRatio, zoom, xRange, yRange, width, height) {
  const pointSize = 1e-3;
  const pointScreenSizeMax = 10;
  const pointScreenSizeMin = 1 / devicePixelRatio;
  const scaleFactor = __pow(2, zoom);
  const xAxisRange = 2 / (xRange * scaleFactor / width);
  const yAxisRange = 2 / (yRange * scaleFactor / height);
  const diagonalScreenSize = Math.sqrt(__pow(width, 2) + __pow(height, 2));
  const diagonalAxisRange = Math.sqrt(__pow(xAxisRange, 2) + __pow(yAxisRange, 2));
  const diagonalFraction = pointSize / diagonalAxisRange;
  const deviceSize = diagonalFraction * diagonalScreenSize;
  const pointSizeDevicePixels = clamp3(deviceSize, pointScreenSizeMin, pointScreenSizeMax);
  return pointSizeDevicePixels;
}
function getPointOpacity(zoom, xRange, yRange, width, height, numCells, avgFillDensity) {
  const N = numCells;
  const [minX, minY, maxX, maxY] = new OrthographicView4({ zoom }).makeViewport({
    height,
    width,
    viewState: { zoom, target: [0, 0, 0] }
  }).getBounds();
  const X = maxY - minY;
  const Y = maxX - minX;
  const X0 = xRange;
  const Y0 = yRange;
  const W = width;
  const H = height;
  let rho = avgFillDensity;
  if (!rho) {
    rho = Math.min(1, 1 / __pow(10, Math.log10(N) - 3));
  }
  const alpha = rho * W * H / N * (Y0 / Y) * (X0 / X);
  const pointOpacity = clamp3(alpha, 1.01 / 255, 1);
  return pointOpacity;
}

// src/components/scatterplot/ScatterplotSubscriber.js
var SCATTERPLOT_DATA_TYPES = ["cells", "expression-matrix", "cell-sets"];
function ScatterplotSubscriber(props) {
  const {
    uuid,
    coordinationScopes,
    removeGridComponent,
    theme,
    disableTooltip = false,
    observationsLabelOverride: observationsLabel = "cell",
    observationsPluralLabelOverride: observationsPluralLabel = `${observationsLabel}s`,
    title: titleOverride,
    averageFillDensity
  } = props;
  const loaders = useLoaders();
  const setComponentHover = useSetComponentHover();
  const setComponentViewInfo = useSetComponentViewInfo(uuid);
  const [{
    dataset,
    embeddingZoom: zoom,
    embeddingTargetX: targetX,
    embeddingTargetY: targetY,
    embeddingTargetZ: targetZ,
    embeddingType: mapping,
    cellFilter,
    cellHighlight,
    geneSelection,
    cellSetSelection,
    cellSetColor,
    cellColorEncoding,
    additionalCellSets,
    embeddingCellSetPolygonsVisible: cellSetPolygonsVisible,
    embeddingCellSetLabelsVisible: cellSetLabelsVisible,
    embeddingCellSetLabelSize: cellSetLabelSize,
    embeddingCellRadius: cellRadiusFixed,
    embeddingCellRadiusMode: cellRadiusMode,
    embeddingCellOpacity: cellOpacityFixed,
    embeddingCellOpacityMode: cellOpacityMode,
    geneExpressionColormap,
    geneExpressionColormapRange
  }, {
    setEmbeddingZoom: setZoom,
    setEmbeddingTargetX: setTargetX,
    setEmbeddingTargetY: setTargetY,
    setEmbeddingTargetZ: setTargetZ,
    setCellFilter,
    setCellSetSelection,
    setCellHighlight,
    setCellSetColor,
    setCellColorEncoding,
    setAdditionalCellSets,
    setEmbeddingCellSetPolygonsVisible: setCellSetPolygonsVisible,
    setEmbeddingCellSetLabelsVisible: setCellSetLabelsVisible,
    setEmbeddingCellSetLabelSize: setCellSetLabelSize,
    setEmbeddingCellRadius: setCellRadiusFixed,
    setEmbeddingCellRadiusMode: setCellRadiusMode,
    setEmbeddingCellOpacity: setCellOpacityFixed,
    setEmbeddingCellOpacityMode: setCellOpacityMode,
    setGeneExpressionColormap,
    setGeneExpressionColormapRange
  }] = useCoordination(COMPONENT_COORDINATION_TYPES.scatterplot, coordinationScopes);
  const [urls, addUrl, resetUrls] = useUrls();
  const [width, height, deckRef] = useDeckCanvasSize();
  const [
    isReady,
    setItemIsReady,
    setItemIsNotReady,
    resetReadyItems
  ] = useReady(SCATTERPLOT_DATA_TYPES);
  const title16 = titleOverride || `Scatterplot (${mapping})`;
  useEffect7(() => {
    resetUrls();
    resetReadyItems();
  }, [loaders, dataset]);
  const [cells, cellsCount] = useCellsData(loaders, dataset, setItemIsReady, addUrl, true);
  const [cellSets] = useCellSetsData(loaders, dataset, setItemIsReady, addUrl, false, { setCellSetSelection, setCellSetColor }, { cellSetSelection, cellSetColor });
  const [expressionData] = useGeneSelection(loaders, dataset, setItemIsReady, false, geneSelection, setItemIsNotReady);
  const [attrs] = useExpressionAttrs(loaders, dataset, setItemIsReady, addUrl, false);
  const [dynamicCellRadius, setDynamicCellRadius] = useState8(cellRadiusFixed);
  const [dynamicCellOpacity, setDynamicCellOpacity] = useState8(cellOpacityFixed);
  const mergedCellSets = useMemo7(() => mergeCellSets(cellSets, additionalCellSets), [cellSets, additionalCellSets]);
  const setCellSelectionProp = useCallback9((v) => {
    setCellSelection(v, additionalCellSets, cellSetColor, setCellSetSelection, setAdditionalCellSets, setCellSetColor, setCellColorEncoding);
  }, [
    additionalCellSets,
    cellSetColor,
    setCellColorEncoding,
    setAdditionalCellSets,
    setCellSetColor,
    setCellSetSelection
  ]);
  const cellColors = useMemo7(() => getCellColors({
    cellColorEncoding,
    expressionData: expressionData && expressionData[0],
    geneSelection,
    cellSets: mergedCellSets,
    cellSetSelection,
    cellSetColor,
    expressionDataAttrs: attrs,
    theme
  }), [
    cellColorEncoding,
    geneSelection,
    mergedCellSets,
    theme,
    cellSetSelection,
    cellSetColor,
    expressionData,
    attrs
  ]);
  const [cellSetPolygonCache, setCellSetPolygonCache] = useState8([]);
  const cacheHas = (cache, key) => cache.findIndex((el) => isEqual6(el[0], key)) !== -1;
  const cacheGet = (cache, key) => {
    var _a2;
    return (_a2 = cache.find((el) => isEqual6(el[0], key))) == null ? void 0 : _a2[1];
  };
  const cellSetPolygons = useMemo7(() => {
    var _a2;
    if ((cellSetLabelsVisible || cellSetPolygonsVisible) && !cacheHas(cellSetPolygonCache, cellSetSelection) && ((_a2 = mergedCellSets == null ? void 0 : mergedCellSets.tree) == null ? void 0 : _a2.length) && Object.values(cells).length && (cellSetColor == null ? void 0 : cellSetColor.length)) {
      const newCellSetPolygons = getCellSetPolygons({
        cells,
        mapping,
        cellSets: mergedCellSets,
        cellSetSelection,
        cellSetColor,
        theme
      });
      setCellSetPolygonCache((cache) => [...cache, [cellSetSelection, newCellSetPolygons]]);
      return newCellSetPolygons;
    }
    return cacheGet(cellSetPolygonCache, cellSetSelection) || [];
  }, [
    cellSetPolygonsVisible,
    cellSetPolygonCache,
    cellSetLabelsVisible,
    theme,
    cells,
    mapping,
    mergedCellSets,
    cellSetSelection,
    cellSetColor
  ]);
  const cellSelection = useMemo7(() => Array.from(cellColors.keys()), [cellColors]);
  const [xRange, yRange, xExtent, yExtent, numCells] = useMemo7(() => {
    const cellValues = cells && Object.values(cells);
    if (cellValues == null ? void 0 : cellValues.length) {
      const cellCoordinates = Object.values(cells).map((c) => c.mappings[mapping]);
      const xE = extent2(cellCoordinates, (c) => c[0]);
      const yE = extent2(cellCoordinates, (c) => c[1]);
      const xR = xE[1] - xE[0];
      const yR = yE[1] - yE[0];
      return [xR, yR, xE, yE, cellValues.length];
    }
    return [null, null, null, null, null];
  }, [cells, mapping]);
  useEffect7(() => {
    if (xRange && yRange) {
      const pointSizeDevicePixels = getPointSizeDevicePixels(window.devicePixelRatio, zoom, xRange, yRange, width, height);
      setDynamicCellRadius(pointSizeDevicePixels);
      const nextCellOpacityScale = getPointOpacity(zoom, xRange, yRange, width, height, numCells, averageFillDensity);
      setDynamicCellOpacity(nextCellOpacityScale);
      if (typeof targetX !== "number" || typeof targetY !== "number") {
        const newTargetX = xExtent[0] + xRange / 2;
        const newTargetY = yExtent[0] + yRange / 2;
        const newZoom = Math.log2(Math.min(width / xRange, height / yRange));
        setTargetX(newTargetX);
        setTargetY(-newTargetY);
        setZoom(newZoom);
      }
    }
  }, [
    xRange,
    yRange,
    xExtent,
    yExtent,
    numCells,
    cells,
    mapping,
    width,
    height,
    zoom,
    averageFillDensity
  ]);
  const getCellInfo = useCallback9((cellId) => {
    const cellInfo = cells[cellId];
    return __spreadValues({
      [`${capitalize(observationsLabel)} ID`]: cellId
    }, cellInfo ? cellInfo.factors : {});
  }, [cells, observationsLabel]);
  const cellSelectionSet = useMemo7(() => new Set(cellSelection), [cellSelection]);
  const getCellIsSelected = useCallback9((cellEntry) => (cellSelectionSet || new Set([])).has(cellEntry[0]) ? 1 : 0, [cellSelectionSet]);
  const cellRadius = cellRadiusMode === "manual" ? cellRadiusFixed : dynamicCellRadius;
  const cellOpacity = cellOpacityMode === "manual" ? cellOpacityFixed : dynamicCellOpacity;
  const getExpressionValue = useExpressionValueGetter({ attrs, expressionData });
  return /* @__PURE__ */ React28.createElement(TitleInfo, {
    title: title16,
    info: `${cellsCount} ${pluralize(observationsLabel, observationsPluralLabel, cellsCount)}`,
    removeGridComponent,
    urls,
    theme,
    isReady,
    options: /* @__PURE__ */ React28.createElement(ScatterplotOptions, {
      observationsLabel,
      cellRadius: cellRadiusFixed,
      setCellRadius: setCellRadiusFixed,
      cellRadiusMode,
      setCellRadiusMode,
      cellOpacity: cellOpacityFixed,
      setCellOpacity: setCellOpacityFixed,
      cellOpacityMode,
      setCellOpacityMode,
      cellSetLabelsVisible,
      setCellSetLabelsVisible,
      cellSetLabelSize,
      setCellSetLabelSize,
      cellSetPolygonsVisible,
      setCellSetPolygonsVisible,
      cellColorEncoding,
      setCellColorEncoding,
      geneExpressionColormap,
      setGeneExpressionColormap,
      geneExpressionColormapRange,
      setGeneExpressionColormapRange
    })
  }, /* @__PURE__ */ React28.createElement(Scatterplot_default, {
    ref: deckRef,
    uuid,
    theme,
    viewState: { zoom, target: [targetX, targetY, targetZ] },
    setViewState: ({ zoom: newZoom, target }) => {
      setZoom(newZoom);
      setTargetX(target[0]);
      setTargetY(target[1]);
      setTargetZ(target[2] || 0);
    },
    cells,
    mapping,
    cellFilter,
    cellSelection,
    cellHighlight,
    cellColors,
    cellSetPolygons,
    cellSetLabelSize,
    cellSetLabelsVisible,
    cellSetPolygonsVisible,
    setCellFilter,
    setCellSelection: setCellSelectionProp,
    setCellHighlight,
    cellRadius,
    cellOpacity,
    cellColorEncoding,
    geneExpressionColormap,
    geneExpressionColormapRange,
    setComponentHover: () => {
      setComponentHover(uuid);
    },
    updateViewInfo: setComponentViewInfo,
    getExpressionValue,
    getCellIsSelected
  }), !disableTooltip && /* @__PURE__ */ React28.createElement(ScatterplotTooltipSubscriber, {
    parentUuid: uuid,
    cellHighlight,
    width,
    height,
    getCellInfo
  }));
}

// src/app/VitessceGrid.js
import React30, {
  useEffect as useEffect9
} from "react";

// src/app/vitessce-grid-layout/VitessceGridLayout.js
import React29 from "react";
import { Responsive, WidthProvider } from "react-grid-layout";
import isEqual7 from "lodash/isEqual";

// src/app/vitessce-grid-layout/layout-utils.js
var COMPONENT_ID_PREFIX = "i";
function sum(a) {
  return a.reduce((x, y) => x + y, 0);
}
function makeGridLayout(colXs, colLayout) {
  const colWs = [];
  for (let i = 0; i < colXs.length; i++) {
    colWs.push(colXs[i + 1] - colXs[i]);
  }
  return Object.entries(colLayout).map(([id, spec]) => ({
    i: id,
    y: spec.y,
    h: spec.h || 1,
    x: colXs[spec.x],
    w: sum(colWs.slice(spec.x, spec.x + (spec.w || 1)))
  }));
}
function getMaxRows(layouts) {
  return Math.max(...Object.values(layouts).map((layout) => Math.max(...layout.map((xywh) => xywh.y + xywh.h))));
}
function resolveLayout(layout) {
  const cols = {};
  const layouts = {};
  const breakpoints = {};
  const components = {};
  const positions = {};
  ("components" in layout ? layout.components : layout).forEach((def, i) => {
    const id = `${COMPONENT_ID_PREFIX}${i}`;
    components[id] = {
      component: def.component,
      props: def.props || {},
      coordinationScopes: def.coordinationScopes || {}
    };
    positions[id] = {
      id,
      x: def.x,
      y: def.y,
      w: def.w,
      h: def.h
    };
  });
  if ("components" in layout) {
    Object.entries(layout.columns).forEach(([width, columnXs]) => {
      cols[width] = columnXs[columnXs.length - 1];
      layouts[width] = makeGridLayout(columnXs, positions);
      breakpoints[width] = width;
    });
  } else {
    const id = "ID";
    const columnCount = 12;
    cols[id] = columnCount;
    layouts[id] = makeGridLayout(range(columnCount + 1), positions);
    breakpoints[id] = 1e3;
  }
  return {
    cols,
    layouts,
    breakpoints,
    components
  };
}

// src/app/vitessce-grid-layout/VitessceGridLayout.js
var ResponsiveGridLayout = WidthProvider(Responsive);
var ResponsiveHeightGridLayout = class extends ResponsiveGridLayout {
  componentDidUpdate(prevProps) {
    if (this.props.height !== prevProps.height) {
      this.onWindowResize();
    }
  }
};
function VitessceGridLayout(props) {
  const {
    layout,
    getComponent: getComponent2,
    padding: padding2,
    margin: margin2,
    draggableHandle,
    reactGridLayoutProps,
    rowHeight,
    theme,
    height,
    onRemoveComponent,
    onLayoutChange: onLayoutChangeProp
  } = props;
  const {
    cols: gridCols,
    layouts: gridLayouts,
    breakpoints: gridBreakpoints,
    components: gridComponents
  } = resolveLayout(layout);
  const maxRows = getMaxRows(gridLayouts);
  const style = /* @__PURE__ */ React29.createElement("style", null, `
        ${draggableHandle} {
          cursor: grab;
        }
        ${draggableHandle}:active {
          cursor: grabbing;
        }
     `);
  const onLayoutChange = (newLayout) => {
    if (newLayout.length === Object.entries(gridComponents).length) {
      const newComponentProps = [];
      newLayout.forEach((nextC) => {
        const id = nextC.i;
        const prevC = gridComponents[id];
        if (prevC) {
          const i = parseInt(id.substring(id.indexOf(COMPONENT_ID_PREFIX) + 1), 10);
          const nextProps = {
            x: nextC.x,
            y: nextC.y,
            w: nextC.w,
            h: nextC.h
          };
          const prevProps = {
            x: prevC.x,
            y: prevC.y,
            w: prevC.w,
            h: prevC.h
          };
          if (!isEqual7(nextProps, prevProps)) {
            newComponentProps.push([i, nextProps]);
          }
        }
      });
      if (newComponentProps.length > 0) {
        onLayoutChangeProp(newComponentProps);
      }
    }
  };
  const layoutChildren = Object.entries(gridComponents).map(([k, v], i) => {
    const Component = getComponent2(v.component);
    const removeGridComponent = () => {
      onRemoveComponent(i);
    };
    return /* @__PURE__ */ React29.createElement("div", {
      key: k
    }, /* @__PURE__ */ React29.createElement(Component, __spreadProps(__spreadValues({}, v.props), {
      uuid: i,
      coordinationScopes: v.coordinationScopes,
      theme,
      removeGridComponent
    })));
  });
  return gridLayouts && gridComponents && gridBreakpoints && gridCols && /* @__PURE__ */ React29.createElement(React29.Fragment, null, style, /* @__PURE__ */ React29.createElement(ResponsiveHeightGridLayout, __spreadValues({
    className: "layout",
    cols: gridCols,
    layouts: gridLayouts,
    breakpoints: gridBreakpoints,
    height,
    rowHeight: rowHeight || (window.innerHeight - 2 * padding2 - (maxRows - 1) * margin2) / maxRows,
    containerPadding: [padding2, padding2],
    margin: [margin2, margin2],
    draggableHandle,
    onLayoutChange
  }, reactGridLayoutProps), layoutChildren));
}
VitessceGridLayout.defaultProps = {
  padding: 10,
  margin: 10
};

// src/app/vitessce-grid-utils.js
import {
  useState as useState9,
  useEffect as useEffect8,
  useRef as useRef6
} from "react";

// src/loaders/JsonLoader.js
import Ajv from "ajv";

// src/loaders/AbstractLoader.js
import uuidv43 from "uuid/v4";
var AbstractLoader = class {
  constructor({
    type: type16,
    url,
    requestInit,
    options
  }) {
    this.type = type16;
    this.url = url;
    this.requestInit = requestInit;
    this.options = options;
    this.subscriptions = {};
  }
  load() {
    throw new Error("The load() method has not been implemented.");
  }
  subscribe(subscriber) {
    const token = uuidv43();
    this.subscriptions[token] = subscriber;
    return token;
  }
  unsubscribe(token) {
    delete this.subscriptions[token];
  }
  publish(data) {
    Object.values(this.subscriptions).forEach((subscriber) => {
      subscriber(data);
    });
  }
};

// src/loaders/AbstractTwoStepLoader.js
var AbstractTwoStepLoader = class extends AbstractLoader {
  constructor(dataSource, params) {
    super(params);
    this.dataSource = dataSource;
  }
};

// src/loaders/LoaderResult.js
var LoaderResult = class {
  constructor(data, url, coordinationValues = null) {
    this.data = data;
    this.url = url;
    this.coordinationValues = coordinationValues;
  }
};

// src/schemas/cells.schema.json
var $schema3 = "http://json-schema.org/draft-07/schema#";
var $id3 = "https://github.com/vitessce/vitessce/#cells";
var title3 = "Vitessce cell data";
var type3 = "object";
var definitions3 = {
  coord: {
    type: "array",
    minItems: 2,
    maxItems: 2,
    items: { type: "number" }
  },
  positiveFloatValues: {
    type: "object",
    patternProperties: {
      ".": {
        type: "number",
        minimum: 0
      }
    }
  },
  stringValues: {
    type: "object",
    patternProperties: {
      ".": {
        type: "string"
      }
    }
  }
};
var patternProperties = {
  ".": {
    additionalProperties: false,
    required: [],
    properties: {
      mappings: {
        type: "object",
        patternProperties: {
          ".": { $ref: "#/definitions/coord" }
        }
      },
      xy: { $ref: "#/definitions/coord" },
      genes: { $ref: "#/definitions/positiveFloatValues" },
      factors: { $ref: "#/definitions/stringValues" },
      poly: {
        type: "array",
        items: { $ref: "#/definitions/coord" }
      }
    }
  }
};
var cells_schema_default = {
  $schema: $schema3,
  $id: $id3,
  title: title3,
  type: type3,
  definitions: definitions3,
  patternProperties
};

// src/schemas/molecules.schema.json
var $schema4 = "http://json-schema.org/draft-07/schema#";
var $id4 = "https://github.com/vitessce/vitessce/#molecules";
var title4 = "Vitessce molecule data";
var type4 = "object";
var definitions4 = {
  coord: {
    type: "array",
    maxItems: 2,
    minItems: 2,
    items: { type: "number" }
  }
};
var patternProperties2 = {
  ".": {
    type: "array",
    items: { $ref: "#/definitions/coord" }
  }
};
var molecules_schema_default = {
  $schema: $schema4,
  $id: $id4,
  title: title4,
  type: type4,
  definitions: definitions4,
  patternProperties: patternProperties2
};

// src/schemas/neighborhoods.schema.json
var $schema5 = "http://json-schema.org/draft-07/schema#";
var $id5 = "https://github.com/vitessce/vitessce/#neighborhoods";
var title5 = "Vitessce neighborhood data";
var type5 = "object";
var definitions5 = {
  coord: {
    type: "array",
    maxItems: 2,
    minItems: 2,
    items: { type: "number" }
  }
};
var patternProperties3 = {
  ".": {
    additionalProperties: false,
    required: ["poly"],
    properties: {
      poly: {
        type: "array",
        maxItems: 3,
        minItems: 3,
        items: { $ref: "#/definitions/coord" }
      }
    }
  }
};
var neighborhoods_schema_default = {
  $schema: $schema5,
  $id: $id5,
  title: title5,
  type: type5,
  definitions: definitions5,
  patternProperties: patternProperties3
};

// src/schemas/raster.schema.json
var $schema6 = "http://json-schema.org/draft-07/schema#";
var $id6 = "https://github.com/vitessce/vitessce/#raster";
var title6 = "Vitessce image data";
var type6 = "object";
var definitions6 = {
  transform: {
    type: "object",
    additionalProperties: false,
    oneOf: [{ required: ["scale", "translate"] }, { required: ["matrix"] }],
    properties: {
      scale: { type: "number" },
      translate: {
        type: "object",
        additionalProperties: false,
        required: ["y", "x"],
        properties: {
          y: { type: "number" },
          x: { type: "number" }
        }
      },
      matrix: {
        type: "array",
        items: { type: "number" },
        minItems: 16,
        maxItems: 16
      }
    }
  },
  dimensions: {
    type: "array",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["field", "type", "values"],
      properties: {
        field: { type: "string" },
        type: {
          type: "string",
          enum: ["quantitative", "nominal", "ordinal", "temporal"]
        },
        values: {
          type: ["array", "null"],
          items: { type: "string" }
        }
      }
    }
  },
  metadata: {
    type: "object",
    additionalProperties: false,
    anyOf: [{ required: ["dimensions", "isPyramid"] }, { required: ["transform"] }, { required: ["omeTiffOffsetsUrl"] }, { required: ["isBitmask"] }],
    properties: {
      dimensions: { $ref: "#/definitions/dimensions" },
      isPyramid: { type: "boolean" },
      transform: { $ref: "#/definitions/transform" },
      isBitmask: { type: "boolean" },
      omeTiffOffsetsUrl: { type: "string", format: "uri" }
    }
  },
  requestInit: {
    type: "object",
    additionalProperties: false,
    required: [],
    properties: {
      method: {
        type: "string"
      },
      headers: {
        type: "object"
      },
      body: {
        type: "string"
      },
      mode: {
        type: "string"
      },
      credentials: {
        type: "string"
      },
      cache: {
        type: "string"
      },
      redirect: {
        type: "string"
      },
      referrer: {
        type: "string"
      },
      integrity: {
        type: "string"
      }
    }
  },
  image: {
    type: "object",
    additionalProperties: false,
    required: ["name", "url", "type"],
    properties: {
      name: { type: "string" },
      url: { type: "string", format: "uri" },
      type: { type: "string" },
      metadata: { $ref: "#/definitions/metadata" },
      requestInit: { $ref: "#/definitions/requestInit" }
    }
  }
};
var additionalProperties = false;
var required = ["schemaVersion", "images"];
var properties = {
  schemaVersion: { type: "string" },
  usePhysicalSizeScaling: { type: "boolean", description: "Default is false: passing true in will infer scaling from the reported physcial size" },
  renderLayers: { type: "array", items: { type: "string" } },
  images: {
    type: "array",
    items: { $ref: "#/definitions/image" }
  }
};
var raster_schema_default = {
  $schema: $schema6,
  $id: $id6,
  title: title6,
  type: type6,
  definitions: definitions6,
  additionalProperties,
  required,
  properties
};

// src/loaders/JsonLoader.js
var typeToSchema = {
  cells: cells_schema_default,
  molecules: molecules_schema_default,
  neighborhoods: neighborhoods_schema_default,
  raster: raster_schema_default,
  "cell-sets": cell_sets_schema_default
};
var JsonLoader = class extends AbstractTwoStepLoader {
  constructor(dataSource, params) {
    super(dataSource, params);
    const { type: type16 } = params;
    this.schema = typeToSchema[type16];
  }
  load() {
    const {
      url,
      type: type16,
      fileType
    } = this;
    if (this.data) {
      return this.data;
    }
    this.data = this.dataSource.data.then((data) => {
      if (data instanceof AbstractLoaderError) {
        return Promise.reject(data);
      }
      const [valid, reason] = this.validate(data);
      if (valid) {
        return Promise.resolve(new LoaderResult(data, url));
      }
      return Promise.reject(new LoaderValidationError(type16, fileType, url, reason));
    });
    return this.data;
  }
  validate(data) {
    const { schema, type: type16 } = this;
    if (!schema) {
      throw Error(`No schema for ${type16}`);
    }
    const validate = new Ajv().compile(schema);
    const valid = validate(data);
    let failureReason;
    if (!valid) {
      failureReason = validate.errors;
    }
    return [valid, failureReason];
  }
};

// src/loaders/MatrixZarrLoader.js
import { openArray } from "zarr";
var MatrixZarrLoader = class extends AbstractTwoStepLoader {
  loadAttrs() {
    if (this.attrs) {
      return this.attrs;
    }
    this.attrs = this.dataSource.getJson(".zattrs");
    return this.attrs;
  }
  loadArr() {
    const { store } = this.dataSource;
    if (this.arr) {
      return this.arr;
    }
    this.arr = openArray({ store, path: "/", mode: "r" }).then((z) => new Promise((resolve) => {
      z.getRaw([null, null]).then(resolve);
    }));
    return this.arr;
  }
  load() {
    return Promise.all([this.loadAttrs(), this.loadArr()]).then((data) => Promise.resolve(new LoaderResult(data, null)));
  }
};

// src/schemas/genes.schema.json
var $schema7 = "http://json-schema.org/draft-07/schema#";
var $id7 = "https://github.com/vitessce/vitessce/#genes";
var title7 = "Vitessce gene data";
var type7 = "object";
var definitions7 = {
  positiveFloatValues: {
    type: "object",
    patternProperties: {
      ".": {
        type: "number",
        minimum: 0
      }
    }
  }
};
var patternProperties4 = {
  ".": {
    additionalProperties: false,
    required: ["max", "cells"],
    properties: {
      max: { type: "number" },
      cells: { $ref: "#/definitions/positiveFloatValues" }
    }
  }
};
var genes_schema_default = {
  $schema: $schema7,
  $id: $id7,
  title: title7,
  type: type7,
  definitions: definitions7,
  patternProperties: patternProperties4
};

// src/loaders/GenesJsonAsMatrixZarrLoader.js
var GenesJsonAsMatrixZarrLoader = class extends JsonLoader {
  constructor(dataSource, params) {
    super(dataSource, params);
    this.schema = genes_schema_default;
  }
  load() {
    var __super = (key) => super[key];
    return __async(this, null, function* () {
      const payload = yield __super("load").call(this).catch((reason) => Promise.resolve(reason));
      if (payload instanceof AbstractLoaderError) {
        return Promise.reject(payload);
      }
      const { data, url } = payload;
      const cols = Object.keys(data);
      const rows = cols.length > 0 ? Object.keys(data[cols[0]].cells) : [];
      const attrs = { rows, cols };
      const normalizedFlatMatrix = rows.flatMap((cellId) => cols.map((geneId) => data[geneId].cells[cellId] / data[geneId].max * 255));
      const arr = { data: Uint8Array.from(normalizedFlatMatrix) };
      return Promise.resolve(new LoaderResult([attrs, arr], url));
    });
  }
};

// src/loaders/ClustersJsonAsMatrixZarrLoader.js
import { extent as extent3 } from "d3-array";
import range6 from "lodash/range";

// src/schemas/clusters.schema.json
var $schema8 = "http://json-schema.org/draft-07/schema#";
var $id8 = "https://github.com/vitessce/vitessce/#clusters";
var title8 = "Vitessce cluster data";
var type8 = "object";
var definitions8 = {
  stringArray: {
    type: "array",
    items: { type: "string" }
  },
  matrix: {
    type: "array",
    items: {
      type: "array",
      items: {
        type: "number",
        minimum: 0,
        maximum: 1
      }
    }
  }
};
var additionalProperties2 = false;
var required2 = ["rows", "cols", "matrix"];
var properties2 = {
  rows: { $ref: "#/definitions/stringArray" },
  cols: { $ref: "#/definitions/stringArray" },
  matrix: { $ref: "#/definitions/matrix" }
};
var clusters_schema_default = {
  $schema: $schema8,
  $id: $id8,
  title: title8,
  type: type8,
  definitions: definitions8,
  additionalProperties: additionalProperties2,
  required: required2,
  properties: properties2
};

// src/loaders/ClustersJsonAsMatrixZarrLoader.js
var ClustersJsonAsMatrixZarrLoader = class extends JsonLoader {
  constructor(dataSource, params) {
    super(dataSource, params);
    this.schema = clusters_schema_default;
  }
  load() {
    var __super = (key) => super[key];
    return __async(this, null, function* () {
      const payload = yield __super("load").call(this).catch((reason) => Promise.resolve(reason));
      if (payload instanceof AbstractLoaderError) {
        return Promise.reject(payload);
      }
      const { data, url } = payload;
      const { rows, cols, matrix } = data;
      const attrs = {
        rows: cols,
        cols: rows
      };
      const shape = [attrs.rows.length, attrs.cols.length];
      const normalizedMatrix = matrix.map((col) => {
        const [min, max2] = extent3(col);
        const normalize2 = (d) => Math.floor((d - min) / (max2 - min) * 255);
        return col.map(normalize2);
      });
      const tNormalizedMatrix = range6(shape[0]).map((i) => range6(shape[1]).map((j) => normalizedMatrix[j][i]));
      const normalizedFlatMatrix = tNormalizedMatrix.flat();
      const arr = { data: Uint8Array.from(normalizedFlatMatrix) };
      return Promise.resolve(new LoaderResult([attrs, arr], url));
    });
  }
};

// src/loaders/RasterJsonLoader.js
import { openArray as openArray2 } from "zarr";
function initLoader(imageData) {
  return __async(this, null, function* () {
    const {
      type: type16,
      url,
      metadata,
      requestInit
    } = imageData;
    switch (type16) {
      case "zarr": {
        const {
          dimensions,
          isPyramid,
          transform
        } = metadata || {};
        const labels = dimensions.map((d) => d.field);
        let source;
        if (isPyramid) {
          const metadataUrl = `${url}${url.slice(-1) === "/" ? "" : "/"}.zmetadata`;
          const response = yield fetch(metadataUrl);
          const { metadata: zarrMetadata } = yield response.json();
          const paths = Object.keys(zarrMetadata).filter((metaKey) => metaKey.includes(".zarray")).map((arrMetaKeys) => arrMetaKeys.slice(0, -7));
          const data = yield Promise.all(paths.map((path) => openArray2({ store: url, path })));
          const [yChunk, xChunk] = data[0].chunks.slice(-2);
          const size = Math.min(yChunk, xChunk);
          const tileSize = __pow(2, Math.floor(Math.log2(size)));
          source = data.map((d) => new ZarrPixelSource(d, labels, tileSize));
        } else {
          const data = yield openArray2({ store: url });
          source = new ZarrPixelSource(data, labels);
        }
        return { data: source, metadata: { dimensions, transform }, channels: (dimensions.find((d) => d.field === "channel") || dimensions[0]).values };
      }
      case "ome-tiff": {
        let loader;
        if (metadata && "omeTiffOffsetsUrl" in metadata) {
          const { omeTiffOffsetsUrl } = metadata;
          const res = yield fetch(omeTiffOffsetsUrl, requestInit || {});
          if (res.ok) {
            const offsets = yield res.json();
            loader = yield loadOmeTiff(url, {
              offsets,
              headers: requestInit == null ? void 0 : requestInit.headers
            });
          } else {
            throw new Error("Offsets not found but provided.");
          }
        } else {
          loader = yield loadOmeTiff(url, { headers: requestInit == null ? void 0 : requestInit.headers });
        }
        const { Pixels: { Channels } } = loader.metadata;
        const channels2 = Array.isArray(Channels) ? Channels.map((channel, i) => channel.Name || `Channel ${i}`) : [Channels.Name || `Channel ${0}`];
        return __spreadProps(__spreadValues({}, loader), { channels: channels2 });
      }
      default: {
        throw Error(`Image type (${type16}) is not supported`);
      }
    }
  });
}
var RasterLoader = class extends JsonLoader {
  constructor(dataSource, params) {
    const { url, options } = params;
    if (!url && options) {
      dataSource.url = URL.createObjectURL(new Blob([JSON.stringify(options)]));
    }
    super(dataSource, params);
    this.schema = raster_schema_default;
  }
  load() {
    var __super = (key) => super[key];
    return __async(this, null, function* () {
      const payload = yield __super("load").call(this).catch((reason) => Promise.resolve(reason));
      if (payload instanceof AbstractLoaderError) {
        return Promise.reject(payload);
      }
      const { data: raster } = payload;
      const { images, renderLayers, usePhysicalSizeScaling = false } = raster;
      const urls = images.filter((image) => !image.url.includes("zarr")).map((image) => [image.url, image.name]);
      const imagesWithLoaderCreators = images.map((image) => __spreadProps(__spreadValues({}, image), {
        loaderCreator: () => __async(this, null, function* () {
          return initLoader(image);
        })
      }));
      if (!this.autoImageCache) {
        this.autoImageCache = initializeRasterLayersAndChannels(imagesWithLoaderCreators, renderLayers, usePhysicalSizeScaling);
      }
      return this.autoImageCache.then((autoImages) => {
        const [autoImageLayers, imageLayerLoaders, imageLayerMeta] = autoImages;
        const coordinationValues = {
          spatialRasterLayers: autoImageLayers
        };
        return new LoaderResult({ loaders: imageLayerLoaders, meta: imageLayerMeta }, urls, coordinationValues);
      });
    });
  }
};

// src/loaders/OmeZarrLoader.js
function hexToRgb(hex) {
  const result = /^#?([A-F\d]{2})([A-F\d]{2})([A-F\d]{2})$/i.exec(hex);
  return [
    parseInt(result[1].toLowerCase(), 16),
    parseInt(result[2].toLowerCase(), 16),
    parseInt(result[3].toLowerCase(), 16)
  ];
}
var OmeZarrLoader = class extends AbstractTwoStepLoader {
  load() {
    return __async(this, null, function* () {
      var _a2, _b2;
      const payload = yield this.dataSource.getJson(".zattrs").catch((reason) => Promise.resolve(reason));
      if (payload instanceof AbstractLoaderError) {
        return Promise.reject(payload);
      }
      const loader = yield loadOmeZarr(this.url, { fetchOptions: this.requestInit, type: "multiscales" });
      const { metadata } = loader;
      const { omero } = metadata;
      if (!omero) {
        console.error("Path for image not valid");
        return Promise.reject(payload);
      }
      const { rdefs, channels: channels2 } = omero;
      const t = (_a2 = rdefs.defaultT) != null ? _a2 : 0;
      const z = (_b2 = rdefs.defaultZ) != null ? _b2 : 0;
      const imagesWithLoaderCreators = [
        {
          name: omero.name,
          channels: channels2.map((channel, i) => ({
            selection: { z, t, c: i },
            slider: [channel.window.start, channel.window.end],
            color: hexToRgb(channel.color)
          })),
          loaderCreator: () => __async(this, null, function* () {
            return __spreadProps(__spreadValues({}, loader), { channels: channels2.map((c) => c.label) });
          })
        }
      ];
      const [
        autoImageLayers,
        imageLayerLoaders,
        imageLayerMeta
      ] = yield initializeRasterLayersAndChannels(imagesWithLoaderCreators, void 0);
      const coordinationValues = {
        spatialRasterLayers: autoImageLayers
      };
      return Promise.resolve(new LoaderResult({ loaders: imageLayerLoaders, meta: imageLayerMeta }, [], coordinationValues));
    });
  }
};

// src/components/sets/io.js
import Ajv2 from "ajv";
import isNil2 from "lodash/isNil";
import { dsvFormat } from "d3-dsv";
import { parse as json2csv } from "json2csv";
function tryUpgradeTreeToLatestSchema(currTree, datatype) {
  const validate = new Ajv2().compile(HIERARCHICAL_SCHEMAS[datatype].schema);
  const valid = validate(currTree);
  if (!valid) {
    const failureReason = JSON.stringify(validate.errors, null, 2);
    throw new Error(`Tree validation failed: ${failureReason}`);
  } else if (currTree.datatype !== datatype) {
    throw new Error(`The data type does not match the expected data type of '${datatype}'.`);
  }
  if (currTree.version === "0.1.2") {
    return __spreadProps(__spreadValues({}, currTree), {
      version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,
      tree: currTree.tree.map((levelZeroNode) => nodeTransform(levelZeroNode, (n) => !n.children && Array.isArray(n.set), (n) => __spreadProps(__spreadValues({}, n), { set: n.set.map((itemId) => [itemId, null]) }), []))
    });
  }
  return currTree;
}
function handleImportJSON(result, datatype, theme) {
  let importData = JSON.parse(result);
  importData = tryUpgradeTreeToLatestSchema(importData, datatype);
  return importData;
}
function handleImportTabular(result, datatype, theme) {
  const dsvParser = dsvFormat(SEPARATOR_TABULAR);
  const importData = dsvParser.parse(result, (row) => ({
    groupName: row.groupName,
    setName: row.setName,
    setColor: row.setColor ? colorStringToArray(row.setColor) : getDefaultColor(theme),
    obsId: row.obsId,
    predictionScore: isNil2(row.predictionScore) || row.predictionScore === NA_VALUE_TABULAR ? null : +row.predictionScore
  }));
  const validate = new Ajv2().compile(TABULAR_SCHEMAS[datatype].schema);
  const valid = validate(importData);
  if (!valid) {
    const failureReason = JSON.stringify(validate.errors, null, 2);
    throw new Error(`Import validation failed: ${failureReason}`);
  } else {
    const treeToImport = {
      version: HIERARCHICAL_SCHEMAS[datatype].latestVersion,
      datatype,
      tree: []
    };
    const uniqueGroupNames = Array.from(new Set(importData.map((d) => d.groupName)));
    uniqueGroupNames.forEach((groupName) => {
      const levelZeroNode = {
        name: groupName,
        children: []
      };
      const groupRows = importData.filter((d) => d.groupName === groupName);
      const uniqueSetNames = Array.from(new Set(groupRows.map((d) => d.setName)));
      uniqueSetNames.forEach((setName) => {
        const setRows = groupRows.filter((d) => d.setName === setName);
        const { setColor } = setRows[0];
        const levelOneNode = {
          name: setName,
          color: setColor,
          set: setRows.map((d) => [d.obsId, d.predictionScore])
        };
        levelZeroNode.children.push(levelOneNode);
      });
      treeToImport.tree.push(levelZeroNode);
    });
    return treeToImport;
  }
}
function handleExportJSON(result) {
  const jsonString = JSON.stringify(result);
  const dataString = `data:${MIME_TYPE_JSON};charset=utf-8,${encodeURIComponent(jsonString)}`;
  return dataString;
}
function handleExportTabular(result) {
  const exportData = [];
  result.tree.forEach((levelZeroNode) => {
    levelZeroNode.children.forEach((levelOneNode) => {
      if (levelOneNode.set) {
        levelOneNode.set.forEach(([obsId, prob]) => {
          exportData.push({
            groupName: levelZeroNode.name,
            setName: levelOneNode.name,
            setColor: colorArrayToString(levelOneNode.color),
            obsId,
            predictionScore: isNil2(prob) ? NA_VALUE_TABULAR : prob
          });
        });
      }
    });
  });
  const csvString = json2csv(exportData, {
    fields: ["groupName", "setName", "setColor", "obsId", "predictionScore"],
    delimiter: SEPARATOR_TABULAR
  });
  const dataString = `data:${MIME_TYPE_TABULAR};charset=utf-8,${encodeURIComponent(csvString)}`;
  return dataString;
}
function downloadForUser(dataString, fileName) {
  const downloadAnchorNode = document.createElement("a");
  downloadAnchorNode.setAttribute("href", dataString);
  downloadAnchorNode.setAttribute("download", fileName);
  document.body.appendChild(downloadAnchorNode);
  downloadAnchorNode.click();
  downloadAnchorNode.remove();
}

// src/loaders/CellSetsJsonLoader.js
var CellSetsJsonLoader = class extends JsonLoader {
  constructor(dataSource, params) {
    super(dataSource, params);
    this.schema = cell_sets_schema_default;
  }
  load() {
    var __super = (key) => super[key];
    return __async(this, null, function* () {
      const payload = yield __super("load").call(this).catch((reason) => Promise.resolve(reason));
      if (payload instanceof AbstractLoaderError) {
        return Promise.reject(payload);
      }
      const { data: rawData, url } = payload;
      const upgradedData = tryUpgradeTreeToLatestSchema(rawData, "cell");
      const coordinationValues = {
        cellSetSelection: [],
        cellSetColor: []
      };
      if (upgradedData && upgradedData.tree.length >= 1) {
        const { tree } = upgradedData;
        const newAutoSetSelectionParentName = tree[0].name;
        const newAutoSetSelections = tree[0].children.map((node) => [newAutoSetSelectionParentName, node.name]);
        const newAutoSetColors = initializeCellSetColor(upgradedData, []);
        coordinationValues.cellSetSelection = newAutoSetSelections;
        coordinationValues.cellSetColor = newAutoSetColors;
      }
      return Promise.resolve(new LoaderResult(upgradedData, url, coordinationValues));
    });
  }
};

// src/loaders/anndata-loaders/CellSetsZarrLoader.js
import { InternMap } from "internmap";
function dataToCellSetsTree(data, options) {
  const [cellNames, cellSets] = data;
  const cellSetsTree = treeInitialize(SETS_DATATYPE_CELL);
  cellSets.forEach((cellSetIds, j) => {
    const name2 = options[j].groupName;
    let levelZeroNode = {
      name: name2,
      children: []
    };
    if (cellSetIds.length > 0 && Array.isArray(cellSetIds[0])) {
      const levelSets = new InternMap([], JSON.stringify);
      cellNames.forEach((id, i) => {
        const classes = cellSetIds.map((col) => col[i]);
        if (levelSets.has(classes)) {
          levelSets.get(classes).push([id, null]);
        } else {
          levelSets.set(classes, [[id, null]]);
        }
      });
      const levels = Array.from(levelSets.keys());
      const getNextLevelNames = (levelSuffixes) => {
        const nextLevelNames = Array.from(new Set(levelSuffixes.map((l) => l[0])));
        return nextLevelNames.sort((a, b) => a.localeCompare(b));
      };
      const getNode = (parentLevelPrefixes, currLevelName, childLevelSuffixes) => {
        const isLeaf = childLevelSuffixes.length === 0;
        const resultNode = {
          name: currLevelName
        };
        if (isLeaf) {
          resultNode.set = levelSets.get([...parentLevelPrefixes, currLevelName]);
        } else {
          const shouldBeLeaf = childLevelSuffixes.length === 1 && currLevelName === childLevelSuffixes[0][childLevelSuffixes[0].length - 1];
          if (shouldBeLeaf) {
            resultNode.set = levelSets.get([...parentLevelPrefixes, currLevelName, ...childLevelSuffixes[0]]);
          } else {
            const nextLevelNames = getNextLevelNames(childLevelSuffixes);
            resultNode.children = nextLevelNames.map((nextLevelName) => getNode([...parentLevelPrefixes, currLevelName], nextLevelName, childLevelSuffixes.filter((l) => l[0] === nextLevelName).map((l) => l.slice(1)).filter((v) => v.length > 0)));
          }
        }
        return resultNode;
      };
      const levelOneNodes = getNextLevelNames(levels).map((levelOneName) => getNode([], levelOneName, levels.filter((l) => l[0] === levelOneName).map((l) => l.slice(1))));
      levelZeroNode.children = levelOneNodes;
    } else {
      const uniqueCellSetIds = Array.from(new Set(cellSetIds)).sort();
      const clusters = {};
      uniqueCellSetIds.forEach((id) => clusters[id] = { name: id, set: [] });
      cellSetIds.forEach((id, i) => clusters[id].set.push([cellNames[i], null]));
      Object.values(clusters).forEach((cluster) => levelZeroNode = nodeAppendChild(levelZeroNode, cluster));
    }
    cellSetsTree.tree.push(levelZeroNode);
  });
  return cellSetsTree;
}
var CellSetsZarrLoader = class extends AbstractTwoStepLoader {
  loadCellSetIds() {
    const { options } = this;
    const cellSetZarrLocation = options.map(({ setName }) => setName);
    return this.dataSource.loadObsVariables(cellSetZarrLocation);
  }
  load() {
    return __async(this, null, function* () {
      if (!this.cellSetsTree) {
        const { options } = this;
        this.cellSetsTree = Promise.all([
          this.dataSource.loadObsIndex(),
          this.loadCellSetIds()
        ]).then((data) => dataToCellSetsTree(data, options));
      }
      const cellSetsTree = yield this.cellSetsTree;
      const coordinationValues = {};
      const { tree } = cellSetsTree;
      const newAutoSetSelectionParentName = tree[0].name;
      const newAutoSetSelections = tree[0].children.map((node) => [
        newAutoSetSelectionParentName,
        node.name
      ]);
      const newAutoSetColors = initializeCellSetColor(cellSetsTree, []);
      coordinationValues.cellSetSelection = newAutoSetSelections;
      coordinationValues.cellSetColor = newAutoSetColors;
      return Promise.resolve(new LoaderResult(cellSetsTree, null, coordinationValues));
    });
  }
};

// src/loaders/anndata-loaders/CellsZarrLoader.js
var CellsZarrLoader = class extends AbstractTwoStepLoader {
  loadXy() {
    const { xy } = this.options || {};
    if (this.xy) {
      return this.xy;
    }
    if (!this.xy && xy) {
      this.xy = this.dataSource.loadNumeric(xy);
      return this.xy;
    }
    this.xy = Promise.resolve(null);
    return this.xy;
  }
  loadPoly() {
    const { poly } = this.options || {};
    if (this.poly) {
      return this.poly;
    }
    if (!this.poly && poly) {
      this.poly = this.dataSource.loadNumeric(poly);
      return this.poly;
    }
    this.poly = Promise.resolve(null);
    return this.poly;
  }
  loadMappings() {
    const { mappings } = this.options || {};
    if (this.mappings) {
      return this.mappings;
    }
    if (!this.mappings && mappings) {
      this.mappings = Promise.all(Object.keys(mappings).map((coordinationName) => __async(this, null, function* () {
        const { key } = mappings[coordinationName];
        return { coordinationName, arr: yield this.dataSource.loadNumeric(key) };
      })));
      return this.mappings;
    }
    this.mappings = Promise.resolve(null);
    return this.mappings;
  }
  loadFactors() {
    const { factors } = this.options || {};
    if (factors) {
      return this.dataSource.loadObsVariables(factors);
    }
    return Promise.resolve(null);
  }
  load() {
    return __async(this, null, function* () {
      if (!this.cells) {
        this.cells = Promise.all([
          this.loadMappings(),
          this.loadXy(),
          this.loadPoly(),
          this.dataSource.loadObsIndex(),
          this.loadFactors()
        ]).then(([mappings, xy, poly, cellNames, factors]) => {
          const cells = {};
          cellNames.forEach((name2, i) => {
            cells[name2] = {};
            if (mappings) {
              mappings.forEach(({ coordinationName, arr }) => {
                if (!cells[name2].mappings) {
                  cells[name2].mappings = {};
                }
                const { dims } = this.options.mappings[coordinationName];
                cells[name2].mappings[coordinationName] = dims.map((dim) => arr.data[i][dim]);
              });
            }
            if (xy) {
              cells[name2].xy = xy.data[i];
            }
            if (poly) {
              cells[name2].poly = poly.data[i];
            }
            if (factors) {
              const factorsObj = {};
              factors.forEach((factor, j) => factorsObj[this.options.factors[j].split("/").slice(-1)] = factor[i]);
              cells[name2].factors = factorsObj;
            }
          });
          return cells;
        });
      }
      return Promise.resolve(new LoaderResult(yield this.cells, null));
    });
  }
};

// src/loaders/anndata-loaders/MatrixZarrLoader.js
import { openArray as openArray3, slice as slice2 } from "zarr";
import { extent as extent4 } from "d3-array";
var normalize = (arr) => {
  const [min, max2] = extent4(arr);
  const ratio = 255 / (max2 - min);
  const data = new Uint8Array(arr.map((i) => Math.floor((i - min) * ratio)));
  return { data };
};
var concatenateColumnVectors = (arr) => {
  const numCols = arr.length;
  const numRows = arr[0].length;
  const { BYTES_PER_ELEMENT } = arr[0];
  const view = new DataView(new ArrayBuffer(numCols * numRows * BYTES_PER_ELEMENT));
  const TypedArray = arr[0].constructor;
  const dtype = TypedArray.name.replace("Array", "");
  for (let i = 0; i < numCols; i += 1) {
    for (let j = 0; j < numRows; j += 1) {
      view[`set${dtype}`](BYTES_PER_ELEMENT * (j * numCols + i), arr[i][j], true);
    }
  }
  return new TypedArray(view.buffer);
};
var MatrixZarrLoader2 = class extends AbstractTwoStepLoader {
  loadFilteredGeneNames() {
    return __async(this, null, function* () {
      if (this.filteredGeneNames) {
        return this.filteredGeneNames;
      }
      const { geneFilter: geneFilterZarr } = this.options;
      const getFilterFn = () => __async(this, null, function* () {
        if (!geneFilterZarr)
          return (data) => data;
        const geneFilter = yield this.dataSource.getFlatArrDecompressed(geneFilterZarr);
        return (data) => data.filter((_, j) => geneFilter[j]);
      });
      this.filteredGeneNames = Promise.all([this.dataSource.loadVarIndex(), getFilterFn()]).then(([data, filter]) => filter(data));
      return this.filteredGeneNames;
    });
  }
  _getFilteredGenes(filterZarr) {
    return __async(this, null, function* () {
      const filter = yield this.dataSource.getFlatArrDecompressed(filterZarr);
      const geneNames = yield this.loadFilteredGeneNames();
      const genes = geneNames.filter((_, i) => filter[i]);
      return genes;
    });
  }
  _getGeneIndices(selection) {
    return __async(this, null, function* () {
      const geneNames = yield this.loadFilteredGeneNames();
      return selection.map((gene) => geneNames.indexOf(gene));
    });
  }
  _getNumCells() {
    return __async(this, null, function* () {
      const cells = yield this.dataSource.loadObsIndex();
      return cells.length;
    });
  }
  _getNumGenes() {
    return __async(this, null, function* () {
      const genes = yield this.loadFilteredGeneNames();
      return genes.length;
    });
  }
  _openSparseArrays() {
    return __async(this, null, function* () {
      const { options: { matrix } } = this;
      const { store } = this.dataSource;
      if (this.sparseArrays) {
        return this.sparseArrays;
      }
      this.sparseArrays = Promise.all(["indptr", "indices", "data"].map((name2) => openArray3({ store, path: `${matrix}/${name2}`, mode: "r" })));
      return this.sparseArrays;
    });
  }
  _loadCSCGeneSelection(selection) {
    return __async(this, null, function* () {
      const indices = yield this._getGeneIndices(selection);
      const [indptrArr, indexArr, cellXGeneArr] = yield this._openSparseArrays();
      const numCells = yield this._getNumCells();
      const { data: cols } = yield indptrArr.getRaw(null);
      return Promise.all(indices.map((index) => __async(this, null, function* () {
        const startRowIndex = cols[index];
        const endRowIndex = cols[index + 1];
        const isColumnAllZeros = startRowIndex === endRowIndex;
        const geneData = new Float32Array(numCells).fill(0);
        if (isColumnAllZeros) {
          return geneData;
        }
        const { data: rowIndices } = yield indexArr.get([
          slice2(startRowIndex, endRowIndex)
        ]);
        const { data: cellXGeneData } = yield cellXGeneArr.get([
          slice2(startRowIndex, endRowIndex)
        ]);
        for (let rowIndex = 0; rowIndex < rowIndices.length; rowIndex += 1) {
          geneData[rowIndices[rowIndex]] = cellXGeneData[rowIndex];
        }
        return geneData;
      })));
    });
  }
  _loadCSRGeneSelection(selection) {
    return __async(this, null, function* () {
      const indices = yield this._getGeneIndices(selection);
      const numGenes = yield this._getNumGenes();
      const numCells = yield this._getNumCells();
      const cellXGene = yield this._loadCSRSparseCellXGene();
      return indices.map((index) => {
        const geneData = new Float32Array(numCells).fill(0);
        for (let i = 0; i < numCells; i += 1) {
          geneData[i] = cellXGene[i * numGenes + index];
        }
        return geneData;
      });
    });
  }
  _loadCSRSparseCellXGene() {
    return __async(this, null, function* () {
      if (this._sparseMatrix) {
        return this._sparseMatrix;
      }
      this._sparseMatrix = this._openSparseArrays().then((sparseArrays) => __async(this, null, function* () {
        const { options: { matrix } } = this;
        const { shape } = yield this.dataSource.getJson(`${matrix}/.zattrs`);
        const [rows, cols, cellXGene] = yield Promise.all(sparseArrays.map((arr) => __async(this, null, function* () {
          const { data } = yield arr.getRaw(null);
          return data;
        })));
        const cellXGeneMatrix = new Float32Array(shape[0] * shape[1]).fill(0);
        let row = 0;
        rows.forEach((_, index) => {
          const rowStart = rows[index];
          const rowEnd = rows[index + 1];
          for (let i = rowStart; i < rowEnd; i += 1) {
            const val = cellXGene[i];
            const col = cols[i];
            cellXGeneMatrix[row * shape[1] + col] = val;
          }
          row += 1;
        });
        return cellXGeneMatrix;
      }));
      return this._sparseMatrix;
    });
  }
  _loadCSCSparseCellXGene() {
    return __async(this, null, function* () {
      if (this._sparseMatrix) {
        return this._sparseMatrix;
      }
      this._sparseMatrix = this._openSparseArrays().then((sparseArrays) => __async(this, null, function* () {
        const { options: { matrix } } = this;
        const { shape } = yield this.dataSource.getJson(`${matrix}/.zattrs`);
        const [cols, rows, cellXGene] = yield Promise.all(sparseArrays.map((arr) => __async(this, null, function* () {
          const { data } = yield arr.getRaw(null);
          return data;
        })));
        const cellXGeneMatrix = new Float32Array(shape[0] * shape[1]).fill(0);
        let col = 0;
        cols.forEach((_, index) => {
          const colStart = cols[index];
          const colEnd = cols[index + 1];
          for (let i = colStart; i < colEnd; i += 1) {
            const val = cellXGene[i];
            const row = rows[i];
            cellXGeneMatrix[row * shape[1] + col] = val;
          }
          col += 1;
        });
        return cellXGeneMatrix;
      }));
      return this._sparseMatrix;
    });
  }
  loadCellXGene() {
    return __async(this, null, function* () {
      const { store } = this.dataSource;
      if (this.cellXGene) {
        return this.cellXGene;
      }
      const { options: { matrix, matrixGeneFilter } } = this;
      if (!this._matrixZattrs) {
        this._matrixZattrs = yield this.dataSource.getJson(`${matrix}/.zattrs`);
      }
      const encodingType = this._matrixZattrs["encoding-type"];
      if (!matrixGeneFilter) {
        if (encodingType === "csr_matrix") {
          this.cellXGene = this._loadCSRSparseCellXGene().then((data) => normalize(data));
        } else if (encodingType === "csc_matrix") {
          this.cellXGene = this._loadCSCSparseCellXGene().then((data) => normalize(data));
        } else {
          if (!this.arr) {
            this.arr = openArray3({ store, path: matrix, mode: "r" });
          }
          this.cellXGene = this.arr.then((z) => z.getRaw(null).then(({ data }) => normalize(data)));
        }
      } else if (encodingType === "csr_matrix") {
        this.cellXGene = this._loadCSRSparseCellXGene().then((cellXGene) => __async(this, null, function* () {
          const filteredGenes = yield this._getFilteredGenes(matrixGeneFilter);
          const numGenesFiltered = filteredGenes.length;
          const geneNames = yield this.loadFilteredGeneNames();
          const numGenes = geneNames.length;
          const numCells = yield this._getNumCells();
          const cellXGeneMatrixFiltered = new Float32Array(numCells * numGenesFiltered).fill(0);
          for (let i = 0; i < numGenesFiltered; i += 1) {
            const index = geneNames.indexOf(filteredGenes[i]);
            for (let j = 0; j < numCells; j += 1) {
              cellXGeneMatrixFiltered[j * numGenesFiltered + i] = cellXGene[j * numGenes + index];
            }
          }
          return normalize(cellXGeneMatrixFiltered);
        }));
      } else {
        const genes = yield this._getFilteredGenes(matrixGeneFilter);
        this.cellXGene = this.loadGeneSelection({ selection: genes, shouldNormalize: false }).then(({ data }) => normalize(concatenateColumnVectors(data)));
      }
      return this.cellXGene;
    });
  }
  loadGeneSelection(_0) {
    return __async(this, arguments, function* ({ selection, shouldNormalize = true }) {
      const { options: { matrix } } = this;
      const { store } = this.dataSource;
      if (!this._matrixZattrs) {
        this._matrixZattrs = yield this.dataSource.getJson(`${matrix}/.zattrs`);
      }
      const encodingType = this._matrixZattrs["encoding-type"];
      let genes;
      if (encodingType === "csc_matrix") {
        genes = yield this._loadCSCGeneSelection(selection);
      } else if (encodingType === "csr_matrix") {
        genes = yield this._loadCSRGeneSelection(selection);
      } else {
        if (!this.arr) {
          this.arr = openArray3({ store, path: matrix, mode: "r" });
        }
        const indices = yield this._getGeneIndices(selection);
        genes = yield Promise.all(indices.map((index) => this.arr.then((z) => z.get([null, index])).then(({ data }) => data)));
      }
      return { data: genes.map((i) => shouldNormalize ? normalize(i).data : i), url: null };
    });
  }
  loadAttrs() {
    return Promise.all([this.dataSource.loadObsIndex(), this.loadFilteredGeneNames()]).then((d) => {
      const [cellNames, geneNames] = d;
      const attrs = { rows: cellNames, cols: geneNames };
      return {
        data: attrs,
        url: null
      };
    });
  }
  load() {
    return Promise.all([this.loadAttrs(), this.loadCellXGene()]).then((d) => __async(this, null, function* () {
      const [{ data: attrs }, cellXGene] = d;
      const {
        options: { matrixGeneFilter: matrixGeneFilterZarr }
      } = this;
      if (matrixGeneFilterZarr) {
        const matrixGeneFilter = yield this.dataSource.getFlatArrDecompressed(matrixGeneFilterZarr);
        attrs.cols = attrs.cols.filter((_, i) => matrixGeneFilter[i]);
      }
      return Promise.resolve(new LoaderResult([attrs, cellXGene], null));
    }));
  }
};

// src/loaders/anndata-loaders/index.js
var anndata_loaders_default = { CellSetsZarrLoader, CellsZarrLoader, MatrixZarrLoader: MatrixZarrLoader2 };

// src/loaders/GenomicProfilesZarrLoader.js
var GenomicProfilesZarrLoader = class extends AbstractTwoStepLoader {
  loadAttrs() {
    if (this.attrs) {
      return this.attrs;
    }
    this.attrs = this.dataSource.getJson(".zattrs");
    return this.attrs;
  }
  load() {
    const { url } = this;
    return this.loadAttrs().then((attrs) => Promise.resolve(new LoaderResult(attrs, url)));
  }
};

// src/loaders/data-sources/AnnDataSource.js
import { openArray as openArray4 } from "zarr";
import range7 from "lodash/range";

// src/loaders/data-sources/ZarrDataSource.js
import { HTTPStore as HTTPStore2, KeyError as KeyError2 } from "zarr";
var ZarrDataSource = class {
  constructor({ url, requestInit }) {
    const supportedMethods = ["GET"];
    this.store = new HTTPStore2(url, {
      supportedMethods,
      fetchOptions: requestInit
    });
  }
  getJson(key) {
    return __async(this, null, function* () {
      try {
        const buf = yield this.store.getItem(key);
        const text = new TextDecoder("utf-8").decode(buf);
        return JSON.parse(text);
      } catch (err) {
        if (err instanceof KeyError2) {
          return {};
        }
        throw err;
      }
    });
  }
};

// src/loaders/data-sources/AnnDataSource.js
var readFloat32FromUint8 = (bytes) => {
  if (bytes.length !== 4) {
    throw new Error("readFloat32 only takes in length 4 byte buffers");
  }
  return new Int32Array(bytes.buffer)[0];
};
var HEADER_LENGTH = 4;
function parseVlenUtf8(buffer) {
  const decoder = new TextDecoder();
  let data = 0;
  const dataEnd = data + buffer.length;
  const length = readFloat32FromUint8(buffer.slice(data, HEADER_LENGTH));
  if (buffer.length < HEADER_LENGTH) {
    throw new Error("corrupt buffer, missing or truncated header");
  }
  data += HEADER_LENGTH;
  const output = new Array(length);
  for (let i = 0; i < length; i += 1) {
    if (data + 4 > dataEnd) {
      throw new Error("corrupt buffer, data seem truncated");
    }
    const l = readFloat32FromUint8(buffer.slice(data, data + 4));
    data += 4;
    if (data + l > dataEnd) {
      throw new Error("corrupt buffer, data seem truncated");
    }
    output[i] = decoder.decode(buffer.slice(data, data + l));
    data += l;
  }
  return output;
}
var AnnDataSource = class extends ZarrDataSource {
  constructor(...args) {
    super(...args);
    this.obsPromises = new Map();
  }
  loadObsVariables(obsPaths) {
    const obsPromises = obsPaths.map((obsPath) => {
      const getObsCol = (obsCol) => {
        if (!this.obsPromises.has(obsCol)) {
          const obsPromise = this._loadObsVariable(obsCol).catch((err) => {
            this.obsPromises.delete(obsCol);
            throw err;
          });
          this.obsPromises.set(obsCol, obsPromise);
        }
        return this.obsPromises.get(obsCol);
      };
      if (Array.isArray(obsPath)) {
        return Promise.resolve(Promise.all(obsPath.map(getObsCol)));
      }
      return getObsCol(obsPath);
    });
    return Promise.all(obsPromises);
  }
  _loadObsVariable(obs) {
    return __async(this, null, function* () {
      const { store } = this;
      const { categories } = yield this.getJson(`${obs}/.zattrs`);
      let categoriesValues;
      if (categories) {
        const { dtype } = yield this.getJson(`/obs/${categories}/.zarray`);
        if (dtype === "|O") {
          categoriesValues = yield this.getFlatArrDecompressed(`/obs/${categories}`);
        }
      }
      const obsArr = yield openArray4({ store, path: obs, mode: "r" });
      const obsValues = yield obsArr.get();
      const { data } = obsValues;
      const mappedObsValues = Array.from(data).map((i) => !categoriesValues ? String(i) : categoriesValues[i]);
      return mappedObsValues;
    });
  }
  loadNumeric(path) {
    const { store } = this;
    return openArray4({
      store,
      path,
      mode: "r"
    }).then((arr) => arr.get());
  }
  getFlatArrDecompressed(path) {
    const { store } = this;
    return openArray4({
      store,
      path,
      mode: "r"
    }).then((z) => __async(this, null, function* () {
      let data;
      const parseAndMergeTextBytes = (dbytes) => {
        const text = parseVlenUtf8(dbytes);
        if (!data) {
          data = text;
        } else {
          data = data.concat(text);
        }
      };
      const mergeBytes = (dbytes) => {
        if (!data) {
          data = dbytes;
        } else {
          const tmp = new Uint8Array(dbytes.buffer.byteLength + data.buffer.byteLength);
          tmp.set(new Uint8Array(data.buffer), 0);
          tmp.set(dbytes, data.buffer.byteLength);
          data = tmp;
        }
      };
      const numRequests = Math.ceil(z.meta.shape[0] / z.meta.chunks[0]);
      const requests = range7(numRequests).map((item) => __async(this, null, function* () {
        return store.getItem(`${z.keyPrefix}${String(item)}`).then((buf) => z.compressor.then((compressor) => compressor.decode(buf)));
      }));
      const dbytesArr = yield Promise.all(requests);
      dbytesArr.forEach((dbytes) => {
        if (Array.isArray(z.meta.filters) && z.meta.filters[0].id === "vlen-utf8") {
          parseAndMergeTextBytes(dbytes);
        } else {
          mergeBytes(dbytes);
        }
      });
      const {
        meta: {
          shape: [length]
        }
      } = z;
      return data.slice(0, length);
    }));
  }
  loadObsIndex() {
    if (this.obsIndex) {
      return this.obsIndex;
    }
    this.obsIndex = this.getJson("obs/.zattrs").then(({ _index }) => this.getFlatArrDecompressed(`/obs/${_index}`));
    return this.obsIndex;
  }
  loadVarIndex() {
    if (this.varIndex) {
      return this.varIndex;
    }
    this.varIndex = this.getJson("var/.zattrs").then(({ _index }) => this.getFlatArrDecompressed(`/var/${_index}`));
    return this.varIndex;
  }
};

// src/loaders/errors/DataSourceFetchError.js
var DataSourceFetchError = class extends AbstractLoaderError {
  constructor(source, url, headers) {
    super(`${source} Error HTTP Status fetching from ${url}`);
    this.source = source;
    this.url = url;
    this.headers = headers;
  }
  warnInConsole() {
    const { source, url, headers } = this;
    console.warn(`${source} failed to fetch from ${url} with headers ${headers}`);
  }
};

// src/loaders/data-sources/JsonSource.js
var JsonSource = class {
  constructor({ url, requestInit }) {
    this.url = url;
    this.requestInit = requestInit;
  }
  get data() {
    if (this._data)
      return this._data;
    this._data = fetch(this.url, this.requestInit).then((response) => {
      if (!response.ok) {
        return Promise.reject(new DataSourceFetchError("JsonSource", this.url, response.headers));
      }
      return response.json();
    }).catch(() => Promise.reject(new DataSourceFetchError("JsonSource", this.url, {})));
    return this._data;
  }
};

// src/loaders/types.js
var ANNDATA = "anndata";
var fileTypeToLoaderAndSource = {
  "expression-matrix.zarr": [ZarrDataSource, MatrixZarrLoader],
  "clusters.json": [JsonSource, ClustersJsonAsMatrixZarrLoader],
  "genes.json": [JsonSource, GenesJsonAsMatrixZarrLoader],
  "cells.json": [JsonSource, JsonLoader],
  "molecules.json": [JsonSource, JsonLoader],
  "neighborhoods.json": [JsonSource, JsonLoader],
  "raster.json": [JsonSource, RasterLoader],
  "raster.ome-zarr": [ZarrDataSource, OmeZarrLoader],
  "cell-sets.json": [JsonSource, CellSetsJsonLoader],
  [`${ANNDATA}-cell-sets.zarr`]: [AnnDataSource, anndata_loaders_default.CellSetsZarrLoader],
  [`${ANNDATA}-cells.zarr`]: [AnnDataSource, anndata_loaders_default.CellsZarrLoader],
  [`${ANNDATA}-expression-matrix.zarr`]: [AnnDataSource, anndata_loaders_default.MatrixZarrLoader],
  "genomic-profiles.zarr": [ZarrDataSource, GenomicProfilesZarrLoader]
};
function getSourceAndLoaderFromFileType(type16) {
  return fileTypeToLoaderAndSource[type16] || [JsonSource, JsonLoader];
}

// src/app/vitessce-grid-utils.js
function getNumRows(layout) {
  let max2 = 0;
  let bottomY;
  for (let i = 0, len = layout.length; i < len; i++) {
    bottomY = layout[i].y + layout[i].h;
    if (bottomY > max2)
      max2 = bottomY;
  }
  return max2;
}
function getRowHeight(containerHeight, numRows, margin2, padding2) {
  const effectiveContainerHeight = containerHeight - 2 * padding2 - (numRows - 1) * margin2;
  return effectiveContainerHeight / numRows;
}
function useRowHeight(config, initialRowHeight, height, margin2, padding2) {
  const [containerHeight, setContainerHeight] = useState9(height);
  const [rowHeight, setRowHeight] = useState9(initialRowHeight);
  const containerRef = useRef6();
  useEffect8(() => {
    const numRows = getNumRows(config.layout);
    const newRowHeight = getRowHeight(containerHeight, numRows, margin2, padding2);
    setRowHeight(newRowHeight);
  }, [containerHeight, config, margin2, padding2]);
  useEffect8(() => {
    if (height !== null && height !== void 0) {
      setContainerHeight(height);
    }
  }, [height]);
  useEffect8(() => {
    if (height !== null && height !== void 0) {
      return () => {
      };
    }
    function onWindowResize() {
      if (!containerRef.current)
        return;
      const containerRect = containerRef.current.getBoundingClientRect();
      setContainerHeight(containerRect.height);
    }
    window.addEventListener("resize", onWindowResize);
    onWindowResize();
    return () => {
      window.removeEventListener("resize", onWindowResize);
    };
  }, [containerRef, height]);
  return [rowHeight, containerRef];
}
function createLoaders(datasets, configDescription) {
  const result = {};
  const dataSources = {};
  datasets.forEach((dataset) => {
    const datasetLoaders = {
      name: dataset.name,
      description: dataset.description || configDescription,
      loaders: {}
    };
    dataset.files.forEach((file) => {
      const [DataSourceClass, LoaderClass] = getSourceAndLoaderFromFileType(file.fileType);
      const { url, options, requestInit } = file;
      const fileId = url || JSON.stringify(options);
      if (!(fileId in dataSources)) {
        dataSources[fileId] = new DataSourceClass({ url, requestInit });
      }
      const loader = new LoaderClass(dataSources[fileId], file);
      datasetLoaders.loaders[file.type] = loader;
    });
    result[dataset.uid] = datasetLoaders;
  });
  return result;
}

// src/app/VitessceGrid.js
var padding = 10;
var margin = 5;
function VitessceGrid(props) {
  const {
    rowHeight: initialRowHeight,
    config,
    getComponent: getComponent2,
    theme,
    height
  } = props;
  const [rowHeight, containerRef] = useRowHeight(config, initialRowHeight, height, margin, padding);
  const onResize = useEmitGridResize();
  useEffect9(() => {
    onResize();
  }, [rowHeight, onResize]);
  const viewConfigStoreApi = useViewConfigStoreApi();
  const setViewConfig = useSetViewConfig(viewConfigStoreApi);
  const setLoaders = useSetLoaders();
  const removeComponent = useRemoveComponent();
  const changeLayout = useChangeLayout();
  const layout = useLayout();
  useEffect9(() => {
    if (config) {
      setViewConfig(config);
      const loaders = createLoaders(config.datasets, config.description);
      setLoaders(loaders);
    } else {
      setLoaders({});
    }
  }, [config, setViewConfig, setLoaders]);
  return /* @__PURE__ */ React30.createElement("div", {
    ref: containerRef,
    className: `vitessce-container vitessce-theme-${theme}`
  }, layout && /* @__PURE__ */ React30.createElement(VitessceGridLayout, {
    layout,
    height,
    rowHeight,
    theme,
    getComponent: getComponent2,
    draggableHandle: ".title",
    margin,
    padding,
    onRemoveComponent: removeComponent,
    onLayoutChange: changeLayout,
    reactGridLayoutProps: {
      onResize,
      onResizeStop: onResize
    }
  }));
}

// src/app/app.js
import React75, { useEffect as useEffect26, useRef as useRef11, useState as useState21 } from "react";

// src/app/api.js
var urlPrefix = "https://s3.amazonaws.com/vitessce-data/0.0.31/master_release";
function makeLayerNameToConfig(datasetPrefix) {
  return (name2) => ({
    name: name2,
    type: name2.toUpperCase(),
    fileType: `${name2}.json`,
    url: `${urlPrefix}/${datasetPrefix}/${datasetPrefix}.${name2}.json`
  });
}
var linnarssonLayerNames = [
  "cells",
  "cell-sets",
  "raster",
  "molecules",
  "neighborhoods"
];
var linnarssonDescription = "Spatial organization of the somatosensory cortex revealed by cyclic smFISH";
var linnarssonBase = {
  description: linnarssonDescription,
  layers: [
    ...linnarssonLayerNames.map(makeLayerNameToConfig("linnarsson")),
    __spreadProps(__spreadValues({}, makeLayerNameToConfig("linnarsson")("clusters")), {
      type: "EXPRESSION-MATRIX"
    })
  ]
};
var linnarssonBaseNoClusters = {
  description: linnarssonDescription,
  layers: linnarssonLayerNames.filter((name2) => name2 !== "clusters").map(makeLayerNameToConfig("linnarsson"))
};
var driesDescription = "Giotto, a pipeline for integrative analysis and visualization of single-cell spatial transcriptomic data";
var driesBase = {
  description: driesDescription,
  layers: [
    "cells",
    "cell-sets"
  ].map(makeLayerNameToConfig("dries"))
};
var wangDescription = "Multiplexed imaging of high-density libraries of RNAs with MERFISH and expansion microscopy";
var wangBase = {
  description: wangDescription,
  layers: [
    ...["cells", "molecules"].map(makeLayerNameToConfig("wang")),
    __spreadProps(__spreadValues({}, makeLayerNameToConfig("wang")("genes")), {
      name: "expression-matrix",
      type: "EXPRESSION-MATRIX"
    })
  ]
};
var vanderbiltDescription = "High Bit Depth (uint16) Multiplex Immunofluorescence Imaging";
var vanderbiltBase = {
  description: vanderbiltDescription,
  layers: [
    "raster"
  ].map(makeLayerNameToConfig("spraggins"))
};
var configs = {
  "just-scatter": {
    version: "0.1.0",
    public: false,
    layers: [
      {
        name: "cells",
        type: "CELLS",
        fileType: "cells.json",
        url: `${urlPrefix}/linnarsson/linnarsson.cells.json`,
        requestInit: {
          method: "GET",
          headers: { "x-foo": "FAKE" },
          mode: "cors",
          credentials: "omit",
          cache: "no-store",
          redirect: "error",
          referrer: "FAKE",
          integrity: "FAKE"
        }
      }
    ],
    name: "Linnarsson, just scatterplot",
    staticLayout: [
      {
        component: "scatterplot",
        props: {
          mapping: "t-SNE",
          view: {
            zoom: 0.75,
            target: [0, 0, 0]
          }
        },
        x: 0,
        y: 0,
        w: 12,
        h: 2
      }
    ]
  },
  "just-scatter-expression": {
    version: "0.1.0",
    public: false,
    layers: [
      {
        name: "cells",
        type: "CELLS",
        url: "https://s3.amazonaws.com/vitessce-data/0.0.20/master_release/linnarsson/linnarsson.cells.json"
      },
      {
        name: "genes",
        type: "GENES",
        url: "https://s3.amazonaws.com/vitessce-data/0.0.20/master_release/linnarsson/linnarsson.genes.json"
      }
    ],
    name: "Linnarsson, just scatterplot and expression",
    staticLayout: [
      {
        component: "scatterplot",
        props: {
          mapping: "t-SNE",
          view: {
            zoom: 0.75,
            target: [0, 0, 0]
          }
        },
        x: 0,
        y: 0,
        w: 8,
        h: 2
      },
      {
        component: "genes",
        x: 8,
        y: 2,
        w: 4,
        h: 2
      }
    ]
  },
  "linnarsson-2018": {
    name: "Linnarsson",
    version: "1.0.0",
    description: linnarssonDescription,
    public: true,
    datasets: [
      {
        uid: "linnarsson-2018",
        name: "Linnarsson 2018",
        description: `Linnarsson: ${linnarssonDescription}`,
        files: linnarssonBase.layers.map((file) => ({
          type: file.type.toLowerCase(),
          fileType: file.fileType,
          url: file.url
        }))
      }
    ],
    initStrategy: "auto",
    coordinationSpace: {
      embeddingZoom: {
        PCA: 0,
        TSNE: 0.75
      },
      embeddingType: {
        PCA: "PCA",
        TSNE: "t-SNE"
      },
      spatialZoom: {
        A: -5.5
      },
      spatialTargetX: {
        A: 16e3
      },
      spatialTargetY: {
        A: 2e4
      }
    },
    layout: [
      {
        component: "description",
        x: 0,
        y: 0,
        w: 2,
        h: 1
      },
      {
        component: "layerController",
        x: 0,
        y: 1,
        w: 2,
        h: 4
      },
      {
        component: "status",
        x: 0,
        y: 5,
        w: 2,
        h: 1
      },
      {
        component: "spatial",
        coordinationScopes: {
          spatialZoom: "A",
          spatialTargetX: "A",
          spatialTargetY: "A"
        },
        x: 2,
        y: 0,
        w: 4,
        h: 4
      },
      {
        component: "genes",
        x: 9,
        y: 0,
        w: 3,
        h: 2
      },
      {
        component: "cellSets",
        x: 9,
        y: 3,
        w: 3,
        h: 2
      },
      {
        component: "heatmap",
        props: {
          transpose: true
        },
        x: 2,
        y: 4,
        w: 5,
        h: 2
      },
      {
        component: "cellSetExpression",
        x: 7,
        y: 4,
        w: 3,
        h: 2
      },
      {
        component: "expressionHistogram",
        x: 10,
        y: 4,
        w: 2,
        h: 2
      },
      {
        component: "scatterplot",
        coordinationScopes: {
          embeddingType: "PCA",
          embeddingZoom: "PCA"
        },
        x: 6,
        y: 0,
        w: 3,
        h: 2
      },
      {
        component: "scatterplot",
        coordinationScopes: {
          embeddingType: "TSNE",
          embeddingZoom: "TSNE"
        },
        x: 6,
        y: 2,
        w: 3,
        h: 2
      }
    ]
  },
  "linnarsson-2018-two-spatial": __spreadProps(__spreadValues({}, linnarssonBase), {
    version: "0.1.0",
    name: "Linnarsson (two spatial)",
    staticLayout: [
      {
        component: "spatial",
        props: {
          view: {
            zoom: -8,
            target: [18e3, 18e3, 0]
          }
        },
        x: 0,
        y: 0,
        w: 5,
        h: 2
      },
      {
        component: "scatterplot",
        props: { mapping: "t-SNE" },
        x: 0,
        y: 2,
        w: 5,
        h: 2
      },
      {
        component: "spatial",
        props: {
          view: {
            zoom: -6,
            target: [18e3, 18e3, 0]
          }
        },
        x: 5,
        y: 0,
        w: 5,
        h: 2
      },
      {
        component: "scatterplot",
        props: { mapping: "PCA" },
        x: 5,
        y: 2,
        w: 5,
        h: 2
      },
      {
        component: "genes",
        x: 10,
        y: 2,
        w: 2,
        h: 2
      },
      {
        component: "heatmap",
        x: 0,
        y: 4,
        w: 12
      }
    ]
  }),
  "linnarsson-2018-just-spatial": __spreadProps(__spreadValues({}, linnarssonBaseNoClusters), {
    version: "0.1.0",
    name: "Linnarsson (just spatial)",
    staticLayout: [
      {
        component: "spatial",
        props: {
          view: {
            zoom: -6.5,
            target: [18e3, 18e3, 0]
          }
        },
        x: 0,
        y: 0,
        w: 10,
        h: 2
      },
      {
        component: "genes",
        x: 10,
        y: 1,
        w: 2,
        h: 1
      }
    ]
  }),
  "linnarsson-2018-static": __spreadProps(__spreadValues({}, linnarssonBase), {
    version: "0.1.0",
    name: "Linnarsson (static layout)",
    staticLayout: [
      {
        component: "description",
        props: {
          description: `Linnarsson (static layout): ${linnarssonDescription}`
        },
        x: 0,
        y: 0,
        w: 3,
        h: 1
      },
      {
        component: "scatterplot",
        props: { mapping: "t-SNE" },
        x: 0,
        y: 2,
        w: 3,
        h: 2
      },
      {
        component: "spatial",
        props: {
          view: {
            zoom: -6.5,
            target: [18e3, 18e3, 0]
          }
        },
        x: 3,
        y: 0,
        w: 6,
        h: 4
      },
      {
        component: "genes",
        x: 9,
        y: 2,
        w: 3,
        h: 2
      },
      {
        component: "heatmap",
        x: 0,
        y: 4,
        w: 12,
        h: 1
      }
    ]
  }),
  "linnarsson-2018-dozen": __spreadProps(__spreadValues({}, linnarssonBase), {
    version: "0.1.0",
    name: "Linnarsson (static layout, redundant components for performance testing)",
    staticLayout: [
      {
        component: "spatial",
        props: {
          view: {
            zoom: -6.5,
            target: [18e3, 18e3, 0]
          }
        },
        x: 0,
        y: 0,
        w: 4,
        h: 1
      },
      {
        component: "spatial",
        props: {
          view: {
            zoom: -6.5,
            target: [18e3, 18e3, 0]
          }
        },
        x: 0,
        y: 1,
        w: 4,
        h: 1
      },
      {
        component: "spatial",
        props: {
          view: {
            zoom: -6.5,
            target: [18e3, 18e3, 0]
          }
        },
        x: 4,
        y: 0,
        w: 4,
        h: 1
      },
      {
        component: "spatial",
        props: {
          view: {
            zoom: -6.5,
            target: [18e3, 18e3, 0]
          }
        },
        x: 4,
        y: 1,
        w: 4,
        h: 1
      },
      {
        component: "scatterplot",
        props: { mapping: "t-SNE" },
        x: 0,
        y: 2,
        w: 4,
        h: 1
      },
      {
        component: "scatterplot",
        props: { mapping: "t-SNE" },
        x: 0,
        y: 3,
        w: 4,
        h: 1
      },
      {
        component: "scatterplot",
        props: { mapping: "t-SNE" },
        x: 0,
        y: 4,
        w: 4,
        h: 1
      },
      {
        component: "scatterplot",
        props: { mapping: "t-SNE" },
        x: 0,
        y: 5,
        w: 4,
        h: 1
      },
      {
        component: "scatterplot",
        props: { mapping: "PCA" },
        x: 4,
        y: 2,
        w: 4,
        h: 1
      },
      {
        component: "scatterplot",
        props: { mapping: "PCA" },
        x: 4,
        y: 3,
        w: 4,
        h: 1
      },
      {
        component: "scatterplot",
        props: { mapping: "PCA" },
        x: 4,
        y: 4,
        w: 4,
        h: 1
      },
      {
        component: "scatterplot",
        props: { mapping: "PCA" },
        x: 4,
        y: 5,
        w: 4,
        h: 1
      },
      {
        component: "genes",
        x: 8,
        y: 2,
        w: 4,
        h: 2
      },
      {
        component: "heatmap",
        x: 8,
        y: 4,
        w: 4,
        h: 2
      }
    ]
  }),
  "dries-2019": {
    name: "Dries",
    version: "1.0.0",
    description: driesDescription,
    public: true,
    datasets: [
      {
        uid: "dries-2019",
        name: "Dries 2019",
        files: driesBase.layers.map((file) => ({
          type: file.type.toLowerCase(),
          fileType: file.fileType,
          url: file.url
        }))
      }
    ],
    initStrategy: "auto",
    coordinationSpace: {
      embeddingType: {
        TSNE: "t-SNE",
        UMAP: "UMAP"
      },
      embeddingCellSetPolygonsVisible: {
        A: false
      },
      embeddingCellSetLabelsVisible: {
        A: true
      },
      embeddingCellSetLabelSize: {
        A: 16
      },
      embeddingCellRadius: {
        A: 1
      },
      embeddingZoom: {
        TSNE: 3,
        UMAP: 3
      },
      spatialZoom: {
        A: -4.4
      },
      spatialTargetX: {
        A: 3800
      },
      spatialTargetY: {
        A: -900
      }
    },
    layout: [
      {
        component: "description",
        x: 9,
        y: 0,
        w: 3,
        h: 2
      },
      {
        component: "status",
        x: 9,
        y: 2,
        w: 3,
        h: 2
      },
      {
        component: "cellSets",
        x: 9,
        y: 4,
        w: 3,
        h: 4
      },
      {
        component: "cellSetSizes",
        x: 5,
        y: 4,
        w: 4,
        h: 4
      },
      {
        component: "scatterplot",
        coordinationScopes: {
          embeddingType: "TSNE",
          embeddingZoom: "TSNE",
          embeddingCellSetLabelsVisible: "A",
          embeddingCellSetLabelSize: "A",
          embeddingCellSetPolygonsVisible: "A",
          embeddingCellRadius: "A"
        },
        x: 0,
        y: 2,
        w: 5,
        h: 4
      },
      {
        component: "spatial",
        props: {
          cellRadius: 50
        },
        coordinationScopes: {
          spatialZoom: "A",
          spatialTargetX: "A",
          spatialTargetY: "A"
        },
        x: 5,
        y: 0,
        w: 4,
        h: 4
      },
      {
        component: "scatterplot",
        coordinationScopes: {
          embeddingType: "UMAP",
          embeddingZoom: "UMAP",
          embeddingCellSetLabelsVisible: "A",
          embeddingCellSetLabelSize: "A",
          embeddingCellSetPolygonsVisible: "A",
          embeddingCellRadius: "A"
        },
        x: 0,
        y: 0,
        w: 5,
        h: 4
      }
    ]
  },
  "wang-2019": {
    name: "Wang",
    version: "1.0.0",
    description: wangDescription,
    public: true,
    datasets: [
      {
        uid: "wang-2019",
        name: "Wang 2019",
        files: wangBase.layers.map((file) => ({
          type: file.type.toLowerCase(),
          fileType: file.fileType,
          url: file.url
        }))
      }
    ],
    initStrategy: "auto",
    coordinationSpace: {
      spatialZoom: {
        A: -1
      },
      spatialLayers: {
        A: [
          {
            type: "molecules",
            radius: 2,
            opacity: 1,
            visible: true
          },
          {
            type: "cells",
            opacity: 1,
            radius: 50,
            visible: true,
            stroked: false
          }
        ]
      }
    },
    layout: [
      {
        component: "spatial",
        coordinationScopes: {
          spatialZoom: "A",
          spatialLayers: "A"
        },
        props: {},
        x: 0,
        y: 0,
        w: 10,
        h: 2
      },
      {
        component: "genes",
        x: 10,
        y: 0,
        w: 2,
        h: 4
      },
      {
        component: "expressionHistogram",
        x: 0,
        y: 2,
        w: 10,
        h: 2
      }
    ]
  },
  vanderbilt: __spreadProps(__spreadValues({}, vanderbiltBase), {
    version: "0.1.0",
    name: "Spraggins",
    public: true,
    staticLayout: [
      {
        component: "spatial",
        props: {
          view: {
            zoom: -6.5,
            target: [2e4, 2e4, 0]
          }
        },
        x: 0,
        y: 0,
        w: 9,
        h: 2
      },
      {
        component: "layerController",
        x: 9,
        y: 0,
        w: 3,
        h: 2
      }
    ]
  }),
  "just-higlass": {
    public: false,
    initStrategy: "auto",
    version: "1.0.0",
    datasets: [
      {
        uid: "higlass-dataset",
        name: "HiGlass Dataset",
        files: []
      }
    ],
    name: "HiGlass demo",
    coordinationSpace: {
      genomicZoomX: {
        A: 0
      },
      genomicZoomY: {
        A: 0
      },
      genomicTargetX: {
        A: 15499999995e-1
      },
      genomicTargetY: {
        A: 15499999995e-1
      }
    },
    layout: [
      {
        component: "higlass",
        coordinationScopes: {
          genomicZoomX: "A",
          genomicZoomY: "A",
          genomicTargetX: "A",
          genomicTargetY: "A"
        },
        props: {
          hgViewConfig: {
            uid: "aa",
            autocompleteSource: "/api/v1/suggest/?d=OHJakQICQD6gTD7skx4EWA&",
            genomePositionSearchBox: {
              autocompleteServer: "//higlass.io/api/v1",
              autocompleteId: "OHJakQICQD6gTD7skx4EWA",
              chromInfoServer: "//higlass.io/api/v1",
              chromInfoId: "hg19",
              visible: true
            },
            chromInfoPath: "//s3.amazonaws.com/pkerp/data/hg19/chromSizes.tsv",
            tracks: {
              top: [
                {
                  type: "horizontal-gene-annotations",
                  height: 60,
                  tilesetUid: "OHJakQICQD6gTD7skx4EWA",
                  server: "//higlass.io/api/v1",
                  uid: "OHJakQICQD6gTD7skx4EWA",
                  options: {
                    name: "Gene Annotations (hg19)",
                    fontSize: 10,
                    labelPosition: "hidden",
                    labelLeftMargin: 0,
                    labelRightMargin: 0,
                    labelTopMargin: 0,
                    labelBottomMargin: 0,
                    minHeight: 24,
                    geneAnnotationHeight: 16,
                    geneLabelPosition: "outside",
                    geneStrandSpacing: 4,
                    showMousePosition: true,
                    mousePositionColor: "#ff00ff",
                    plusStrandColor: "#fdff54",
                    minusStrandColor: "#68bf30",
                    labelColor: "black",
                    trackBorderWidth: 0,
                    trackBorderColor: "black"
                  }
                },
                {
                  chromInfoPath: "//s3.amazonaws.com/pkerp/data/hg19/chromSizes.tsv",
                  type: "horizontal-chromosome-labels",
                  height: 30,
                  uid: "X4e_1DKiQHmyghDa6lLMVA",
                  options: {
                    color: "#808080",
                    stroke: "black",
                    fontSize: 12,
                    fontIsLeftAligned: false,
                    showMousePosition: true,
                    mousePositionColor: "#ff00ff"
                  }
                }
              ],
              left: [
                {
                  type: "vertical-gene-annotations",
                  width: 60,
                  tilesetUid: "OHJakQICQD6gTD7skx4EWA",
                  server: "//higlass.io/api/v1",
                  options: {
                    labelPosition: "bottomRight",
                    name: "Gene Annotations (hg19)",
                    fontSize: 10,
                    labelLeftMargin: 0,
                    labelRightMargin: 0,
                    labelTopMargin: 0,
                    labelBottomMargin: 0,
                    minWidth: 24,
                    geneAnnotationHeight: 16,
                    geneLabelPosition: "outside",
                    geneStrandSpacing: 4,
                    showMousePosition: true,
                    mousePositionColor: "#ff00ff",
                    plusStrandColor: "#fdff54",
                    minusStrandColor: "#68bf30",
                    labelColor: "black",
                    trackBorderWidth: 0,
                    trackBorderColor: "black"
                  },
                  uid: "dqBTMH78Rn6DeSyDBoAEXw"
                },
                {
                  chromInfoPath: "//s3.amazonaws.com/pkerp/data/hg19/chromSizes.tsv",
                  type: "vertical-chromosome-labels",
                  width: 30,
                  uid: "RHdQK4IRQ7yJeDmKWb7Pcg",
                  options: {
                    color: "#777777",
                    stroke: "black",
                    fontSize: 12,
                    fontIsLeftAligned: false,
                    minWidth: 35,
                    showMousePosition: true,
                    mousePositionColor: "#ff00ff"
                  }
                }
              ],
              center: [
                {
                  uid: "c1",
                  type: "combined",
                  height: 600,
                  contents: [
                    {
                      server: "//higlass.io/api/v1",
                      tilesetUid: "CQMd6V_cRw6iCI_-Unl3PQ",
                      type: "heatmap",
                      options: {
                        maxZoom: null,
                        labelPosition: "bottomRight",
                        name: "Rao et al. (2014) GM12878 MboI (allreps) 1kb",
                        backgroundColor: "black",
                        labelLeftMargin: 0,
                        labelRightMargin: 0,
                        labelTopMargin: 0,
                        labelBottomMargin: 0,
                        labelShowResolution: true,
                        labelShowAssembly: true,
                        labelColor: "#ffffff",
                        labelTextOpacity: 0.5,
                        labelBackgroundColor: "black",
                        labelBackgroundOpacity: 0.01,
                        colorRange: [
                          "#000000",
                          "#222e54",
                          "#448db2",
                          "#68bf30",
                          "#fdff54",
                          "#FFFFFF"
                        ],
                        colorbarBackgroundColor: "black",
                        colorbarBackgroundOpacity: 0.01,
                        colorbarPosition: "topRight",
                        trackBorderWidth: 0,
                        trackBorderColor: "black",
                        heatmapValueScaling: "log",
                        showMousePosition: true,
                        mousePositionColor: "#ff00ff",
                        showTooltip: false,
                        extent: "full",
                        zeroValueColor: null,
                        scaleStartPercent: "0.00000",
                        scaleEndPercent: "1.00000"
                      },
                      height: 500,
                      uid: "GjuZed1ySGW1IzZZqFB9BA",
                      transforms: [
                        {
                          name: "ICE",
                          value: "weight"
                        }
                      ]
                    }
                  ],
                  options: {}
                }
              ],
              right: [],
              bottom: [],
              whole: [],
              gallery: []
            },
            layout: {
              w: 12,
              h: 12,
              x: 0,
              y: 0,
              moved: false,
              static: false
            }
          }
        },
        x: 0,
        y: 0,
        w: 8,
        h: 2
      },
      {
        component: "higlass",
        coordinationScopes: {
          genomicZoomX: "A",
          genomicZoomY: "A",
          genomicTargetX: "A",
          genomicTargetY: "A"
        },
        props: {
          hgViewConfig: {
            uid: "aa",
            autocompleteSource: "/api/v1/suggest/?d=OHJakQICQD6gTD7skx4EWA&",
            genomePositionSearchBox: {
              autocompleteServer: "//higlass.io/api/v1",
              autocompleteId: "OHJakQICQD6gTD7skx4EWA",
              chromInfoServer: "//higlass.io/api/v1",
              chromInfoId: "hg19",
              visible: true
            },
            chromInfoPath: "//s3.amazonaws.com/pkerp/data/hg19/chromSizes.tsv",
            tracks: {
              top: [
                {
                  type: "horizontal-gene-annotations",
                  height: 60,
                  tilesetUid: "OHJakQICQD6gTD7skx4EWA",
                  server: "//higlass.io/api/v1",
                  uid: "OHJakQICQD6gTD7skx4EWA",
                  options: {
                    name: "Gene Annotations (hg19)",
                    fontSize: 10,
                    labelPosition: "hidden",
                    labelLeftMargin: 0,
                    labelRightMargin: 0,
                    labelTopMargin: 0,
                    labelBottomMargin: 0,
                    minHeight: 24,
                    geneAnnotationHeight: 16,
                    geneLabelPosition: "outside",
                    geneStrandSpacing: 4,
                    showMousePosition: true,
                    mousePositionColor: "#ff00ff",
                    plusStrandColor: "#fdff54",
                    minusStrandColor: "#68bf30",
                    labelColor: "black",
                    trackBorderWidth: 0,
                    trackBorderColor: "black"
                  }
                },
                {
                  chromInfoPath: "//s3.amazonaws.com/pkerp/data/hg19/chromSizes.tsv",
                  type: "horizontal-chromosome-labels",
                  height: 30,
                  uid: "X4e_1DKiQHmyghDa6lLMVA",
                  options: {
                    color: "#808080",
                    stroke: "black",
                    fontSize: 12,
                    fontIsLeftAligned: false,
                    showMousePosition: true,
                    mousePositionColor: "#ff00ff"
                  }
                }
              ],
              left: [
                {
                  type: "vertical-gene-annotations",
                  width: 60,
                  tilesetUid: "OHJakQICQD6gTD7skx4EWA",
                  server: "//higlass.io/api/v1",
                  options: {
                    labelPosition: "bottomRight",
                    name: "Gene Annotations (hg19)",
                    fontSize: 10,
                    labelLeftMargin: 0,
                    labelRightMargin: 0,
                    labelTopMargin: 0,
                    labelBottomMargin: 0,
                    minWidth: 24,
                    geneAnnotationHeight: 16,
                    geneLabelPosition: "outside",
                    geneStrandSpacing: 4,
                    showMousePosition: true,
                    mousePositionColor: "#ff00ff",
                    plusStrandColor: "#fdff54",
                    minusStrandColor: "#68bf30",
                    labelColor: "black",
                    trackBorderWidth: 0,
                    trackBorderColor: "black"
                  },
                  uid: "dqBTMH78Rn6DeSyDBoAEXw"
                },
                {
                  chromInfoPath: "//s3.amazonaws.com/pkerp/data/hg19/chromSizes.tsv",
                  type: "vertical-chromosome-labels",
                  width: 30,
                  uid: "RHdQK4IRQ7yJeDmKWb7Pcg",
                  options: {
                    color: "#777777",
                    stroke: "black",
                    fontSize: 12,
                    fontIsLeftAligned: false,
                    minWidth: 35,
                    showMousePosition: true,
                    mousePositionColor: "#ff00ff"
                  }
                }
              ],
              center: [
                {
                  uid: "c1",
                  type: "combined",
                  height: 600,
                  contents: [
                    {
                      server: "//higlass.io/api/v1",
                      tilesetUid: "CQMd6V_cRw6iCI_-Unl3PQ",
                      type: "heatmap",
                      options: {
                        maxZoom: null,
                        labelPosition: "bottomRight",
                        name: "Rao et al. (2014) GM12878 MboI (allreps) 1kb",
                        backgroundColor: "black",
                        labelLeftMargin: 0,
                        labelRightMargin: 0,
                        labelTopMargin: 0,
                        labelBottomMargin: 0,
                        labelShowResolution: true,
                        labelShowAssembly: true,
                        labelColor: "#ffffff",
                        labelTextOpacity: 0.5,
                        labelBackgroundColor: "black",
                        labelBackgroundOpacity: 0.01,
                        colorRange: [
                          "#000000",
                          "#222e54",
                          "#448db2",
                          "#68bf30",
                          "#fdff54",
                          "#FFFFFF"
                        ],
                        colorbarBackgroundColor: "black",
                        colorbarBackgroundOpacity: 0.01,
                        colorbarPosition: "topRight",
                        trackBorderWidth: 0,
                        trackBorderColor: "black",
                        heatmapValueScaling: "log",
                        showMousePosition: true,
                        mousePositionColor: "#ff00ff",
                        showTooltip: false,
                        extent: "full",
                        zeroValueColor: null,
                        scaleStartPercent: "0.00000",
                        scaleEndPercent: "1.00000"
                      },
                      height: 500,
                      uid: "GjuZed1ySGW1IzZZqFB9BA",
                      transforms: [
                        {
                          name: "ICE",
                          value: "weight"
                        }
                      ]
                    }
                  ],
                  options: {}
                }
              ],
              right: [],
              bottom: [],
              whole: [],
              gallery: []
            },
            layout: {
              w: 12,
              h: 12,
              x: 0,
              y: 0,
              moved: false,
              static: false
            }
          }
        },
        x: 8,
        y: 0,
        w: 4,
        h: 2
      }
    ]
  },
  "sc-atac-seq-10x-genomics-pbmc": {
    version: "1.0.0",
    name: "HiGlass serverless demo with 10x Genomics scATAC-seq 5k PBMC dataset",
    datasets: [
      {
        uid: "10x-genomics-pbmc",
        name: "10x Genomics PBMC",
        files: [
          {
            type: "genomic-profiles",
            fileType: "genomic-profiles.zarr",
            url: "http://higlass-serverless.s3.amazonaws.com/multivec/pbmc_10x_peaks_by_cluster.zarr"
          }
        ]
      }
    ],
    layout: [
      {
        component: "genomicProfiles",
        props: {
          profileTrackUidKey: "file"
        },
        x: 0,
        y: 0,
        w: 8,
        h: 2
      },
      {
        component: "description",
        props: {
          description: "10x Genomics scATAC-seq of 5k PBMCs. Note: the Zarr HiGlass Plugin Datafetcher is not yet optimized. Please be patient while the HiGlass tracks load."
        },
        x: 8,
        y: 0,
        w: 4,
        h: 2
      }
    ],
    initStrategy: "auto"
  },
  "portal-ui-featured": {
    coordinationSpace: {
      dataset: {
        A: "A"
      },
      spatialZoom: {
        A: 0.6219962674826599
      },
      spatialRotation: {
        A: 0
      },
      spatialTargetX: {
        A: 550.9755273834661
      },
      spatialTargetY: {
        A: 418.2987491735642
      },
      spatialTargetZ: {
        A: 6252776074688882e-28
      },
      heatmapZoomX: {
        A: 0
      },
      heatmapZoomY: {
        A: 0
      },
      heatmapTargetX: {
        A: 0
      },
      heatmapTargetY: {
        A: 0
      },
      cellFilter: {
        A: null
      },
      cellHighlight: {
        A: "761"
      },
      cellSetSelection: {
        A: [
          [
            "K-Means [Mean] Expression",
            "Cluster 1"
          ],
          [
            "K-Means [Mean] Expression",
            "Cluster 2"
          ],
          [
            "K-Means [Mean] Expression",
            "Cluster 3"
          ],
          [
            "K-Means [Mean] Expression",
            "Cluster 4"
          ],
          [
            "K-Means [Mean] Expression",
            "Cluster 5"
          ],
          [
            "K-Means [Mean] Expression",
            "Cluster 6"
          ]
        ]
      },
      cellSetHighlight: {
        A: null
      },
      cellSetColor: {
        A: [
          {
            path: [
              "K-Means [Mean] Expression"
            ],
            color: [
              68,
              119,
              170,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean] Expression",
              "Cluster 1"
            ],
            color: [
              68,
              119,
              170,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean] Expression",
              "Cluster 2"
            ],
            color: [
              136,
              204,
              238,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean] Expression",
              "Cluster 3"
            ],
            color: [
              68,
              170,
              153,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean] Expression",
              "Cluster 4"
            ],
            color: [
              17,
              119,
              51,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean] Expression",
              "Cluster 5"
            ],
            color: [
              153,
              153,
              51,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean] Expression",
              "Cluster 6"
            ],
            color: [
              221,
              204,
              119,
              255
            ]
          },
          {
            path: [
              "K-Means [Covariance] Expression"
            ],
            color: [
              68,
              119,
              170,
              255
            ]
          },
          {
            path: [
              "K-Means [Covariance] Expression",
              "Cluster 1"
            ],
            color: [
              68,
              119,
              170,
              255
            ]
          },
          {
            path: [
              "K-Means [Covariance] Expression",
              "Cluster 2"
            ],
            color: [
              136,
              204,
              238,
              255
            ]
          },
          {
            path: [
              "K-Means [Covariance] Expression",
              "Cluster 3"
            ],
            color: [
              68,
              170,
              153,
              255
            ]
          },
          {
            path: [
              "K-Means [Covariance] Expression",
              "Cluster 4"
            ],
            color: [
              17,
              119,
              51,
              255
            ]
          },
          {
            path: [
              "K-Means [Covariance] Expression",
              "Cluster 5"
            ],
            color: [
              153,
              153,
              51,
              255
            ]
          },
          {
            path: [
              "K-Means [Covariance] Expression",
              "Cluster 6"
            ],
            color: [
              221,
              204,
              119,
              255
            ]
          },
          {
            path: [
              "K-Means [Total] Expression"
            ],
            color: [
              68,
              119,
              170,
              255
            ]
          },
          {
            path: [
              "K-Means [Total] Expression",
              "Cluster 1"
            ],
            color: [
              68,
              119,
              170,
              255
            ]
          },
          {
            path: [
              "K-Means [Total] Expression",
              "Cluster 2"
            ],
            color: [
              136,
              204,
              238,
              255
            ]
          },
          {
            path: [
              "K-Means [Total] Expression",
              "Cluster 3"
            ],
            color: [
              68,
              170,
              153,
              255
            ]
          },
          {
            path: [
              "K-Means [Total] Expression",
              "Cluster 4"
            ],
            color: [
              17,
              119,
              51,
              255
            ]
          },
          {
            path: [
              "K-Means [Total] Expression",
              "Cluster 5"
            ],
            color: [
              153,
              153,
              51,
              255
            ]
          },
          {
            path: [
              "K-Means [Total] Expression",
              "Cluster 6"
            ],
            color: [
              221,
              204,
              119,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean-All-SubRegions] Expression"
            ],
            color: [
              68,
              119,
              170,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean-All-SubRegions] Expression",
              "Cluster 1"
            ],
            color: [
              68,
              119,
              170,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean-All-SubRegions] Expression",
              "Cluster 2"
            ],
            color: [
              136,
              204,
              238,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean-All-SubRegions] Expression",
              "Cluster 3"
            ],
            color: [
              68,
              170,
              153,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean-All-SubRegions] Expression",
              "Cluster 4"
            ],
            color: [
              17,
              119,
              51,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean-All-SubRegions] Expression",
              "Cluster 5"
            ],
            color: [
              153,
              153,
              51,
              255
            ]
          },
          {
            path: [
              "K-Means [Mean-All-SubRegions] Expression",
              "Cluster 6"
            ],
            color: [
              221,
              204,
              119,
              255
            ]
          },
          {
            path: [
              "K-Means [Shape-Vectors]"
            ],
            color: [
              68,
              119,
              170,
              255
            ]
          },
          {
            path: [
              "K-Means [Shape-Vectors]",
              "Cluster 1"
            ],
            color: [
              68,
              119,
              170,
              255
            ]
          },
          {
            path: [
              "K-Means [Shape-Vectors]",
              "Cluster 2"
            ],
            color: [
              136,
              204,
              238,
              255
            ]
          },
          {
            path: [
              "K-Means [Shape-Vectors]",
              "Cluster 3"
            ],
            color: [
              68,
              170,
              153,
              255
            ]
          }
        ]
      },
      geneFilter: {
        A: null
      },
      geneHighlight: {
        A: null
      },
      geneSelection: {
        A: null
      },
      geneExpressionColormap: {
        A: "plasma"
      },
      geneExpressionColormapRange: {
        A: [
          0.065,
          0.435
        ]
      },
      cellColorEncoding: {
        A: "cellSetSelection"
      },
      spatialRasterLayers: {
        A: [
          {
            type: "t",
            index: 0,
            colormap: null,
            opacity: 1,
            domainType: "Min/Max",
            transparentColor: null,
            channels: [
              {
                selection: {
                  z: 5,
                  t: 0,
                  c: 10
                },
                color: [
                  0,
                  0,
                  255
                ],
                visible: true,
                slider: [
                  1,
                  14906
                ]
              },
              {
                selection: {
                  z: 5,
                  t: 0,
                  c: 15
                },
                color: [
                  0,
                  255,
                  0
                ],
                visible: true,
                slider: [
                  2313,
                  31611
                ]
              },
              {
                selection: {
                  z: 5,
                  t: 0,
                  c: 45
                },
                color: [
                  255,
                  0,
                  255
                ],
                visible: true,
                slider: [
                  2570,
                  21074
                ]
              },
              {
                selection: {
                  z: 5,
                  t: 0,
                  c: 20
                },
                color: [
                  255,
                  255,
                  0
                ],
                visible: true,
                slider: [
                  2827,
                  11565
                ]
              },
              {
                selection: {
                  z: 5,
                  t: 0,
                  c: 31
                },
                slider: [
                  5658,
                  17479
                ],
                visible: true,
                color: [
                  255,
                  128,
                  0
                ]
              },
              {
                selection: {
                  z: 5,
                  t: 0,
                  c: 39
                },
                slider: [
                  1767,
                  11735
                ],
                visible: true,
                color: [
                  255,
                  255,
                  255
                ]
              }
            ]
          }
        ]
      },
      spatialCellsLayer: {
        A: {
          opacity: 0,
          radius: 50,
          visible: true,
          stroked: true
        }
      },
      spatialMoleculesLayer: {
        A: null
      },
      spatialNeighborhoodsLayer: {
        A: null
      },
      additionalCellSets: {
        A: null
      },
      moleculeHighlight: {
        A: null
      }
    },
    datasets: [
      {
        files: [
          {
            fileType: "cells.json",
            type: "cells",
            url: "https://assets.hubmapconsortium.org/ca3016d836d8ee50bef1b93f339c9679/output_json/R002_X002_Y007.cells.json?token="
          },
          {
            fileType: "cell-sets.json",
            type: "cell-sets",
            url: "https://assets.hubmapconsortium.org/ca3016d836d8ee50bef1b93f339c9679/output_json/R002_X002_Y007.cell-sets.json?token="
          },
          {
            fileType: "clusters.json",
            type: "expression-matrix",
            url: "https://assets.hubmapconsortium.org/ca3016d836d8ee50bef1b93f339c9679/output_json/R002_X002_Y007.clusters.json?token="
          },
          {
            fileType: "raster.json",
            options: {
              images: [
                {
                  metadata: {
                    omeTiffOffsetsUrl: "https://assets.hubmapconsortium.org/ca3016d836d8ee50bef1b93f339c9679/output_offsets/R002_X002_Y007.offsets.json?token="
                  },
                  name: "R002_X002_Y007",
                  type: "ome-tiff",
                  url: "https://assets.hubmapconsortium.org/ca3016d836d8ee50bef1b93f339c9679/output/extract/expressions/ome-tiff/R002_X002_Y007.ome.tiff?token="
                }
              ],
              schemaVersion: "0.0.2"
            },
            type: "raster"
          }
        ],
        name: "SPRM",
        uid: "A"
      }
    ],
    description: "",
    initStrategy: "auto",
    layout: [
      {
        component: "spatial",
        coordinationScopes: {
          dataset: "A",
          spatialZoom: "A",
          spatialRotation: "A",
          spatialTargetX: "A",
          spatialTargetY: "A",
          spatialTargetZ: "A",
          cellFilter: "A",
          cellHighlight: "A",
          cellSetSelection: "A",
          cellSetHighlight: "A",
          cellSetColor: "A",
          geneHighlight: "A",
          geneSelection: "A",
          geneExpressionColormap: "A",
          geneExpressionColormapRange: "A",
          cellColorEncoding: "A",
          spatialRasterLayers: "A",
          spatialCellsLayer: "A",
          spatialMoleculesLayer: "A",
          spatialNeighborhoodsLayer: "A",
          additionalCellSets: "A",
          moleculeHighlight: "A"
        },
        h: 8,
        w: 7,
        x: 3,
        y: 0
      },
      {
        component: "description",
        coordinationScopes: {
          dataset: "A",
          spatialRasterLayers: "A"
        },
        h: 2,
        w: 2,
        x: 10,
        y: 10
      },
      {
        component: "layerController",
        coordinationScopes: {
          dataset: "A",
          spatialRasterLayers: "A",
          spatialCellsLayer: "A",
          spatialMoleculesLayer: "A",
          spatialNeighborhoodsLayer: "A"
        },
        h: 8,
        w: 3,
        x: 0,
        y: 0
      },
      {
        component: "cellSets",
        coordinationScopes: {
          dataset: "A",
          cellSetSelection: "A",
          cellSetHighlight: "A",
          cellSetColor: "A",
          cellColorEncoding: "A",
          additionalCellSets: "A"
        },
        h: 5,
        w: 2,
        x: 10,
        y: 5
      },
      {
        component: "genes",
        coordinationScopes: {
          dataset: "A",
          geneFilter: "A",
          geneHighlight: "A",
          geneSelection: "A",
          cellColorEncoding: "A"
        },
        h: 5,
        props: {
          variablesLabelOverride: "antigen"
        },
        w: 2,
        x: 10,
        y: 0
      },
      {
        component: "heatmap",
        coordinationScopes: {
          dataset: "A",
          heatmapZoomX: "A",
          heatmapZoomY: "A",
          heatmapTargetX: "A",
          heatmapTargetY: "A",
          cellFilter: "A",
          cellHighlight: "A",
          cellSetSelection: "A",
          cellSetHighlight: "A",
          cellSetColor: "A",
          geneFilter: "A",
          geneHighlight: "A",
          geneSelection: "A",
          geneExpressionColormap: "A",
          geneExpressionColormapRange: "A",
          cellColorEncoding: "A",
          additionalCellSets: "A"
        },
        h: 4,
        props: {
          transpose: true,
          variablesLabelOverride: "antigen"
        },
        w: 10,
        x: 0,
        y: 8
      }
    ],
    name: "R002_X002_Y007",
    version: "1.0.1"
  }
};
function listConfigs(showAll) {
  return Object.entries(configs).filter((entry) => showAll || entry[1].public).map(([id, config]) => ({
    id,
    name: config.name,
    description: config.description
  }));
}
function getConfig(id) {
  return configs[id];
}

// src/app/Welcome.js
import React31 from "react";

// src/version.json
var note = "This file is regenerated by push-demo.sh.";
var branch = "release_1.1.17";
var date = "2021-11-17";
var hash = "db07d05";
var version_default = {
  note,
  branch,
  date,
  hash
};

// src/app/Welcome.js
function DatasetList(props) {
  const { configs: configs2, theme } = props;
  const aClassName = "list-group-item list-group-item-action flex-column align-items-start bg-secondary";
  const links = configs2.map(({ id, name: name2, description: description2 }) => /* @__PURE__ */ React31.createElement("div", {
    className: aClassName,
    key: id
  }, /* @__PURE__ */ React31.createElement("a", {
    href: `?dataset=${id}&theme=${theme}`,
    key: id
  }, /* @__PURE__ */ React31.createElement("h5", null, name2), /* @__PURE__ */ React31.createElement("p", null, description2)), /* @__PURE__ */ React31.createElement("a", {
    href: `?dataset=${id}&theme=${theme}&small`,
    style: { fontSize: "75%" }
  }, name2, " as component")));
  return /* @__PURE__ */ React31.createElement("div", {
    className: "list-group"
  }, links);
}
function Form(props) {
  const { configs: configs2, theme } = props;
  return /* @__PURE__ */ React31.createElement("form", {
    method: "GET"
  }, /* @__PURE__ */ React31.createElement("h1", null, "Vitessce"), /* @__PURE__ */ React31.createElement("div", null, "Select a dataset:"), /* @__PURE__ */ React31.createElement(DatasetList, {
    configs: configs2,
    theme
  }), /* @__PURE__ */ React31.createElement("br", null), /* @__PURE__ */ React31.createElement("div", null, "Or specify URL of configuration:"), /* @__PURE__ */ React31.createElement("div", {
    className: "input-group mb-3"
  }, /* @__PURE__ */ React31.createElement("input", {
    type: "text",
    name: "url",
    className: "form-control"
  }), /* @__PURE__ */ React31.createElement("input", {
    type: "hidden",
    name: "theme",
    value: theme
  }), /* @__PURE__ */ React31.createElement("div", {
    className: "input-group-append"
  }, /* @__PURE__ */ React31.createElement("button", {
    className: "btn btn-outline-secondary",
    type: "submit"
  }, "Load"))));
}
function Info() {
  return /* @__PURE__ */ React31.createElement(React31.Fragment, null, /* @__PURE__ */ React31.createElement("p", {
    className: "info-paragraph"
  }, "Vitessce is a visual integration tool for exploration of spatial single cell experiments. Its modular design is optimized for scalable, linked visualizations that support the spatial and non-spatial representation of tissue-, cell- and molecule-level data. Vitessce integrates the ", /* @__PURE__ */ React31.createElement("a", {
    href: "https://github.com/hms-dbmi/viv"
  }, "Viv library"), " to visualize highly multiplexed, high-resolution, high-bit depth image data directly from OME-TIFF files and Bio-Formats-compatible Zarr stores."), /* @__PURE__ */ React31.createElement("h5", {
    className: "info-section-text"
  }, "Contributors"), /* @__PURE__ */ React31.createElement("ul", null, /* @__PURE__ */ React31.createElement("li", null, /* @__PURE__ */ React31.createElement("a", {
    href: "https://github.com/keller-mark"
  }, "Mark Keller")), /* @__PURE__ */ React31.createElement("li", null, /* @__PURE__ */ React31.createElement("a", {
    href: "https://github.com/mccalluc"
  }, "Chuck McCallum")), /* @__PURE__ */ React31.createElement("li", null, /* @__PURE__ */ React31.createElement("a", {
    href: "https://github.com/ilan-gold"
  }, "Ilan Gold")), /* @__PURE__ */ React31.createElement("li", null, /* @__PURE__ */ React31.createElement("a", {
    href: "https://github.com/manzt"
  }, "Trevor Manz")), /* @__PURE__ */ React31.createElement("li", null, /* @__PURE__ */ React31.createElement("a", {
    href: "https://github.com/thomaslchan"
  }, "Tos Chan")), /* @__PURE__ */ React31.createElement("li", null, /* @__PURE__ */ React31.createElement("a", {
    href: "https://github.com/jkmarx"
  }, "Jennifer Marx")), /* @__PURE__ */ React31.createElement("li", null, /* @__PURE__ */ React31.createElement("a", {
    href: "https://github.com/pkharchenko"
  }, "Peter Kharchenko")), /* @__PURE__ */ React31.createElement("li", null, /* @__PURE__ */ React31.createElement("a", {
    href: "https://github.com/ngehlenborg"
  }, "Nils Gehlenborg"))), /* @__PURE__ */ React31.createElement("h5", {
    className: "info-section-text"
  }, "Source Code"), /* @__PURE__ */ React31.createElement("ul", null, /* @__PURE__ */ React31.createElement("li", null, /* @__PURE__ */ React31.createElement("a", {
    href: "https://github.com/vitessce/vitessce"
  }, "GitHub")), /* @__PURE__ */ React31.createElement("li", null, /* @__PURE__ */ React31.createElement("a", {
    href: "https://www.npmjs.com/package/vitessce"
  }, "NPM"))), /* @__PURE__ */ React31.createElement("h5", {
    className: "info-section-text"
  }, "Funding"), /* @__PURE__ */ React31.createElement("ul", null, /* @__PURE__ */ React31.createElement("li", null, "NIH/OD Human BioMolecular Atlas Program (HuBMAP) (OT2OD026677, PI: Nils Gehlenborg)."), /* @__PURE__ */ React31.createElement("li", null, "NIH/NLM Biomedical Informatics and Data Science Research Training Program (T15LM007092, PI: Nils Gehlenborg)"), /* @__PURE__ */ React31.createElement("li", null, "Harvard Stem Cell Institute (CF-0014-17-03, PI: Nils Gehlenborg)")), /* @__PURE__ */ React31.createElement("p", {
    className: "info-section-text"
  }, "This deployment: branch=", version_default.branch, " | hash=", version_default.hash, " | date=", version_default.date));
}
function Welcome(props) {
  const { configs: configs2, theme, showBetaHeader } = props;
  return /* @__PURE__ */ React31.createElement("div", {
    className: `vitessce-container vitessce-theme-${theme} welcome-container`
  }, showBetaHeader && /* @__PURE__ */ React31.createElement("div", {
    className: "welcome-beta-header"
  }, /* @__PURE__ */ React31.createElement("p", null, "Visit ", /* @__PURE__ */ React31.createElement("a", {
    href: "http://beta.vitessce.io"
  }, "beta.vitessce.io"), " to view the next version of the Vitessce home page and documentation!")), /* @__PURE__ */ React31.createElement("div", {
    className: "react-grid-layout container-fluid",
    style: { height: "max(100vh, 100%)" }
  }, /* @__PURE__ */ React31.createElement("div", {
    className: "row"
  }, /* @__PURE__ */ React31.createElement("div", {
    className: "welcome-col-left"
  }, /* @__PURE__ */ React31.createElement("div", {
    className: "card card-body bg-primary"
  }, /* @__PURE__ */ React31.createElement(Form, {
    configs: configs2,
    theme
  }))), /* @__PURE__ */ React31.createElement("div", {
    className: "welcome-col-right"
  }, /* @__PURE__ */ React31.createElement("div", {
    className: "card card-body bg-primary"
  }, /* @__PURE__ */ React31.createElement(Info, null))))));
}

// src/app/Warning.js
import React32 from "react";
function Warning(props) {
  const {
    title: title16,
    preformatted,
    unformatted,
    theme
  } = props;
  return /* @__PURE__ */ React32.createElement("div", {
    className: `vitessce-container vitessce-theme-${theme}`
  }, /* @__PURE__ */ React32.createElement("div", {
    className: "warning-layout container-fluid"
  }, /* @__PURE__ */ React32.createElement("div", {
    className: "row"
  }, /* @__PURE__ */ React32.createElement("div", {
    className: "col-12"
  }, /* @__PURE__ */ React32.createElement("div", {
    className: PRIMARY_CARD
  }, /* @__PURE__ */ React32.createElement("h1", null, title16), /* @__PURE__ */ React32.createElement("pre", null, preformatted), /* @__PURE__ */ React32.createElement("div", null, unformatted))))));
}

// src/app/Vitessce.js
import React74, { useEffect as useEffect25, useMemo as useMemo17 } from "react";
import {
  ThemeProvider,
  StylesProvider,
  createGenerateClassName
} from "@material-ui/core/styles";
import isEqual14 from "lodash/isEqual";

// src/app/CallbackPublisher.js
import { useEffect as useEffect10 } from "react";

// src/app/view-config-versions.js
import Ajv3 from "ajv";

// src/schemas/config-0.1.0.schema.json
var $schema9 = "http://json-schema.org/draft-07/schema#";
var $id9 = "https://github.com/vitessce/vitessce/#dataset";
var title9 = "Vitessce data set";
var type9 = "object";
var definitions9 = {
  components: {
    type: "array",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["component", "x", "y"],
      properties: {
        component: { type: "string" },
        props: { type: "object" },
        x: { type: "integer" },
        y: { type: "integer" },
        w: { type: "integer" },
        h: { type: "integer" }
      }
    }
  },
  requestInit: {
    type: "object",
    additionalProperties: false,
    required: [],
    properties: {
      method: {
        type: "string"
      },
      headers: {
        type: "object"
      },
      body: {
        type: "string"
      },
      mode: {
        type: "string"
      },
      credentials: {
        type: "string"
      },
      cache: {
        type: "string"
      },
      redirect: {
        type: "string"
      },
      referrer: {
        type: "string"
      },
      integrity: {
        type: "string"
      }
    }
  }
};
var additionalProperties3 = false;
var required3 = ["version", "name", "layers"];
var properties3 = {
  name: { type: "string" },
  public: { type: "boolean" },
  description: { type: "string" },
  layers: {
    type: "array",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["name", "type", "fileType", "url"],
      properties: {
        name: { type: "string" },
        type: { type: "string" },
        fileType: { type: "string" },
        url: { type: "string" },
        requestInit: { $ref: "#/definitions/requestInit" }
      }
    }
  },
  staticLayout: { $ref: "#/definitions/components" },
  version: {
    type: "string",
    enum: ["0.1.0"]
  }
};
var config_0_1_0_schema_default = {
  $schema: $schema9,
  $id: $id9,
  title: title9,
  type: type9,
  definitions: definitions9,
  additionalProperties: additionalProperties3,
  required: required3,
  properties: properties3
};

// src/schemas/config-1.0.0.schema.json
var $schema10 = "http://json-schema.org/draft-07/schema#";
var $id10 = "https://github.com/vitessce/vitessce/#dataset";
var title10 = "Vitessce data set";
var type10 = "object";
var definitions10 = {
  components: {
    description: "The layout array defines the views, or components, rendered in the grid.",
    type: "array",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["component", "x", "y"],
      properties: {
        component: {
          type: "string",
          description: "Specify a component using a name defined in the component registry."
        },
        props: {
          type: "object",
          description: "Extra prop values for the component."
        },
        x: { type: "integer" },
        y: { type: "integer" },
        w: { type: "integer" },
        h: { type: "integer" },
        coordinationScopes: {
          type: "object",
          description: "Component-level coordination scope mappings define which coordination object values a particular component can read and write, for each coordination type.",
          additionalProperties: false,
          required: [],
          properties: {
            dataset: { type: "string" },
            embeddingType: { type: "string" },
            embeddingZoom: { type: "string" },
            embeddingRotation: { type: "string" },
            embeddingTargetX: { type: "string" },
            embeddingTargetY: { type: "string" },
            embeddingTargetZ: { type: "string" },
            embeddingCellSetPolygonsVisible: { type: "string" },
            embeddingCellSetLabelsVisible: { type: "string" },
            embeddingCellSetLabelSize: { type: "string" },
            embeddingCellRadius: { type: "string" },
            spatialZoom: { type: "string" },
            spatialRotation: { type: "string" },
            spatialTargetX: { type: "string" },
            spatialTargetY: { type: "string" },
            spatialTargetZ: { type: "string" },
            heatmapZoomX: { type: "string" },
            heatmapZoomY: { type: "string" },
            heatmapTargetX: { type: "string" },
            heatmapTargetY: { type: "string" },
            cellFilter: { type: "string" },
            cellHighlight: { type: "string" },
            cellSetSelection: { type: "string" },
            cellSetHighlight: { type: "string" },
            cellSetColor: { type: "string" },
            geneFilter: { type: "string" },
            geneHighlight: { type: "string" },
            geneSelection: { type: "string" },
            geneExpressionTransform: { type: "string" },
            geneExpressionColormap: { type: "string" },
            geneExpressionColormapRange: { type: "string" },
            cellColorEncoding: { type: "string" },
            spatialLayers: { type: "string" },
            genomicZoomX: { type: "string" },
            genomicZoomY: { type: "string" },
            genomicTargetX: { type: "string" },
            genomicTargetY: { type: "string" },
            additionalCellSets: { type: "string" },
            moleculeHighlight: { type: "string" }
          }
        }
      }
    }
  },
  annDataCellSets: {
    type: "array",
    description: "Array of cell set configuration, following closely the conventions of the tabular schema",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["groupName", "setName"],
      properties: {
        groupName: {
          type: "string",
          description: "The display name for the set, like 'Cell Type' or 'Louvain.'"
        },
        setName: {
          type: "string",
          description: "The location in the AnnData store for the set, like 'obs/louvain' or 'obs/celltype.'"
        }
      }
    }
  },
  annDataCells: {
    type: "object",
    description: "The properties of this object are the configuration for how to layout scatterplots and spatial information",
    minProperties: 1,
    additionalProperties: false,
    required: [],
    properties: {
      xy: {
        type: "string",
        description: "The location in the AnnData store of cell centroids, like 'obsm/X_centroids.'"
      },
      poly: {
        type: "string",
        description: "The location in the AnnData store of cell polygon outlines, like 'obsm/X_polygons.'"
      },
      factors: {
        type: "array",
        description: "List of locations in the AnnData store of cell sets, like 'obs/louvain'",
        items: {
          type: "string"
        }
      },
      mappings: {
        patternProperties: {
          ".": {
            type: "object",
            description: "An object containing key-values for mappings like { UMAP: { key: 'obsm/X_umap', dims: [0, 1] } }.",
            additionalProperties: false,
            required: ["key"],
            properties: {
              key: {
                type: "string",
                description: "Where to look in the AnnData store for this mapping, like 'obsm/X_umap.'"
              },
              dims: {
                type: "array",
                description: "Which indices of the obsm object to take for a scatterplot, allowing for, for example, different PCs from obsm/X_pca",
                minItems: 2,
                maxItems: 2,
                items: { type: "number" }
              }
            }
          }
        }
      }
    }
  },
  annDataExpressionMatrix: {
    type: "object",
    description: "The properties of this object are the configuration for how to fetch the cell x genes matrix",
    additionalProperties: false,
    required: ["matrix"],
    properties: {
      matrix: {
        type: "string",
        description: "The location in the AnnData store of the cell x gene matrix, like 'obsm/hvg_subset.' or 'X'"
      },
      geneFilter: {
        type: "string",
        description: "The location in the AnnData store of a filter for the genes if using a subset of the data, like 'var.highly_variable.' if the matrix comes from 'obsm/hvg_subset.'"
      },
      matrixGeneFilter: {
        type: "string",
        description: "The location in the AnnData store of a filter for the matrix data (used in heatmap and histogram), like 'var.highly_variable.''"
      }
    }
  },
  requestInit: {
    type: "object",
    description: "The properties of this object correspond to the parameters of the JavaScript fetch() function.",
    additionalProperties: false,
    required: [],
    properties: {
      method: {
        type: "string"
      },
      headers: {
        type: "object"
      },
      body: {
        type: "string"
      },
      mode: {
        type: "string"
      },
      credentials: {
        type: "string"
      },
      cache: {
        type: "string"
      },
      redirect: {
        type: "string"
      },
      referrer: {
        type: "string"
      },
      integrity: {
        type: "string"
      }
    }
  },
  rasterLayer: {
    description: "The properties of this object are the rendering settings for the raster layer.",
    additionalProperties: false,
    required: ["channels", "colormap", "index", "opacity", "type"],
    properties: {
      channels: {
        type: "array",
        items: {
          type: "object",
          additionalProperties: false,
          required: ["selection"],
          properties: {
            color: {
              type: "array",
              items: { type: "number" },
              description: "The color to use when rendering this channel under the null colormap."
            },
            selection: {
              type: "object",
              description: "Determines the channel selection, e.g. some Z and time slice."
            },
            slider: {
              type: "array",
              items: { type: "number" },
              description: "Determines the range for color mapping."
            },
            visible: {
              type: "boolean",
              description: "Determines whether this channel of the layer will be rendered in the spatial component."
            }
          }
        }
      },
      colormap: {
        oneOf: [
          {
            type: "string",
            description: "The name of the colormap to use for this layer."
          },
          {
            type: "null",
            description: "Use the solid color definitions."
          }
        ]
      },
      transparentColor: {
        oneOf: [
          {
            type: "array",
            minItems: 3,
            maxItems: 3,
            items: {
              type: "number",
              description: "One of R G or B (0 - 255)."
            },
            description: "Determines the color to be set to opacity 0"
          },
          {
            type: "null",
            description: "No selection."
          }
        ]
      },
      index: {
        type: "number",
        description: "The index of the layer among the array of layers available in the image file."
      },
      modelMatrix: {
        oneOf: [
          {
            type: "array",
            minItems: 16,
            maxItems: 16,
            description: "transformation matrix for this layer"
          },
          {
            type: "null",
            description: "Use no transformation."
          }
        ]
      },
      opacity: {
        type: "number"
      },
      domainType: {
        type: "string",
        enum: ["Full", "Min/Max"],
        description: "Determines the extent of the channel slider input element in the layer controller."
      },
      type: {
        type: "string",
        enum: ["raster"]
      }
    }
  },
  moleculesLayer: {
    description: "The properties of this object are the rendering settings for the molecules layer.",
    additionalProperties: false,
    required: ["visible", "radius", "opacity", "type"],
    properties: {
      visible: {
        type: "boolean"
      },
      radius: {
        type: "number"
      },
      opacity: {
        type: "number"
      },
      type: {
        type: "string",
        enum: ["molecules"]
      }
    }
  },
  cellsLayer: {
    description: "The properties of this object are the rendering settings for the cells layer.",
    additionalProperties: false,
    required: ["visible", "stroked", "radius", "opacity", "type"],
    properties: {
      visible: {
        type: "boolean"
      },
      stroked: {
        type: "boolean"
      },
      radius: {
        type: "number"
      },
      opacity: {
        type: "number"
      },
      type: {
        type: "string",
        enum: ["cells"]
      }
    }
  },
  neighborhoodsLayer: {
    description: "The properties of this object are the rendering settings for the neighborhoods layer.",
    additionalProperties: false,
    required: ["visible", "type"],
    properties: {
      visible: {
        type: "boolean"
      },
      type: {
        type: "string",
        enum: ["neighborhoods"]
      }
    }
  },
  spatialLayers: {
    type: "array",
    description: "Array of Spatial Layers",
    items: {
      oneOf: [
        {
          $ref: "#/definitions/rasterLayer"
        },
        {
          $ref: "#/definitions/cellsLayer"
        },
        {
          $ref: "#/definitions/moleculesLayer"
        },
        {
          $ref: "#/definitions/neighborhoodsLayer"
        }
      ]
    }
  }
};
var additionalProperties4 = false;
var required4 = ["version", "name", "datasets", "layout", "initStrategy"];
var properties4 = {
  name: { type: "string" },
  public: { type: "boolean" },
  description: { type: "string" },
  datasets: {
    type: "array",
    description: "The datasets array defines groups of files, where the files within each dataset reference the same entities (cells, genes, cell sets, etc).",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["uid", "files"],
      properties: {
        uid: { type: "string" },
        name: { type: "string" },
        description: { type: "string" },
        files: {
          type: "array",
          items: {
            type: "object",
            additionalProperties: false,
            required: ["type", "fileType"],
            properties: {
              name: { type: "string" },
              type: { type: "string" },
              fileType: { type: "string" },
              url: { type: "string" },
              options: { oneOf: [{ $ref: "#/definitions/annDataCellSets" }, { $ref: "https://github.com/vitessce/vitessce/#raster" }, { $ref: "#/definitions/annDataCells" }, { $ref: "#/definitions/annDataExpressionMatrix" }] },
              requestInit: { $ref: "#/definitions/requestInit" }
            }
          }
        }
      }
    }
  },
  coordinationSpace: {
    type: "object",
    description: "The coordination space stores the values for each scope of each coordination object.",
    additionalProperties: false,
    required: [],
    properties: {
      dataset: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      embeddingZoom: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingRotation: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingTargetX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingTargetY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingTargetZ: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingType: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      embeddingCellSetPolygonsVisible: {
        type: "object",
        patternProperties: {
          ".": { type: "boolean" }
        }
      },
      embeddingCellSetLabelsVisible: {
        type: "object",
        patternProperties: {
          ".": { type: "boolean" }
        }
      },
      embeddingCellSetLabelSize: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingCellRadius: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      spatialZoom: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotation: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      spatialTargetX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialTargetY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialTargetZ: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      spatialLayers: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/spatialLayers" }
            ]
          }
        }
      },
      heatmapZoomX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapZoomY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapTargetX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapTargetY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      cellFilter: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cells will be filtered out initially."
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      cellHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      cellSetSelection: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto cell set initialization is enabled, cell set selections will be automatically initialized."
              },
              { type: "array" }
            ]
          }
        }
      },
      cellSetHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell sets will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      cellSetColor: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, cell set colors will be automatically initialized."
              },
              {
                type: "array",
                items: {
                  type: "object",
                  additionalProperties: false,
                  required: ["path", "color"],
                  properties: {
                    path: {
                      type: "array",
                      items: { type: "string" }
                    },
                    color: {
                      type: "array",
                      items: { type: "number" }
                    }
                  }
                }
              }
            ]
          }
        }
      },
      cellColorEncoding: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      geneFilter: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no genes will be filtered out initially."
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      geneHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no genes will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      geneSelection: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null"
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      geneExpressionTransform: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null"
              },
              { type: "string", pattern: "log1p" }
            ]
          }
        }
      },
      geneExpressionColormap: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      geneExpressionColormapRange: {
        type: "object",
        patternProperties: {
          ".": { type: "array", items: { type: "number" } }
        }
      },
      genomicZoomX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicZoomY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicTargetX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicTargetY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      additionalCellSets: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell will be highlighted initially."
              },
              {
                $ref: "https://github.com/vitessce/vitessce/#cell-sets"
              }
            ]
          }
        }
      },
      moleculeHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no molecule will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      }
    }
  },
  layout: { $ref: "#/definitions/components" },
  initStrategy: {
    type: "string",
    enum: ["none", "auto"],
    description: "The initialization strategy determines how missing coordination objects and coordination scope mappings are initially filled in."
  },
  version: {
    type: "string",
    enum: ["1.0.0"],
    description: "The schema version for the view config."
  }
};
var config_1_0_0_schema_default = {
  $schema: $schema10,
  $id: $id10,
  title: title10,
  type: type10,
  definitions: definitions10,
  additionalProperties: additionalProperties4,
  required: required4,
  properties: properties4
};

// src/schemas/config-1.0.1.schema.json
var $schema11 = "http://json-schema.org/draft-07/schema#";
var $id11 = "https://github.com/vitessce/vitessce/#dataset";
var title11 = "Vitessce data set";
var type11 = "object";
var definitions11 = {
  components: {
    description: "The layout array defines the views, or components, rendered in the grid.",
    type: "array",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["component", "x", "y"],
      properties: {
        component: {
          type: "string",
          description: "Specify a component using a name defined in the component registry."
        },
        props: {
          type: "object",
          description: "Extra prop values for the component."
        },
        x: { type: "integer" },
        y: { type: "integer" },
        w: { type: "integer" },
        h: { type: "integer" },
        coordinationScopes: {
          type: "object",
          description: "Component-level coordination scope mappings define which coordination object values a particular component can read and write, for each coordination type.",
          additionalProperties: false,
          required: [],
          properties: {
            dataset: { type: "string" },
            embeddingType: { type: "string" },
            embeddingZoom: { type: "string" },
            embeddingRotation: { type: "string" },
            embeddingTargetX: { type: "string" },
            embeddingTargetY: { type: "string" },
            embeddingTargetZ: { type: "string" },
            embeddingCellSetPolygonsVisible: { type: "string" },
            embeddingCellSetLabelsVisible: { type: "string" },
            embeddingCellSetLabelSize: { type: "string" },
            embeddingCellRadius: { type: "string" },
            spatialZoom: { type: "string" },
            spatialRotation: { type: "string" },
            spatialTargetX: { type: "string" },
            spatialTargetY: { type: "string" },
            spatialTargetZ: { type: "string" },
            spatialRotationX: { type: "string" },
            spatialRotationY: { type: "string" },
            spatialRotationZ: { type: "string" },
            spatialRotationOrbit: { type: "string" },
            spatialOrbitAxis: { type: "string" },
            spatialAxisFixed: { type: "string" },
            heatmapZoomX: { type: "string" },
            heatmapZoomY: { type: "string" },
            heatmapTargetX: { type: "string" },
            heatmapTargetY: { type: "string" },
            cellFilter: { type: "string" },
            cellHighlight: { type: "string" },
            cellSetSelection: { type: "string" },
            cellSetHighlight: { type: "string" },
            cellSetColor: { type: "string" },
            geneFilter: { type: "string" },
            geneHighlight: { type: "string" },
            geneSelection: { type: "string" },
            geneExpressionTransform: { type: "string" },
            geneExpressionColormap: { type: "string" },
            geneExpressionColormapRange: { type: "string" },
            cellColorEncoding: { type: "string" },
            spatialRasterLayers: { type: "string" },
            spatialCellsLayer: { type: "string" },
            spatialMoleculesLayer: { type: "string" },
            spatialNeighborhoodsLayer: { type: "string" },
            genomicZoomX: { type: "string" },
            genomicZoomY: { type: "string" },
            genomicTargetX: { type: "string" },
            genomicTargetY: { type: "string" },
            additionalCellSets: { type: "string" },
            moleculeHighlight: { type: "string" }
          }
        }
      }
    }
  },
  annDataCellSets: {
    type: "array",
    description: "Array of cell set configuration, following closely the conventions of the tabular schema",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["groupName", "setName"],
      properties: {
        groupName: {
          type: "string",
          description: "The display name for the set, like 'Cell Type' or 'Louvain.'"
        },
        setName: {
          type: "string",
          description: "The location in the AnnData store for the set, like 'obs/louvain' or 'obs/celltype.'"
        }
      }
    }
  },
  annDataCells: {
    type: "object",
    description: "The properties of this object are the configuration for how to layout scatterplots and spatial information",
    minProperties: 1,
    additionalProperties: false,
    required: [],
    properties: {
      xy: {
        type: "string",
        description: "The location in the AnnData store of cell centroids, like 'obsm/X_centroids.'"
      },
      poly: {
        type: "string",
        description: "The location in the AnnData store of cell polygon outlines, like 'obsm/X_polygons.'"
      },
      factors: {
        type: "array",
        description: "List of locations in the AnnData store of cell sets, like 'obs/louvain'",
        items: {
          type: "string"
        }
      },
      mappings: {
        patternProperties: {
          ".": {
            type: "object",
            description: "An object containing key-values for mappings like { UMAP: { key: 'obsm/X_umap', dims: [0, 1] } }.",
            additionalProperties: false,
            required: ["key"],
            properties: {
              key: {
                type: "string",
                description: "Where to look in the AnnData store for this mapping, like 'obsm/X_umap.'"
              },
              dims: {
                type: "array",
                description: "Which indices of the obsm object to take for a scatterplot, allowing for, for example, different PCs from obsm/X_pca",
                minItems: 2,
                maxItems: 2,
                items: { type: "number" }
              }
            }
          }
        }
      }
    }
  },
  annDataExpressionMatrix: {
    type: "object",
    description: "The properties of this object are the configuration for how to fetch the cell x genes matrix",
    additionalProperties: false,
    required: ["matrix"],
    properties: {
      matrix: {
        type: "string",
        description: "The location in the AnnData store of the cell x gene matrix, like 'obsm/hvg_subset.' or 'X'"
      },
      geneFilter: {
        type: "string",
        description: "The location in the AnnData store of a filter for the genes if using a subset of the data, like 'var.highly_variable.' if the matrix comes from 'obsm/hvg_subset.'"
      },
      matrixGeneFilter: {
        type: "string",
        description: "The location in the AnnData store of a filter for the matrix data (used in heatmap and histogram), like 'var.highly_variable.''"
      }
    }
  },
  requestInit: {
    type: "object",
    description: "The properties of this object correspond to the parameters of the JavaScript fetch() function.",
    additionalProperties: false,
    required: [],
    properties: {
      method: {
        type: "string"
      },
      headers: {
        type: "object"
      },
      body: {
        type: "string"
      },
      mode: {
        type: "string"
      },
      credentials: {
        type: "string"
      },
      cache: {
        type: "string"
      },
      redirect: {
        type: "string"
      },
      referrer: {
        type: "string"
      },
      integrity: {
        type: "string"
      }
    }
  },
  rasterLayer: {
    description: "The properties of this object are the rendering settings for the raster layer.",
    additionalProperties: false,
    required: ["channels", "colormap", "index", "opacity"],
    properties: {
      channels: {
        type: "array",
        items: {
          type: "object",
          additionalProperties: false,
          required: ["selection"],
          properties: {
            color: {
              type: "array",
              items: { type: "number" },
              description: "The color to use when rendering this channel under the null colormap."
            },
            selection: {
              type: "object",
              description: "Determines the channel selection, e.g. some Z and time slice."
            },
            slider: {
              type: "array",
              items: { type: "number" },
              description: "Determines the range for color mapping."
            },
            visible: {
              type: "boolean",
              description: "Determines whether this channel of the layer will be rendered in the spatial component."
            }
          }
        }
      },
      colormap: {
        oneOf: [
          {
            type: "string",
            description: "The name of the colormap to use for this layer."
          },
          {
            type: "null",
            description: "Use the solid color definitions."
          }
        ]
      },
      transparentColor: {
        oneOf: [
          {
            type: "array",
            minItems: 3,
            maxItems: 3,
            items: {
              type: "number",
              description: "One of R G or B (0 - 255)."
            },
            description: "Determines the color to be set to opacity 0"
          },
          {
            type: "null",
            description: "No selection."
          }
        ]
      },
      index: {
        type: "number",
        description: "The index of the layer among the array of layers available in the image file."
      },
      opacity: {
        type: "number"
      },
      modelMatrix: {
        oneOf: [
          {
            type: "array",
            minItems: 16,
            maxItems: 16,
            description: "transformation matrix for this layer"
          },
          {
            type: "null",
            description: "Use no transformation."
          }
        ]
      },
      domainType: {
        type: "string",
        enum: ["Full", "Min/Max"],
        description: "Determines the extent of the channel slider input element in the layer controller."
      },
      resolution: {
        type: "number",
        description: "Resolution of 3D volumetric rendering"
      },
      xSlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      renderingMode: {
        type: "string",
        description: "Rendering mode of 3D volumetric rendering"
      },
      ySlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      zSlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      type: {
        type: "string"
      },
      use3d: {
        type: "boolean"
      },
      visible: {
        type: "boolean",
        description: "Determines whether this entire layer will be rendered in the spatial component."
      }
    }
  },
  moleculesLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the molecules layer.",
    additionalProperties: false,
    required: ["visible", "radius", "opacity"],
    properties: {
      visible: {
        type: "boolean"
      },
      radius: {
        type: "number"
      },
      opacity: {
        type: "number"
      }
    }
  },
  cellsLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the cells layer.",
    additionalProperties: false,
    required: ["visible", "stroked", "radius", "opacity"],
    properties: {
      visible: {
        type: "boolean"
      },
      stroked: {
        type: "boolean"
      },
      radius: {
        type: "number"
      },
      opacity: {
        type: "number"
      }
    }
  },
  neighborhoodsLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the neighborhoods layer.",
    additionalProperties: false,
    required: ["visible"],
    properties: {
      visible: {
        type: "boolean"
      }
    }
  },
  spatialRasterLayers: {
    type: "array",
    description: "Array of Spatial Layers",
    items: {
      $ref: "#/definitions/rasterLayer"
    }
  }
};
var additionalProperties5 = false;
var required5 = ["version", "name", "datasets", "layout", "initStrategy"];
var properties5 = {
  name: { type: "string" },
  public: { type: "boolean" },
  description: { type: "string" },
  datasets: {
    type: "array",
    description: "The datasets array defines groups of files, where the files within each dataset reference the same entities (cells, genes, cell sets, etc).",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["uid", "files"],
      properties: {
        uid: { type: "string" },
        name: { type: "string" },
        description: { type: "string" },
        files: {
          type: "array",
          items: {
            type: "object",
            additionalProperties: false,
            required: ["type", "fileType"],
            properties: {
              name: { type: "string" },
              type: { type: "string" },
              fileType: { type: "string" },
              url: { type: "string" },
              options: { oneOf: [{ $ref: "#/definitions/annDataCellSets" }, { $ref: "https://github.com/vitessce/vitessce/#raster" }, { $ref: "#/definitions/annDataCells" }, { $ref: "#/definitions/annDataExpressionMatrix" }] },
              requestInit: { $ref: "#/definitions/requestInit" }
            }
          }
        }
      }
    }
  },
  coordinationSpace: {
    type: "object",
    description: "The coordination space stores the values for each scope of each coordination object.",
    additionalProperties: false,
    required: [],
    properties: {
      dataset: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      embeddingZoom: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingRotation: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingTargetX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingTargetY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingTargetZ: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingType: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      embeddingCellSetPolygonsVisible: {
        type: "object",
        patternProperties: {
          ".": { type: "boolean" }
        }
      },
      embeddingCellSetLabelsVisible: {
        type: "object",
        patternProperties: {
          ".": { type: "boolean" }
        }
      },
      embeddingCellSetLabelSize: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingCellRadius: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      spatialZoom: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotation: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      spatialTargetX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialTargetY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialTargetZ: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationZ: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationOrbit: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialOrbitAxis: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "string" }
            ]
          }
        }
      },
      spatialAxisFixed: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "Whether or not to have a fixed axis for the camera. Only useful for 3D viewing."
              },
              { type: "boolean" }
            ]
          }
        }
      },
      spatialRasterLayers: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/spatialRasterLayers" }
            ]
          }
        }
      },
      spatialCellsLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/cellsLayer" }
            ]
          }
        }
      },
      spatialNeighborhoodsLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/neighborhoodsLayer" }
            ]
          }
        }
      },
      spatialMoleculesLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/moleculesLayer" }
            ]
          }
        }
      },
      heatmapZoomX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapZoomY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapTargetX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapTargetY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      cellFilter: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cells will be filtered out initially."
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      cellHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      cellSetSelection: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto cell set initialization is enabled, cell set selections will be automatically initialized."
              },
              { type: "array" }
            ]
          }
        }
      },
      cellSetHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell sets will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      cellSetColor: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, cell set colors will be automatically initialized."
              },
              {
                type: "array",
                items: {
                  type: "object",
                  additionalProperties: false,
                  required: ["path", "color"],
                  properties: {
                    path: {
                      type: "array",
                      items: { type: "string" }
                    },
                    color: {
                      type: "array",
                      items: { type: "number" }
                    }
                  }
                }
              }
            ]
          }
        }
      },
      cellColorEncoding: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      geneFilter: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no genes will be filtered out initially."
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      geneHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no genes will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      geneSelection: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null"
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      geneExpressionTransform: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null"
              },
              { type: "string", pattern: "log1p" }
            ]
          }
        }
      },
      geneExpressionColormap: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      geneExpressionColormapRange: {
        type: "object",
        patternProperties: {
          ".": { type: "array", items: { type: "number" } }
        }
      },
      genomicZoomX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicZoomY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicTargetX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicTargetY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      additionalCellSets: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell will be highlighted initially."
              },
              {
                $ref: "https://github.com/vitessce/vitessce/#cell-sets"
              }
            ]
          }
        }
      },
      moleculeHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no molecule will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      }
    }
  },
  layout: { $ref: "#/definitions/components" },
  initStrategy: {
    type: "string",
    enum: ["none", "auto"],
    description: "The initialization strategy determines how missing coordination objects and coordination scope mappings are initially filled in."
  },
  version: {
    type: "string",
    enum: ["1.0.1"],
    description: "The schema version for the view config."
  }
};
var config_1_0_1_schema_default = {
  $schema: $schema11,
  $id: $id11,
  title: title11,
  type: type11,
  definitions: definitions11,
  additionalProperties: additionalProperties5,
  required: required5,
  properties: properties5
};

// src/schemas/config-1.0.2.schema.json
var $schema12 = "http://json-schema.org/draft-07/schema#";
var $id12 = "https://github.com/vitessce/vitessce/#dataset";
var title12 = "Vitessce data set";
var type12 = "object";
var definitions12 = {
  components: {
    description: "The layout array defines the views, or components, rendered in the grid.",
    type: "array",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["component", "x", "y"],
      properties: {
        component: {
          type: "string",
          description: "Specify a component using a name defined in the component registry."
        },
        props: {
          type: "object",
          description: "Extra prop values for the component."
        },
        x: { type: "integer" },
        y: { type: "integer" },
        w: { type: "integer" },
        h: { type: "integer" },
        coordinationScopes: {
          type: "object",
          description: "Component-level coordination scope mappings define which coordination object values a particular component can read and write, for each coordination type.",
          additionalProperties: false,
          required: [],
          properties: {
            dataset: { type: "string" },
            embeddingType: { type: "string" },
            embeddingZoom: { type: "string" },
            embeddingRotation: { type: "string" },
            embeddingTargetX: { type: "string" },
            embeddingTargetY: { type: "string" },
            embeddingTargetZ: { type: "string" },
            embeddingCellSetPolygonsVisible: { type: "string" },
            embeddingCellSetLabelsVisible: { type: "string" },
            embeddingCellSetLabelSize: { type: "string" },
            embeddingCellRadius: { type: "string" },
            spatialZoom: { type: "string" },
            spatialRotation: { type: "string" },
            spatialTargetX: { type: "string" },
            spatialTargetY: { type: "string" },
            spatialTargetZ: { type: "string" },
            spatialRotationX: { type: "string" },
            spatialRotationY: { type: "string" },
            spatialRotationZ: { type: "string" },
            spatialRotationOrbit: { type: "string" },
            spatialOrbitAxis: { type: "string" },
            spatialAxisFixed: { type: "string" },
            heatmapZoomX: { type: "string" },
            heatmapZoomY: { type: "string" },
            heatmapTargetX: { type: "string" },
            heatmapTargetY: { type: "string" },
            cellFilter: { type: "string" },
            cellHighlight: { type: "string" },
            cellSetSelection: { type: "string" },
            cellSetHighlight: { type: "string" },
            cellSetColor: { type: "string" },
            geneFilter: { type: "string" },
            geneHighlight: { type: "string" },
            geneSelection: { type: "string" },
            geneExpressionTransform: { type: "string" },
            geneExpressionColormap: { type: "string" },
            geneExpressionColormapRange: { type: "string" },
            cellColorEncoding: { type: "string" },
            spatialRasterLayers: { type: "string" },
            spatialCellsLayer: { type: "string" },
            spatialMoleculesLayer: { type: "string" },
            spatialNeighborhoodsLayer: { type: "string" },
            genomicZoomX: { type: "string" },
            genomicZoomY: { type: "string" },
            genomicTargetX: { type: "string" },
            genomicTargetY: { type: "string" },
            additionalCellSets: { type: "string" },
            moleculeHighlight: { type: "string" }
          }
        }
      }
    }
  },
  annDataCellSets: {
    type: "array",
    description: "Array of cell set configuration, following closely the conventions of the tabular schema",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["groupName", "setName"],
      properties: {
        groupName: {
          type: "string",
          description: "The display name for the set, like 'Cell Type' or 'Louvain.'"
        },
        setName: {
          type: "string",
          description: "The location in the AnnData store for the set, like 'obs/louvain' or 'obs/celltype.'"
        }
      }
    }
  },
  annDataCells: {
    type: "object",
    description: "The properties of this object are the configuration for how to layout scatterplots and spatial information",
    minProperties: 1,
    additionalProperties: false,
    required: [],
    properties: {
      xy: {
        type: "string",
        description: "The location in the AnnData store of cell centroids, like 'obsm/X_centroids.'"
      },
      poly: {
        type: "string",
        description: "The location in the AnnData store of cell polygon outlines, like 'obsm/X_polygons.'"
      },
      factors: {
        type: "array",
        description: "List of locations in the AnnData store of cell sets, like 'obs/louvain'",
        items: {
          type: "string"
        }
      },
      mappings: {
        patternProperties: {
          ".": {
            type: "object",
            description: "An object containing key-values for mappings like { UMAP: { key: 'obsm/X_umap', dims: [0, 1] } }.",
            additionalProperties: false,
            required: ["key"],
            properties: {
              key: {
                type: "string",
                description: "Where to look in the AnnData store for this mapping, like 'obsm/X_umap.'"
              },
              dims: {
                type: "array",
                description: "Which indices of the obsm object to take for a scatterplot, allowing for, for example, different PCs from obsm/X_pca",
                minItems: 2,
                maxItems: 2,
                items: { type: "number" }
              }
            }
          }
        }
      }
    }
  },
  annDataExpressionMatrix: {
    type: "object",
    description: "The properties of this object are the configuration for how to fetch the cell x genes matrix",
    additionalProperties: false,
    required: ["matrix"],
    properties: {
      matrix: {
        type: "string",
        description: "The location in the AnnData store of the cell x gene matrix, like 'obsm/hvg_subset.' or 'X'"
      },
      geneFilter: {
        type: "string",
        description: "The location in the AnnData store of a filter for the genes if using a subset of the data, like 'var.highly_variable.' if the matrix comes from 'obsm/hvg_subset.'"
      },
      matrixGeneFilter: {
        type: "string",
        description: "The location in the AnnData store of a filter for the matrix data (used in heatmap and histogram), like 'var.highly_variable.''"
      }
    }
  },
  requestInit: {
    type: "object",
    description: "The properties of this object correspond to the parameters of the JavaScript fetch() function.",
    additionalProperties: false,
    required: [],
    properties: {
      method: {
        type: "string"
      },
      headers: {
        type: "object"
      },
      body: {
        type: "string"
      },
      mode: {
        type: "string"
      },
      credentials: {
        type: "string"
      },
      cache: {
        type: "string"
      },
      redirect: {
        type: "string"
      },
      referrer: {
        type: "string"
      },
      integrity: {
        type: "string"
      }
    }
  },
  rasterLayer: {
    description: "The properties of this object are the rendering settings for the raster layer.",
    additionalProperties: false,
    required: ["channels", "colormap", "index", "opacity"],
    properties: {
      channels: {
        type: "array",
        items: {
          type: "object",
          additionalProperties: false,
          required: ["selection"],
          properties: {
            color: {
              type: "array",
              items: { type: "number" },
              description: "The color to use when rendering this channel under the null colormap."
            },
            selection: {
              type: "object",
              description: "Determines the channel selection, e.g. some Z and time slice."
            },
            slider: {
              type: "array",
              items: { type: "number" },
              description: "Determines the range for color mapping."
            },
            visible: {
              type: "boolean",
              description: "Determines whether this channel of the layer will be rendered in the spatial component."
            }
          }
        }
      },
      colormap: {
        oneOf: [
          {
            type: "string",
            description: "The name of the colormap to use for this layer."
          },
          {
            type: "null",
            description: "Use the solid color definitions."
          }
        ]
      },
      transparentColor: {
        oneOf: [
          {
            type: "array",
            minItems: 3,
            maxItems: 3,
            items: {
              type: "number",
              description: "One of R G or B (0 - 255)."
            },
            description: "Determines the color to be set to opacity 0"
          },
          {
            type: "null",
            description: "No selection."
          }
        ]
      },
      index: {
        type: "number",
        description: "The index of the layer among the array of layers available in the image file."
      },
      opacity: {
        type: "number"
      },
      modelMatrix: {
        oneOf: [
          {
            type: "array",
            minItems: 16,
            maxItems: 16,
            description: "transformation matrix for this layer"
          },
          {
            type: "null",
            description: "Use no transformation."
          }
        ]
      },
      domainType: {
        type: "string",
        enum: ["Full", "Min/Max"],
        description: "Determines the extent of the channel slider input element in the layer controller."
      },
      resolution: {
        type: "number",
        description: "Resolution of 3D volumetric rendering"
      },
      xSlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      renderingMode: {
        type: "string",
        description: "Rendering mode of 3D volumetric rendering"
      },
      ySlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      zSlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      type: {
        type: "string",
        enum: ["raster", "bitmask"]
      },
      use3d: {
        type: "boolean"
      },
      visible: {
        type: "boolean",
        description: "Determines whether this entire layer will be rendered in the spatial component."
      }
    }
  },
  moleculesLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the molecules layer.",
    additionalProperties: false,
    required: ["visible", "radius", "opacity"],
    properties: {
      visible: {
        type: "boolean"
      },
      radius: {
        type: "number"
      },
      opacity: {
        type: "number"
      }
    }
  },
  cellsLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the cells layer.",
    additionalProperties: false,
    required: ["visible", "stroked", "radius", "opacity"],
    properties: {
      visible: {
        type: "boolean"
      },
      stroked: {
        type: "boolean"
      },
      radius: {
        type: "number"
      },
      opacity: {
        type: "number"
      }
    }
  },
  neighborhoodsLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the neighborhoods layer.",
    additionalProperties: false,
    required: ["visible"],
    properties: {
      visible: {
        type: "boolean"
      }
    }
  },
  spatialRasterLayers: {
    type: "array",
    description: "Array of Spatial Layers",
    items: {
      $ref: "#/definitions/rasterLayer"
    }
  }
};
var additionalProperties6 = false;
var required6 = ["version", "name", "datasets", "layout", "initStrategy"];
var properties6 = {
  name: { type: "string" },
  public: { type: "boolean" },
  description: { type: "string" },
  datasets: {
    type: "array",
    description: "The datasets array defines groups of files, where the files within each dataset reference the same entities (cells, genes, cell sets, etc).",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["uid", "files"],
      properties: {
        uid: { type: "string" },
        name: { type: "string" },
        description: { type: "string" },
        files: {
          type: "array",
          items: {
            type: "object",
            additionalProperties: false,
            required: ["type", "fileType"],
            properties: {
              name: { type: "string" },
              type: { type: "string" },
              fileType: { type: "string" },
              url: { type: "string" },
              options: { oneOf: [{ $ref: "#/definitions/annDataCellSets" }, { $ref: "https://github.com/vitessce/vitessce/#raster" }, { $ref: "#/definitions/annDataCells" }, { $ref: "#/definitions/annDataExpressionMatrix" }] },
              requestInit: { $ref: "#/definitions/requestInit" }
            }
          }
        }
      }
    }
  },
  coordinationSpace: {
    type: "object",
    description: "The coordination space stores the values for each scope of each coordination object.",
    additionalProperties: false,
    required: [],
    properties: {
      dataset: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      embeddingZoom: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingRotation: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingTargetX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingTargetY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingTargetZ: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingType: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      embeddingCellSetPolygonsVisible: {
        type: "object",
        patternProperties: {
          ".": { type: "boolean" }
        }
      },
      embeddingCellSetLabelsVisible: {
        type: "object",
        patternProperties: {
          ".": { type: "boolean" }
        }
      },
      embeddingCellSetLabelSize: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingCellRadius: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      spatialZoom: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotation: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      spatialTargetX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialTargetY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialTargetZ: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationZ: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationOrbit: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialOrbitAxis: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "string" }
            ]
          }
        }
      },
      spatialAxisFixed: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "Whether or not to have a fixed axis for the camera. Only useful for 3D viewing."
              },
              { type: "boolean" }
            ]
          }
        }
      },
      spatialRasterLayers: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/spatialRasterLayers" }
            ]
          }
        }
      },
      spatialCellsLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/cellsLayer" }
            ]
          }
        }
      },
      spatialNeighborhoodsLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/neighborhoodsLayer" }
            ]
          }
        }
      },
      spatialMoleculesLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/moleculesLayer" }
            ]
          }
        }
      },
      heatmapZoomX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapZoomY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapTargetX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapTargetY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      cellFilter: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cells will be filtered out initially."
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      cellHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      cellSetSelection: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto cell set initialization is enabled, cell set selections will be automatically initialized."
              },
              { type: "array" }
            ]
          }
        }
      },
      cellSetHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell sets will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      cellSetColor: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, cell set colors will be automatically initialized."
              },
              {
                type: "array",
                items: {
                  type: "object",
                  additionalProperties: false,
                  required: ["path", "color"],
                  properties: {
                    path: {
                      type: "array",
                      items: { type: "string" }
                    },
                    color: {
                      type: "array",
                      items: { type: "number" }
                    }
                  }
                }
              }
            ]
          }
        }
      },
      cellColorEncoding: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      geneFilter: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no genes will be filtered out initially."
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      geneHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no genes will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      geneSelection: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null"
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      geneExpressionTransform: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null"
              },
              { type: "string", pattern: "log1p" }
            ]
          }
        }
      },
      geneExpressionColormap: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      geneExpressionColormapRange: {
        type: "object",
        patternProperties: {
          ".": { type: "array", items: { type: "number" } }
        }
      },
      genomicZoomX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicZoomY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicTargetX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicTargetY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      additionalCellSets: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell will be highlighted initially."
              },
              {
                $ref: "https://github.com/vitessce/vitessce/#cell-sets"
              }
            ]
          }
        }
      },
      moleculeHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no molecule will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      }
    }
  },
  layout: { $ref: "#/definitions/components" },
  initStrategy: {
    type: "string",
    enum: ["none", "auto"],
    description: "The initialization strategy determines how missing coordination objects and coordination scope mappings are initially filled in."
  },
  version: {
    type: "string",
    enum: ["1.0.2"],
    description: "The schema version for the view config."
  }
};
var config_1_0_2_schema_default = {
  $schema: $schema12,
  $id: $id12,
  title: title12,
  type: type12,
  definitions: definitions12,
  additionalProperties: additionalProperties6,
  required: required6,
  properties: properties6
};

// src/schemas/config-1.0.3.schema.json
var $schema13 = "http://json-schema.org/draft-07/schema#";
var $id13 = "https://github.com/vitessce/vitessce/#dataset";
var title13 = "Vitessce data set";
var type13 = "object";
var definitions13 = {
  components: {
    description: "The layout array defines the views, or components, rendered in the grid.",
    type: "array",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["component", "x", "y"],
      properties: {
        component: {
          type: "string",
          description: "Specify a component using a name defined in the component registry."
        },
        props: {
          type: "object",
          description: "Extra prop values for the component."
        },
        x: { type: "integer" },
        y: { type: "integer" },
        w: { type: "integer" },
        h: { type: "integer" },
        coordinationScopes: {
          type: "object",
          description: "Component-level coordination scope mappings define which coordination object values a particular component can read and write, for each coordination type.",
          additionalProperties: false,
          required: [],
          properties: {
            dataset: { type: "string" },
            embeddingType: { type: "string" },
            embeddingZoom: { type: "string" },
            embeddingRotation: { type: "string" },
            embeddingTargetX: { type: "string" },
            embeddingTargetY: { type: "string" },
            embeddingTargetZ: { type: "string" },
            embeddingCellSetPolygonsVisible: { type: "string" },
            embeddingCellSetLabelsVisible: { type: "string" },
            embeddingCellSetLabelSize: { type: "string" },
            embeddingCellRadius: { type: "string" },
            spatialZoom: { type: "string" },
            spatialRotation: { type: "string" },
            spatialTargetX: { type: "string" },
            spatialTargetY: { type: "string" },
            spatialTargetZ: { type: "string" },
            spatialRotationX: { type: "string" },
            spatialRotationY: { type: "string" },
            spatialRotationZ: { type: "string" },
            spatialRotationOrbit: { type: "string" },
            spatialOrbitAxis: { type: "string" },
            spatialAxisFixed: { type: "string" },
            heatmapZoomX: { type: "string" },
            heatmapZoomY: { type: "string" },
            heatmapTargetX: { type: "string" },
            heatmapTargetY: { type: "string" },
            cellFilter: { type: "string" },
            cellHighlight: { type: "string" },
            cellSetSelection: { type: "string" },
            cellSetHighlight: { type: "string" },
            cellSetColor: { type: "string" },
            geneFilter: { type: "string" },
            geneHighlight: { type: "string" },
            geneSelection: { type: "string" },
            geneExpressionTransform: { type: "string" },
            geneExpressionColormap: { type: "string" },
            geneExpressionColormapRange: { type: "string" },
            cellColorEncoding: { type: "string" },
            spatialRasterLayers: { type: "string" },
            spatialCellsLayer: { type: "string" },
            spatialMoleculesLayer: { type: "string" },
            spatialNeighborhoodsLayer: { type: "string" },
            genomicZoomX: { type: "string" },
            genomicZoomY: { type: "string" },
            genomicTargetX: { type: "string" },
            genomicTargetY: { type: "string" },
            additionalCellSets: { type: "string" },
            moleculeHighlight: { type: "string" }
          }
        }
      }
    }
  },
  annDataCellSets: {
    type: "array",
    description: "Array of cell set configuration, following closely the conventions of the tabular schema",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["groupName", "setName"],
      properties: {
        groupName: {
          type: "string",
          description: "The display name for the set, like 'Cell Type' or 'Louvain.'"
        },
        setName: {
          type: "string",
          description: "The location in the AnnData store for the set, like 'obs/louvain' or 'obs/celltype.'"
        }
      }
    }
  },
  annDataCells: {
    type: "object",
    description: "The properties of this object are the configuration for how to layout scatterplots and spatial information",
    minProperties: 1,
    additionalProperties: false,
    required: [],
    properties: {
      xy: {
        type: "string",
        description: "The location in the AnnData store of cell centroids, like 'obsm/X_centroids.'"
      },
      poly: {
        type: "string",
        description: "The location in the AnnData store of cell polygon outlines, like 'obsm/X_polygons.'"
      },
      factors: {
        type: "array",
        description: "List of locations in the AnnData store of cell sets, like 'obs/louvain'",
        items: {
          type: "string"
        }
      },
      mappings: {
        patternProperties: {
          ".": {
            type: "object",
            description: "An object containing key-values for mappings like { UMAP: { key: 'obsm/X_umap', dims: [0, 1] } }.",
            additionalProperties: false,
            required: ["key"],
            properties: {
              key: {
                type: "string",
                description: "Where to look in the AnnData store for this mapping, like 'obsm/X_umap.'"
              },
              dims: {
                type: "array",
                description: "Which indices of the obsm object to take for a scatterplot, allowing for, for example, different PCs from obsm/X_pca",
                minItems: 2,
                maxItems: 2,
                items: { type: "number" }
              }
            }
          }
        }
      }
    }
  },
  annDataExpressionMatrix: {
    type: "object",
    description: "The properties of this object are the configuration for how to fetch the cell x genes matrix",
    additionalProperties: false,
    required: ["matrix"],
    properties: {
      matrix: {
        type: "string",
        description: "The location in the AnnData store of the cell x gene matrix, like 'obsm/hvg_subset.' or 'X'"
      },
      geneFilter: {
        type: "string",
        description: "The location in the AnnData store of a filter for the genes if using a subset of the data, like 'var.highly_variable.' if the matrix comes from 'obsm/hvg_subset.'"
      },
      matrixGeneFilter: {
        type: "string",
        description: "The location in the AnnData store of a filter for the matrix data (used in heatmap and histogram), like 'var.highly_variable.''"
      }
    }
  },
  requestInit: {
    type: "object",
    description: "The properties of this object correspond to the parameters of the JavaScript fetch() function.",
    additionalProperties: false,
    required: [],
    properties: {
      method: {
        type: "string"
      },
      headers: {
        type: "object"
      },
      body: {
        type: "string"
      },
      mode: {
        type: "string"
      },
      credentials: {
        type: "string"
      },
      cache: {
        type: "string"
      },
      redirect: {
        type: "string"
      },
      referrer: {
        type: "string"
      },
      integrity: {
        type: "string"
      }
    }
  },
  rasterLayer: {
    description: "The properties of this object are the rendering settings for the raster layer.",
    additionalProperties: false,
    required: ["channels", "colormap", "index", "opacity"],
    properties: {
      channels: {
        type: "array",
        items: {
          type: "object",
          additionalProperties: false,
          required: ["selection"],
          properties: {
            color: {
              type: "array",
              items: { type: "number" },
              description: "The color to use when rendering this channel under the null colormap."
            },
            selection: {
              type: "object",
              description: "Determines the channel selection, e.g. some Z and time slice."
            },
            slider: {
              type: "array",
              items: { type: "number" },
              description: "Determines the range for color mapping."
            },
            visible: {
              type: "boolean",
              description: "Determines whether this channel of the layer will be rendered in the spatial component."
            }
          }
        }
      },
      colormap: {
        oneOf: [
          {
            type: "string",
            description: "The name of the colormap to use for this layer."
          },
          {
            type: "null",
            description: "Use the solid color definitions."
          }
        ]
      },
      transparentColor: {
        oneOf: [
          {
            type: "array",
            minItems: 3,
            maxItems: 3,
            items: {
              type: "number",
              description: "One of R G or B (0 - 255)."
            },
            description: "Determines the color to be set to opacity 0"
          },
          {
            type: "null",
            description: "No selection."
          }
        ]
      },
      index: {
        type: "number",
        description: "The index of the layer among the array of layers available in the image file."
      },
      opacity: {
        type: "number"
      },
      modelMatrix: {
        oneOf: [
          {
            type: "array",
            minItems: 16,
            maxItems: 16,
            description: "transformation matrix for this layer"
          },
          {
            type: "null",
            description: "Use no transformation."
          }
        ]
      },
      domainType: {
        type: "string",
        enum: ["Full", "Min/Max"],
        description: "Determines the extent of the channel slider input element in the layer controller."
      },
      resolution: {
        type: "number",
        description: "Resolution of 3D volumetric rendering"
      },
      xSlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      renderingMode: {
        type: "string",
        description: "Rendering mode of 3D volumetric rendering"
      },
      ySlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      zSlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      type: {
        type: "string",
        enum: ["raster", "bitmask"]
      },
      use3d: {
        type: "boolean"
      },
      visible: {
        type: "boolean",
        description: "Determines whether this entire layer will be rendered in the spatial component."
      }
    }
  },
  moleculesLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the molecules layer.",
    additionalProperties: false,
    required: ["visible", "radius", "opacity"],
    properties: {
      visible: {
        type: "boolean"
      },
      radius: {
        type: "number"
      },
      opacity: {
        type: "number"
      }
    }
  },
  cellsLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the cells layer.",
    additionalProperties: false,
    required: ["visible", "stroked", "radius", "opacity"],
    properties: {
      visible: {
        type: "boolean"
      },
      stroked: {
        type: "boolean"
      },
      radius: {
        type: "number"
      },
      opacity: {
        type: "number"
      }
    }
  },
  neighborhoodsLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the neighborhoods layer.",
    additionalProperties: false,
    required: ["visible"],
    properties: {
      visible: {
        type: "boolean"
      }
    }
  },
  spatialRasterLayers: {
    type: "array",
    description: "Array of Spatial Layers",
    items: {
      $ref: "#/definitions/rasterLayer"
    }
  }
};
var additionalProperties7 = false;
var required7 = ["version", "name", "datasets", "layout", "initStrategy"];
var properties7 = {
  name: { type: "string" },
  public: { type: "boolean" },
  description: { type: "string" },
  datasets: {
    type: "array",
    description: "The datasets array defines groups of files, where the files within each dataset reference the same entities (cells, genes, cell sets, etc).",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["uid", "files"],
      properties: {
        uid: { type: "string" },
        name: { type: "string" },
        description: { type: "string" },
        files: {
          type: "array",
          items: {
            type: "object",
            additionalProperties: false,
            required: ["type", "fileType"],
            properties: {
              name: { type: "string" },
              type: { type: "string" },
              fileType: { type: "string" },
              url: { type: "string" },
              options: { oneOf: [{ $ref: "#/definitions/annDataCellSets" }, { $ref: "https://github.com/vitessce/vitessce/#raster" }, { $ref: "#/definitions/annDataCells" }, { $ref: "#/definitions/annDataExpressionMatrix" }] },
              requestInit: { $ref: "#/definitions/requestInit" }
            }
          }
        }
      }
    }
  },
  coordinationSpace: {
    type: "object",
    description: "The coordination space stores the values for each scope of each coordination object.",
    additionalProperties: false,
    required: [],
    properties: {
      dataset: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      embeddingZoom: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingRotation: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingTargetX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingTargetY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingTargetZ: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingType: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      embeddingCellSetPolygonsVisible: {
        type: "object",
        patternProperties: {
          ".": { type: "boolean" }
        }
      },
      embeddingCellSetLabelsVisible: {
        type: "object",
        patternProperties: {
          ".": { type: "boolean" }
        }
      },
      embeddingCellSetLabelSize: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingCellRadius: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      spatialZoom: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotation: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      spatialTargetX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialTargetY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialTargetZ: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationZ: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationOrbit: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialOrbitAxis: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "string" }
            ]
          }
        }
      },
      spatialAxisFixed: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "Whether or not to have a fixed axis for the camera. Only useful for 3D viewing."
              },
              { type: "boolean" }
            ]
          }
        }
      },
      spatialRasterLayers: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/spatialRasterLayers" }
            ]
          }
        }
      },
      spatialCellsLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/cellsLayer" }
            ]
          }
        }
      },
      spatialNeighborhoodsLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/neighborhoodsLayer" }
            ]
          }
        }
      },
      spatialMoleculesLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/moleculesLayer" }
            ]
          }
        }
      },
      heatmapZoomX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapZoomY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapTargetX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapTargetY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      cellFilter: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cells will be filtered out initially."
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      cellHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      cellSetSelection: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto cell set initialization is enabled, cell set selections will be automatically initialized."
              },
              { type: "array" }
            ]
          }
        }
      },
      cellSetHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell sets will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      cellSetColor: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, cell set colors will be automatically initialized."
              },
              {
                type: "array",
                items: {
                  type: "object",
                  additionalProperties: false,
                  required: ["path", "color"],
                  properties: {
                    path: {
                      type: "array",
                      items: { type: "string" }
                    },
                    color: {
                      type: "array",
                      items: { type: "number" }
                    }
                  }
                }
              }
            ]
          }
        }
      },
      cellColorEncoding: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      geneFilter: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no genes will be filtered out initially."
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      geneHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no genes will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      geneSelection: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null"
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      geneExpressionTransform: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null"
              },
              { type: "string", pattern: "log1p" }
            ]
          }
        }
      },
      geneExpressionColormap: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      geneExpressionColormapRange: {
        type: "object",
        patternProperties: {
          ".": { type: "array", items: { type: "number" } }
        }
      },
      genomicZoomX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicZoomY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicTargetX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicTargetY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      additionalCellSets: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell will be highlighted initially."
              },
              {
                $ref: "https://github.com/vitessce/vitessce/#cell-sets"
              }
            ]
          }
        }
      },
      moleculeHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no molecule will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      }
    }
  },
  layout: { $ref: "#/definitions/components" },
  initStrategy: {
    type: "string",
    enum: ["none", "auto"],
    description: "The initialization strategy determines how missing coordination objects and coordination scope mappings are initially filled in."
  },
  version: {
    type: "string",
    enum: ["1.0.3"],
    description: "The schema version for the view config."
  }
};
var config_1_0_3_schema_default = {
  $schema: $schema13,
  $id: $id13,
  title: title13,
  type: type13,
  definitions: definitions13,
  additionalProperties: additionalProperties7,
  required: required7,
  properties: properties7
};

// src/schemas/config-1.0.4.schema.json
var $schema14 = "http://json-schema.org/draft-07/schema#";
var $id14 = "https://github.com/vitessce/vitessce/#dataset";
var title14 = "Vitessce data set";
var type14 = "object";
var definitions14 = {
  components: {
    description: "The layout array defines the views, or components, rendered in the grid.",
    type: "array",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["component", "x", "y"],
      properties: {
        component: {
          type: "string",
          description: "Specify a component using a name defined in the component registry."
        },
        props: {
          type: "object",
          description: "Extra prop values for the component."
        },
        x: { type: "integer" },
        y: { type: "integer" },
        w: { type: "integer" },
        h: { type: "integer" },
        coordinationScopes: {
          type: "object",
          description: "Component-level coordination scope mappings define which coordination object values a particular component can read and write, for each coordination type.",
          additionalProperties: false,
          required: [],
          properties: {
            dataset: { type: "string" },
            embeddingType: { type: "string" },
            embeddingZoom: { type: "string" },
            embeddingRotation: { type: "string" },
            embeddingTargetX: { type: "string" },
            embeddingTargetY: { type: "string" },
            embeddingTargetZ: { type: "string" },
            embeddingCellSetPolygonsVisible: { type: "string" },
            embeddingCellSetLabelsVisible: { type: "string" },
            embeddingCellSetLabelSize: { type: "string" },
            embeddingCellRadius: { type: "string" },
            embeddingCellOpacity: { type: "string" },
            embeddingCellRadiusMode: { type: "string" },
            embeddingCellOpacityMode: { type: "string" },
            spatialZoom: { type: "string" },
            spatialRotation: { type: "string" },
            spatialTargetX: { type: "string" },
            spatialTargetY: { type: "string" },
            spatialTargetZ: { type: "string" },
            spatialRotationX: { type: "string" },
            spatialRotationY: { type: "string" },
            spatialRotationZ: { type: "string" },
            spatialRotationOrbit: { type: "string" },
            spatialOrbitAxis: { type: "string" },
            spatialAxisFixed: { type: "string" },
            heatmapZoomX: { type: "string" },
            heatmapZoomY: { type: "string" },
            heatmapTargetX: { type: "string" },
            heatmapTargetY: { type: "string" },
            cellFilter: { type: "string" },
            cellHighlight: { type: "string" },
            cellSetSelection: { type: "string" },
            cellSetHighlight: { type: "string" },
            cellSetColor: { type: "string" },
            geneFilter: { type: "string" },
            geneHighlight: { type: "string" },
            geneSelection: { type: "string" },
            geneExpressionTransform: { type: "string" },
            geneExpressionColormap: { type: "string" },
            geneExpressionColormapRange: { type: "string" },
            cellColorEncoding: { type: "string" },
            spatialRasterLayers: { type: "string" },
            spatialCellsLayer: { type: "string" },
            spatialMoleculesLayer: { type: "string" },
            spatialNeighborhoodsLayer: { type: "string" },
            genomicZoomX: { type: "string" },
            genomicZoomY: { type: "string" },
            genomicTargetX: { type: "string" },
            genomicTargetY: { type: "string" },
            additionalCellSets: { type: "string" },
            moleculeHighlight: { type: "string" }
          }
        }
      }
    }
  },
  annDataCellSets: {
    type: "array",
    description: "Array of cell set configuration, following closely the conventions of the tabular schema",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["groupName", "setName"],
      properties: {
        groupName: {
          type: "string",
          description: "The display name for the set, like 'Cell Type' or 'Louvain.'"
        },
        setName: {
          type: "string",
          description: "The location in the AnnData store for the set, like 'obs/louvain' or 'obs/celltype.'"
        }
      }
    }
  },
  annDataCells: {
    type: "object",
    description: "The properties of this object are the configuration for how to layout scatterplots and spatial information",
    minProperties: 1,
    additionalProperties: false,
    required: [],
    properties: {
      xy: {
        type: "string",
        description: "The location in the AnnData store of cell centroids, like 'obsm/X_centroids.'"
      },
      poly: {
        type: "string",
        description: "The location in the AnnData store of cell polygon outlines, like 'obsm/X_polygons.'"
      },
      factors: {
        type: "array",
        description: "List of locations in the AnnData store of cell sets, like 'obs/louvain'",
        items: {
          type: "string"
        }
      },
      mappings: {
        patternProperties: {
          ".": {
            type: "object",
            description: "An object containing key-values for mappings like { UMAP: { key: 'obsm/X_umap', dims: [0, 1] } }.",
            additionalProperties: false,
            required: ["key"],
            properties: {
              key: {
                type: "string",
                description: "Where to look in the AnnData store for this mapping, like 'obsm/X_umap.'"
              },
              dims: {
                type: "array",
                description: "Which indices of the obsm object to take for a scatterplot, allowing for, for example, different PCs from obsm/X_pca",
                minItems: 2,
                maxItems: 2,
                items: { type: "number" }
              }
            }
          }
        }
      }
    }
  },
  annDataExpressionMatrix: {
    type: "object",
    description: "The properties of this object are the configuration for how to fetch the cell x genes matrix",
    additionalProperties: false,
    required: ["matrix"],
    properties: {
      matrix: {
        type: "string",
        description: "The location in the AnnData store of the cell x gene matrix, like 'obsm/hvg_subset.' or 'X'"
      },
      geneFilter: {
        type: "string",
        description: "The location in the AnnData store of a filter for the genes if using a subset of the data, like 'var.highly_variable.' if the matrix comes from 'obsm/hvg_subset.'"
      },
      matrixGeneFilter: {
        type: "string",
        description: "The location in the AnnData store of a filter for the matrix data (used in heatmap and histogram), like 'var.highly_variable.''"
      }
    }
  },
  requestInit: {
    type: "object",
    description: "The properties of this object correspond to the parameters of the JavaScript fetch() function.",
    additionalProperties: false,
    required: [],
    properties: {
      method: {
        type: "string"
      },
      headers: {
        type: "object"
      },
      body: {
        type: "string"
      },
      mode: {
        type: "string"
      },
      credentials: {
        type: "string"
      },
      cache: {
        type: "string"
      },
      redirect: {
        type: "string"
      },
      referrer: {
        type: "string"
      },
      integrity: {
        type: "string"
      }
    }
  },
  rasterLayer: {
    description: "The properties of this object are the rendering settings for the raster layer.",
    additionalProperties: false,
    required: ["channels", "colormap", "index", "opacity"],
    properties: {
      channels: {
        type: "array",
        items: {
          type: "object",
          additionalProperties: false,
          required: ["selection"],
          properties: {
            color: {
              type: "array",
              items: { type: "number" },
              description: "The color to use when rendering this channel under the null colormap."
            },
            selection: {
              type: "object",
              description: "Determines the channel selection, e.g. some Z and time slice."
            },
            slider: {
              type: "array",
              items: { type: "number" },
              description: "Determines the range for color mapping."
            },
            visible: {
              type: "boolean",
              description: "Determines whether this channel of the layer will be rendered in the spatial component."
            }
          }
        }
      },
      colormap: {
        oneOf: [
          {
            type: "string",
            description: "The name of the colormap to use for this layer."
          },
          {
            type: "null",
            description: "Use the solid color definitions."
          }
        ]
      },
      transparentColor: {
        oneOf: [
          {
            type: "array",
            minItems: 3,
            maxItems: 3,
            items: {
              type: "number",
              description: "One of R G or B (0 - 255)."
            },
            description: "Determines the color to be set to opacity 0"
          },
          {
            type: "null",
            description: "No selection."
          }
        ]
      },
      index: {
        type: "number",
        description: "The index of the layer among the array of layers available in the image file."
      },
      opacity: {
        type: "number"
      },
      modelMatrix: {
        oneOf: [
          {
            type: "array",
            minItems: 16,
            maxItems: 16,
            description: "transformation matrix for this layer"
          },
          {
            type: "null",
            description: "Use no transformation."
          }
        ]
      },
      domainType: {
        type: "string",
        enum: ["Full", "Min/Max"],
        description: "Determines the extent of the channel slider input element in the layer controller."
      },
      resolution: {
        type: "number",
        description: "Resolution of 3D volumetric rendering"
      },
      xSlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      renderingMode: {
        type: "string",
        description: "Rendering mode of 3D volumetric rendering"
      },
      ySlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      zSlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      type: {
        type: "string",
        enum: ["raster", "bitmask"]
      },
      use3d: {
        type: "boolean"
      },
      visible: {
        type: "boolean",
        description: "Determines whether this entire layer will be rendered in the spatial component."
      }
    }
  },
  moleculesLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the molecules layer.",
    additionalProperties: false,
    required: ["visible", "radius", "opacity"],
    properties: {
      visible: {
        type: "boolean"
      },
      radius: {
        type: "number"
      },
      opacity: {
        type: "number"
      }
    }
  },
  cellsLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the cells layer.",
    additionalProperties: false,
    required: ["visible", "stroked", "radius", "opacity"],
    properties: {
      visible: {
        type: "boolean"
      },
      stroked: {
        type: "boolean"
      },
      radius: {
        type: "number"
      },
      opacity: {
        type: "number"
      }
    }
  },
  neighborhoodsLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the neighborhoods layer.",
    additionalProperties: false,
    required: ["visible"],
    properties: {
      visible: {
        type: "boolean"
      }
    }
  },
  spatialRasterLayers: {
    type: "array",
    description: "Array of Spatial Layers",
    items: {
      $ref: "#/definitions/rasterLayer"
    }
  }
};
var additionalProperties8 = false;
var required8 = ["version", "name", "datasets", "layout", "initStrategy"];
var properties8 = {
  name: { type: "string" },
  public: { type: "boolean" },
  description: { type: "string" },
  datasets: {
    type: "array",
    description: "The datasets array defines groups of files, where the files within each dataset reference the same entities (cells, genes, cell sets, etc).",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["uid", "files"],
      properties: {
        uid: { type: "string" },
        name: { type: "string" },
        description: { type: "string" },
        files: {
          type: "array",
          items: {
            type: "object",
            additionalProperties: false,
            required: ["type", "fileType"],
            properties: {
              name: { type: "string" },
              type: { type: "string" },
              fileType: { type: "string" },
              url: { type: "string" },
              options: { oneOf: [{ $ref: "#/definitions/annDataCellSets" }, { $ref: "https://github.com/vitessce/vitessce/#raster" }, { $ref: "#/definitions/annDataCells" }, { $ref: "#/definitions/annDataExpressionMatrix" }] },
              requestInit: { $ref: "#/definitions/requestInit" }
            }
          }
        }
      }
    }
  },
  coordinationSpace: {
    type: "object",
    description: "The coordination space stores the values for each scope of each coordination object.",
    additionalProperties: false,
    required: [],
    properties: {
      dataset: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      embeddingZoom: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingRotation: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingTargetX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingTargetY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingTargetZ: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingType: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      embeddingCellSetPolygonsVisible: {
        type: "object",
        patternProperties: {
          ".": { type: "boolean" }
        }
      },
      embeddingCellSetLabelsVisible: {
        type: "object",
        patternProperties: {
          ".": { type: "boolean" }
        }
      },
      embeddingCellSetLabelSize: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingCellRadius: {
        type: "object",
        patternProperties: {
          ".": {
            type: "number",
            description: "The cell radius value, used when embeddingCellRadiusMode is absolute or relative."
          }
        }
      },
      embeddingCellOpacity: {
        type: "object",
        patternProperties: {
          ".": {
            type: "number",
            description: "The cell opacity value, used when embeddingCellOpacityMode is static."
          }
        }
      },
      embeddingCellRadiusMode: {
        type: "object",
        patternProperties: {
          ".": {
            type: "string",
            enum: ["manual", "auto"],
            description: "Should data points representing cells be assigned a static (manual) or dynamic (auto, based on zoom level and data extent) radius?"
          }
        }
      },
      embeddingCellOpacityMode: {
        type: "object",
        patternProperties: {
          ".": {
            type: "string",
            enum: ["manual", "auto"],
            description: "Should data points representing cells be assigned a static (manual) or dynamic (auto, based on zoom level and data extent) opacity?"
          }
        }
      },
      spatialZoom: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotation: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      spatialTargetX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialTargetY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialTargetZ: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationZ: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationOrbit: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialOrbitAxis: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "string" }
            ]
          }
        }
      },
      spatialAxisFixed: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "Whether or not to have a fixed axis for the camera. Only useful for 3D viewing."
              },
              { type: "boolean" }
            ]
          }
        }
      },
      spatialRasterLayers: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/spatialRasterLayers" }
            ]
          }
        }
      },
      spatialCellsLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/cellsLayer" }
            ]
          }
        }
      },
      spatialNeighborhoodsLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/neighborhoodsLayer" }
            ]
          }
        }
      },
      spatialMoleculesLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/moleculesLayer" }
            ]
          }
        }
      },
      heatmapZoomX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapZoomY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapTargetX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapTargetY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      cellFilter: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cells will be filtered out initially."
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      cellHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      cellSetSelection: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto cell set initialization is enabled, cell set selections will be automatically initialized."
              },
              { type: "array" }
            ]
          }
        }
      },
      cellSetHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell sets will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      cellSetColor: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, cell set colors will be automatically initialized."
              },
              {
                type: "array",
                items: {
                  type: "object",
                  additionalProperties: false,
                  required: ["path", "color"],
                  properties: {
                    path: {
                      type: "array",
                      items: { type: "string" }
                    },
                    color: {
                      type: "array",
                      items: { type: "number" }
                    }
                  }
                }
              }
            ]
          }
        }
      },
      cellColorEncoding: {
        type: "object",
        patternProperties: {
          ".": {
            type: "string",
            enum: ["geneSelection", "cellSetSelection"],
            description: "How should data points representing cells be colored?"
          }
        }
      },
      geneFilter: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no genes will be filtered out initially."
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      geneHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no genes will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      geneSelection: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null"
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      geneExpressionTransform: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null"
              },
              { type: "string", pattern: "log1p" }
            ]
          }
        }
      },
      geneExpressionColormap: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      geneExpressionColormapRange: {
        type: "object",
        patternProperties: {
          ".": { type: "array", items: { type: "number" } }
        }
      },
      genomicZoomX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicZoomY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicTargetX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicTargetY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      additionalCellSets: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell will be highlighted initially."
              },
              {
                $ref: "https://github.com/vitessce/vitessce/#cell-sets"
              }
            ]
          }
        }
      },
      moleculeHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no molecule will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      }
    }
  },
  layout: { $ref: "#/definitions/components" },
  initStrategy: {
    type: "string",
    enum: ["none", "auto"],
    description: "The initialization strategy determines how missing coordination objects and coordination scope mappings are initially filled in."
  },
  version: {
    type: "string",
    enum: ["1.0.4"],
    description: "The schema version for the view config."
  }
};
var config_1_0_4_schema_default = {
  $schema: $schema14,
  $id: $id14,
  title: title14,
  type: type14,
  definitions: definitions14,
  additionalProperties: additionalProperties8,
  required: required8,
  properties: properties8
};

// src/schemas/config-1.0.5.schema.json
var $schema15 = "http://json-schema.org/draft-07/schema#";
var $id15 = "https://github.com/vitessce/vitessce/#dataset";
var title15 = "Vitessce data set";
var type15 = "object";
var definitions15 = {
  components: {
    description: "The layout array defines the views, or components, rendered in the grid.",
    type: "array",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["component", "x", "y"],
      properties: {
        component: {
          type: "string",
          description: "Specify a component using a name defined in the component registry."
        },
        props: {
          type: "object",
          description: "Extra prop values for the component."
        },
        x: { type: "integer" },
        y: { type: "integer" },
        w: { type: "integer" },
        h: { type: "integer" },
        coordinationScopes: {
          type: "object",
          description: "Component-level coordination scope mappings define which coordination object values a particular component can read and write, for each coordination type.",
          additionalProperties: false,
          required: [],
          properties: {
            dataset: { type: "string" },
            embeddingType: { type: "string" },
            embeddingZoom: { type: "string" },
            embeddingRotation: { type: "string" },
            embeddingTargetX: { type: "string" },
            embeddingTargetY: { type: "string" },
            embeddingTargetZ: { type: "string" },
            embeddingCellSetPolygonsVisible: { type: "string" },
            embeddingCellSetLabelsVisible: { type: "string" },
            embeddingCellSetLabelSize: { type: "string" },
            embeddingCellRadius: { type: "string" },
            embeddingCellOpacity: { type: "string" },
            embeddingCellRadiusMode: { type: "string" },
            embeddingCellOpacityMode: { type: "string" },
            spatialZoom: { type: "string" },
            spatialRotation: { type: "string" },
            spatialTargetX: { type: "string" },
            spatialTargetY: { type: "string" },
            spatialTargetZ: { type: "string" },
            spatialRotationX: { type: "string" },
            spatialRotationY: { type: "string" },
            spatialRotationZ: { type: "string" },
            spatialRotationOrbit: { type: "string" },
            spatialOrbitAxis: { type: "string" },
            spatialAxisFixed: { type: "string" },
            heatmapZoomX: { type: "string" },
            heatmapZoomY: { type: "string" },
            heatmapTargetX: { type: "string" },
            heatmapTargetY: { type: "string" },
            cellFilter: { type: "string" },
            cellHighlight: { type: "string" },
            cellSetSelection: { type: "string" },
            cellSetHighlight: { type: "string" },
            cellSetColor: { type: "string" },
            geneFilter: { type: "string" },
            geneHighlight: { type: "string" },
            geneSelection: { type: "string" },
            geneExpressionTransform: { type: "string" },
            geneExpressionColormap: { type: "string" },
            geneExpressionColormapRange: { type: "string" },
            cellColorEncoding: { type: "string" },
            spatialRasterLayers: { type: "string" },
            spatialCellsLayer: { type: "string" },
            spatialMoleculesLayer: { type: "string" },
            spatialNeighborhoodsLayer: { type: "string" },
            genomicZoomX: { type: "string" },
            genomicZoomY: { type: "string" },
            genomicTargetX: { type: "string" },
            genomicTargetY: { type: "string" },
            additionalCellSets: { type: "string" },
            moleculeHighlight: { type: "string" }
          }
        }
      }
    }
  },
  annDataCellSets: {
    type: "array",
    description: "Array of cell set configuration, following closely the conventions of the tabular schema",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["groupName", "setName"],
      properties: {
        groupName: {
          type: "string",
          description: "The display name for the set, like 'Cell Type' or 'Louvain.'"
        },
        setName: {
          oneOf: [
            {
              type: "string",
              description: "The location in the AnnData store for the set, like 'obs/louvain' or 'obs/celltype.'"
            },
            {
              type: "array",
              items: { type: "string" },
              description: "An array of locations in the AnnData store for a hierarchy of set names, from coarse to fine levels."
            }
          ]
        }
      }
    }
  },
  annDataCells: {
    type: "object",
    description: "The properties of this object are the configuration for how to layout scatterplots and spatial information",
    minProperties: 1,
    additionalProperties: false,
    required: [],
    properties: {
      xy: {
        type: "string",
        description: "The location in the AnnData store of cell centroids, like 'obsm/X_centroids.'"
      },
      poly: {
        type: "string",
        description: "The location in the AnnData store of cell polygon outlines, like 'obsm/X_polygons.'"
      },
      factors: {
        type: "array",
        description: "List of locations in the AnnData store of cell sets, like 'obs/louvain'",
        items: {
          type: "string"
        }
      },
      mappings: {
        patternProperties: {
          ".": {
            type: "object",
            description: "An object containing key-values for mappings like { UMAP: { key: 'obsm/X_umap', dims: [0, 1] } }.",
            additionalProperties: false,
            required: ["key"],
            properties: {
              key: {
                type: "string",
                description: "Where to look in the AnnData store for this mapping, like 'obsm/X_umap.'"
              },
              dims: {
                type: "array",
                description: "Which indices of the obsm object to take for a scatterplot, allowing for, for example, different PCs from obsm/X_pca",
                minItems: 2,
                maxItems: 2,
                items: { type: "number" }
              }
            }
          }
        }
      }
    }
  },
  annDataExpressionMatrix: {
    type: "object",
    description: "The properties of this object are the configuration for how to fetch the cell x genes matrix",
    additionalProperties: false,
    required: ["matrix"],
    properties: {
      matrix: {
        type: "string",
        description: "The location in the AnnData store of the cell x gene matrix, like 'obsm/hvg_subset.' or 'X'"
      },
      geneFilter: {
        type: "string",
        description: "The location in the AnnData store of a filter for the genes if using a subset of the data, like 'var.highly_variable.' if the matrix comes from 'obsm/hvg_subset.'"
      },
      matrixGeneFilter: {
        type: "string",
        description: "The location in the AnnData store of a filter for the matrix data (used in heatmap and histogram), like 'var.highly_variable.''"
      }
    }
  },
  requestInit: {
    type: "object",
    description: "The properties of this object correspond to the parameters of the JavaScript fetch() function.",
    additionalProperties: false,
    required: [],
    properties: {
      method: {
        type: "string"
      },
      headers: {
        type: "object"
      },
      body: {
        type: "string"
      },
      mode: {
        type: "string"
      },
      credentials: {
        type: "string"
      },
      cache: {
        type: "string"
      },
      redirect: {
        type: "string"
      },
      referrer: {
        type: "string"
      },
      integrity: {
        type: "string"
      }
    }
  },
  rasterLayer: {
    description: "The properties of this object are the rendering settings for the raster layer.",
    additionalProperties: false,
    required: ["channels", "colormap", "index", "opacity"],
    properties: {
      channels: {
        type: "array",
        items: {
          type: "object",
          additionalProperties: false,
          required: ["selection"],
          properties: {
            color: {
              type: "array",
              items: { type: "number" },
              description: "The color to use when rendering this channel under the null colormap."
            },
            selection: {
              type: "object",
              description: "Determines the channel selection, e.g. some Z and time slice."
            },
            slider: {
              type: "array",
              items: { type: "number" },
              description: "Determines the range for color mapping."
            },
            visible: {
              type: "boolean",
              description: "Determines whether this channel of the layer will be rendered in the spatial component."
            }
          }
        }
      },
      colormap: {
        oneOf: [
          {
            type: "string",
            description: "The name of the colormap to use for this layer."
          },
          {
            type: "null",
            description: "Use the solid color definitions."
          }
        ]
      },
      transparentColor: {
        oneOf: [
          {
            type: "array",
            minItems: 3,
            maxItems: 3,
            items: {
              type: "number",
              description: "One of R G or B (0 - 255)."
            },
            description: "Determines the color to be set to opacity 0"
          },
          {
            type: "null",
            description: "No selection."
          }
        ]
      },
      index: {
        type: "number",
        description: "The index of the layer among the array of layers available in the image file."
      },
      opacity: {
        type: "number"
      },
      modelMatrix: {
        oneOf: [
          {
            type: "array",
            minItems: 16,
            maxItems: 16,
            description: "transformation matrix for this layer"
          },
          {
            type: "null",
            description: "Use no transformation."
          }
        ]
      },
      domainType: {
        type: "string",
        enum: ["Full", "Min/Max"],
        description: "Determines the extent of the channel slider input element in the layer controller."
      },
      resolution: {
        type: "number",
        description: "Resolution of 3D volumetric rendering"
      },
      xSlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      renderingMode: {
        type: "string",
        description: "Rendering mode of 3D volumetric rendering"
      },
      ySlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      zSlice: {
        oneOf: [
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            description: "Slice bounds"
          },
          {
            type: "null",
            description: "No slicing"
          }
        ]
      },
      type: {
        type: "string",
        enum: ["raster", "bitmask"]
      },
      use3d: {
        type: "boolean"
      },
      visible: {
        type: "boolean",
        description: "Determines whether this entire layer will be rendered in the spatial component."
      }
    }
  },
  moleculesLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the molecules layer.",
    additionalProperties: false,
    required: ["visible", "radius", "opacity"],
    properties: {
      visible: {
        type: "boolean"
      },
      radius: {
        type: "number"
      },
      opacity: {
        type: "number"
      }
    }
  },
  cellsLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the cells layer.",
    additionalProperties: false,
    required: ["visible", "stroked", "radius", "opacity"],
    properties: {
      visible: {
        type: "boolean"
      },
      stroked: {
        type: "boolean"
      },
      radius: {
        type: "number"
      },
      opacity: {
        type: "number"
      }
    }
  },
  neighborhoodsLayer: {
    type: "object",
    description: "The properties of this object are the rendering settings for the neighborhoods layer.",
    additionalProperties: false,
    required: ["visible"],
    properties: {
      visible: {
        type: "boolean"
      }
    }
  },
  spatialRasterLayers: {
    type: "array",
    description: "Array of Spatial Layers",
    items: {
      $ref: "#/definitions/rasterLayer"
    }
  }
};
var additionalProperties9 = false;
var required9 = ["version", "name", "datasets", "layout", "initStrategy"];
var properties9 = {
  name: { type: "string" },
  public: { type: "boolean" },
  description: { type: "string" },
  datasets: {
    type: "array",
    description: "The datasets array defines groups of files, where the files within each dataset reference the same entities (cells, genes, cell sets, etc).",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["uid", "files"],
      properties: {
        uid: { type: "string" },
        name: { type: "string" },
        description: { type: "string" },
        files: {
          type: "array",
          items: {
            type: "object",
            additionalProperties: false,
            required: ["type", "fileType"],
            properties: {
              name: { type: "string" },
              type: { type: "string" },
              fileType: { type: "string" },
              url: { type: "string" },
              options: { oneOf: [{ $ref: "#/definitions/annDataCellSets" }, { $ref: "https://github.com/vitessce/vitessce/#raster" }, { $ref: "#/definitions/annDataCells" }, { $ref: "#/definitions/annDataExpressionMatrix" }] },
              requestInit: { $ref: "#/definitions/requestInit" }
            }
          }
        }
      }
    }
  },
  coordinationSpace: {
    type: "object",
    description: "The coordination space stores the values for each scope of each coordination object.",
    additionalProperties: false,
    required: [],
    properties: {
      dataset: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      embeddingZoom: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingRotation: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingTargetX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingTargetY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      embeddingTargetZ: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingType: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      embeddingCellSetPolygonsVisible: {
        type: "object",
        patternProperties: {
          ".": { type: "boolean" }
        }
      },
      embeddingCellSetLabelsVisible: {
        type: "object",
        patternProperties: {
          ".": { type: "boolean" }
        }
      },
      embeddingCellSetLabelSize: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      embeddingCellRadius: {
        type: "object",
        patternProperties: {
          ".": {
            type: "number",
            description: "The cell radius value, used when embeddingCellRadiusMode is absolute or relative."
          }
        }
      },
      embeddingCellOpacity: {
        type: "object",
        patternProperties: {
          ".": {
            type: "number",
            description: "The cell opacity value, used when embeddingCellOpacityMode is static."
          }
        }
      },
      embeddingCellRadiusMode: {
        type: "object",
        patternProperties: {
          ".": {
            type: "string",
            enum: ["manual", "auto"],
            description: "Should data points representing cells be assigned a static (manual) or dynamic (auto, based on zoom level and data extent) radius?"
          }
        }
      },
      embeddingCellOpacityMode: {
        type: "object",
        patternProperties: {
          ".": {
            type: "string",
            enum: ["manual", "auto"],
            description: "Should data points representing cells be assigned a static (manual) or dynamic (auto, based on zoom level and data extent) opacity?"
          }
        }
      },
      spatialZoom: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotation: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      spatialTargetX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialTargetY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialTargetZ: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationX: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationY: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationZ: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialRotationOrbit: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "number" }
            ]
          }
        }
      },
      spatialOrbitAxis: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, value will be automatically set. Only useful for 3D viewing."
              },
              { type: "string" }
            ]
          }
        }
      },
      spatialAxisFixed: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "Whether or not to have a fixed axis for the camera. Only useful for 3D viewing."
              },
              { type: "boolean" }
            ]
          }
        }
      },
      spatialRasterLayers: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/spatialRasterLayers" }
            ]
          }
        }
      },
      spatialCellsLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/cellsLayer" }
            ]
          }
        }
      },
      spatialNeighborhoodsLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/neighborhoodsLayer" }
            ]
          }
        }
      },
      spatialMoleculesLayer: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto layer initialization is enabled, layers will be automatically initialized."
              },
              { $ref: "#/definitions/moleculesLayer" }
            ]
          }
        }
      },
      heatmapZoomX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapZoomY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapTargetX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      heatmapTargetY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      cellFilter: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cells will be filtered out initially."
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      cellHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      cellSetSelection: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided and auto cell set initialization is enabled, cell set selections will be automatically initialized."
              },
              { type: "array" }
            ]
          }
        }
      },
      cellSetHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell sets will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      cellSetColor: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, cell set colors will be automatically initialized."
              },
              {
                type: "array",
                items: {
                  type: "object",
                  additionalProperties: false,
                  required: ["path", "color"],
                  properties: {
                    path: {
                      type: "array",
                      items: { type: "string" }
                    },
                    color: {
                      type: "array",
                      items: { type: "number" }
                    }
                  }
                }
              }
            ]
          }
        }
      },
      cellColorEncoding: {
        type: "object",
        patternProperties: {
          ".": {
            type: "string",
            enum: ["geneSelection", "cellSetSelection"],
            description: "How should data points representing cells be colored?"
          }
        }
      },
      geneFilter: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no genes will be filtered out initially."
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      geneHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no genes will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      },
      geneSelection: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null"
              },
              { type: "array", items: { type: "string" } }
            ]
          }
        }
      },
      geneExpressionTransform: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null"
              },
              { type: "string", pattern: "log1p" }
            ]
          }
        }
      },
      geneExpressionColormap: {
        type: "object",
        patternProperties: {
          ".": { type: "string" }
        }
      },
      geneExpressionColormapRange: {
        type: "object",
        patternProperties: {
          ".": { type: "array", items: { type: "number" } }
        }
      },
      genomicZoomX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicZoomY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicTargetX: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      genomicTargetY: {
        type: "object",
        patternProperties: {
          ".": { type: "number" }
        }
      },
      additionalCellSets: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no cell will be highlighted initially."
              },
              {
                $ref: "https://github.com/vitessce/vitessce/#cell-sets"
              }
            ]
          }
        }
      },
      moleculeHighlight: {
        type: "object",
        patternProperties: {
          ".": {
            oneOf: [
              {
                type: "null",
                description: "If null is provided, no molecule will be highlighted initially."
              },
              { type: "string" }
            ]
          }
        }
      }
    }
  },
  layout: { $ref: "#/definitions/components" },
  initStrategy: {
    type: "string",
    enum: ["none", "auto"],
    description: "The initialization strategy determines how missing coordination objects and coordination scope mappings are initially filled in."
  },
  version: {
    type: "string",
    enum: ["1.0.5"],
    description: "The schema version for the view config."
  }
};
var config_1_0_5_schema_default = {
  $schema: $schema15,
  $id: $id15,
  title: title15,
  type: type15,
  definitions: definitions15,
  additionalProperties: additionalProperties9,
  required: required9,
  properties: properties9
};

// src/app/view-config-upgraders.js
import uuidv44 from "uuid/v4";
import cloneDeep from "lodash/cloneDeep";
function upgradeReplaceViewProp(prefix, view, coordinationSpace) {
  const prevZScopes = Object.keys(coordinationSpace[`${prefix}Zoom`]);
  const prevTXScopes = Object.keys(coordinationSpace[`${prefix}TargetX`]);
  const prevTYScopes = Object.keys(coordinationSpace[`${prefix}TargetY`]);
  const nextZScope = getNextScope(prevZScopes);
  const nextTXScope = getNextScope(prevTXScopes);
  const nextTYScope = getNextScope(prevTYScopes);
  const { zoom, target: [targetX, targetY] } = view;
  coordinationSpace[`${prefix}Zoom`][nextZScope] = zoom;
  coordinationSpace[`${prefix}TargetX`][nextTXScope] = targetX;
  coordinationSpace[`${prefix}TargetY`][nextTYScope] = targetY;
  return {
    [`${prefix}Zoom`]: nextZScope,
    [`${prefix}TargetX`]: nextTXScope,
    [`${prefix}TargetY`]: nextTYScope
  };
}
function upgradeFrom0_1_0(config, datasetUid = null) {
  const coordinationSpace = {
    embeddingType: {},
    embeddingZoom: {},
    embeddingTargetX: {},
    embeddingTargetY: {},
    spatialZoom: {},
    spatialTargetX: {},
    spatialTargetY: {}
  };
  const layout = [];
  config.staticLayout.forEach((componentDef) => {
    var _a2;
    let newComponentDef = __spreadProps(__spreadValues({}, componentDef), {
      coordinationScopes: {}
    });
    if (componentDef.component === "scatterplot") {
      if (componentDef.props.mapping) {
        coordinationSpace.embeddingType[componentDef.props.mapping] = componentDef.props.mapping;
        newComponentDef = __spreadProps(__spreadValues({}, newComponentDef), {
          coordinationScopes: __spreadProps(__spreadValues({}, newComponentDef.coordinationScopes), {
            embeddingType: componentDef.props.mapping
          })
        });
      }
      if (componentDef.props.view) {
        const newScopeValues = upgradeReplaceViewProp("embedding", componentDef.props.view, coordinationSpace);
        newComponentDef = __spreadProps(__spreadValues({}, newComponentDef), {
          coordinationScopes: __spreadValues(__spreadValues({}, newComponentDef.coordinationScopes), newScopeValues)
        });
      }
    }
    if (componentDef.component === "spatial") {
      if ((_a2 = componentDef == null ? void 0 : componentDef.props) == null ? void 0 : _a2.view) {
        const newScopeValues = upgradeReplaceViewProp("spatial", componentDef.props.view, coordinationSpace);
        newComponentDef = __spreadProps(__spreadValues({}, newComponentDef), {
          coordinationScopes: __spreadValues(__spreadValues({}, newComponentDef.coordinationScopes), newScopeValues)
        });
      }
    }
    layout.push(newComponentDef);
  });
  const newDatasetUid = datasetUid || uuidv44();
  return {
    version: "1.0.1",
    name: config.name,
    description: config.description,
    public: config.public,
    datasets: [
      {
        uid: newDatasetUid,
        name: newDatasetUid,
        files: config.layers.map((layer) => ({
          type: layer.type.toLowerCase(),
          fileType: layer.fileType,
          url: layer.url
        }))
      }
    ],
    initStrategy: "auto",
    coordinationSpace,
    layout
  };
}
function upgradeFrom1_0_0(config) {
  const coordinationSpace = __spreadValues({}, config.coordinationSpace);
  function replaceLayerType(layerType) {
    const isRaster = layerType === "raster";
    coordinationSpace[`spatial${capitalize(layerType)}Layer${isRaster ? "s" : ""}`] = {};
    Object.entries(coordinationSpace.spatialLayers).forEach(([scope, layers]) => {
      if (Array.isArray(layers) && layers.find((layer) => layer.type === layerType)) {
        const typedLayers = layers.filter((layer) => layer.type === layerType).map((layer) => {
          const newLayer = __spreadValues({}, layer);
          delete newLayer.type;
          return newLayer;
        });
        coordinationSpace[`spatial${capitalize(layerType)}Layer${isRaster ? "s" : ""}`][scope] = isRaster ? typedLayers : typedLayers[0];
      } else {
        coordinationSpace[`spatial${capitalize(layerType)}Layer${isRaster ? "s" : ""}`][scope] = null;
      }
    });
  }
  if (coordinationSpace.spatialLayers) {
    replaceLayerType("raster");
    replaceLayerType("cells");
    replaceLayerType("molecules");
    replaceLayerType("neighborhoods");
    delete coordinationSpace.spatialLayers;
  }
  const layout = config.layout.map((component) => {
    const newComponent = __spreadValues({}, component);
    function replaceCoordinationScope(layerType) {
      const isRaster = layerType === "raster";
      if (COMPONENT_COORDINATION_TYPES[newComponent.component].includes(`spatial${capitalize(layerType)}Layer${isRaster ? "s" : ""}`)) {
        newComponent.coordinationScopes[`spatial${capitalize(layerType)}Layer${isRaster ? "s" : ""}`] = newComponent.coordinationScopes.spatialLayers;
      }
    }
    if (newComponent.coordinationScopes && newComponent.coordinationScopes.spatialLayers) {
      replaceCoordinationScope("raster");
      replaceCoordinationScope("cells");
      replaceCoordinationScope("molecules");
      replaceCoordinationScope("neighborhoods");
      delete newComponent.coordinationScopes.spatialLayers;
    }
    return newComponent;
  });
  return __spreadProps(__spreadValues({}, config), {
    coordinationSpace,
    layout,
    version: "1.0.1"
  });
}
function upgradeFrom1_0_1(config) {
  var _a2;
  const layout = config.layout.map((component) => {
    const newComponent = __spreadValues({}, component);
    if (newComponent.component === "layerController") {
      newComponent.props = __spreadProps(__spreadValues({}, newComponent.props), {
        globalDisable3d: true
      });
    }
    return newComponent;
  });
  const newConfig = cloneDeep(config);
  Object.keys(((_a2 = newConfig == null ? void 0 : newConfig.coordinationSpace) == null ? void 0 : _a2.spatialRasterLayers) || {}).forEach((key) => {
    if (newConfig.coordinationSpace.spatialRasterLayers[key]) {
      newConfig.coordinationSpace.spatialRasterLayers[key].forEach((layer, index) => {
        newConfig.coordinationSpace.spatialRasterLayers[key][index].type = ["bitmask", "raster"].includes(layer.type) ? layer.type : "raster";
      });
    }
  });
  return __spreadProps(__spreadValues({}, newConfig), {
    layout,
    version: "1.0.2"
  });
}
function upgradeFrom1_0_2(config) {
  const layout = config.layout.map((component) => {
    const newComponent = __spreadValues({}, component);
    if (newComponent.component === "layerController") {
      newComponent.props = __spreadProps(__spreadValues({}, newComponent.props), {
        disableChannelsIfRgbDetected: true
      });
    }
    return newComponent;
  });
  const newConfig = cloneDeep(config);
  return __spreadProps(__spreadValues({}, newConfig), {
    layout,
    version: "1.0.3"
  });
}
function upgradeFrom1_0_3(config) {
  const newConfig = cloneDeep(config);
  return __spreadProps(__spreadValues({}, newConfig), {
    version: "1.0.4"
  });
}
function upgradeFrom1_0_4(config) {
  const newConfig = cloneDeep(config);
  return __spreadProps(__spreadValues({}, newConfig), {
    version: "1.0.5"
  });
}

// src/app/view-config-versions.js
var LATEST_VERSION = "1.0.5";
var SCHEMA_HANDLERS = {
  "0.1.0": [new Ajv3().compile(config_0_1_0_schema_default), upgradeFrom0_1_0],
  "1.0.0": [new Ajv3().addSchema(cell_sets_schema_default).addSchema(raster_schema_default).compile(config_1_0_0_schema_default), upgradeFrom1_0_0],
  "1.0.1": [new Ajv3().addSchema(cell_sets_schema_default).addSchema(raster_schema_default).compile(config_1_0_1_schema_default), upgradeFrom1_0_1],
  "1.0.2": [new Ajv3().addSchema(cell_sets_schema_default).addSchema(raster_schema_default).compile(config_1_0_2_schema_default), upgradeFrom1_0_2],
  "1.0.3": [new Ajv3().addSchema(cell_sets_schema_default).addSchema(raster_schema_default).compile(config_1_0_3_schema_default), upgradeFrom1_0_3],
  "1.0.4": [new Ajv3().addSchema(cell_sets_schema_default).addSchema(raster_schema_default).compile(config_1_0_4_schema_default), upgradeFrom1_0_4],
  "1.0.5": [new Ajv3().addSchema(cell_sets_schema_default).addSchema(raster_schema_default).compile(config_1_0_5_schema_default), null]
};

// src/app/CallbackPublisher.js
function validateViewConfig(viewConfig) {
  try {
    const validate = SCHEMA_HANDLERS[LATEST_VERSION][0];
    const valid = validate(viewConfig);
    if (!valid) {
      const failureReason = JSON.stringify(validate.errors, null, 2);
      throw new Error(`Config validation failed: ${failureReason}`);
    }
  } catch (e) {
    console.error(e);
  }
}
function CallbackPublisher(props) {
  const {
    onWarn,
    onConfigChange,
    onLoaderChange,
    validateOnConfigChange
  } = props;
  const warning = useWarning();
  const loaders = useLoaders();
  const viewConfigStoreApi = useViewConfigStoreApi();
  useEffect10(() => viewConfigStoreApi.subscribe((viewConfig) => {
    if (validateOnConfigChange && viewConfig) {
      validateViewConfig(viewConfig);
    }
    if (onConfigChange && viewConfig) {
      onConfigChange(viewConfig);
    }
  }, (state) => state.viewConfig), [onConfigChange, validateOnConfigChange, viewConfigStoreApi]);
  useEffect10(() => {
    if (onWarn && warning) {
      onWarn(warning);
    }
  }, [warning, onWarn]);
  useEffect10(() => {
    if (onLoaderChange && loaders) {
      onLoaderChange(loaders);
    }
  }, [loaders, onLoaderChange]);
  return null;
}

// src/components/description/DescriptionSubscriber.js
import React34, { useEffect as useEffect11, useMemo as useMemo8 } from "react";

// src/components/description/Description.js
import React33 from "react";
function Description(props) {
  const { description: description2, metadata } = props;
  return /* @__PURE__ */ React33.createElement("div", {
    className: "description"
  }, /* @__PURE__ */ React33.createElement("p", null, description2), metadata && Array.from(metadata.entries()).map(([layerIndex, { name: layerName, metadata: metadataRecord }]) => metadataRecord && Object.entries(metadataRecord).length > 0 ? /* @__PURE__ */ React33.createElement("details", {
    key: layerIndex
  }, /* @__PURE__ */ React33.createElement("summary", null, layerName), /* @__PURE__ */ React33.createElement("div", {
    className: "metadata-container"
  }, /* @__PURE__ */ React33.createElement("table", null, /* @__PURE__ */ React33.createElement("tbody", null, Object.entries(metadataRecord).map(([key, value]) => /* @__PURE__ */ React33.createElement("tr", {
    key
  }, /* @__PURE__ */ React33.createElement("th", {
    title: key
  }, key), /* @__PURE__ */ React33.createElement("td", {
    title: value
  }, value))))))) : null));
}

// src/components/description/DescriptionSubscriber.js
var DESCRIPTION_DATA_TYPES = ["raster"];
function DescriptionSubscriber(props) {
  const {
    coordinationScopes,
    description: descriptionOverride,
    removeGridComponent,
    theme,
    title: title16 = "Data Set"
  } = props;
  const loaders = useLoaders();
  const [{
    dataset,
    spatialRasterLayers: rasterLayers
  }] = useCoordination(COMPONENT_COORDINATION_TYPES.description, coordinationScopes);
  const [
    isReady,
    setItemIsReady,
    setItemIsNotReady,
    resetReadyItems
  ] = useReady(DESCRIPTION_DATA_TYPES);
  useEffect11(() => {
    resetReadyItems();
  }, [loaders, dataset]);
  const [description2] = useDescription(loaders, dataset);
  const [raster, imageLayerLoaders, imageLayerMeta] = useRasterData(loaders, dataset, setItemIsReady, () => {
  }, false);
  const metadata = useMemo8(() => {
    const result = new Map();
    if (rasterLayers && rasterLayers.length > 0 && raster && imageLayerMeta && imageLayerLoaders) {
      rasterLayers.forEach((layer) => {
        if (imageLayerMeta[layer.index]) {
          const { format } = imageLayerLoaders[layer.index].metadata;
          result.set(`${layer.index}`, {
            name: raster.meta[layer.index].name,
            metadata: format && format()
          });
        }
      });
    }
    return result;
  }, [raster, rasterLayers, imageLayerMeta, imageLayerLoaders]);
  return /* @__PURE__ */ React34.createElement(TitleInfo, {
    title: title16,
    removeGridComponent,
    isScroll: true,
    theme,
    isReady
  }, /* @__PURE__ */ React34.createElement(Description, {
    description: descriptionOverride || description2,
    metadata
  }));
}

// src/components/status/StatusSubscriber.js
import React36 from "react";

// src/components/status/Status.js
import React35 from "react";
function Status(props) {
  const warnClass = "alert alert-warning my-0 details";
  const { info, warn: warn2 } = props;
  const messages = [];
  if (info) {
    messages.push(/* @__PURE__ */ React35.createElement("p", {
      className: "details",
      key: "info"
    }, info));
  }
  if (warn2) {
    messages.push(/* @__PURE__ */ React35.createElement("p", {
      className: warnClass,
      key: "warn"
    }, warn2));
  }
  return messages;
}

// src/components/status/StatusSubscriber.js
function StatusSubscriber(props) {
  const {
    coordinationScopes,
    removeGridComponent,
    theme,
    title: title16 = "Status"
  } = props;
  const [{
    cellHighlight,
    geneHighlight,
    moleculeHighlight
  }] = useCoordination(COMPONENT_COORDINATION_TYPES.status, coordinationScopes);
  const warn2 = useWarning();
  const infos = [
    ...cellHighlight ? [`Hovered cell ${cellHighlight}`] : [],
    ...geneHighlight ? [`Hovered gene ${geneHighlight}`] : [],
    ...moleculeHighlight ? [`Hovered gene ${moleculeHighlight}`] : []
  ];
  const info = infos.join("; ");
  return /* @__PURE__ */ React36.createElement(TitleInfo, {
    title: title16,
    theme,
    removeGridComponent,
    isScroll: true,
    isReady: true
  }, /* @__PURE__ */ React36.createElement(Status, {
    warn: warn2,
    info
  }));
}

// src/components/genes/GenesSubscriber.js
import React39, { useEffect as useEffect14 } from "react";

// src/components/genes/Genes.js
import React38, { useEffect as useEffect13, useState as useState11 } from "react";

// src/components/selectable-table/SelectableTable.js
import React37, { useEffect as useEffect12, useCallback as useCallback10, useState as useState10 } from "react";
import { Table as Table2, AutoSizer } from "react-virtualized";
import uuidv45 from "uuid/v4";
import union from "lodash/union";
import difference from "lodash/difference";
import isEqual8 from "lodash/isEqual";
function SelectableTable(props) {
  const {
    hasColorEncoding,
    columns,
    data,
    onChange,
    idKey = "id",
    valueKey = "value",
    allowMultiple = false,
    allowUncheck = false,
    showTableHead = true,
    showTableInputs = false,
    testHeight = void 0,
    testWidth = void 0
  } = props;
  const [selectedRows, setSelectedRows] = useState10(null);
  const onSelectRow = useCallback10((value, checked) => {
    if (checked || allowUncheck) {
      if (!allowMultiple) {
        setSelectedRows(checked ? [value] : []);
      } else {
        setSelectedRows(checked ? union(selectedRows || [], [value]) : difference(selectedRows || [], [value]));
      }
    }
  }, [allowMultiple, allowUncheck, selectedRows]);
  const handleInputChange = useCallback10((event) => {
    const { target } = event;
    const { checked } = target;
    const { value } = target;
    onSelectRow(value, checked);
  }, [onSelectRow]);
  const getDataFromIds = useCallback10((ids) => ids.map((id) => ({
    [idKey]: id,
    data: data.find((item) => item[idKey] === id)
  })), [data, idKey]);
  const isSelected = useCallback10((id) => Array.isArray(selectedRows) && selectedRows.includes(id), [selectedRows]);
  useEffect12(() => {
    const initialSelectedRows = data.map((d) => {
      if (d[valueKey]) {
        return d[idKey];
      }
      return null;
    }).filter(Boolean);
    if (!isEqual8(initialSelectedRows, selectedRows)) {
      if (initialSelectedRows.length > 0) {
        setSelectedRows(initialSelectedRows);
      } else {
        setSelectedRows(null);
      }
    }
  }, [data, idKey, valueKey]);
  useEffect12(() => {
    if (!onChange || !selectedRows) {
      return;
    }
    const selectedRowData = getDataFromIds(selectedRows);
    if (allowMultiple) {
      onChange(selectedRowData);
    } else if (selectedRows.length === 1) {
      onChange(selectedRowData[0]);
    } else if (selectedRows.length === 0) {
      onChange(null);
    }
  }, [selectedRows]);
  const inputUuid = uuidv45();
  const hiddenInputsClass = showTableInputs ? "" : "hidden-input-column";
  const rowRenderer = ({ index, style }) => /* @__PURE__ */ React37.createElement("div", {
    key: data[index][idKey],
    className: `table-item table-row ${isSelected(data[index][idKey]) ? "row-checked " : ""}`,
    style,
    role: "button",
    onClick: () => onSelectRow(data[index][idKey], !isSelected(data[index][idKey]) || !hasColorEncoding)
  }, /* @__PURE__ */ React37.createElement("div", {
    className: `input-container ${hiddenInputsClass} table-cell`
  }, /* @__PURE__ */ React37.createElement("label", {
    htmlFor: `${inputUuid}_${data[index][idKey]}`
  }, /* @__PURE__ */ React37.createElement("input", {
    id: `${inputUuid}_${data[index][idKey]}`,
    type: "checkbox",
    className: allowMultiple ? "checkbox" : "radio",
    name: inputUuid,
    value: data[index][idKey],
    onChange: handleInputChange,
    checked: isSelected(data[index][idKey])
  }))), columns.map((column) => /* @__PURE__ */ React37.createElement("div", {
    className: "table-cell",
    key: column
  }, data[index][column])));
  const headerRowRenderer = ({ style }) => /* @__PURE__ */ React37.createElement("div", {
    className: `${hiddenInputsClass} table-row`,
    style
  }, columns.map((column) => /* @__PURE__ */ React37.createElement("div", {
    key: column
  }, column)));
  return /* @__PURE__ */ React37.createElement("div", {
    className: "selectable-table"
  }, /* @__PURE__ */ React37.createElement(AutoSizer, null, ({ width, height }) => /* @__PURE__ */ React37.createElement(Table2, {
    height: testHeight || height,
    gridStyle: { outline: "none" },
    rowCount: data.length,
    rowHeight: 24,
    headerHeight: showTableHead ? 24 : void 0,
    rowRenderer,
    width: testWidth || width,
    headerRowRenderer: showTableHead ? headerRowRenderer : void 0,
    rowGetter: ({ index }) => data[index]
  })));
}

// src/components/genes/Genes.js
function Genes(props) {
  const {
    hasColorEncoding,
    geneList = [],
    geneSelection = [],
    geneFilter = null,
    setGeneSelection
  } = props;
  const [searchTerm, setSearchTerm] = useState11("");
  const [searchResults, setSearchResults] = useState11(geneList);
  useEffect13(() => {
    const results = geneList.filter((gene) => gene.toLowerCase().includes(searchTerm.toLowerCase()));
    setSearchResults(results);
  }, [searchTerm, geneList]);
  function onChange(selection) {
    if (setGeneSelection && selection && selection.name) {
      setGeneSelection([selection.name]);
    }
  }
  const data = searchResults.filter((gene) => geneFilter ? geneFilter.includes(gene) : true).sort((a, b) => a.localeCompare(b)).map((gene) => ({ name: gene, value: geneSelection ? geneSelection.includes(gene) : false }));
  const handleChange = (event) => {
    setSearchTerm(event.target.value);
  };
  return /* @__PURE__ */ React38.createElement(React38.Fragment, null, /* @__PURE__ */ React38.createElement("input", {
    className: "search-bar",
    type: "text",
    placeholder: "Search",
    value: searchTerm,
    onChange: handleChange
  }), /* @__PURE__ */ React38.createElement(SelectableTable, {
    columns: ["name"],
    data,
    hasColorEncoding,
    idKey: "name",
    valueKey: "value",
    onChange,
    allowUncheck: false,
    showTableHead: false
  }));
}

// src/components/genes/GenesSubscriber.js
var GENES_DATA_TYPES = ["expression-matrix"];
function GenesSubscriber(props) {
  const {
    coordinationScopes,
    removeGridComponent,
    variablesLabelOverride: variablesLabel = "gene",
    variablesPluralLabelOverride: variablesPluralLabel = `${variablesLabel}s`,
    theme,
    title: title16 = "Expression Levels"
  } = props;
  const loaders = useLoaders();
  const [{
    dataset,
    geneSelection,
    geneFilter,
    cellColorEncoding
  }, {
    setGeneSelection,
    setGeneFilter,
    setGeneHighlight,
    setCellColorEncoding
  }] = useCoordination(COMPONENT_COORDINATION_TYPES.genes, coordinationScopes);
  const [urls, addUrl, resetUrls] = useUrls();
  const [
    isReady,
    setItemIsReady,
    setItemIsNotReady,
    resetReadyItems
  ] = useReady(GENES_DATA_TYPES);
  useEffect14(() => {
    resetUrls();
    resetReadyItems();
  }, [loaders, dataset]);
  const [attrs] = useExpressionAttrs(loaders, dataset, setItemIsReady, addUrl, true);
  const geneList = attrs ? attrs.cols : [];
  const numGenes = geneList.length;
  function setGeneSelectionAndColorEncoding(newSelection) {
    setGeneSelection(newSelection);
    setCellColorEncoding("geneSelection");
  }
  return /* @__PURE__ */ React39.createElement(TitleInfo, {
    title: title16,
    info: `${numGenes} ${pluralize(variablesLabel, variablesPluralLabel, numGenes)}`,
    theme,
    isScroll: true,
    removeGridComponent,
    isReady,
    urls
  }, /* @__PURE__ */ React39.createElement(Genes, {
    hasColorEncoding: cellColorEncoding === "geneSelection",
    geneList,
    geneSelection,
    geneFilter,
    setGeneSelection: setGeneSelectionAndColorEncoding,
    setGeneFilter,
    setGeneHighlight
  }));
}

// src/components/sets/CellSetsManagerSubscriber.js
import React51, {
  useEffect as useEffect16,
  useState as useState15,
  useMemo as useMemo10
} from "react";
import isEqual11 from "lodash/isEqual";

// package.json
var name = "vitessce";
var version = "1.1.17";
var description = "Vitessce app and React component library";
var author = "C McCallum";
var homepage = "http://vitessce.io/";
var license = "MIT";
var repository = "https://github.com/vitessce/vitessce/";
var keywords = [
  "react-component"
];
var files = [
  "dist",
  "src"
];
var main = "dist/umd/production/index.min.js";
var module = "dist/esm/index.js";
var peerDependencies = {
  react: "^16.8.6",
  "react-dom": "^16.8.6"
};
var dependencies = {
  "@hms-dbmi/viv": "^0.11.0",
  "@loaders.gl/3d-tiles": "^3.0.0",
  "@loaders.gl/core": "^3.0.0",
  "@loaders.gl/images": "^3.0.0",
  "@loaders.gl/loader-utils": "^3.0.0",
  "@luma.gl/core": "~8.5.7",
  "@material-ui/core": "^4.8.3",
  "@material-ui/icons": "^4.9.1",
  "@turf/area": "^6.5.0",
  "@turf/boolean-contains": "^6.0.1",
  "@turf/boolean-overlap": "^6.0.1",
  "@turf/boolean-point-in-polygon": "^6.0.1",
  "@turf/boolean-within": "^6.0.1",
  "@turf/centroid": "^6.0.2",
  "@turf/helpers": "^6.1.4",
  ajv: "^6.10.0",
  bowser: "^2.11.0",
  classnames: "^2.2.6",
  clsx: "^1.1.1",
  concaveman: "^1.2.0",
  "d3-array": "^2.4.0",
  "d3-dsv": "^1.1.1",
  "d3-force": "^2.1.1",
  "d3-quadtree": "^1.0.7",
  "d3-scale-chromatic": "^1.3.3",
  "deck.gl": "~8.5.8",
  "dynamic-import-polyfill": "^0.1.1",
  "fast-deep-equal": "^3.1.3",
  glslify: "^7.0.0",
  higlass: "1.11.4",
  "higlass-register": "^0.3.0",
  "higlass-zarr-datafetchers": "^0.2.1",
  internmap: "^2.0.3",
  json2csv: "^4.5.2",
  lodash: "^4.17.15",
  "lz-string": "^1.4.4",
  "math.gl": "^3.1.3",
  mathjs: "^9.2.0",
  "nebula.gl": "^0.23.8",
  "prop-types": "^15.7.2",
  "rc-tooltip": "^4.0.3",
  "rc-tree": "2.1.0",
  "react-color": "^2.18.0",
  "react-grid-layout": "^1.1.1",
  "react-vega": "^7.3.0",
  "react-virtualized": "^9.22.2",
  "short-number": "^1.0.6",
  store: "^2.0.12",
  tinycolor2: "^1.4.1",
  tinyqueue: "^2.0.3",
  uuid: "^3.3.2",
  vega: "^5.13.0",
  "vega-lite": "^4.13.0",
  "vega-tooltip": "^0.23.0",
  "whatwg-fetch": "^3.0.0",
  "window-pixi": "5.3.3",
  zarr: "^0.4.0",
  zustand: "^3.5.10"
};
var devDependencies = {
  "@babel/core": "7.9.0",
  "@babel/plugin-proposal-class-properties": "^7.14.5",
  "@svgr/webpack": "5.3.1",
  "@typescript-eslint/eslint-plugin": "^2.10.0",
  "@typescript-eslint/parser": "^2.10.0",
  "babel-eslint": "10.0.3",
  "babel-loader": "8.1.0",
  "babel-plugin-glsl": "^1.0.0",
  "babel-plugin-named-asset-import": "^0.3.6",
  "babel-preset-react-app": "^9.1.2",
  camelcase: "^5.3.1",
  "case-sensitive-paths-webpack-plugin": "2.3.0",
  concurrently: "^5.3.0",
  "css-loader": "3.4.2",
  cypress: "^3.6.1",
  "cypress-fail-on-console-error": "^2.0.6",
  dotenv: "8.2.0",
  "dotenv-expand": "5.1.0",
  enzyme: "^3.9.0",
  "enzyme-adapter-react-16": "^1.11.2",
  esbuild: "^0.12.28",
  "esbuild-plugin-babel": "^0.2.3",
  "esbuild-plugin-sass": "^0.6.0",
  eslint: "^6.6.0",
  "eslint-config-airbnb": "^17.1.0",
  "eslint-config-react-app": "^5.2.0",
  "eslint-loader": "3.0.3",
  "eslint-plugin-cypress": "^2.2.1",
  "eslint-plugin-flowtype": "4.6.0",
  "eslint-plugin-import": "2.20.0",
  "eslint-plugin-jsx-a11y": "6.2.3",
  "eslint-plugin-react": "7.18.0",
  "eslint-plugin-react-hooks": "^1.6.1",
  "eslint-plugin-vitessce-rules": "file:eslint",
  expect: "^24.5.0",
  "file-loader": "4.3.0",
  "fs-extra": "^8.1.0",
  "glsl-colormap": "^1.0.1",
  "html-webpack-plugin": "4.0.0-beta.11",
  "http-server": "^0.12.3",
  "identity-obj-proxy": "3.0.0",
  "js-yaml": "^3.13.1",
  karma: "4.4.1",
  "karma-chrome-launcher": "3.1.0",
  "karma-mocha": "1.3.0",
  "karma-mocha-reporter": "2.2.5",
  "karma-sourcemap-loader": "0.3.7",
  "karma-webpack": "4.0.2",
  "mini-css-extract-plugin": "0.9.0",
  mocha: "7.1.0",
  "node-sass": "^6.0.0",
  "object.fromentries": "^2.0.2",
  "optimize-css-assets-webpack-plugin": "5.0.3",
  "pnp-webpack-plugin": "1.6.0",
  "postcss-flexbugs-fixes": "4.1.0",
  "postcss-loader": "3.0.0",
  "postcss-normalize": "8.0.1",
  "postcss-preset-env": "6.7.0",
  "postcss-safe-parser": "4.0.1",
  react: "^16.8.6",
  "react-app-polyfill": "^1.0.6",
  "react-dev-utils": "^10.2.0",
  "react-dom": "^16.8.6",
  resolve: "1.15.0",
  "resolve-url-loader": "3.1.1",
  "sass-loader": "^10.0.1",
  semver: "6.3.0",
  "style-loader": "0.23.1",
  "terser-webpack-plugin": "2.3.4",
  "url-loader": "2.3.0",
  "wait-on": "^3.2.0",
  webpack: "4.41.5",
  "webpack-dev-server": "3.10.2",
  "webpack-node-externals": "^2.5.2",
  "workbox-webpack-plugin": "4.3.1",
  "worker-loader": "^2.0.0"
};
var resolutions = {
  "@turf/difference": "6.0.1"
};
var scripts = {
  "build-demo:prod": "node scripts/build-demo.js production",
  "build-lib:prod": "NODE_ENV=production node scripts/build-esm.mjs && node scripts/build-lib.js production",
  "build-demo:dev": "node scripts/build-demo.js development",
  "build-lib:dev": "NODE_ENV=development node scripts/build-esm.mjs && node scripts/build-lib.js development",
  "build:prod": "npm run build-demo:prod && npm run build-lib:prod",
  "build:dev": "npm run build-demo:dev && npm run build-lib:dev",
  prepublishOnly: "npm run build-lib:prod",
  clean: "rm -r dist-demo dist",
  start: "node scripts/start-demo.js",
  "start:fixtures": 'http-server src/loaders/fixtures/ --cors="*" -s',
  "start:fixtures-concurrently": 'concurrently --kill-others "npm run start:fixtures"',
  test: 'npm run start:fixtures-concurrently -- --success first "karma start scripts/karma.config.js --single-run"',
  "test:watch": 'npm run start:fixtures-concurrently -- "karma start scripts/karma.config.js --auto-watch"',
  "cypress:open": 'npm run start:fixtures-concurrently -- "cypress open"',
  "cypress:run": 'npm run start:fixtures-concurrently -- --success first --kill-others "cypress run"',
  "lint-fix": "eslint -c .eslintrc.yml --ext .js --fix src/"
};
var browserslist = {
  production: [
    ">0.2%",
    "not dead",
    "not op_mini all"
  ],
  development: [
    "last 1 chrome version",
    "last 1 firefox version",
    "last 1 safari version"
  ]
};
var babel = {
  presets: [
    "react-app"
  ],
  plugins: [
    "glsl"
  ]
};
var package_default = {
  name,
  version,
  description,
  author,
  homepage,
  license,
  repository,
  keywords,
  files,
  main,
  module,
  peerDependencies,
  dependencies,
  devDependencies,
  resolutions,
  scripts,
  browserslist,
  babel
};

// src/components/sets/SetsManager.js
import React50, { useState as useState14, useMemo as useMemo9 } from "react";
import isEqual10 from "lodash/isEqual";

// src/components/sets/Tree.js
import React40 from "react";
import RcTree from "rc-tree";
import classNames from "classnames";
var Tree = React40.forwardRef((props, ref) => {
  const {
    prefixCls,
    className,
    showIcon,
    blockNode,
    children,
    checkable
  } = props;
  return /* @__PURE__ */ React40.createElement(RcTree, __spreadProps(__spreadValues({
    itemHeight: 32,
    ref
  }, props), {
    className: classNames(className, {
      [`${prefixCls}-icon-hide`]: !showIcon,
      [`${prefixCls}-block-node`]: blockNode
    }),
    checkable: checkable ? /* @__PURE__ */ React40.createElement("span", {
      className: `${prefixCls}-checkbox-inner`
    }) : checkable
  }), children);
});
Tree.defaultProps = {
  virtual: false,
  checkable: false,
  showIcon: false,
  blockNode: true,
  prefixCls: "rc-tree"
};
var Tree_default = Tree;

// src/components/sets/TreeNode.js
import React45, { useState as useState13 } from "react";
import clsx from "clsx";
import { TreeNode as RcTreeNode } from "rc-tree";
import { getDataAndAria } from "rc-tree/es/util";
import classNames2 from "classnames";
import range8 from "lodash/range";
import isEqual9 from "lodash/isEqual";

// src/components/sets/PopoverMenu.js
import React43, { useState as useState12, useEffect as useEffect15 } from "react";
import { TwitterPicker } from "react-color";

// src/components/sets/Popover.js
import React42 from "react";

// src/components/sets/HelpTooltip.js
import React41, { useRef as useRef7 } from "react";
import RcTooltip from "rc-tooltip";
function HelpTooltip(props) {
  const { title: title16, content, overlayClassName } = props;
  const spanRef = useRef7();
  const getTooltipContainer = useVitessceContainer(spanRef);
  const overlay = title16 || content;
  return /* @__PURE__ */ React41.createElement(React41.Fragment, null, /* @__PURE__ */ React41.createElement("span", {
    ref: spanRef
  }), /* @__PURE__ */ React41.createElement(RcTooltip, __spreadValues({
    getTooltipContainer,
    overlayClassName,
    overlay
  }, props)));
}
HelpTooltip.defaultProps = {
  overlayClassName: "help-tooltip",
  placement: "top",
  trigger: "hover",
  mouseEnterDelay: 0.2,
  mouseLeaveDelay: 0
};

// src/components/sets/Popover.js
function Popover(props) {
  return /* @__PURE__ */ React42.createElement(HelpTooltip, __spreadValues({}, props));
}
Popover.defaultProps = {
  overlayClassName: "popover",
  placement: "top",
  trigger: "click",
  mouseEnterDelay: 0,
  mouseLeaveDelay: 0
};

// src/components/sets/PopoverMenu.js
function PopoverMenuListButton(props) {
  const {
    title: title16,
    subtitle,
    onClick,
    handler,
    handlerKey,
    confirm,
    visible
  } = props;
  const [isConfirming, setIsConfirming] = useState12(false);
  useEffect15(() => {
    setIsConfirming(false);
  }, [visible]);
  function handleOrRequireConfirm() {
    if (!confirm || isConfirming) {
      onClick();
      handler();
    } else {
      setIsConfirming(true);
    }
  }
  const titleWithConfirm = `${isConfirming ? "Confirm " : ""}${title16}`;
  return /* @__PURE__ */ React43.createElement("button", {
    title: titleWithConfirm,
    type: "button",
    onClick: handleOrRequireConfirm,
    onKeyPress: (e) => callbackOnKeyPress(e, handlerKey, handleOrRequireConfirm)
  }, titleWithConfirm, subtitle && /* @__PURE__ */ React43.createElement(React43.Fragment, null, /* @__PURE__ */ React43.createElement("br", null), /* @__PURE__ */ React43.createElement("span", {
    className: "small"
  }, subtitle)));
}
function PopoverMenuList(props) {
  const {
    menuConfig,
    onClick,
    color = null,
    palette = null,
    setColor = null,
    visible
  } = props;
  function handleColorChange({ rgb }) {
    if (rgb && setColor) {
      setColor([rgb.r, rgb.g, rgb.b]);
    }
  }
  const defaultPalette = palette ? palette.map(colorArrayToString) : PALETTE.concat([[255, 255, 255], [128, 128, 128], [0, 0, 0]]).map(colorArrayToString);
  return /* @__PURE__ */ React43.createElement("div", null, color && setColor && defaultPalette && /* @__PURE__ */ React43.createElement(TwitterPicker, {
    className: "popover-menu-color",
    disableAlpha: true,
    width: 108,
    triangle: "hide",
    colors: defaultPalette,
    color: colorArrayToString(color),
    onChangeComplete: handleColorChange
  }), /* @__PURE__ */ React43.createElement("ul", {
    className: "popover-menu-list"
  }, menuConfig.map((item) => /* @__PURE__ */ React43.createElement("li", {
    key: item.title + item.subtitle
  }, /* @__PURE__ */ React43.createElement(PopoverMenuListButton, __spreadProps(__spreadValues({}, item), {
    onClick,
    visible
  }))))));
}
function PopoverMenu(props) {
  const {
    menuConfig,
    placement,
    children,
    color = null,
    setColor = null,
    palette = null
  } = props;
  const [visible, setVisible] = useState12(false);
  return /* @__PURE__ */ React43.createElement(Popover, {
    content: /* @__PURE__ */ React43.createElement(PopoverMenuList, {
      menuConfig,
      onClick: () => setVisible(false),
      color,
      setColor,
      palette,
      visible
    }),
    placement,
    visible,
    onVisibleChange: setVisible
  }, children);
}

// src/assets/menu.svg
import {
  createElement as createElement4
} from "react";
function SvgMenu(props) {
  return /* @__PURE__ */ createElement4("svg", __spreadValues({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24"
  }, props), /* @__PURE__ */ createElement4("path", {
    d: "M12 18c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zm0-9c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zm0-9c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3z"
  }));
}
var ReactComponent4 = SvgMenu;

// src/components/sets/TreeNode.js
function makeNodeViewMenuConfig(props) {
  const {
    path,
    level,
    height,
    onCheckNode,
    onNodeRemove,
    onNodeSetIsEditing,
    onExportLevelZeroNodeJSON,
    onExportLevelZeroNodeTabular,
    onExportSetJSON,
    checkable,
    editable,
    exportable,
    checked
  } = props;
  return [
    ...editable ? [
      {
        title: "Rename",
        handler: () => {
          onNodeSetIsEditing(path, true);
        },
        handlerKey: "r"
      },
      {
        title: "Delete",
        confirm: true,
        handler: () => {
          onNodeRemove(path);
        },
        handlerKey: "d"
      }
    ] : [],
    ...level === 0 && exportable ? [
      {
        title: "Export hierarchy",
        subtitle: "(to JSON file)",
        handler: () => {
          onExportLevelZeroNodeJSON(path);
        },
        handlerKey: "j"
      },
      ...height <= 1 ? [
        {
          title: "Export hierarchy",
          subtitle: "(to CSV file)",
          handler: () => {
            onExportLevelZeroNodeTabular(path);
          },
          handlerKey: "t"
        }
      ] : []
    ] : [],
    ...level > 0 ? [
      ...checkable ? [
        {
          title: checked ? "Uncheck" : "Check",
          handler: () => {
            onCheckNode(path, !checked);
          },
          handlerKey: "s"
        }
      ] : [],
      ...exportable ? [
        {
          title: "Export set",
          subtitle: "(to JSON file)",
          handler: () => {
            onExportSetJSON(path);
          },
          handlerKey: "e"
        }
      ] : []
    ] : []
  ];
}
function NamedSetNodeStatic(props) {
  const {
    title: title16,
    path,
    nodeKey,
    level,
    height,
    color,
    checkbox,
    isChecking,
    isLeaf,
    onNodeSetColor,
    onNodeView,
    expanded,
    onCheckLevel,
    checkedLevelPath,
    checkedLevelIndex,
    disableTooltip,
    size,
    datatype,
    editable,
    theme
  } = props;
  const shouldCheckNextLevel = level === 0 && !expanded;
  const nextLevelToCheck = checkedLevelIndex && isEqual9(path, checkedLevelPath) && checkedLevelIndex < height ? checkedLevelIndex + 1 : 1;
  const numberFormatter = new Intl.NumberFormat("en-US");
  const niceSize = numberFormatter.format(size);
  let tooltipText;
  if (shouldCheckNextLevel) {
    tooltipText = getLevelTooltipText(nextLevelToCheck);
  } else if (isLeaf || !expanded) {
    tooltipText = `Color individual set (${niceSize} ${datatype}${size === 1 ? "" : "s"})`;
  } else {
    tooltipText = "Color by expanded descendants";
  }
  const onClick = level === 0 && !expanded ? () => onCheckLevel(nodeKey, nextLevelToCheck) : () => onNodeView(path);
  const tooltipProps = disableTooltip ? { visible: false } : {};
  const popoverMenuConfig = makeNodeViewMenuConfig(props);
  return /* @__PURE__ */ React45.createElement("span", null, /* @__PURE__ */ React45.createElement(HelpTooltip, __spreadValues({
    title: tooltipText
  }, tooltipProps), /* @__PURE__ */ React45.createElement("button", {
    type: "button",
    onClick,
    onKeyPress: (e) => callbackOnKeyPress(e, "v", () => onNodeView(path)),
    className: "title-button"
  }, title16)), popoverMenuConfig.length > 0 ? /* @__PURE__ */ React45.createElement(PopoverMenu, {
    menuConfig: makeNodeViewMenuConfig(props),
    color: level > 0 && editable ? color || getDefaultColor(theme) : null,
    setColor: (c) => onNodeSetColor(path, c)
  }, /* @__PURE__ */ React45.createElement(ReactComponent4, {
    className: "node-menu-icon"
  })) : null, level > 0 && isChecking ? checkbox : null, level > 0 && /* @__PURE__ */ React45.createElement("span", {
    className: "node-size-label"
  }, niceSize));
}
function NamedSetNodeEditing(props) {
  const {
    title: title16,
    path,
    onNodeSetName,
    onNodeCheckNewName
  } = props;
  const [currentTitle, setCurrentTitle] = useState13(title16);
  const hasConflicts = onNodeCheckNewName(path, currentTitle);
  function trySetName() {
    if (!hasConflicts) {
      onNodeSetName(path, currentTitle, true);
    }
  }
  return /* @__PURE__ */ React45.createElement("span", {
    className: "title-button-with-input"
  }, /* @__PURE__ */ React45.createElement("input", {
    autoFocus: true,
    className: "title-input",
    type: "text",
    value: currentTitle,
    onChange: (e) => {
      setCurrentTitle(e.target.value);
    },
    onKeyPress: (e) => callbackOnKeyPress(e, "Enter", trySetName),
    onFocus: (e) => e.target.select()
  }), !hasConflicts && /* @__PURE__ */ React45.createElement("button", {
    type: "button",
    className: "title-save-button",
    onClick: trySetName
  }, "Save"));
}
function NamedSetNode(props) {
  const {
    isEditing,
    isCurrentSet
  } = props;
  return isEditing || isCurrentSet ? /* @__PURE__ */ React45.createElement(NamedSetNodeEditing, __spreadValues({}, props)) : /* @__PURE__ */ React45.createElement(NamedSetNodeStatic, __spreadValues({}, props));
}
function LevelsButtons(props) {
  const {
    nodeKey,
    path,
    height,
    onCheckLevel,
    checkedLevelPath,
    checkedLevelIndex,
    hasColorEncoding
  } = props;
  function onCheck(event) {
    if (event.target.checked) {
      const newLevel = parseInt(event.target.value, 10);
      onCheckLevel(nodeKey, newLevel);
    }
  }
  return /* @__PURE__ */ React45.createElement("div", {
    className: "level-buttons-container"
  }, range8(1, height + 1).map((i) => {
    const isChecked = isEqual9(path, checkedLevelPath) && i === checkedLevelIndex;
    return /* @__PURE__ */ React45.createElement("div", {
      className: "level-buttons",
      key: i
    }, /* @__PURE__ */ React45.createElement(HelpTooltip, {
      title: getLevelTooltipText(i)
    }, /* @__PURE__ */ React45.createElement("input", {
      className: clsx("level-radio-button", { checked: isChecked && !hasColorEncoding }),
      type: "checkbox",
      value: i,
      checked: isChecked && hasColorEncoding,
      onChange: onCheck
    })));
  }));
}
function SwitcherIcon(props) {
  const {
    isLeaf,
    isOpen,
    color
  } = props;
  const hexColor = color ? colorArrayToString(color) : void 0;
  if (isLeaf) {
    return /* @__PURE__ */ React45.createElement("i", {
      className: "anticon anticon-circle rc-tree-switcher-icon"
    }, /* @__PURE__ */ React45.createElement("svg", {
      viewBox: "0 0 1024 1024",
      focusable: "false",
      "data-icon": "caret-down",
      width: "1em",
      height: "1em",
      "aria-hidden": "true"
    }, /* @__PURE__ */ React45.createElement("rect", {
      fill: hexColor,
      x: 600 / 2,
      y: 600 / 2,
      width: 1024 - 600,
      height: 1024 - 600
    })));
  }
  return /* @__PURE__ */ React45.createElement("i", {
    className: "anticon anticon-caret-down rc-tree-switcher-icon"
  }, /* @__PURE__ */ React45.createElement("svg", {
    viewBox: "0 0 1024 1024",
    focusable: "false",
    "data-icon": "caret-down",
    width: "1em",
    height: "1em",
    "aria-hidden": "true"
  }, /* @__PURE__ */ React45.createElement("path", {
    fill: isOpen ? "#444" : hexColor,
    d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z"
  })));
}
var TreeNode = class extends RcTreeNode {
  constructor() {
    super(...arguments);
    __publicField(this, "renderSelector", () => {
      const {
        title: title16,
        isCurrentSet,
        isSelected,
        isEditing,
        onDragStart: onDragStartProp
      } = this.props;
      const {
        rcTree: {
          prefixCls: prefixClass,
          draggable
        }
      } = this.context;
      const onDragStart = (e) => {
        onDragStartProp();
        this.onDragStart(e);
      };
      const wrapClass = `${prefixClass}-node-content-wrapper`;
      const isDraggable = !isCurrentSet && !isEditing && draggable;
      return /* @__PURE__ */ React45.createElement("span", {
        ref: this.setSelectHandle,
        title: title16,
        className: classNames2(wrapClass, `${wrapClass}-${this.getNodeState() || "normal"}`, isSelected && `${prefixClass}-node-selected`, isDraggable && "draggable"),
        draggable: isDraggable,
        "aria-grabbed": isDraggable,
        onDragStart: isDraggable ? onDragStart : void 0
      }, /* @__PURE__ */ React45.createElement(NamedSetNode, __spreadProps(__spreadValues({}, this.props), {
        prefixClass,
        checkbox: this.renderCheckbox()
      })), this.renderLevels());
    });
    __publicField(this, "renderLevels", () => {
      const { level, expanded } = this.props;
      if (level !== 0 || expanded) {
        return null;
      }
      return /* @__PURE__ */ React45.createElement(LevelsButtons, __spreadValues({}, this.props));
    });
    __publicField(this, "renderSwitcher", () => {
      const { expanded, isLeaf, color } = this.props;
      const {
        rcTree: {
          prefixCls: prefixClass,
          onNodeExpand
        }
      } = this.context;
      const onNodeExpandWrapper = (e) => {
        if (!isLeaf) {
          onNodeExpand(e, this);
        }
      };
      const switcherClass = classNames2(`${prefixClass}-switcher`, { [`${prefixClass}-switcher_${expanded ? "open" : "close"}`]: !isLeaf });
      return /* @__PURE__ */ React45.createElement("span", {
        className: switcherClass,
        onClick: onNodeExpandWrapper,
        onKeyPress: (e) => callbackOnKeyPress(e, "d", onNodeExpandWrapper),
        role: "button",
        tabIndex: "0"
      }, /* @__PURE__ */ React45.createElement(SwitcherIcon, {
        isLeaf,
        isOpen: expanded,
        color
      }));
    });
  }
  render() {
    const _a2 = this.props, {
      style,
      loading,
      level,
      dragOver,
      dragOverGapTop,
      dragOverGapBottom,
      isLeaf,
      expanded,
      selected,
      checked,
      halfChecked,
      onDragEnd: onDragEndProp,
      expandable
    } = _a2, otherProps = __objRest(_a2, [
      "style",
      "loading",
      "level",
      "dragOver",
      "dragOverGapTop",
      "dragOverGapBottom",
      "isLeaf",
      "expanded",
      "selected",
      "checked",
      "halfChecked",
      "onDragEnd",
      "expandable"
    ]);
    const {
      rcTree: {
        prefixCls: prefixClass,
        filterTreeNode,
        draggable
      }
    } = this.context;
    const disabled = this.isDisabled();
    const dataAndAriaAttributeProps = getDataAndAria(otherProps);
    const onDragEnd = (e) => {
      onDragEndProp();
      this.onDragEnd(e);
    };
    return /* @__PURE__ */ React45.createElement("li", __spreadValues({
      className: classNames2("rc-tree-treenode", `level-${level}-treenode`, {
        [`${prefixClass}-treenode-disabled`]: disabled,
        [`${prefixClass}-treenode-switcher-${expanded ? "open" : "close"}`]: !isLeaf,
        [`${prefixClass}-treenode-checkbox-checked`]: checked,
        [`${prefixClass}-treenode-checkbox-indeterminate`]: halfChecked,
        [`${prefixClass}-treenode-selected`]: selected,
        [`${prefixClass}-treenode-loading`]: loading,
        "drag-over": !disabled && dragOver,
        "drag-over-gap-top": !disabled && dragOverGapTop,
        "drag-over-gap-bottom": !disabled && dragOverGapBottom,
        "filter-node": filterTreeNode && filterTreeNode(this)
      }),
      style,
      role: "treeitem",
      onDragEnter: draggable ? this.onDragEnter : void 0,
      onDragOver: draggable ? this.onDragOver : void 0,
      onDragLeave: draggable ? this.onDragLeave : void 0,
      onDrop: draggable ? this.onDrop.bind(this) : void 0,
      onDragEnd: draggable ? onDragEnd : void 0
    }, dataAndAriaAttributeProps), expandable ? this.renderSwitcher() : null, this.renderSelector(), this.renderChildren());
  }
};

// src/components/sets/SetsManagerButtons.js
import React49, { useCallback as useCallback11 } from "react";

// src/assets/sets/union.svg
import {
  createElement as createElement5
} from "react";
function SvgUnion(props) {
  return /* @__PURE__ */ createElement5("svg", __spreadValues({
    viewBox: "0 0 16.433999 10.234",
    height: 12,
    width: 18
  }, props), /* @__PURE__ */ createElement5("g", {
    transform: "translate(0.117,-2.883)"
  }, /* @__PURE__ */ createElement5("path", {
    d: "m 11.467471,11.811278 c 0.198237,-0.322177 0.508,-1.011333 0.653661,-1.454255 0.659343,-2.0049141 0.44323,-4.2620847 -0.577734,-6.0340822 l -0.168844,-0.2930481 0.105744,0.017887 c 0.759902,0.1285441 1.368762,0.3699553 1.856675,0.7361658 1.988296,1.4923476 2.192477,4.3353549 0.434717,6.0529895 -0.641216,0.626581 -1.299647,0.94683 -2.294136,1.115833 l -0.108488,0.01844 z M 4.3162122,11.919169 C 1.9278944,11.487872 0.46692382,9.0323123 1.234873,6.7401372 1.5621727,5.763213 2.2610593,4.9489746 3.1840041,4.4693005 3.5978035,4.2542401 3.9427842,4.145371 4.5197023,4.0477802 L 4.6254464,4.0298927 4.4571836,4.3223069 C 3.4332707,6.1017061 3.2180432,8.3476022 3.878868,10.357023 c 0.1458466,0.443487 0.4554716,1.132155 0.6542959,1.455285 0.054471,0.08853 0.087814,0.159599 0.074096,0.157937 -0.013718,-0.0017 -0.1446898,-0.02465 -0.2910477,-0.05108 z M 5.0000001,3 C 2.2,3 0,5.2 0,8 c 0,2.8 2.2,5 5.0000001,5 0.6,0 1.1,-0.1 1.6,-0.3 C 5.3000001,11.6 4.5,9.7999998 4.5,8 4.5,6.2 5.3000001,4.5 6.6000001,3.3 c -0.5,-0.2 -1,-0.3 -1.6,-0.3 z M 4.65,4.02 C 3.92,5.17 3.51,6.54 3.51,8 c 0,1.4599998 0.42,2.83 1.14,3.98 C 2.61,11.8 1.01,10.08 1.01,8 1.01,5.92 2.61,4.2 4.65,4.02 Z M 8,4 C 6.8,4.9 6,6.4 6,8 6,9.6 6.8,11.1 8,12 9.2,11.1 10,9.7 10,8 10,6.3 9.2,4.9 8,4 Z m 3,-1 c 2.8,0 5,2.2 5,5 0,2.8 -2.2,5 -5,5 C 10.4,13 9.9,12.9 9.4,12.7 10.7,11.6 11.5,9.8 11.5,8 11.5,6.2 10.7,4.5 9.4,3.3 9.9,3.1 10.4,3 11,3 Z m 0.35,1.02 c 0.73,1.15 1.14,2.52 1.14,3.98 0,1.46 -0.42,2.83 -1.14,3.98 2.04,-0.18 3.64,-1.9 3.64,-3.98 0,-2.08 -1.6,-3.8 -3.64,-3.98 z",
    style: {
      strokeWidth: 0.234,
      strokeMiterlimit: 4,
      strokeDasharray: "none",
      strokeOpacity: 1
    }
  })));
}
var ReactComponent5 = SvgUnion;

// src/assets/sets/intersection.svg
import {
  createElement as createElement6
} from "react";
function SvgIntersection(props) {
  return /* @__PURE__ */ createElement6("svg", __spreadValues({
    width: 18,
    height: 12,
    viewBox: "0 0 16 10"
  }, props), /* @__PURE__ */ createElement6("g", {
    transform: "translate(0,-3)"
  }, /* @__PURE__ */ createElement6("path", {
    d: "M 5.0000001,3 C 2.2,3 0,5.2 0,8 c 0,2.8 2.2,5 5.0000001,5 0.6,0 1.1,-0.1 1.6,-0.3 C 5.3000001,11.6 4.5,9.7999998 4.5,8 4.5,6.2 5.3000001,4.5 6.6000001,3.3 c -0.5,-0.2 -1,-0.3 -1.6,-0.3 z M 4.65,4.02 C 3.92,5.17 3.51,6.54 3.51,8 c 0,1.4599998 0.42,2.83 1.14,3.98 C 2.61,11.8 1.01,10.08 1.01,8 1.01,5.92 2.61,4.2 4.65,4.02 Z M 8,4 C 6.8,4.9 6,6.4 6,8 6,9.6 6.8,11.1 8,12 9.2,11.1 10,9.7 10,8 10,6.3 9.2,4.9 8,4 Z m 3,-1 c 2.8,0 5,2.2 5,5 0,2.8 -2.2,5 -5,5 C 10.4,13 9.9,12.9 9.4,12.7 10.7,11.6 11.5,9.8 11.5,8 11.5,6.2 10.7,4.5 9.4,3.3 9.9,3.1 10.4,3 11,3 Z m 0.35,1.02 c 0.73,1.15 1.14,2.52 1.14,3.98 0,1.46 -0.42,2.83 -1.14,3.98 2.04,-0.18 3.64,-1.9 3.64,-3.98 0,-2.08 -1.6,-3.8 -3.64,-3.98 z",
    style: {
      strokeWidth: 0.234,
      strokeMiterlimit: 4,
      strokeDasharray: "none",
      strokeOpacity: 1
    }
  })));
}
var ReactComponent6 = SvgIntersection;

// src/assets/sets/complement.svg
import {
  createElement as createElement7
} from "react";
function SvgComplement(props) {
  return /* @__PURE__ */ createElement7("svg", __spreadValues({
    id: "svg14",
    viewBox: "0 0 25.3804963846 16",
    height: 16,
    width: 25.3804963846
  }, props), /* @__PURE__ */ createElement7("defs", null, /* @__PURE__ */ createElement7("mask", {
    id: "union-mask",
    x: 0,
    y: 0,
    width: 25.3804963846,
    height: 16
  }, /* @__PURE__ */ createElement7("rect", {
    x: "5%",
    width: "90%",
    height: "100%",
    fill: "white"
  }), /* @__PURE__ */ createElement7("g", {
    transform: "translate(4.69,0)"
  }, /* @__PURE__ */ createElement7("path", {
    d: "m 11.467471,11.811278 c 0.198237,-0.322177 0.508,-1.011333 0.653661,-1.454255 0.659343,-2.0049141 0.44323,-4.2620847 -0.577734,-6.0340822 l -0.168844,-0.2930481 0.105744,0.017887 c 0.759902,0.1285441 1.368762,0.3699553 1.856675,0.7361658 1.988296,1.4923476 2.192477,4.3353549 0.434717,6.0529895 -0.641216,0.626581 -1.299647,0.94683 -2.294136,1.115833 l -0.108488,0.01844 z M 4.3162122,11.919169 C 1.9278944,11.487872 0.46692382,9.0323123 1.234873,6.7401372 1.5621727,5.763213 2.2610593,4.9489746 3.1840041,4.4693005 3.5978035,4.2542401 3.9427842,4.145371 4.5197023,4.0477802 L 4.6254464,4.0298927 4.4571836,4.3223069 C 3.4332707,6.1017061 3.2180432,8.3476022 3.878868,10.357023 c 0.1458466,0.443487 0.4554716,1.132155 0.6542959,1.455285 0.054471,0.08853 0.087814,0.159599 0.074096,0.157937 -0.013718,-0.0017 -0.1446898,-0.02465 -0.2910477,-0.05108 z M 5.0000001,3 C 2.2,3 0,5.2 0,8 c 0,2.8 2.2,5 5.0000001,5 0.6,0 1.1,-0.1 1.6,-0.3 C 5.3000001,11.6 4.5,9.7999998 4.5,8 4.5,6.2 5.3000001,4.5 6.6000001,3.3 c -0.5,-0.2 -1,-0.3 -1.6,-0.3 z M 4.65,4.02 C 3.92,5.17 3.51,6.54 3.51,8 c 0,1.4599998 0.42,2.83 1.14,3.98 C 2.61,11.8 1.01,10.08 1.01,8 1.01,5.92 2.61,4.2 4.65,4.02 Z M 8,4 C 6.8,4.9 6,6.4 6,8 6,9.6 6.8,11.1 8,12 9.2,11.1 10,9.7 10,8 10,6.3 9.2,4.9 8,4 Z m 3,-1 c 2.8,0 5,2.2 5,5 0,2.8 -2.2,5 -5,5 C 10.4,13 9.9,12.9 9.4,12.7 10.7,11.6 11.5,9.8 11.5,8 11.5,6.2 10.7,4.5 9.4,3.3 9.9,3.1 10.4,3 11,3 Z m 0.35,1.02 c 0.73,1.15 1.14,2.52 1.14,3.98 0,1.46 -0.42,2.83 -1.14,3.98 2.04,-0.18 3.64,-1.9 3.64,-3.98 0,-2.08 -1.6,-3.8 -3.64,-3.98 z",
    style: {
      strokeWidth: 0.234,
      strokeMiterlimit: 4,
      strokeDasharray: "none",
      strokeOpacity: 1
    },
    fill: "black"
  })))), /* @__PURE__ */ createElement7("g", null, /* @__PURE__ */ createElement7("rect", {
    x: 0,
    y: 0,
    width: 25.3804963846,
    height: 16,
    mask: "url(#union-mask)"
  })));
}
var ReactComponent7 = SvgComplement;

// src/components/sets/SetsManagerButtons.js
function PlusButton(props) {
  const {
    datatype,
    onError,
    onImportTree,
    onCreateLevelZeroNode,
    importable,
    editable
  } = props;
  const onImport = useCallback11((importHandler, mimeType) => () => {
    const uploadInputNode = document.createElement("input");
    uploadInputNode.setAttribute("type", "file");
    uploadInputNode.setAttribute("accept", mimeType);
    document.body.appendChild(uploadInputNode);
    uploadInputNode.click();
    uploadInputNode.addEventListener("change", (event) => {
      if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
        onError("Local file reading APIs are not fully supported in this browser.");
        return;
      }
      const { files: files2 } = event.target;
      if (!files2 || files2.length !== 1) {
        onError("Incorrect number of files selected.");
        return;
      }
      const reader = new FileReader();
      reader.addEventListener("load", () => {
        const { result } = reader;
        try {
          const treeToImport = importHandler(result, datatype);
          onError(false);
          onImportTree(treeToImport);
        } catch (e) {
          onError(e.message);
        }
      }, false);
      reader.readAsText(files2[0]);
    });
    uploadInputNode.remove();
  }, [datatype, onError, onImportTree]);
  const menuConfig = [
    ...editable ? [
      {
        title: "Create hierarchy",
        handler: onCreateLevelZeroNode,
        handlerKey: "n"
      }
    ] : [],
    ...importable ? [
      {
        title: "Import hierarchy",
        subtitle: "(from CSV file)",
        handler: onImport(handleImportTabular, MIME_TYPE_TABULAR),
        handlerKey: "c"
      },
      {
        title: "Import hierarchy",
        subtitle: "(from JSON file)",
        handler: onImport(handleImportJSON, MIME_TYPE_JSON),
        handlerKey: "j"
      }
    ] : []
  ];
  return menuConfig.length > 0 ? /* @__PURE__ */ React49.createElement(PopoverMenu, {
    menuConfig
  }, /* @__PURE__ */ React49.createElement("button", {
    className: "plus-button",
    type: "submit"
  }, "+")) : null;
}
function SetOperationButtons(props) {
  const {
    onUnion,
    onIntersection,
    onComplement,
    operatable,
    hasCheckedSetsToUnion,
    hasCheckedSetsToIntersect,
    hasCheckedSetsToComplement
  } = props;
  return /* @__PURE__ */ React49.createElement(React49.Fragment, null, operatable && /* @__PURE__ */ React49.createElement(React49.Fragment, null, /* @__PURE__ */ React49.createElement("button", {
    onClick: onUnion,
    title: "New set from union of checked sets",
    type: "submit",
    disabled: !hasCheckedSetsToUnion
  }, /* @__PURE__ */ React49.createElement(ReactComponent5, null)), /* @__PURE__ */ React49.createElement("button", {
    onClick: onIntersection,
    title: "New set from intersection of checked sets",
    type: "submit",
    disabled: !hasCheckedSetsToIntersect
  }, /* @__PURE__ */ React49.createElement(ReactComponent6, null)), /* @__PURE__ */ React49.createElement("button", {
    onClick: onComplement,
    title: "New set from complement of checked sets",
    type: "submit",
    disabled: !hasCheckedSetsToComplement
  }, /* @__PURE__ */ React49.createElement(ReactComponent7, null))));
}

// src/components/sets/SetsManager.js
function processNode(node, prevPath, setColor, theme) {
  var _a2;
  const nodePath = [...prevPath, node.name];
  return __spreadProps(__spreadValues(__spreadValues({}, node), node.children ? {
    children: node.children.map((c) => processNode(c, nodePath, setColor))
  } : {}), {
    color: ((_a2 = setColor == null ? void 0 : setColor.find((d) => isEqual10(d.path, nodePath))) == null ? void 0 : _a2.color) || getDefaultColor(theme)
  });
}
function processSets(sets, setColor, theme) {
  return __spreadProps(__spreadValues({}, sets), {
    tree: sets ? sets.tree.map((lzn) => processNode(lzn, [], setColor, theme)) : []
  });
}
function getAllKeys(node, path = []) {
  if (!node) {
    return null;
  }
  const newPath = [...path, node.name];
  if (node.children) {
    return [pathToKey(newPath), ...node.children.flatMap((v) => getAllKeys(v, newPath))];
  }
  return pathToKey(newPath);
}
function SetsManager(props) {
  const {
    theme,
    sets,
    additionalSets,
    setColor,
    levelSelection: checkedLevel,
    setSelection,
    setExpansion,
    hasColorEncoding,
    datatype,
    draggable = true,
    checkable = true,
    editable = true,
    expandable = true,
    operatable = true,
    exportable = true,
    importable = true,
    onError,
    onCheckNode,
    onExpandNode,
    onDropNode,
    onCheckLevel,
    onNodeSetColor,
    onNodeSetName,
    onNodeCheckNewName,
    onNodeRemove,
    onNodeView,
    onImportTree,
    onCreateLevelZeroNode,
    onExportLevelZeroNodeJSON,
    onExportLevelZeroNodeTabular,
    onExportSetJSON,
    onUnion,
    onIntersection,
    onComplement,
    hasCheckedSetsToUnion,
    hasCheckedSetsToIntersect,
    hasCheckedSetsToComplement
  } = props;
  const isChecking = true;
  const autoExpandParent = true;
  const [isDragging, setIsDragging] = useState14(false);
  const [isEditingNodeName, setIsEditingNodeName] = useState14(null);
  const processedSets = useMemo9(() => processSets(sets, setColor, theme), [sets, setColor, theme]);
  const processedAdditionalSets = useMemo9(() => processSets(additionalSets, setColor, theme), [additionalSets, setColor, theme]);
  const additionalSetKeys = processedAdditionalSets ? processedAdditionalSets.tree.flatMap((v) => getAllKeys(v, [])) : [];
  const allSetSelectionKeys = (setSelection || []).map(pathToKey);
  const allSetExpansionKeys = (setExpansion || []).map(pathToKey);
  const setSelectionKeys = allSetSelectionKeys.filter((k) => !additionalSetKeys.includes(k));
  const setExpansionKeys = allSetExpansionKeys.filter((k) => !additionalSetKeys.includes(k));
  const additionalSetSelectionKeys = allSetSelectionKeys.filter((k) => additionalSetKeys.includes(k));
  const additionalSetExpansionKeys = allSetExpansionKeys.filter((k) => additionalSetKeys.includes(k));
  function renderTreeNodes(nodes, readOnly, currPath) {
    if (!nodes) {
      return null;
    }
    return nodes.map((node) => {
      const newPath = [...currPath, node.name];
      return /* @__PURE__ */ React50.createElement(TreeNode, __spreadProps(__spreadValues({
        theme,
        key: pathToKey(newPath)
      }, nodeToRenderProps(node, newPath, setColor)), {
        isEditing: isEqual10(isEditingNodeName, newPath),
        datatype,
        draggable: draggable && !readOnly,
        editable: editable && !readOnly,
        checkable,
        expandable,
        exportable,
        hasColorEncoding,
        isChecking,
        checkedLevelPath: checkedLevel ? checkedLevel.levelZeroPath : null,
        checkedLevelIndex: checkedLevel ? checkedLevel.levelIndex : null,
        onCheckNode,
        onCheckLevel,
        onNodeView,
        onNodeSetColor,
        onNodeSetName: (targetPath, name2) => {
          onNodeSetName(targetPath, name2);
          setIsEditingNodeName(null);
        },
        onNodeCheckNewName,
        onNodeSetIsEditing: setIsEditingNodeName,
        onNodeRemove,
        onExportLevelZeroNodeJSON,
        onExportLevelZeroNodeTabular,
        onExportSetJSON,
        disableTooltip: isDragging,
        onDragStart: () => setIsDragging(true),
        onDragEnd: () => setIsDragging(false)
      }), renderTreeNodes(node.children, readOnly, newPath, theme));
    });
  }
  return /* @__PURE__ */ React50.createElement("div", {
    className: "sets-manager"
  }, /* @__PURE__ */ React50.createElement("div", {
    className: "sets-manager-tree"
  }, /* @__PURE__ */ React50.createElement(Tree_default, {
    draggable: false,
    checkable,
    checkedKeys: setSelectionKeys,
    expandedKeys: setExpansionKeys,
    autoExpandParent,
    onCheck: (checkedKeys, info) => onCheckNode(info.node.props.nodeKey, info.checked),
    onExpand: (expandedKeys, info) => onExpandNode(expandedKeys, info.node.props.nodeKey, info.expanded)
  }, renderTreeNodes(processedSets.tree, true, [], theme)), /* @__PURE__ */ React50.createElement(Tree_default, {
    draggable: true,
    checkable,
    checkedKeys: additionalSetSelectionKeys,
    expandedKeys: additionalSetExpansionKeys,
    autoExpandParent,
    onCheck: (checkedKeys, info) => onCheckNode(info.node.props.nodeKey, info.checked),
    onExpand: (expandedKeys, info) => onExpandNode(expandedKeys, info.node.props.nodeKey, info.expanded),
    onDrop: (info) => {
      const { eventKey: dropKey } = info.node.props;
      const { eventKey: dragKey } = info.dragNode.props;
      const { dropToGap, dropPosition } = info;
      onDropNode(dropKey, dragKey, dropPosition, dropToGap);
    }
  }, renderTreeNodes(processedAdditionalSets.tree, false, [], theme)), /* @__PURE__ */ React50.createElement(PlusButton, {
    datatype,
    onError,
    onImportTree,
    onCreateLevelZeroNode,
    importable,
    editable
  })), isChecking ? /* @__PURE__ */ React50.createElement("div", {
    className: "set-operation-buttons"
  }, /* @__PURE__ */ React50.createElement(SetOperationButtons, {
    onUnion,
    onIntersection,
    onComplement,
    operatable,
    hasCheckedSetsToUnion,
    hasCheckedSetsToIntersect,
    hasCheckedSetsToComplement
  })) : null);
}

// src/components/sets/CellSetsManagerSubscriber.js
var CELL_SETS_DATA_TYPES = ["cells", "cell-sets"];
function CellSetsManagerSubscriber(props) {
  const {
    coordinationScopes,
    removeGridComponent,
    theme,
    title: title16 = "Cell Sets"
  } = props;
  const loaders = useLoaders();
  const setWarning = useSetWarning();
  const [{
    dataset,
    cellSetSelection,
    cellSetColor,
    additionalCellSets,
    cellColorEncoding
  }, {
    setCellSetSelection,
    setCellColorEncoding,
    setCellSetColor,
    setAdditionalCellSets
  }] = useCoordination(COMPONENT_COORDINATION_TYPES.cellSets, coordinationScopes);
  const [urls, addUrl, resetUrls] = useUrls();
  const [
    isReady,
    setItemIsReady,
    setItemIsNotReady,
    resetReadyItems
  ] = useReady(CELL_SETS_DATA_TYPES);
  const [cellSetExpansion, setCellSetExpansion] = useState15([]);
  useEffect16(() => {
    resetUrls();
    resetReadyItems();
    setCellSetExpansion([]);
  }, [loaders, dataset]);
  const [cells] = useCellsData(loaders, dataset, setItemIsReady, addUrl, true);
  const [cellSets] = useCellSetsData(loaders, dataset, setItemIsReady, addUrl, true, { setCellSetSelection, setCellSetColor }, { cellSetSelection, cellSetColor });
  useEffect16(() => {
    if (additionalCellSets) {
      let upgradedCellSets;
      try {
        upgradedCellSets = tryUpgradeTreeToLatestSchema(additionalCellSets, SETS_DATATYPE_CELL);
      } catch (e) {
        setWarning(e.message);
        return;
      }
      setAdditionalCellSets(upgradedCellSets);
    }
  }, [additionalCellSets, setAdditionalCellSets, setWarning]);
  const allCellIds = useMemo10(() => cells ? Object.keys(cells) : [], [cells]);
  function setCellSetColorEncoding() {
    setCellColorEncoding("cellSetSelection");
  }
  const mergedCellSets = useMemo10(() => mergeCellSets(cellSets, additionalCellSets), [cellSets, additionalCellSets]);
  const checkedLevel = useMemo10(() => {
    if (cellSetSelection && cellSetSelection.length > 0 && mergedCellSets && mergedCellSets.tree.length > 0) {
      return treeToExpectedCheckedLevel(mergedCellSets, cellSetSelection);
    }
    return null;
  }, [cellSetSelection, mergedCellSets]);
  function onCheckLevel(levelZeroName, levelIndex) {
    const lzn = mergedCellSets.tree.find((n) => n.name === levelZeroName);
    if (lzn) {
      const newCellSetSelection = nodeToLevelDescendantNamePaths(lzn, levelIndex, [], true);
      setCellSetSelection(newCellSetSelection);
      setCellSetColorEncoding();
    }
  }
  function onCheckNode(targetKey, checked) {
    const targetPath = Array.isArray(targetKey) ? targetKey : targetKey.split(PATH_SEP);
    if (!targetKey) {
      return;
    }
    if (checked) {
      setCellSetSelection([...cellSetSelection, targetPath]);
    } else {
      setCellSetSelection(cellSetSelection.filter((d) => !isEqual11(d, targetPath)));
    }
    setCellSetColorEncoding();
  }
  function onExpandNode(expandedKeys, targetKey, expanded) {
    if (expanded) {
      setCellSetExpansion((prev) => [...prev, targetKey.split(PATH_SEP)]);
    } else {
      setCellSetExpansion((prev) => prev.filter((d) => !isEqual11(d, targetKey.split(PATH_SEP))));
    }
  }
  function onDropNode(dropKey, dragKey, dropPosition, dropToGap) {
    const dropPath = dropKey.split(PATH_SEP);
    const dropNode = treeFindNodeByNamePath(additionalCellSets, dropPath);
    if (!dropNode.children && !dropToGap) {
      return;
    }
    const dropNodeLevel = dropPath.length - 1;
    const dropNodeIsLevelZero = dropNodeLevel === 0;
    const dragPath = dragKey.split(PATH_SEP);
    const dragNode = treeFindNodeByNamePath(additionalCellSets, dragPath);
    if (dropNodeIsLevelZero && dropToGap && !dragNode.children) {
      return;
    }
    let dropParentNode;
    let dropParentPath;
    let dropNodeCurrIndex;
    if (!dropNodeIsLevelZero) {
      dropParentPath = dropPath.slice(0, -1);
      dropParentNode = treeFindNodeByNamePath(additionalCellSets, dropParentPath);
      dropNodeCurrIndex = dropParentNode.children.findIndex((c) => c.name === dropNode.name);
    } else {
      dropNodeCurrIndex = additionalCellSets.tree.findIndex((lzn) => lzn.name === dropNode.name);
    }
    let hasSiblingNameConflict;
    const dragNodeName = dragNode.name;
    if (!dropNodeIsLevelZero && dropToGap) {
      hasSiblingNameConflict = dropParentNode.children.find((c) => c !== dragNode && c.name === dragNodeName);
    } else if (!dropToGap) {
      hasSiblingNameConflict = dropNode.children.find((c) => c !== dragNode && c.name === dragNodeName);
    } else {
      hasSiblingNameConflict = additionalCellSets.tree.find((lzn) => lzn !== dragNode && lzn.name === dragNodeName);
    }
    if (hasSiblingNameConflict) {
      return;
    }
    const nextAdditionalCellSets = __spreadProps(__spreadValues({}, additionalCellSets), {
      tree: additionalCellSets.tree.map((lzn) => filterNode(lzn, [], dragPath)).filter(Boolean)
    });
    if (!dropNodeIsLevelZero) {
      dropNodeCurrIndex = dropParentNode.children.findIndex((c) => c.name === dropNode.name);
    } else {
      dropNodeCurrIndex = nextAdditionalCellSets.tree.findIndex((lzn) => lzn.name === dropNode.name);
    }
    let newDragPath = [];
    if (!dropToGap || !dropNodeIsLevelZero) {
      let addChildFunction;
      let checkPathFunction;
      const newPath = [];
      if (!dropToGap) {
        addChildFunction = (n) => nodeAppendChild(n, dragNode);
        checkPathFunction = (path) => isEqual11(path, dropPath);
      } else if (!dropNodeIsLevelZero) {
        checkPathFunction = (path) => isEqual11(path, dropParentPath);
        if (dropPosition === -1) {
          addChildFunction = (n) => nodePrependChild(n, dragNode);
        } else {
          const insertIndex = dropNodeCurrIndex + (dropPosition > dropNodeCurrIndex ? 1 : 0);
          addChildFunction = (n) => nodeInsertChild(n, dragNode, insertIndex);
        }
      }
      nextAdditionalCellSets.tree = nextAdditionalCellSets.tree.map((node) => nodeTransform(node, (n, path) => checkPathFunction(path), (n) => {
        const newNode = addChildFunction(n);
        return newNode;
      }, newPath));
      setAdditionalCellSets(nextAdditionalCellSets);
      newDragPath = [...newPath[0], dragNode.name];
      setCellSetSelection([newDragPath]);
    } else if (dropPosition === -1) {
      nextAdditionalCellSets.tree.unshift(dragNode);
      setAdditionalCellSets(nextAdditionalCellSets);
      newDragPath = [dragNode.name];
      setCellSetSelection([newDragPath]);
    } else {
      const insertIndex = dropNodeCurrIndex + (dropPosition > dropNodeCurrIndex ? 1 : 0);
      const newLevelZero = Array.from(nextAdditionalCellSets.tree);
      newLevelZero.splice(insertIndex, 0, dragNode);
      nextAdditionalCellSets.tree = newLevelZero;
      setAdditionalCellSets(nextAdditionalCellSets);
      newDragPath = [dragNode.name];
      setCellSetSelection([newDragPath]);
    }
    const oldColors = cellSetColor.filter((i) => isEqualOrPrefix(dragPath, i.path));
    const newColors = oldColors.map((i) => __spreadProps(__spreadValues({}, i), {
      path: !isEqual11(i.path, dragPath) ? newDragPath.concat(i.path.slice(dragPath.length)) : newDragPath
    }));
    const newCellSetColor = cellSetColor.filter((i) => !isEqualOrPrefix(dragPath, i.path));
    newCellSetColor.push(...newColors);
    setCellSetColor(newCellSetColor);
  }
  function onNodeSetColor(targetPath, color) {
    const prevNodeColor = cellSetColor == null ? void 0 : cellSetColor.find((d) => isEqual11(d.path, targetPath));
    if (!prevNodeColor) {
      setCellSetColor([
        ...cellSetColor || [],
        {
          path: targetPath,
          color
        }
      ]);
    } else {
      setCellSetColor([
        ...cellSetColor.filter((d) => !isEqual11(d.path, targetPath)),
        {
          path: targetPath,
          color
        }
      ]);
    }
  }
  function onNodeSetName(targetPath, name2) {
    const nextNamePath = [...targetPath];
    nextNamePath.pop();
    nextNamePath.push(name2);
    function renameNode(node, prevPath) {
      if (isEqual11([...prevPath, node.name], targetPath)) {
        return __spreadProps(__spreadValues({}, node), {
          name: name2
        });
      }
      if (!node.children) {
        return node;
      }
      return __spreadProps(__spreadValues({}, node), {
        children: node.children.map((c) => renameNode(c, [...prevPath, node.name]))
      });
    }
    const nextAdditionalCellSets = __spreadProps(__spreadValues({}, additionalCellSets), {
      tree: additionalCellSets.tree.map((lzn) => renameNode(lzn, []))
    });
    const nextCellSetColor = cellSetColor.map((d) => ({
      path: tryRenamePath(targetPath, d.path, nextNamePath),
      color: d.color
    }));
    const nextCellSetSelection = cellSetSelection.map((d) => tryRenamePath(targetPath, d, nextNamePath));
    const nextCellSetExpansion = cellSetExpansion.map((d) => tryRenamePath(targetPath, d, nextNamePath));
    setAdditionalCellSets(nextAdditionalCellSets);
    setCellSetColor(nextCellSetColor);
    setCellSetSelection(nextCellSetSelection);
    setCellSetExpansion(nextCellSetExpansion);
  }
  function onNodeCheckNewName(targetPath, name2) {
    const nextNamePath = [...targetPath];
    nextNamePath.pop();
    nextNamePath.push(name2);
    const hasConflicts = !isEqual11(targetPath, nextNamePath) && treeFindNodeByNamePath(additionalCellSets, nextNamePath);
    return hasConflicts;
  }
  function onNodeRemove(targetPath) {
    const nextAdditionalCellSets = __spreadProps(__spreadValues({}, additionalCellSets), {
      tree: additionalCellSets.tree.map((lzn) => filterNode(lzn, [], targetPath)).filter(Boolean)
    });
    const nextCellSetColor = cellSetColor.filter((d) => !isEqualOrPrefix(targetPath, d.path));
    const nextCellSetSelection = cellSetSelection.filter((d) => !isEqualOrPrefix(targetPath, d));
    const nextCellSetExpansion = cellSetExpansion.filter((d) => !isEqualOrPrefix(targetPath, d));
    setAdditionalCellSets(nextAdditionalCellSets);
    setCellSetColor(nextCellSetColor);
    setCellSetSelection(nextCellSetSelection);
    setCellSetExpansion(nextCellSetExpansion);
  }
  function onNodeView(targetPath) {
    const setsToView = [];
    function viewNode(node, nodePath) {
      if (cellSetExpansion.find((expandedPath) => isEqual11(nodePath, expandedPath))) {
        if (node.children) {
          node.children.forEach((c) => {
            viewNode(c, [...nodePath, c.name]);
          });
        } else {
          setsToView.push(nodePath);
        }
      } else {
        setsToView.push(nodePath);
      }
    }
    const targetNode = treeFindNodeByNamePath(mergedCellSets, targetPath);
    viewNode(targetNode, targetPath);
    setCellSetSelection(setsToView);
    setCellSetColorEncoding();
  }
  function onCreateLevelZeroNode() {
    const nextName = getNextNumberedNodeName(additionalCellSets == null ? void 0 : additionalCellSets.tree, "My hierarchy ");
    setAdditionalCellSets(__spreadProps(__spreadValues({}, additionalCellSets || treeInitialize(SETS_DATATYPE_CELL)), {
      tree: [
        ...additionalCellSets ? additionalCellSets.tree : [],
        {
          name: nextName,
          children: []
        }
      ]
    }));
  }
  function onUnion() {
    const newSet = treeToUnion(mergedCellSets, cellSetSelection);
    setCellSelection(newSet, additionalCellSets, cellSetColor, setCellSetSelection, setAdditionalCellSets, setCellSetColor, setCellColorEncoding, "Union ");
  }
  function onIntersection() {
    const newSet = treeToIntersection(mergedCellSets, cellSetSelection);
    setCellSelection(newSet, additionalCellSets, cellSetColor, setCellSetSelection, setAdditionalCellSets, setCellSetColor, setCellColorEncoding, "Intersection ");
  }
  function onComplement() {
    const newSet = treeToComplement(mergedCellSets, cellSetSelection, allCellIds);
    setCellSelection(newSet, additionalCellSets, cellSetColor, setCellSetSelection, setAdditionalCellSets, setCellSetColor, setCellColorEncoding, "Complement ");
  }
  function onImportTree(treeToImport) {
    const hasConflict = treesConflict(mergedCellSets, treeToImport);
    if (!hasConflict) {
      setAdditionalCellSets(__spreadProps(__spreadValues({}, additionalCellSets || treeInitialize(SETS_DATATYPE_CELL)), {
        tree: [
          ...additionalCellSets ? additionalCellSets.tree : [],
          ...treeToImport.tree
        ]
      }));
      const importAutoSetColors = initializeCellSetColor(treeToImport, cellSetColor);
      setCellSetColor([
        ...cellSetColor,
        ...importAutoSetColors
      ]);
    }
  }
  function onExportLevelZeroNodeJSON(nodePath) {
    const {
      treeToExport,
      nodeName
    } = treeExportLevelZeroNode(mergedCellSets, nodePath, SETS_DATATYPE_CELL, cellSetColor, theme);
    downloadForUser(handleExportJSON(treeToExport), `${nodeName}_${package_default.name}-${SETS_DATATYPE_CELL}-hierarchy.${FILE_EXTENSION_JSON}`);
  }
  function onExportLevelZeroNodeTabular(nodePath) {
    const {
      treeToExport,
      nodeName
    } = treeExportLevelZeroNode(mergedCellSets, nodePath, SETS_DATATYPE_CELL, cellSetColor, theme);
    downloadForUser(handleExportTabular(treeToExport), `${nodeName}_${package_default.name}-${SETS_DATATYPE_CELL}-hierarchy.${FILE_EXTENSION_TABULAR}`);
  }
  function onExportSetJSON(nodePath) {
    const { setToExport, nodeName } = treeExportSet(mergedCellSets, nodePath);
    downloadForUser(handleExportJSON(setToExport), `${nodeName}_${package_default.name}-${SETS_DATATYPE_CELL}-set.${FILE_EXTENSION_JSON}`, FILE_EXTENSION_JSON);
  }
  return /* @__PURE__ */ React51.createElement(TitleInfo, {
    title: title16,
    isScroll: true,
    removeGridComponent,
    urls,
    theme,
    isReady
  }, /* @__PURE__ */ React51.createElement(SetsManager, {
    setColor: cellSetColor,
    sets: cellSets,
    additionalSets: additionalCellSets,
    levelSelection: checkedLevel,
    setSelection: cellSetSelection,
    setExpansion: cellSetExpansion,
    hasColorEncoding: cellColorEncoding === "cellSetSelection",
    draggable: true,
    datatype: SETS_DATATYPE_CELL,
    onError: setWarning,
    onCheckNode,
    onExpandNode,
    onDropNode,
    onCheckLevel,
    onNodeSetColor,
    onNodeSetName,
    onNodeCheckNewName,
    onNodeRemove,
    onNodeView,
    onImportTree,
    onCreateLevelZeroNode,
    onExportLevelZeroNodeJSON,
    onExportLevelZeroNodeTabular,
    onExportSetJSON,
    onUnion,
    onIntersection,
    onComplement,
    hasCheckedSetsToUnion: (cellSetSelection == null ? void 0 : cellSetSelection.length) > 1,
    hasCheckedSetsToIntersect: (cellSetSelection == null ? void 0 : cellSetSelection.length) > 1,
    hasCheckedSetsToComplement: (cellSetSelection == null ? void 0 : cellSetSelection.length) > 0,
    theme
  }));
}

// src/components/layer-controller/LayerControllerSubscriber.js
import React62, {
  useEffect as useEffect19,
  useCallback as useCallback13,
  useRef as useRef9,
  forwardRef as forwardRef4
} from "react";
import Grid8 from "@material-ui/core/Grid";

// src/components/layer-controller/RasterChannelController.js
import React55, { useCallback as useCallback12, useState as useState17, useEffect as useEffect17 } from "react";
import Grid2 from "@material-ui/core/Grid";
import Slider5 from "@material-ui/core/Slider";
import debounce5 from "lodash/debounce";
import isEqual12 from "lodash/isEqual";

// src/components/layer-controller/ChannelOptions.js
import React53, { useState as useState16 } from "react";
import { makeStyles as makeStyles7 } from "@material-ui/core/styles";
import MoreVertIcon from "@material-ui/icons/MoreVert";
import MenuItem2 from "@material-ui/core/MenuItem";

// src/components/layer-controller/ColorPalette.js
import React52 from "react";
import IconButton4 from "@material-ui/core/IconButton";
import LensIcon from "@material-ui/icons/Lens";
import { makeStyles as makeStyles6 } from "@material-ui/core/styles";
var useStyles3 = makeStyles6((theme) => ({
  container: {
    width: "70px",
    height: "40px",
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    flexWrap: "wrap"
  },
  button: {
    padding: "3px",
    width: "16px"
  },
  icon: {
    width: "17px",
    height: "17px",
    stroke: theme.palette.action.selected,
    "stroke-width": "1px"
  }
}));
var ColorPalette = ({ handleChange }) => {
  const classes = useStyles3();
  return /* @__PURE__ */ React52.createElement("div", {
    className: classes.container,
    "aria-label": "color-swatch"
  }, VIEWER_PALETTE.map((color) => /* @__PURE__ */ React52.createElement(IconButton4, {
    className: classes.button,
    key: color,
    onClick: () => handleChange(color)
  }, /* @__PURE__ */ React52.createElement(LensIcon, {
    fontSize: "small",
    style: { color: `rgb(${color})` },
    className: classes.icon
  }))));
};
var ColorPalette_default = ColorPalette;

// src/components/layer-controller/ChannelOptions.js
var useStyles4 = makeStyles7(() => ({
  menuButton: {
    backgroundColor: "transparent"
  },
  colors: {
    "&:hover": {
      backgroundColor: "transparent"
    },
    paddingLeft: "2px",
    paddingRight: "2px"
  }
}));
function ChannelOptions({ handlePropertyChange, handleChannelRemove, handleIQRUpdate }) {
  const [open, setOpen] = useState16(false);
  const classes = useStyles4();
  const handleColorSelect = (color) => {
    handlePropertyChange("color", color);
  };
  const handleRemove = () => {
    setOpen(false);
    handleChannelRemove();
  };
  return /* @__PURE__ */ React53.createElement(PopperMenu, {
    open,
    setOpen,
    buttonIcon: /* @__PURE__ */ React53.createElement(MoreVertIcon, {
      fontSize: "small"
    }),
    buttonClassName: classes.menuButton
  }, /* @__PURE__ */ React53.createElement(MenuItem2, {
    dense: true,
    disableGutters: true,
    onClick: handleRemove
  }, /* @__PURE__ */ React53.createElement(MuiSpan, null, "Remove")), /* @__PURE__ */ React53.createElement(MenuItem2, {
    dense: true,
    disableGutters: true,
    onClick: handleIQRUpdate
  }, /* @__PURE__ */ React53.createElement(MuiSpan, null, "Use IQR")), /* @__PURE__ */ React53.createElement(MenuItem2, {
    dense: true,
    disableGutters: true,
    className: classes.colors
  }, /* @__PURE__ */ React53.createElement(ColorPalette_default, {
    handleChange: handleColorSelect
  })));
}
var ChannelOptions_default = ChannelOptions;

// src/components/layer-controller/constants.js
function getDomains() {
  const domains = {};
  const needMin = ["Int8", "Int16", "Int32"];
  Object.keys(DTYPE_VALUES).forEach((dtype) => {
    const { max: max2 } = DTYPE_VALUES[dtype];
    const min = needMin.includes(dtype) ? -(max2 + 1) : 0;
    domains[dtype] = [min, max2];
  });
  return domains;
}
var DOMAINS = getDomains();

// src/components/layer-controller/shared-channel-controls.js
import React54 from "react";
import Checkbox3 from "@material-ui/core/Checkbox";
import Select2 from "@material-ui/core/Select";

// src/components/layer-controller/styles.js
import { makeStyles as makeStyles8, withStyles } from "@material-ui/core/styles";
import ExpansionPanelSummary from "@material-ui/core/ExpansionPanelSummary";
import ExpansionPanelDetails from "@material-ui/core/ExpansionPanelDetails";
import InputLabel from "@material-ui/core/InputLabel";
import Slider4 from "@material-ui/core/Slider";
import Grid from "@material-ui/core/Grid";
var useSelectStyles = makeStyles8(() => ({
  selectRoot: {
    padding: 0,
    height: "auto",
    margin: "4px 0"
  }
}));
var useOptionStyles = withStyles((theme) => ({
  paper: {
    backgroundColor: theme.palette.background.paper
  },
  span: {
    width: "70px",
    textAlign: "center",
    paddingLeft: "2px",
    paddingRight: "2px"
  },
  colors: {
    "&:hover": {
      backgroundColor: "transparent"
    },
    paddingLeft: "2px",
    paddingRight: "2px"
  },
  popper: {
    zIndex: 4
  }
}));
var sharedControllerStyles = {
  width: "100%",
  flexDirection: "column"
};
var useControllerSectionStyles = makeStyles8(() => ({
  root: __spreadProps(__spreadValues({}, sharedControllerStyles), {
    padding: "0px 8px"
  })
}));
var StyledExpansionPanelDetails = withStyles(() => ({
  root: __spreadProps(__spreadValues({}, sharedControllerStyles), {
    padding: "8px 8px 24px 8px"
  })
}))(ExpansionPanelDetails);
var StyledExpansionPanelSummary = withStyles((theme) => ({
  root: {
    padding: "0px 8px"
  },
  content: {
    margin: "4px 0px",
    minWidth: "0px"
  },
  expanded: {
    marginBottom: theme.spacing(-3),
    top: theme.spacing(-1)
  },
  expandIcon: {
    "&$expanded": {
      top: theme.spacing(-1.3)
    }
  }
}))(ExpansionPanelSummary);
var StyledInputLabel = withStyles(() => ({
  root: {
    fontSize: "14px"
  }
}))(InputLabel);
var OverflowEllipsisGrid = withStyles(() => ({
  item: {
    width: "100%",
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis"
  }
}))(Grid);
var StyledSelectionSlider = withStyles(() => ({
  root: {
    marginTop: "7px"
  },
  markActive: {
    backgroundColor: "rgba(128, 128, 128, 0.7)"
  }
}))(Slider4);

// src/components/layer-controller/shared-channel-controls.js
function ChannelSelectionDropdown({
  handleChange,
  disabled,
  channelOptions,
  selectionIndex
}) {
  const classes = useSelectStyles();
  return /* @__PURE__ */ React54.createElement(Select2, {
    classes: { root: classes.selectRoot },
    native: true,
    value: selectionIndex,
    onChange: (e) => handleChange(Number(e.target.value))
  }, channelOptions.map((opt, i) => /* @__PURE__ */ React54.createElement("option", {
    disabled,
    key: opt,
    value: i
  }, opt)));
}
function ChannelVisibilityCheckbox({
  color,
  checked,
  toggle,
  disabled
}) {
  return /* @__PURE__ */ React54.createElement(Checkbox3, {
    onChange: toggle,
    checked,
    disabled,
    style: { color, "&$checked": { color } }
  });
}

// src/components/layer-controller/RasterChannelController.js
var toRgbUIString = (on, arr, theme) => {
  const color = on || theme === "light" && arr.every((i) => i === 255) ? [220, 220, 220] : arr;
  return `rgb(${color})`;
};
function abbreviateNumber2(value) {
  const maxLength = 5;
  let maxNaiveDigits = maxLength;
  if (!Number.isInteger(value)) {
    --maxNaiveDigits;
  }
  if (value < 1) {
    --maxNaiveDigits;
  }
  const naive = Intl.NumberFormat("en-US", {
    maximumSignificantDigits: maxNaiveDigits,
    useGrouping: false
  }).format(value);
  if (naive.length <= maxLength)
    return naive;
  return value.toExponential(0);
}
function ChannelSlider({
  color,
  slider = [0, 0],
  handleChange,
  domain = [0, 0],
  dtype,
  disabled
}) {
  const [min, max2] = domain;
  const handleChangeDebounced = useCallback12(debounce5(handleChange, 3, { trailing: true }), [handleChange]);
  const step = max2 - min < 500 && dtype === "Float32" ? (max2 - min) / 500 : 1;
  return /* @__PURE__ */ React55.createElement(Slider5, {
    value: slider,
    valueLabelFormat: abbreviateNumber2,
    onChange: (e, v) => handleChangeDebounced(v),
    valueLabelDisplay: "auto",
    getAriaLabel: () => `${color}-${slider}`,
    min,
    max: max2,
    step,
    orientation: "horizontal",
    style: { color, marginTop: "7px" },
    disabled
  });
}
function RasterChannelController({
  visibility = false,
  slider,
  color,
  channels: channels2,
  channelId,
  domainType: newDomainType,
  dimName,
  theme,
  loader,
  colormapOn,
  channelOptions,
  handlePropertyChange,
  handleChannelRemove,
  handleIQRUpdate,
  selectionIndex,
  isLoading,
  use3d: newUse3d
}) {
  const { dtype } = getSourceFromLoader(loader);
  const [domain, setDomain] = useState17(null);
  const [domainType, setDomainType] = useState17(null);
  const [use3d, setUse3d] = useState17(null);
  const [selection, setSelection] = useState17([
    __spreadValues({}, channels2[channelId].selection)
  ]);
  const rgbColor = toRgbUIString(colormapOn, color, theme);
  useEffect17(() => {
    let mounted = true;
    if (dtype && loader && channels2) {
      const selections = [__spreadValues({}, channels2[channelId].selection)];
      let domains;
      const hasDomainChanged = newDomainType !== domainType;
      const has3dChanged = use3d !== newUse3d;
      const hasSelectionChanged = !isEqual12(selections, selection);
      if (hasDomainChanged || hasSelectionChanged || has3dChanged) {
        if (newDomainType === "Full") {
          domains = [DOMAINS[dtype]];
          const [newDomain] = domains;
          if (mounted) {
            setDomain(newDomain);
            setDomainType(newDomainType);
            if (hasSelectionChanged) {
              setSelection(selections);
            }
            if (has3dChanged) {
              setUse3d(newUse3d);
            }
          }
        } else {
          getMultiSelectionStats({
            loader: loader.data,
            selections,
            use3d: newUse3d
          }).then((stats) => {
            domains = stats.domains;
            const [newDomain] = domains;
            if (mounted) {
              setDomain(newDomain);
              setDomainType(newDomainType);
              if (hasSelectionChanged) {
                setSelection(selections);
              }
              if (has3dChanged) {
                setUse3d(newUse3d);
              }
            }
          });
        }
      }
    }
    return () => {
      mounted = false;
    };
  }, [
    domainType,
    channels2,
    channelId,
    loader,
    dtype,
    newDomainType,
    selection,
    newUse3d,
    use3d
  ]);
  const createSelection = (index) => ({ [dimName]: index });
  return /* @__PURE__ */ React55.createElement(Grid2, {
    container: true,
    direction: "column",
    m: 1,
    justify: "center"
  }, /* @__PURE__ */ React55.createElement(Grid2, {
    container: true,
    direction: "row",
    justify: "space-between"
  }, /* @__PURE__ */ React55.createElement(Grid2, {
    item: true,
    xs: 10
  }, /* @__PURE__ */ React55.createElement(ChannelSelectionDropdown, {
    handleChange: (v) => handlePropertyChange("selection", createSelection(v)),
    selectionIndex,
    channelOptions,
    disabled: isLoading
  })), /* @__PURE__ */ React55.createElement(Grid2, {
    item: true,
    xs: 1,
    style: { marginTop: "4px" }
  }, /* @__PURE__ */ React55.createElement(ChannelOptions_default, {
    handlePropertyChange,
    handleChannelRemove,
    handleIQRUpdate,
    disabled: isLoading
  }))), /* @__PURE__ */ React55.createElement(Grid2, {
    container: true,
    direction: "row",
    justify: "space-between"
  }, /* @__PURE__ */ React55.createElement(Grid2, {
    item: true,
    xs: 2
  }, /* @__PURE__ */ React55.createElement(ChannelVisibilityCheckbox, {
    color: rgbColor,
    checked: visibility,
    toggle: () => handlePropertyChange("visible", !visibility),
    disabled: isLoading
  })), /* @__PURE__ */ React55.createElement(Grid2, {
    item: true,
    xs: 9
  }, /* @__PURE__ */ React55.createElement(ChannelSlider, {
    color: rgbColor,
    slider,
    domain: domain || DOMAINS[dtype],
    dtype,
    handleChange: (v) => handlePropertyChange("slider", v),
    disabled: isLoading
  }))));
}
var RasterChannelController_default = RasterChannelController;

// src/components/layer-controller/BitmaskChannelController.js
import React56 from "react";
import RemoveCircleIcon from "@material-ui/icons/RemoveCircle";
import IconButton5 from "@material-ui/core/IconButton";
import Grid3 from "@material-ui/core/Grid";
function BitmaskChannelController({
  visibility = false,
  dimName,
  channelOptions,
  handlePropertyChange,
  handleChannelRemove,
  selectionIndex,
  disableOptions = false
}) {
  const createSelection = (index) => ({ [dimName]: index });
  return /* @__PURE__ */ React56.createElement(Grid3, {
    container: true,
    direction: "row",
    justify: "space-between"
  }, /* @__PURE__ */ React56.createElement(Grid3, {
    item: true,
    xs: 2
  }, /* @__PURE__ */ React56.createElement(ChannelVisibilityCheckbox, {
    color: [220, 220, 220],
    checked: visibility,
    toggle: () => handlePropertyChange("visible", !visibility)
  })), /* @__PURE__ */ React56.createElement(Grid3, {
    item: true,
    xs: 9
  }, /* @__PURE__ */ React56.createElement(ChannelSelectionDropdown, {
    handleChange: (v) => handlePropertyChange("selection", createSelection(v)),
    selectionIndex,
    disableOptions,
    channelOptions
  })), /* @__PURE__ */ React56.createElement(Grid3, {
    item: true,
    xs: 1
  }, /* @__PURE__ */ React56.createElement(IconButton5, {
    onClick: handleChannelRemove,
    style: { padding: "6px 6px 6px 0px" }
  }, /* @__PURE__ */ React56.createElement(RemoveCircleIcon, null))));
}
var BitmaskChannelController_default = BitmaskChannelController;

// src/components/layer-controller/VectorLayerController.js
import React57 from "react";
import Grid4 from "@material-ui/core/Grid";
import Checkbox4 from "@material-ui/core/Checkbox";
import Paper3 from "@material-ui/core/Paper";
import Typography from "@material-ui/core/Typography";
import Slider6 from "@material-ui/core/Slider";
function VectorLayerController(props) {
  const {
    label,
    layer,
    layerType,
    handleLayerChange
  } = props;
  const slider = layer.opacity;
  const isOn = layer.visible;
  function handleSliderChange(v) {
    if (layerType === "cells") {
      const stroked = v < 0.7;
      handleLayerChange(__spreadProps(__spreadValues({}, layer), { opacity: v, stroked }));
    } else {
      handleLayerChange(__spreadProps(__spreadValues({}, layer), { opacity: v }));
    }
  }
  function handleCheckBoxChange(v) {
    handleLayerChange(__spreadProps(__spreadValues({}, layer), { visible: v }));
  }
  const classes = useControllerSectionStyles();
  return /* @__PURE__ */ React57.createElement(Grid4, {
    item: true,
    style: { marginTop: "10px" }
  }, /* @__PURE__ */ React57.createElement(Paper3, {
    className: classes.root
  }, /* @__PURE__ */ React57.createElement(Typography, {
    style: {
      padding: "15px 8px 0px 8px",
      marginBottom: "-5px"
    }
  }, label), /* @__PURE__ */ React57.createElement(Grid4, {
    container: true,
    direction: "row",
    justify: "space-between"
  }, /* @__PURE__ */ React57.createElement(Grid4, {
    item: true,
    xs: 2
  }, /* @__PURE__ */ React57.createElement(Checkbox4, {
    color: "primary",
    checked: isOn,
    onChange: (e, v) => handleCheckBoxChange(v)
  })), /* @__PURE__ */ React57.createElement(Grid4, {
    item: true,
    xs: 9,
    style: { paddingRight: "8px" }
  }, /* @__PURE__ */ React57.createElement(Slider6, {
    value: slider,
    min: 0,
    max: 1,
    step: 1e-3,
    onChange: (e, v) => handleSliderChange(v),
    style: { marginTop: "7px" },
    orientation: "horizontal"
  })))));
}

// src/components/layer-controller/LayerController.js
import React60, { useState as useState18, useRef as useRef8, useEffect as useEffect18 } from "react";
import Grid7 from "@material-ui/core/Grid";
import Button2 from "@material-ui/core/Button";
import AddIcon from "@material-ui/icons/Add";
import Slider9 from "@material-ui/core/Slider";
import Tabs from "@material-ui/core/Tabs";
import Tab from "@material-ui/core/Tab";
import ExpansionPanel from "@material-ui/core/ExpansionPanel";
import ExpandMoreIcon from "@material-ui/icons/ExpandMore";
import VisibilityIcon from "@material-ui/icons/Visibility";
import VisibilityOffIcon from "@material-ui/icons/VisibilityOff";

// src/components/layer-controller/LayerOptions.js
import React58 from "react";
import range9 from "lodash/range";
import { Matrix4 as Matrix45 } from "math.gl";
import Grid5 from "@material-ui/core/Grid";
import Slider7 from "@material-ui/core/Slider";
import InputLabel2 from "@material-ui/core/InputLabel";
import Select3 from "@material-ui/core/Select";
import Checkbox5 from "@material-ui/core/Checkbox";
var DOMAIN_OPTIONS = ["Full", "Min/Max"];
function VolumeDropdown({
  loader: loaderWithMeta,
  handleMultiPropertyChange,
  resolution: currResolution,
  disable3d,
  setRasterLayerCallback,
  setAreAllChannelsLoading,
  setViewState,
  spatialHeight,
  spatialWidth,
  channels: channels2,
  use3d,
  modelMatrix
}) {
  const classes = useSelectStyles();
  const selections = channels2.map((i) => i.selection);
  const { data: loader } = loaderWithMeta;
  const handleChange = (val) => __async(this, null, function* () {
    const shouldUse3D = typeof val === "number";
    setAreAllChannelsLoading(true);
    setRasterLayerCallback(() => {
      setAreAllChannelsLoading(false);
      setRasterLayerCallback(null);
    });
    if (shouldUse3D) {
      const [xSlice, ySlice, zSlice] = getBoundingCube(loader);
      const propertiesChanged = {
        resolution: val,
        xSlice,
        ySlice,
        zSlice,
        use3d: shouldUse3D
      };
      if (!use3d) {
        const { sliders } = yield getMultiSelectionStats({
          loader,
          selections,
          use3d: shouldUse3D
        });
        propertiesChanged.channels = [...channels2];
        propertiesChanged.channels.forEach((ch, i) => {
          ch.slider = sliders[i];
        });
      }
      handleMultiPropertyChange(propertiesChanged);
      const defaultViewState = getDefaultInitialViewState(loader, { height: spatialHeight, width: spatialWidth }, 1.5, true, new Matrix45(modelMatrix));
      setViewState(__spreadProps(__spreadValues({}, defaultViewState), {
        rotationX: 0,
        rotationOrbit: 0
      }));
    } else {
      const { sliders } = yield getMultiSelectionStats({
        loader,
        selections,
        use3d: shouldUse3D
      });
      const newChannels = [...channels2];
      newChannels.forEach((ch, i) => {
        ch.slider = sliders[i];
      });
      handleMultiPropertyChange({
        resolution: val,
        use3d: shouldUse3D,
        spatialAxisFixed: false,
        channels: newChannels
      });
      const defaultViewState = getDefaultInitialViewState(loader, { height: spatialHeight, width: spatialWidth }, 0.5, false, new Matrix45(modelMatrix));
      setViewState(__spreadProps(__spreadValues({}, defaultViewState), {
        rotationX: null,
        rotationOrbit: null,
        orbitAxis: null
      }));
    }
  });
  const { labels, shape } = Array.isArray(loader) ? loader[0] : loader;
  const hasZStack = shape[labels.indexOf("z")] > 1;
  return /* @__PURE__ */ React58.createElement(React58.Fragment, null, /* @__PURE__ */ React58.createElement(Select3, {
    native: true,
    value: currResolution,
    onChange: (e) => handleChange(e.target.value === "2D" ? e.target.value : Number(e.target.value)),
    classes: { root: classes.selectRoot }
  }, /* @__PURE__ */ React58.createElement("option", {
    key: "2D",
    value: "2D"
  }, "2D Visualization"), Array.from({ length: loader.length }).fill(0).map((_, resolution) => {
    if (loader) {
      if (canLoadResolution(loader, resolution)) {
        const {
          height,
          width,
          depthDownsampled,
          totalBytes
        } = getStatsForResolution(loader, resolution);
        return /* @__PURE__ */ React58.createElement("option", {
          key: `(${height}, ${width}, ${depthDownsampled})`,
          value: resolution,
          disabled: disable3d || !hasZStack
        }, `3D: ${resolution}x Downsampled, ~${formatBytes(totalBytes)} per channel, (${height}, ${width}, ${depthDownsampled})`);
      }
    }
    return null;
  })));
}
function ColormapSelect({ value, inputId, handleChange }) {
  const classes = useSelectStyles();
  return /* @__PURE__ */ React58.createElement(Select3, {
    native: true,
    onChange: (e) => handleChange(e.target.value === "" ? null : e.target.value),
    value,
    inputProps: { name: "colormap", id: inputId },
    style: { width: "100%" },
    classes: { root: classes.selectRoot }
  }, /* @__PURE__ */ React58.createElement("option", {
    "aria-label": "None",
    value: ""
  }, "None"), COLORMAP_OPTIONS.map((name2) => /* @__PURE__ */ React58.createElement("option", {
    key: name2,
    value: name2
  }, name2)));
}
function TransparentColorCheckbox({ value, handleChange }) {
  return /* @__PURE__ */ React58.createElement(Checkbox5, {
    style: { float: "left", padding: 0 },
    color: "default",
    onChange: () => {
      if (value) {
        handleChange(null);
      } else {
        handleChange([0, 0, 0]);
      }
    },
    checked: Boolean(value)
  });
}
function OpacitySlider({ value, handleChange }) {
  return /* @__PURE__ */ React58.createElement(Slider7, {
    value,
    onChange: (e, v) => handleChange(v),
    valueLabelDisplay: "auto",
    getAriaLabel: () => "opacity slider",
    min: 0,
    max: 1,
    step: 0.01,
    orientation: "horizontal",
    style: { marginTop: "7px" }
  });
}
function SliderDomainSelector({ value, inputId, handleChange }) {
  const classes = useSelectStyles();
  return /* @__PURE__ */ React58.createElement(Select3, {
    native: true,
    onChange: (e) => handleChange(e.target.value),
    value,
    inputProps: { name: "domain-selector", id: inputId },
    style: { width: "100%" },
    classes: { root: classes.selectRoot }
  }, DOMAIN_OPTIONS.map((name2) => /* @__PURE__ */ React58.createElement("option", {
    key: name2,
    value: name2
  }, name2)));
}
function GlobalSelectionSlider({
  field,
  value,
  handleChange,
  possibleValues
}) {
  return /* @__PURE__ */ React58.createElement(StyledSelectionSlider, {
    value,
    onChange: (event, newValue) => {
      handleChange({ selection: { [field]: newValue }, event });
    },
    onChangeCommitted: (event, newValue) => {
      handleChange({ selection: { [field]: newValue }, event });
    },
    valueLabelDisplay: "auto",
    getAriaLabel: () => `${field} slider`,
    marks: possibleValues.map((val) => ({ value: val })),
    min: Number(possibleValues[0]),
    max: Number(possibleValues.slice(-1)),
    orientation: "horizontal",
    step: null
  });
}
function LayerOption({ name: name2, inputId, children }) {
  return /* @__PURE__ */ React58.createElement(Grid5, {
    container: true,
    direction: "row",
    alignItems: "center",
    justify: "center"
  }, /* @__PURE__ */ React58.createElement(Grid5, {
    item: true,
    xs: 6
  }, /* @__PURE__ */ React58.createElement(InputLabel2, {
    htmlFor: inputId
  }, name2, ":")), /* @__PURE__ */ React58.createElement(Grid5, {
    item: true,
    xs: 6
  }, children));
}
function LayerOptions({
  colormap,
  opacity,
  handleColormapChange,
  handleOpacityChange,
  handleTransparentColorChange,
  globalControlLabels,
  globalLabelValues,
  handleGlobalChannelsSelectionChange,
  handleSliderChange,
  handleDomainChange,
  transparentColor,
  channels: channels2,
  domainType,
  disableChannelsIfRgbDetected,
  shouldShowTransparentColor,
  shouldShowDomain,
  shouldShowColormap,
  use3d,
  loader,
  handleMultiPropertyChange,
  resolution,
  disable3d,
  setRasterLayerCallback,
  setAreAllChannelsLoading,
  setViewState,
  spatialHeight,
  spatialWidth,
  modelMatrix
}) {
  const { labels, shape } = Array.isArray(loader.data) ? loader.data[0] : loader.data;
  const hasDimensionsAndChannels = labels.length > 0 && channels2.length > 0;
  const hasZStack = shape[labels.indexOf("z")] > 1;
  const hasViewableResolutions = Boolean(Array.from({
    length: loader.data.length
  }).filter((_, res) => canLoadResolution(loader.data, res)).length);
  return /* @__PURE__ */ React58.createElement(Grid5, {
    container: true,
    direction: "column",
    style: { width: "100%" }
  }, hasZStack && !disable3d && hasViewableResolutions && /* @__PURE__ */ React58.createElement(VolumeDropdown, {
    loader,
    handleSliderChange,
    handleDomainChange,
    channels: channels2,
    handleMultiPropertyChange,
    resolution,
    disable3d,
    setRasterLayerCallback,
    setAreAllChannelsLoading,
    setViewState,
    spatialHeight,
    spatialWidth,
    use3d,
    modelMatrix
  }), hasDimensionsAndChannels && !use3d && globalControlLabels.map((field) => shape[labels.indexOf(field)] > 1 && /* @__PURE__ */ React58.createElement(LayerOption, {
    name: field,
    inputId: `${field}-slider`,
    key: field
  }, /* @__PURE__ */ React58.createElement(GlobalSelectionSlider, {
    field,
    value: globalLabelValues[field],
    handleChange: handleGlobalChannelsSelectionChange,
    possibleValues: range9(shape[labels.indexOf(field)])
  }))), !disableChannelsIfRgbDetected ? /* @__PURE__ */ React58.createElement(React58.Fragment, null, shouldShowColormap && /* @__PURE__ */ React58.createElement(Grid5, {
    item: true
  }, /* @__PURE__ */ React58.createElement(LayerOption, {
    name: "Colormap",
    inputId: "colormap-select"
  }, /* @__PURE__ */ React58.createElement(ColormapSelect, {
    value: colormap || "",
    inputId: "colormap-select",
    handleChange: handleColormapChange
  }))), shouldShowDomain && /* @__PURE__ */ React58.createElement(Grid5, {
    item: true
  }, /* @__PURE__ */ React58.createElement(LayerOption, {
    name: "Domain",
    inputId: "domain-selector"
  }, /* @__PURE__ */ React58.createElement(SliderDomainSelector, {
    value: domainType || DEFAULT_RASTER_DOMAIN_TYPE,
    handleChange: (value) => {
      handleDomainChange(value);
    }
  })))) : null, !use3d && /* @__PURE__ */ React58.createElement(Grid5, {
    item: true
  }, /* @__PURE__ */ React58.createElement(LayerOption, {
    name: "Opacity",
    inputId: "opacity-slider"
  }, /* @__PURE__ */ React58.createElement(OpacitySlider, {
    value: opacity,
    handleChange: handleOpacityChange
  }))), shouldShowTransparentColor && !use3d && /* @__PURE__ */ React58.createElement(Grid5, {
    item: true
  }, /* @__PURE__ */ React58.createElement(LayerOption, {
    name: "Zero Transparent",
    inputId: "transparent-color-selector"
  }, /* @__PURE__ */ React58.createElement(TransparentColorCheckbox, {
    value: transparentColor,
    handleChange: handleTransparentColorChange
  }))));
}
var LayerOptions_default = LayerOptions;

// src/components/layer-controller/VolumeOptions.js
import React59 from "react";
import { Matrix4 as Matrix46 } from "math.gl";
import Grid6 from "@material-ui/core/Grid";
import Typography2 from "@material-ui/core/Typography";
import Button from "@material-ui/core/Button";
import { makeStyles as makeStyles9, createStyles as createStyles2 } from "@material-ui/core/styles";
import FormControl from "@material-ui/core/FormControl";
import Select4 from "@material-ui/core/Select";
import InputLabel3 from "@material-ui/core/InputLabel";
import Slider8 from "@material-ui/core/Slider";
var useSlicerStyles = makeStyles9((theme) => createStyles2({
  enabled: {},
  disabled: {
    color: theme.palette.text.disabled,
    "& .MuiSlider-thumb": {
      color: "rgb(100, 100, 100, 1.0)"
    },
    "&  .MuiSlider-track": {
      color: "rgb(100, 100, 100, 1.0)"
    }
  }
}));
var Slicer = ({
  xSlice,
  ySlice,
  zSlice,
  handleSlicerSetting,
  loader,
  use3d
}) => {
  const [xSliceInit, ySliceInit, zSliceInit] = getBoundingCube(loader.data);
  const sliceValuesAndSetSliceFunctions = [
    [
      xSlice,
      (xSliceNew) => handleSlicerSetting("x", xSliceNew),
      "x",
      xSliceInit
    ],
    [
      ySlice,
      (ySliceNew) => handleSlicerSetting("y", ySliceNew),
      "y",
      ySliceInit
    ],
    [
      zSlice,
      (zSliceNew) => handleSlicerSetting("z", zSliceNew),
      "z",
      zSliceInit
    ]
  ];
  const classes = useSlicerStyles();
  const Slicers = sliceValuesAndSetSliceFunctions.map(([val, setVal, label, [min, max2]]) => /* @__PURE__ */ React59.createElement(Grid6, {
    container: true,
    direction: "row",
    justify: "flex-start",
    alignItems: "center",
    key: label
  }, /* @__PURE__ */ React59.createElement(Grid6, {
    item: true,
    xs: 1
  }, /* @__PURE__ */ React59.createElement(Typography2, {
    className: !use3d ? classes.disabled : classes.enabled,
    style: { marginBottom: 0 }
  }, label, ":")), /* @__PURE__ */ React59.createElement(Grid6, {
    item: true,
    xs: 11
  }, /* @__PURE__ */ React59.createElement(Slider8, {
    disabled: !use3d,
    className: !use3d ? classes.disabled : classes.enabled,
    value: val,
    onChange: (e, v) => setVal(v),
    valueLabelDisplay: "auto",
    valueLabelFormat: (v) => abbreviateNumber(v),
    getAriaLabel: () => `${label} slider`,
    min,
    max: max2,
    step: 5e-3,
    orientation: "horizontal"
  }))));
  return /* @__PURE__ */ React59.createElement(React59.Fragment, null, /* @__PURE__ */ React59.createElement(Typography2, {
    className: !use3d ? classes.disabled : classes.enabled,
    style: { marginTop: 16, marginBottom: 0 }
  }, "Clipping Planes:", " "), " ", Slicers);
};
var renderingOptions = Object.values(RENDERING_MODES);
function RenderingModeSelect({
  handleRenderingModeChange,
  renderingMode,
  use3d
}) {
  const classes = useSelectStyles();
  const options = !use3d ? [...renderingOptions, ""] : renderingOptions;
  return /* @__PURE__ */ React59.createElement(FormControl, {
    fullWidth: true
  }, /* @__PURE__ */ React59.createElement(InputLabel3, {
    htmlFor: "rendering-mode-select"
  }, "Rendering Mode"), /* @__PURE__ */ React59.createElement(Select4, {
    native: true,
    onChange: (e) => handleRenderingModeChange(e.target.value),
    value: use3d ? renderingMode : "",
    inputProps: {
      name: "rendering-mode",
      id: "rendering-mode-select"
    },
    disabled: !use3d,
    classes: { root: classes.selectRoot }
  }, options.map((name2) => /* @__PURE__ */ React59.createElement("option", {
    key: name2,
    value: name2
  }, name2))));
}
var ReCenterButton = ({
  setViewState,
  use3d,
  spatialHeight,
  spatialWidth,
  loader,
  modelMatrix
}) => /* @__PURE__ */ React59.createElement(Grid6, {
  item: true,
  xs: "auto",
  key: "recenter"
}, /* @__PURE__ */ React59.createElement(Button, {
  onClick: () => {
    const defaultViewState = getDefaultInitialViewState(loader.data, { height: spatialHeight, width: spatialWidth }, 1.5, use3d, new Matrix46(modelMatrix));
    setViewState(__spreadProps(__spreadValues({}, defaultViewState), {
      rotationX: 0,
      rotationOrbit: 0
    }));
  },
  disabled: !use3d,
  style: {
    padding: 0,
    marginBottom: 6
  }
}, "Re-Center"));
var VolumeOptions = ({
  handleSlicerSetting,
  handleRenderingModeChange,
  renderingMode,
  xSlice,
  ySlice,
  zSlice,
  use3d,
  loader,
  setViewState,
  spatialHeight,
  spatialWidth,
  modelMatrix
}) => /* @__PURE__ */ React59.createElement(React59.Fragment, null, /* @__PURE__ */ React59.createElement(RenderingModeSelect, {
  handleRenderingModeChange,
  renderingMode,
  use3d
}), /* @__PURE__ */ React59.createElement(Slicer, {
  xSlice,
  ySlice,
  zSlice,
  handleSlicerSetting,
  use3d,
  loader
}), /* @__PURE__ */ React59.createElement(ReCenterButton, {
  setViewState,
  use3d,
  spatialHeight,
  spatialWidth,
  loader,
  modelMatrix
}));
var VolumeOptions_default = VolumeOptions;

// src/components/layer-controller/LayerController.js
function TabPanel(props) {
  const _a2 = props, {
    children,
    value,
    index
  } = _a2, other = __objRest(_a2, [
    "children",
    "value",
    "index"
  ]);
  return /* @__PURE__ */ React60.createElement("div", __spreadValues({
    role: "tabpanel",
    hidden: value !== index,
    id: `simple-tabpanel-${index}`,
    "aria-labelledby": `simple-tab-${index}`
  }, other), value === index && children);
}
function getDomainsAndSliders(loader, selections, domainType, use3d) {
  return __async(this, null, function* () {
    let domains;
    const stats = yield getMultiSelectionStats({
      loader: loader.data,
      selections,
      use3d
    });
    const { sliders } = stats;
    if (domainType === "Min/Max") {
      domains = stats.domains;
    }
    if (domainType === "Full") {
      const source = getSourceFromLoader(loader);
      domains = selections.map(() => DOMAINS[source.dtype]);
    }
    return { domains, sliders };
  });
}
var buttonStyles = {
  borderStyle: "dashed",
  marginTop: "10px",
  fontWeight: 400
};
function LayerController(props) {
  var _a2;
  const {
    layer,
    name: name2,
    loader,
    theme,
    handleLayerRemove,
    handleLayerChange,
    shouldShowTransparentColor,
    shouldShowDomain,
    shouldShowColormap,
    ChannelController,
    setViewState,
    disable3d,
    setRasterLayerCallback,
    setAreLayerChannelsLoading,
    areLayerChannelsLoading,
    disabled,
    spatialHeight,
    spatialWidth,
    disableChannelsIfRgbDetected,
    shouldShowRemoveLayerButton
  } = props;
  const {
    colormap,
    opacity,
    channels: channels2,
    transparentColor,
    renderingMode,
    xSlice,
    ySlice,
    zSlice,
    resolution,
    use3d,
    modelMatrix
  } = layer;
  const channelRef = useRef8(channels2);
  useEffect18(() => {
    channelRef.current = channels2;
    return void 0;
  }, [channels2]);
  const firstSelection = ((_a2 = channels2[0]) == null ? void 0 : _a2.selection) || {};
  const { data, channels: channelOptions } = loader;
  const [tab, setTab] = useState18(0);
  const handleTabChange = (event, newTab) => {
    setTab(newTab);
  };
  const { labels, shape } = Array.isArray(data) ? data[data.length - 1] : data;
  const [domainType, setDomainType] = useState18(layer.domainType);
  const [isExpanded, setIsExpanded] = useState18(true);
  const [globalLabelValues, setGlobalLabelValues] = useState18(GLOBAL_LABELS.filter((field) => typeof firstSelection[field] === "number").reduce((o, key) => __spreadProps(__spreadValues({}, o), { [key]: firstSelection[key] }), {}));
  function setVisible(v) {
    handleLayerChange(__spreadProps(__spreadValues({}, layer), { visible: v }));
  }
  function setColormap(v) {
    handleLayerChange(__spreadProps(__spreadValues({}, layer), { colormap: v }));
  }
  function setOpacity(v) {
    handleLayerChange(__spreadProps(__spreadValues({}, layer), { opacity: v }));
  }
  function setChannels(v) {
    handleLayerChange(__spreadProps(__spreadValues({}, layer), { channels: v }));
  }
  function setTransparentColor(v) {
    handleLayerChange(__spreadProps(__spreadValues({}, layer), { transparentColor: v }));
  }
  function setRenderingMode(v) {
    handleLayerChange(__spreadProps(__spreadValues({}, layer), { renderingMode: v }));
  }
  function handleMultiPropertyChange(obj) {
    handleLayerChange(__spreadValues(__spreadValues({}, layer), obj));
  }
  function handleSlicerSetting(slice3, val) {
    handleLayerChange(__spreadProps(__spreadValues({}, layer), { [`${slice3}Slice`]: val }));
  }
  function setChannelsAndDomainType(newChannels, newDomainType) {
    handleLayerChange(__spreadProps(__spreadValues({}, layer), {
      channels: newChannels,
      domainType: newDomainType
    }));
  }
  function setChannel(v, i) {
    const newChannels = [...channelRef.current];
    newChannels[i] = v;
    handleLayerChange(__spreadProps(__spreadValues({}, layer), { channels: newChannels }));
  }
  function addChannel(v) {
    const newChannels = [...channelRef.current, v];
    handleLayerChange(__spreadProps(__spreadValues({}, layer), { channels: newChannels }));
  }
  function removeChannel(i) {
    const newChannels = [...channelRef.current];
    newChannels.splice(i, 1);
    handleLayerChange(__spreadProps(__spreadValues({}, layer), { channels: newChannels }));
  }
  const setAreAllChannelsLoading = (val) => {
    const newAreLayerChannelsLoading = channelRef.current.map(() => val);
    setAreLayerChannelsLoading(newAreLayerChannelsLoading);
  };
  const handleChannelAdd = () => __async(this, null, function* () {
    const selection = {};
    labels.forEach((label) => {
      selection[label] = GLOBAL_LABELS.includes(label) ? globalLabelValues[label] || 0 : 0;
    });
    const { domains, sliders } = yield getDomainsAndSliders(loader, [selection], domainType, use3d);
    const domain = domains[0];
    const slider = domain;
    const color = [255, 255, 255];
    const visible2 = true;
    const newChannelId = channels2.length;
    const newAreLayerChannelsLoading = [...areLayerChannelsLoading];
    newAreLayerChannelsLoading[newChannelId] = true;
    setAreLayerChannelsLoading(newAreLayerChannelsLoading);
    const channel = {
      selection,
      slider,
      visible: visible2,
      color
    };
    setRasterLayerCallback(() => {
      setChannel(__spreadProps(__spreadValues({}, channel), { slider: sliders[0] }), newChannelId);
      const areLayerChannelsLoadingCallback = [...newAreLayerChannelsLoading];
      areLayerChannelsLoadingCallback[newChannelId] = false;
      setAreLayerChannelsLoading(areLayerChannelsLoadingCallback);
      setRasterLayerCallback(null);
    });
    addChannel(channel);
  });
  const handleDomainChange = (value) => __async(this, null, function* () {
    setDomainType(value);
    const selections = channels2.map((channel) => channel.selection);
    let sliders = channels2.map((channel) => channel.slider);
    const { domains } = yield getDomainsAndSliders(loader, selections, value, use3d);
    sliders = sliders.map((slider, i) => {
      const [left, right] = slider;
      return [Math.max(left, domains[i][0]), Math.min(right, domains[i][1])];
    });
    const newChannels = channels2.map((c, i) => __spreadProps(__spreadValues({}, c), { slider: sliders[i] }));
    setChannelsAndDomainType(newChannels, value);
  });
  const handleGlobalChannelsSelectionChange = (_0) => __async(this, [_0], function* ({ selection, event }) {
    const selections = channels2.map((channel) => __spreadValues(__spreadValues({}, channel.selection), selection));
    const canUpdateChannels = event.type === "mouseup" || event.type === "keydown";
    if (canUpdateChannels) {
      setAreAllChannelsLoading(true);
      getDomainsAndSliders(loader, selections, domainType, use3d).then(({ sliders }) => {
        const newChannelsWithSelection = channels2.map((c) => __spreadProps(__spreadValues({}, c), {
          selection: __spreadValues(__spreadValues({}, c.selection), selection)
        }));
        setRasterLayerCallback(() => {
          setRasterLayerCallback(null);
          setAreAllChannelsLoading(false);
          const newChannelsWithSliders = [...newChannelsWithSelection].map((c, i) => __spreadProps(__spreadValues({}, c), {
            slider: sliders[i]
          }));
          setChannels(newChannelsWithSliders);
        });
        setChannels(newChannelsWithSelection);
      });
    }
    setGlobalLabelValues((prev) => __spreadValues(__spreadValues({}, prev), selection));
  });
  let channelControllers = [];
  if (labels.length > 0) {
    const channelLabel = labels.find((c) => c === "channel" || c === "c") || labels[0];
    channelControllers = channels2.map((c, channelId) => {
      const setIsLoading = (val) => {
        const newAreLayerChannelsLoading = [...areLayerChannelsLoading];
        newAreLayerChannelsLoading[channelId] = val;
        setAreLayerChannelsLoading(newAreLayerChannelsLoading);
      };
      const handleChannelPropertyChange = (property, value) => {
        const update = { [property]: value };
        if (property === "selection") {
          setIsLoading(true);
          update.selection = __spreadValues(__spreadValues({}, globalLabelValues), update.selection);
          setChannel(__spreadValues(__spreadValues({}, c), update), channelId);
          setRasterLayerCallback(() => __async(this, null, function* () {
            const selections = [
              __spreadValues(__spreadValues({}, channels2[channelId][property]), value)
            ];
            const { sliders } = yield getDomainsAndSliders(loader, selections, domainType, use3d);
            [update.slider] = sliders;
            setChannel(__spreadValues(__spreadValues({}, c), update), channelId);
            setRasterLayerCallback(null);
            setIsLoading(false);
          }));
        } else {
          setChannel(__spreadValues(__spreadValues({}, c), update), channelId);
        }
      };
      const handleChannelRemove = () => {
        removeChannel(channelId);
      };
      const handleIQRUpdate = () => __async(this, null, function* () {
        const { data: loaderData } = loader;
        const source = Array.isArray(loaderData) ? loaderData[loaderData.length - 1] : loaderData;
        const raster = yield source.getRaster({
          selection: channels2[channelId].selection
        });
        const stats = getChannelStats(raster.data);
        const { q1, q3 } = stats;
        setChannel(__spreadProps(__spreadValues({}, c), { slider: [q1, q3] }), channelId);
      });
      return /* @__PURE__ */ React60.createElement(ChannelController, {
        key: `channel-controller-${channelId}`,
        dimName: channelLabel,
        visibility: c.visible,
        selectionIndex: c.selection[channelLabel],
        slider: c.slider,
        color: c.color,
        channels: channels2,
        channelId,
        domainType,
        loader,
        globalLabelValues,
        theme,
        channelOptions,
        colormapOn: Boolean(colormap),
        handlePropertyChange: handleChannelPropertyChange,
        handleChannelRemove,
        handleIQRUpdate,
        setRasterLayerCallback,
        isLoading: areLayerChannelsLoading[channelId],
        use3d
      });
    });
  }
  const controllerSectionClasses = useControllerSectionStyles();
  const { visible } = layer;
  const visibleSetting = typeof visible === "boolean" ? visible : true;
  const Visibility = visibleSetting ? VisibilityIcon : VisibilityOffIcon;
  const hasViewableResolutions = Boolean(Array.from({
    length: loader.data.length
  }).filter((_, res) => canLoadResolution(loader.data, res)).length);
  const useVolumeTabs = !disable3d && shape[labels.indexOf("z")] > 1 && hasViewableResolutions;
  const FullController = /* @__PURE__ */ React60.createElement(React60.Fragment, null, /* @__PURE__ */ React60.createElement(LayerOptions_default, {
    channels: channels2,
    opacity,
    colormap,
    transparentColor,
    domainType,
    globalControlLabels: labels.filter((label) => GLOBAL_LABELS.includes(label)),
    globalLabelValues,
    handleOpacityChange: setOpacity,
    handleColormapChange: setColormap,
    handleGlobalChannelsSelectionChange,
    handleTransparentColorChange: setTransparentColor,
    disableChannelsIfRgbDetected: isRgb(loader) && disableChannelsIfRgbDetected,
    handleDomainChange,
    shouldShowTransparentColor,
    shouldShowDomain,
    shouldShowColormap,
    use3d,
    loader,
    handleMultiPropertyChange,
    resolution,
    disable3d,
    setRasterLayerCallback,
    setAreAllChannelsLoading,
    setViewState,
    spatialHeight,
    spatialWidth,
    modelMatrix
  }), isRgb(loader) && disableChannelsIfRgbDetected ? null : channelControllers, isRgb(loader) && disableChannelsIfRgbDetected ? null : /* @__PURE__ */ React60.createElement(Button2, {
    disabled: channels2.length === MAX_CHANNELS,
    onClick: handleChannelAdd,
    fullWidth: true,
    variant: "outlined",
    style: buttonStyles,
    startIcon: /* @__PURE__ */ React60.createElement(AddIcon, null),
    size: "small"
  }, "Add Channel"));
  return /* @__PURE__ */ React60.createElement(ExpansionPanel, {
    className: controllerSectionClasses.root,
    onChange: (e, expanded) => {
      var _a3, _b2, _c;
      return !disabled && setIsExpanded(expanded && ((_c = (_b2 = (_a3 = e == null ? void 0 : e.target) == null ? void 0 : _a3.attributes) == null ? void 0 : _b2.role) == null ? void 0 : _c.value) === "presentation");
    },
    TransitionProps: { enter: false },
    expanded: !disabled && isExpanded
  }, /* @__PURE__ */ React60.createElement(StyledExpansionPanelSummary, {
    expandIcon: /* @__PURE__ */ React60.createElement(ExpandMoreIcon, null),
    "aria-controls": `layer-${name2}-controls`
  }, /* @__PURE__ */ React60.createElement(Grid7, {
    container: true,
    direction: "column",
    m: 1,
    justify: "center"
  }, /* @__PURE__ */ React60.createElement(OverflowEllipsisGrid, {
    item: true
  }, /* @__PURE__ */ React60.createElement(Button2, {
    onClick: (e) => {
      if (!disabled) {
        e.stopPropagation();
        const nextVisible = typeof visible === "boolean" ? !visible : false;
        setVisible(nextVisible);
      }
    },
    style: {
      marginRight: 8,
      marginBottom: 2,
      padding: 0,
      minWidth: 0
    }
  }, /* @__PURE__ */ React60.createElement(Visibility, null)), name2), !disabled && !isExpanded && !use3d && /* @__PURE__ */ React60.createElement(Grid7, {
    container: true,
    direction: "row",
    alignItems: "center",
    justify: "center"
  }, /* @__PURE__ */ React60.createElement(Grid7, {
    item: true,
    xs: 6
  }, /* @__PURE__ */ React60.createElement(StyledInputLabel, {
    htmlFor: `layer-${name2}-opacity-closed`
  }, "Opacity:")), /* @__PURE__ */ React60.createElement(Grid7, {
    item: true,
    xs: 6
  }, /* @__PURE__ */ React60.createElement(Slider9, {
    id: `layer-${name2}-opacity-closed`,
    value: opacity,
    onChange: (e, v) => setOpacity(v),
    valueLabelDisplay: "auto",
    getAriaLabel: () => "opacity slider",
    min: 0,
    max: 1,
    step: 0.01,
    orientation: "horizontal"
  }))))), /* @__PURE__ */ React60.createElement(StyledExpansionPanelDetails, null, useVolumeTabs ? /* @__PURE__ */ React60.createElement(React60.Fragment, null, /* @__PURE__ */ React60.createElement(Tabs, {
    value: tab,
    onChange: handleTabChange,
    "aria-label": "simple tabs example",
    style: { height: "24px", minHeight: "24px" }
  }, /* @__PURE__ */ React60.createElement(Tab, {
    label: "Channels",
    style: {
      fontSize: ".75rem",
      bottom: 12,
      width: "50%",
      minWidth: "50%"
    },
    disableRipple: true
  }), /* @__PURE__ */ React60.createElement(Tab, {
    label: "Volume",
    style: {
      fontSize: ".75rem",
      bottom: 12,
      width: "50%",
      minWidth: "50%"
    }
  })), /* @__PURE__ */ React60.createElement(TabPanel, {
    value: tab,
    index: 0
  }, FullController), /* @__PURE__ */ React60.createElement(TabPanel, {
    value: tab,
    index: 1,
    style: { marginTop: 4 }
  }, /* @__PURE__ */ React60.createElement(VolumeOptions_default, {
    loader,
    handleSlicerSetting,
    handleRenderingModeChange: setRenderingMode,
    renderingMode,
    xSlice,
    ySlice,
    zSlice,
    use3d,
    setViewState,
    spatialHeight,
    spatialWidth,
    modelMatrix
  }))) : FullController, shouldShowRemoveLayerButton ? /* @__PURE__ */ React60.createElement(Button2, {
    onClick: handleLayerRemove,
    fullWidth: true,
    variant: "outlined",
    style: buttonStyles,
    size: "small"
  }, "Remove Image Layer") : null));
}

// src/components/layer-controller/ImageAddButton.js
import React61, { useState as useState19 } from "react";
import { makeStyles as makeStyles10 } from "@material-ui/core/styles";
import AddIcon2 from "@material-ui/icons/Add";
import MenuItem3 from "@material-ui/core/MenuItem";
var useStyles5 = makeStyles10(() => ({
  addButton: {
    marginTop: "10px",
    marginBottom: "10px",
    fontWeight: 400
  }
}));
function ImageAddIcon() {
  return /* @__PURE__ */ React61.createElement(React61.Fragment, null, /* @__PURE__ */ React61.createElement(AddIcon2, null), "Add Image Layer");
}
function ImageAddButton({ imageOptions, handleImageAdd }) {
  const [open, setOpen] = useState19(false);
  const classes = useStyles5();
  const handleAdd = (imgData) => {
    setOpen((prev) => !prev);
    handleImageAdd(imgData);
  };
  if (!imageOptions)
    return null;
  return /* @__PURE__ */ React61.createElement(PopperMenu, {
    open,
    setOpen,
    buttonIcon: /* @__PURE__ */ React61.createElement(ImageAddIcon, null),
    buttonClassName: classes.addButton
  }, imageOptions.map((imgData, i) => /* @__PURE__ */ React61.createElement(MenuItem3, {
    dense: true,
    key: imgData.name,
    onClick: () => handleAdd(i)
  }, /* @__PURE__ */ React61.createElement("span", null, imgData.name))));
}
var ImageAddButton_default = ImageAddButton;

// src/components/layer-controller/LayerControllerSubscriber.js
var LAYER_CONTROLLER_DATA_TYPES = ["raster"];
var LayerControllerMemoized = React62.memo(forwardRef4((props, ref) => {
  const {
    title: title16,
    removeGridComponent,
    theme,
    isReady,
    moleculesLayer,
    dataset,
    setMoleculesLayer,
    cellsLayer,
    canShowCellVecmask,
    setCellsLayer,
    rasterLayers,
    imageLayerLoaders,
    imageLayerMeta,
    rasterLayersCallbacks,
    setRasterLayersCallbacks,
    areLoadingRasterChannnels,
    setAreLoadingRasterChannnels,
    handleRasterLayerChange,
    handleRasterLayerRemove,
    disable3d,
    globalDisable3d,
    disableChannelsIfRgbDetected,
    layerIs3DIndex,
    setZoom,
    setTargetX,
    setTargetY,
    setTargetZ,
    setRotationX,
    setRotationOrbit,
    componentHeight,
    componentWidth,
    spatialLayout,
    handleImageAdd,
    enableLayerButtonsWithOneLayer
  } = props;
  const shouldShowImageLayerButton = Boolean(enableLayerButtonsWithOneLayer || (imageLayerLoaders == null ? void 0 : imageLayerLoaders.length) > 1);
  return /* @__PURE__ */ React62.createElement(TitleInfo, {
    title: title16,
    isScroll: true,
    removeGridComponent,
    theme,
    isReady
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "layer-controller-container",
    ref
  }, moleculesLayer && /* @__PURE__ */ React62.createElement(VectorLayerController, {
    key: `${dataset}-molecules`,
    label: "Molecules",
    layerType: "molecules",
    layer: moleculesLayer,
    handleLayerChange: setMoleculesLayer
  }), cellsLayer && canShowCellVecmask && /* @__PURE__ */ React62.createElement(VectorLayerController, {
    key: `${dataset}-cells`,
    label: "Cell Segmentations",
    layerType: "cells",
    layer: cellsLayer,
    handleLayerChange: setCellsLayer
  }), rasterLayers && rasterLayers.map((layer, i) => {
    var _a2;
    const { index } = layer;
    const loader = imageLayerLoaders[index];
    const layerMeta = imageLayerMeta[index];
    const isRaster = !((_a2 = layerMeta == null ? void 0 : layerMeta.metadata) == null ? void 0 : _a2.isBitmask);
    const ChannelController = isRaster ? RasterChannelController_default : BitmaskChannelController_default;
    const setRasterLayerCallback = (cb) => {
      const newRasterLayersCallbacks = [
        ...rasterLayersCallbacks || []
      ];
      newRasterLayersCallbacks[i] = cb;
      setRasterLayersCallbacks(newRasterLayersCallbacks);
    };
    const areLayerChannelsLoading = (areLoadingRasterChannnels || [])[i] || [];
    const setAreLayerChannelsLoading = (v) => {
      const newAreLoadingRasterChannnels = [
        ...areLoadingRasterChannnels || []
      ];
      newAreLoadingRasterChannnels[i] = v;
      setAreLoadingRasterChannnels(newAreLoadingRasterChannnels);
    };
    return loader && layerMeta ? /* @__PURE__ */ React62.createElement(Grid8, {
      key: `${dataset}-raster-${index}-${i}`,
      item: true,
      style: { marginTop: "10px" }
    }, /* @__PURE__ */ React62.createElement(LayerController, {
      name: layerMeta.name,
      layer,
      loader,
      theme,
      handleLayerChange: (v) => handleRasterLayerChange(v, i),
      handleLayerRemove: () => handleRasterLayerRemove(i),
      ChannelController,
      shouldShowTransparentColor: isRaster,
      shouldShowDomain: isRaster,
      shouldShowColormap: isRaster,
      disable3d: globalDisable3d || (disable3d || []).indexOf(layerMeta.name) >= 0 || typeof layerIs3DIndex === "number" && layerIs3DIndex !== -1 && layerIs3DIndex !== i,
      disabled: typeof layerIs3DIndex === "number" && layerIs3DIndex !== -1 && layerIs3DIndex !== i,
      disableChannelsIfRgbDetected,
      rasterLayersCallbacks,
      setRasterLayerCallback,
      setViewState: ({
        zoom: newZoom,
        target,
        rotationX: newRotationX,
        rotationOrbit: newRotationOrbit
      }) => {
        setZoom(newZoom);
        setTargetX(target[0]);
        setTargetY(target[1]);
        setTargetZ(target[2]);
        setRotationX(newRotationX);
        setRotationOrbit(newRotationOrbit);
      },
      setAreLayerChannelsLoading,
      areLayerChannelsLoading,
      spatialHeight: componentHeight * (spatialLayout ? spatialLayout.h : 1) / 12,
      spatialWidth: componentWidth * (spatialLayout ? spatialLayout.w : 1) / 12,
      shouldShowRemoveLayerButton: shouldShowImageLayerButton
    })) : null;
  }), shouldShowImageLayerButton ? /* @__PURE__ */ React62.createElement(Grid8, {
    item: true
  }, /* @__PURE__ */ React62.createElement(ImageAddButton_default, {
    imageOptions: imageLayerMeta,
    handleImageAdd
  })) : null));
}));
function LayerControllerSubscriber(props) {
  const {
    coordinationScopes,
    removeGridComponent,
    theme,
    title: title16 = "Spatial Layers",
    disable3d,
    globalDisable3d,
    disableChannelsIfRgbDetected,
    enableLayerButtonsWithOneLayer
  } = props;
  const loaders = useLoaders();
  const [
    {
      dataset,
      spatialRasterLayers: rasterLayers,
      spatialCellsLayer: cellsLayer,
      spatialMoleculesLayer: moleculesLayer
    },
    {
      setSpatialRasterLayers: setRasterLayers,
      setSpatialCellsLayer: setCellsLayer,
      setSpatialMoleculesLayer: setMoleculesLayer,
      setSpatialTargetX: setTargetX,
      setSpatialTargetY: setTargetY,
      setSpatialTargetZ: setTargetZ,
      setSpatialRotationX: setRotationX,
      setSpatialRotationOrbit: setRotationOrbit,
      setSpatialZoom: setZoom
    }
  ] = useCoordination(COMPONENT_COORDINATION_TYPES.layerController, coordinationScopes);
  const [
    {
      rasterLayersCallbacks,
      areLoadingRasterChannnels
    },
    {
      setRasterLayersCallbacks,
      setAreLoadingRasterChannnels
    }
  ] = useAuxiliaryCoordination(COMPONENT_COORDINATION_TYPES.layerController, coordinationScopes);
  const [spatialLayout] = useComponentLayout("spatial", ["spatialRasterLayers"], coordinationScopes);
  const layerControllerRef = useRef9();
  const [componentWidth, componentHeight] = useClosestVitessceContainerSize(layerControllerRef);
  const { height: windowHeight, width: windowWidth } = useWindowDimensions();
  const [
    isReady,
    setItemIsReady,
    setItemIsNotReady,
    resetReadyItems
  ] = useReady(LAYER_CONTROLLER_DATA_TYPES);
  useEffect19(() => {
    resetReadyItems();
  }, [loaders, dataset]);
  const [raster, imageLayerLoaders, imageLayerMeta] = useRasterData(loaders, dataset, setItemIsReady, () => {
  }, false, { setSpatialRasterLayers: setRasterLayers }, { spatialRasterLayers: rasterLayers });
  useCellsData(loaders, dataset, setItemIsReady, () => {
  }, false, { setSpatialCellsLayer: setCellsLayer }, { spatialCellsLayer: cellsLayer });
  useMoleculesData(loaders, dataset, setItemIsReady, () => {
  }, false, { setSpatialMoleculesLayer: setMoleculesLayer }, { spatialMoleculesLayer: moleculesLayer });
  const handleImageAdd = useCallback13((index) => __async(this, null, function* () {
    var _a2, _b2, _c, _d, _e;
    const loader = imageLayerLoaders[index];
    const newChannels = yield initializeLayerChannels(loader, (rasterLayers[index] || {}).use3d);
    const newLayer = __spreadProps(__spreadValues({
      index,
      modelMatrix: (_c = (_b2 = (_a2 = imageLayerMeta[index]) == null ? void 0 : _a2.metadata) == null ? void 0 : _b2.transform) == null ? void 0 : _c.matrix
    }, DEFAULT_RASTER_LAYER_PROPS), {
      channels: newChannels,
      type: ((_e = (_d = imageLayerMeta[index]) == null ? void 0 : _d.metadata) == null ? void 0 : _e.isBitmask) ? "bitmask" : "raster"
    });
    const newLayers = [...rasterLayers, newLayer];
    setRasterLayers(newLayers);
  }), [imageLayerLoaders, imageLayerMeta, rasterLayers, setRasterLayers]);
  const handleRasterLayerChange = useCallback13((newLayer, i) => {
    const newLayers = [...rasterLayers];
    newLayers[i] = newLayer;
    setRasterLayers(newLayers);
  }, [rasterLayers, setRasterLayers]);
  const handleRasterLayerRemove = useCallback13((i) => {
    const newLayers = [...rasterLayers];
    newLayers.splice(i, 1);
    setRasterLayers(newLayers);
  }, [rasterLayers, setRasterLayers]);
  const hasNoBitmask = (imageLayerMeta.length ? imageLayerMeta : [{ metadata: { isBitmask: true } }]).every((l) => {
    var _a2;
    return !((_a2 = l == null ? void 0 : l.metadata) == null ? void 0 : _a2.isBitmask);
  });
  const canShowCellVecmask = hasNoBitmask;
  const layerIs3DIndex = (rasterLayers == null ? void 0 : rasterLayers.findIndex) && rasterLayers.findIndex((layer) => layer.use3d);
  return /* @__PURE__ */ React62.createElement(LayerControllerMemoized, {
    ref: layerControllerRef,
    title: title16,
    removeGridComponent,
    theme,
    isReady,
    moleculesLayer,
    dataset,
    setMoleculesLayer,
    cellsLayer,
    canShowCellVecmask,
    setCellsLayer,
    rasterLayers,
    imageLayerLoaders,
    imageLayerMeta,
    rasterLayersCallbacks,
    setRasterLayersCallbacks,
    areLoadingRasterChannnels,
    setAreLoadingRasterChannnels,
    handleRasterLayerChange,
    handleRasterLayerRemove,
    disable3d,
    globalDisable3d,
    layerIs3DIndex,
    disableChannelsIfRgbDetected,
    enableLayerButtonsWithOneLayer,
    setZoom,
    setTargetX,
    setTargetY,
    setTargetZ,
    setRotationX,
    setRotationOrbit,
    componentHeight: componentHeight || windowHeight,
    componentWidth: componentWidth || windowWidth,
    spatialLayout,
    handleImageAdd
  });
}
var LayerControllerSubscriber_default = LayerControllerSubscriber;

// src/components/higlass/HiGlassSubscriber.js
import React64 from "react";

// src/components/higlass/HiGlassLazy.js
import React63, {
  useMemo as useMemo11,
  useEffect as useEffect20,
  useRef as useRef10,
  Suspense,
  useState as useState20
} from "react";
import ReactDOM from "react-dom";
import dynamicImportPolyfill from "dynamic-import-polyfill";
import register from "higlass-register";
import { ZarrMultivecDataFetcher } from "higlass-zarr-datafetchers";
var PIXI_BUNDLE_VERSION = package_default.dependencies["window-pixi"];
var HIGLASS_BUNDLE_VERSION = package_default.dependencies.higlass;
var BUNDLE_FILE_EXT = true ? "js" : "min.js";
var PIXI_BUNDLE_URL = `https://unpkg.com/window-pixi@${PIXI_BUNDLE_VERSION}/dist/pixi.${BUNDLE_FILE_EXT}`;
var HIGLASS_BUNDLE_URL = `https://unpkg.com/higlass@${HIGLASS_BUNDLE_VERSION}/dist/hglib.${BUNDLE_FILE_EXT}`;
dynamicImportPolyfill.initialize();
register({ dataFetcher: ZarrMultivecDataFetcher, config: ZarrMultivecDataFetcher.config }, { pluginType: "dataFetcher" });
var HiGlassComponent = React63.lazy(() => {
  if (!window.React) {
    window.React = React63;
  }
  if (!window.ReactDOM) {
    window.ReactDOM = ReactDOM;
  }
  return new Promise((resolve) => {
    const handleImportError = (e) => {
      console.warn(e);
      resolve(asEsModule(createWarningComponent({
        title: "Could not load HiGlass",
        message: "The HiGlass scripts could not be dynamically imported."
      })));
    };
    __import__(PIXI_BUNDLE_URL).then(() => {
      __import__(HIGLASS_BUNDLE_URL).then(() => {
        resolve(asEsModule(window.hglib.HiGlassComponent));
      }).catch(handleImportError);
    }).catch(handleImportError);
  });
});
var HG_SIZE = 800;
function HiGlassLazy(props) {
  const {
    coordinationScopes,
    theme,
    hgViewConfig: hgViewConfigProp,
    hgOptions: hgOptionsProp,
    genomeSize,
    height
  } = props;
  const [{
    genomicZoomX,
    genomicZoomY,
    genomicTargetX,
    genomicTargetY
  }, {
    setGenomicZoomX,
    setGenomicZoomY,
    setGenomicTargetX,
    setGenomicTargetY
  }] = useCoordination(COMPONENT_COORDINATION_TYPES.higlass, coordinationScopes);
  const [width, computedHeight, containerRef] = useGridItemSize();
  const [hgInstance, setHgInstance] = useState20();
  const isActiveRef = useRef10();
  const hgOptions = useMemo11(() => __spreadProps(__spreadValues({}, hgOptionsProp), {
    theme
  }), [hgOptionsProp, theme]);
  const hgViewConfig = useMemo11(() => {
    const centerX = genomicTargetX;
    const genomesPerUnitX = genomeSize / __pow(2, genomicZoomX);
    const unitX = width / HG_SIZE;
    const initialXDomain = [
      centerX - genomesPerUnitX * unitX / 2,
      centerX + genomesPerUnitX * unitX / 2
    ];
    const centerY = genomicTargetY;
    const genomesPerUnitY = genomeSize / __pow(2, genomicZoomY);
    const unitY = height / HG_SIZE;
    const initialYDomain = [
      centerY - genomesPerUnitY * unitY / 2,
      centerY + genomesPerUnitY * unitY / 2
    ];
    return {
      editable: false,
      zoomFixed: false,
      trackSourceServers: [
        "//higlass.io/api/v1"
      ],
      exportViewUrl: "//higlass.io/api/v1/viewconfs",
      views: [
        __spreadProps(__spreadValues({
          uid: "main"
        }, hgViewConfigProp), {
          initialXDomain,
          initialYDomain
        })
      ],
      zoomLocks: {
        locksByViewUid: {},
        locksDict: {}
      },
      locationLocks: {
        locksByViewUid: {},
        locksDict: {}
      },
      valueScaleLocks: {
        locksByViewUid: {},
        locksDict: {}
      }
    };
  }, [
    genomicTargetX,
    genomeSize,
    genomicZoomX,
    width,
    genomicTargetY,
    genomicZoomY,
    height,
    hgViewConfigProp
  ]);
  useEffect20(() => {
    const handleMouseEnter = () => {
      isActiveRef.current = true;
    };
    const handleMouseLeave = () => {
      isActiveRef.current = false;
    };
    const container = containerRef.current;
    container.addEventListener("mouseenter", handleMouseEnter);
    container.addEventListener("mouseleave", handleMouseLeave);
    return () => {
      container.removeEventListener("mouseenter", handleMouseEnter);
      container.removeEventListener("mouseenter", handleMouseLeave);
    };
  }, [containerRef]);
  useEffect20(() => {
    if (!hgInstance) {
      return () => {
      };
    }
    hgInstance.api.on("viewConfig", (viewConfigString) => {
      if (!isActiveRef.current) {
        return;
      }
      const viewConfig = JSON.parse(viewConfigString);
      const xDomain = viewConfig.views[0].initialXDomain;
      const yDomain = viewConfig.views[0].initialYDomain;
      const nextGenomicZoomX = Math.log2(genomeSize / ((xDomain[1] - xDomain[0]) * (HG_SIZE / width)));
      const nextGenomicZoomY = Math.log2(genomeSize / ((yDomain[1] - yDomain[0]) * (HG_SIZE / height)));
      const nextGenomicTargetX = xDomain[0] + (xDomain[1] - xDomain[0]) / 2;
      const nextGenomicTargetY = yDomain[0] + (yDomain[1] - yDomain[0]) / 2;
      setGenomicZoomX(nextGenomicZoomX);
      setGenomicZoomY(nextGenomicZoomY);
      setGenomicTargetX(nextGenomicTargetX);
      setGenomicTargetY(nextGenomicTargetY);
    });
    return () => hgInstance.api.off("viewConfig");
  }, [
    hgInstance,
    genomeSize,
    width,
    height,
    setGenomicZoomX,
    setGenomicZoomY,
    setGenomicTargetX,
    setGenomicTargetY
  ]);
  return /* @__PURE__ */ React63.createElement("div", {
    className: "higlass-wrapper-parent"
  }, /* @__PURE__ */ React63.createElement("div", {
    className: "higlass-wrapper",
    ref: containerRef,
    style: { height: `${height}px` }
  }, /* @__PURE__ */ React63.createElement(Suspense, {
    fallback: /* @__PURE__ */ React63.createElement("div", null, "Loading...")
  }, /* @__PURE__ */ React63.createElement(HiGlassComponent, {
    ref: setHgInstance,
    zoomFixed: false,
    viewConfig: hgViewConfig,
    options: hgOptions
  }))));
}
HiGlassLazy.defaultProps = {
  hgOptions: {
    bounded: true,
    pixelPreciseMarginPadding: true,
    containerPaddingX: 0,
    containerPaddingY: 0,
    sizeMode: "default"
  },
  genomeSize: 31e8
};

// src/components/higlass/HiGlassSubscriber.js
var HIGLASS_DATA_TYPES = [];
function HiGlassSubscriber(props) {
  const {
    coordinationScopes,
    theme,
    hgViewConfig,
    removeGridComponent
  } = props;
  const [width, height, containerRef] = useGridItemSize();
  const [
    isReady,
    setItemIsReady,
    setItemIsNotReady,
    resetReadyItems
  ] = useReady(HIGLASS_DATA_TYPES);
  const [urls, addUrl, resetUrls] = useUrls();
  return /* @__PURE__ */ React64.createElement("div", {
    className: "higlass-title-wrapper"
  }, /* @__PURE__ */ React64.createElement(TitleInfo, {
    title: "HiGlass",
    removeGridComponent,
    theme,
    isReady,
    urls
  }, /* @__PURE__ */ React64.createElement("div", {
    className: "higlass-lazy-wrapper",
    ref: containerRef
  }, /* @__PURE__ */ React64.createElement(HiGlassLazy, {
    coordinationScopes,
    theme,
    hgViewConfig,
    height
  }))));
}

// src/components/sets/CellSetSizesPlotSubscriber.js
import React67, { useMemo as useMemo13, useEffect as useEffect21 } from "react";

// src/components/sets/CellSetSizesPlot.js
import React66 from "react";
import clamp4 from "lodash/clamp";

// src/components/vega/VegaPlot.js
import React65, { Suspense as Suspense2, useMemo as useMemo12 } from "react";
import { Handler } from "vega-tooltip";

// src/components/vega/ReactVega.js
import { Vega } from "react-vega";

// src/components/vega/VegaPlot.js
var DATASET_NAME = "table";
function isVega(spec) {
  return spec.$schema === "https://vega.github.io/schema/vega/v5.json";
}
function VegaPlot(props) {
  const {
    spec: partialSpec,
    data,
    signalListeners
  } = props;
  const spec = __spreadProps(__spreadValues({}, partialSpec), {
    data: isVega(partialSpec) ? [
      { name: DATASET_NAME },
      ...partialSpec.data
    ] : { name: DATASET_NAME }
  });
  const vegaComponent = useMemo12(() => /* @__PURE__ */ React65.createElement(Vega, {
    spec,
    data: {
      [DATASET_NAME]: data
    },
    signalListeners,
    tooltip: new Handler().call,
    renderer: "canvas",
    scaleFactor: 3
  }), [spec, data, signalListeners]);
  return spec && data && data.length > 0 ? /* @__PURE__ */ React65.createElement(Suspense2, {
    fallback: /* @__PURE__ */ React65.createElement("div", null, "Loading...")
  }, vegaComponent) : null;
}

// src/components/vega/utils.js
var VEGA_THEMES = {
  dark: {
    background: null,
    title: { color: "#fff" },
    style: {
      "guide-label": {
        fill: "#fff"
      },
      "guide-title": {
        fill: "#fff"
      }
    },
    axis: {
      domainColor: "#fff",
      gridColor: "#888",
      tickColor: "#fff"
    }
  },
  light: {
    background: null
  }
};

// src/components/sets/CellSetSizesPlot.js
function CellSetSizesPlot(props) {
  const {
    data: rawData,
    theme,
    width,
    height,
    marginRight = 90,
    marginBottom = 120,
    keyLength = 36
  } = props;
  const data = rawData.map((d) => __spreadProps(__spreadValues({}, d), {
    keyName: d.key + d.name,
    colorString: colorArrayToString(d.color)
  }));
  const colors = {
    domain: data.map((d) => d.key),
    range: data.map((d) => d.colorString)
  };
  const keys = data.map((d) => d.keyName);
  const spec = {
    mark: { type: "bar" },
    encoding: {
      x: {
        field: "keyName",
        type: "nominal",
        axis: { labelExpr: `substring(datum.label, ${keyLength})` },
        title: "Cell Set",
        sort: keys
      },
      y: {
        field: "size",
        type: "quantitative",
        title: "Cell Set Size"
      },
      color: {
        field: "key",
        type: "nominal",
        scale: colors,
        legend: null
      },
      tooltip: {
        field: "size",
        type: "quantitative"
      }
    },
    width: clamp4(width - marginRight, 10, Infinity),
    height: clamp4(height - marginBottom, 10, Infinity),
    config: VEGA_THEMES[theme]
  };
  return /* @__PURE__ */ React66.createElement(VegaPlot, {
    data,
    spec
  });
}

// src/components/sets/CellSetSizesPlotSubscriber.js
var CELL_SET_SIZES_DATA_TYPES = ["cell-sets"];
function CellSetSizesPlotSubscriber(props) {
  const {
    coordinationScopes,
    removeGridComponent,
    theme,
    title: title16 = "Cell Set Sizes"
  } = props;
  const loaders = useLoaders();
  const [{
    dataset,
    cellSetSelection,
    cellSetColor,
    additionalCellSets
  }, {
    setCellSetSelection,
    setCellSetColor
  }] = useCoordination(COMPONENT_COORDINATION_TYPES.cellSetSizes, coordinationScopes);
  const [width, height, containerRef] = useGridItemSize();
  const [urls, addUrl, resetUrls] = useUrls();
  const [
    isReady,
    setItemIsReady,
    setItemIsNotReady,
    resetReadyItems
  ] = useReady(CELL_SET_SIZES_DATA_TYPES);
  useEffect21(() => {
    resetUrls();
    resetReadyItems();
  }, [loaders, dataset]);
  const [cellSets] = useCellSetsData(loaders, dataset, setItemIsReady, addUrl, true, { setCellSetSelection, setCellSetColor }, { cellSetSelection, cellSetColor });
  const mergedCellSets = useMemo13(() => mergeCellSets(cellSets, additionalCellSets), [cellSets, additionalCellSets]);
  const data = useMemo13(() => mergedCellSets && cellSetSelection && cellSetColor ? treeToSetSizesBySetNames(mergedCellSets, cellSetSelection, cellSetColor, theme) : [], [mergedCellSets, cellSetSelection, cellSetColor, theme]);
  return /* @__PURE__ */ React67.createElement(TitleInfo, {
    title: title16,
    removeGridComponent,
    urls,
    theme,
    isReady
  }, /* @__PURE__ */ React67.createElement("div", {
    ref: containerRef,
    className: "vega-container"
  }, /* @__PURE__ */ React67.createElement(CellSetSizesPlot, {
    data,
    theme,
    width,
    height
  })));
}

// src/components/higlass/GenomicProfilesSubscriber.js
import React68, {
  useMemo as useMemo14,
  useEffect as useEffect22
} from "react";
import isEqual13 from "lodash/isEqual";
import { sum as sum2 } from "d3-array";
var GENOMIC_PROFILES_DATA_TYPES = ["genomic-profiles"];
var REFERENCE_TILESETS = {
  hg38: {
    chromosomes: "NyITQvZsS_mOFNlz5C2LJg",
    genes: "P0PLbQMwTYGy-5uPIQid7A"
  },
  hg19: {
    chromosomes: "N12wVGG9SPiTkk03yUayUw",
    genes: "OHJakQICQD6gTD7skx4EWA"
  },
  mm9: {
    chromosomes: "WAVhNHYxQVueq6KulwgWiQ",
    genes: "GUm5aBiLRCyz2PsBea7Yzg"
  },
  mm10: {
    chromosomes: "EtrWT0VtScixmsmwFSd7zg",
    genes: "QDutvmyiSrec5nX4pA5WGQ"
  }
};
function GenomicProfilesSubscriber(props) {
  const {
    coordinationScopes,
    theme,
    removeGridComponent,
    profileTrackUidKey = "path",
    profileTrackNameKey = null,
    higlassServer = "https://higlass.io/api/v1",
    assembly = "hg38",
    title: title16 = "Genomic Profiles"
  } = props;
  const [width, height, containerRef] = useGridItemSize();
  const loaders = useLoaders();
  const [{
    dataset,
    cellSetColor,
    cellSetSelection
  }] = useCoordination(COMPONENT_COORDINATION_TYPES.genomicProfiles, coordinationScopes);
  const [
    isReady,
    setItemIsReady,
    setItemIsNotReady,
    resetReadyItems
  ] = useReady(GENOMIC_PROFILES_DATA_TYPES);
  const [urls, addUrl, resetUrls] = useUrls();
  const [genomicProfilesAttrs] = useGenomicProfilesData(loaders, dataset, setItemIsReady, addUrl, true);
  const hgViewConfig = useMemo14(() => {
    if (!genomicProfilesAttrs || urls.length !== 1) {
      return null;
    }
    const { url } = urls[0];
    const foregroundColor = theme === "dark" ? "#C0C0C0" : "#000000";
    const backgroundColor = theme === "dark" ? "#000000" : "#f1f1f1";
    const dimColor = theme === "dark" ? "dimgray" : "silver";
    const referenceTracks = [
      {
        type: "horizontal-chromosome-labels",
        server: higlassServer,
        tilesetUid: REFERENCE_TILESETS[assembly].chromosomes,
        uid: "chromosome-labels",
        options: {
          color: foregroundColor,
          fontSize: 12,
          fontIsLeftAligned: false,
          showMousePosition: true,
          mousePositionColor: foregroundColor
        },
        height: 30
      },
      {
        type: "horizontal-gene-annotations",
        server: higlassServer,
        tilesetUid: REFERENCE_TILESETS[assembly].genes,
        uid: "gene-annotations",
        options: {
          name: "Gene Annotations (hg38)",
          fontSize: 10,
          labelPosition: "hidden",
          labelLeftMargin: 0,
          labelRightMargin: 0,
          labelTopMargin: 0,
          labelBottomMargin: 0,
          minHeight: 24,
          geneAnnotationHeight: 16,
          geneLabelPosition: "outside",
          geneStrandSpacing: 4,
          showMousePosition: true,
          mousePositionColor: foregroundColor,
          plusStrandColor: foregroundColor,
          minusStrandColor: foregroundColor,
          labelColor: "black",
          labelBackgroundColor: backgroundColor,
          trackBorderWidth: 0,
          trackBorderColor: "black"
        },
        height: 70
      }
    ];
    const referenceTracksHeightSum = sum2(referenceTracks.map((t) => t.height));
    const profileTracksHeightSum = height - referenceTracksHeightSum - 10;
    const profileTrackHeight = profileTracksHeightSum / genomicProfilesAttrs.row_infos.length;
    const profileTracks = genomicProfilesAttrs.row_infos.map((rowInfo, i) => {
      var _a2;
      const trackUid = rowInfo[profileTrackUidKey];
      const isPath = Array.isArray(trackUid);
      const trackName = profileTrackNameKey ? rowInfo[profileTrackNameKey] : isPath ? trackUid[trackUid.length - 1] : trackUid;
      const setInSelection = isPath ? cellSetSelection == null ? void 0 : cellSetSelection.find((s) => isEqual13(s, trackUid)) : false;
      const setColor = isPath ? (_a2 = cellSetColor == null ? void 0 : cellSetColor.find((s) => isEqual13(s.path, trackUid))) == null ? void 0 : _a2.color : null;
      const trackUidString = isPath ? trackUid.join("__") : trackUid;
      const track = {
        type: "horizontal-bar",
        uid: `bar-track-${trackUidString}`,
        data: {
          type: "zarr-multivec",
          url,
          row: i
        },
        options: {
          name: trackName,
          showMousePosition: true,
          mousePositionColor: foregroundColor,
          labelColor: theme === "dark" ? "white" : "black",
          labelBackgroundColor: theme === "dark" ? "black" : "white",
          labelShowAssembly: false
        },
        height: profileTrackHeight
      };
      if (setColor && setInSelection) {
        const c = setColor;
        track.options.barFillColor = `rgb(${c[0]},${c[1]},${c[2]})`;
      } else {
        track.options.barFillColor = dimColor;
      }
      return track;
    });
    const hgView = {
      tracks: {
        top: [
          ...referenceTracks,
          ...profileTracks
        ],
        left: [],
        center: [],
        right: [],
        bottom: [],
        whole: [],
        gallery: []
      },
      layout: {
        w: 12,
        h: 12,
        x: 0,
        y: 0,
        static: false
      }
    };
    return hgView;
  }, [
    genomicProfilesAttrs,
    urls,
    theme,
    height,
    profileTrackUidKey,
    profileTrackNameKey,
    cellSetSelection,
    cellSetColor,
    higlassServer,
    assembly
  ]);
  useEffect22(() => {
    resetUrls();
    resetReadyItems();
  }, [loaders, dataset]);
  return /* @__PURE__ */ React68.createElement("div", {
    className: "higlass-title-wrapper"
  }, /* @__PURE__ */ React68.createElement(TitleInfo, {
    title: title16,
    removeGridComponent,
    theme,
    isReady,
    urls
  }, /* @__PURE__ */ React68.createElement("div", {
    className: "higlass-lazy-wrapper",
    ref: containerRef
  }, hgViewConfig ? /* @__PURE__ */ React68.createElement(HiGlassLazy, {
    coordinationScopes,
    theme,
    hgViewConfig,
    height
  }) : null)));
}

// src/components/genes/ExpressionHistogramSubscriber.js
import React70, { useMemo as useMemo15, useEffect as useEffect23 } from "react";
import { sum as sum3 } from "d3-array";

// src/components/genes/ExpressionHistogram.js
import React69 from "react";
import clamp5 from "lodash/clamp";
function ExpressionHistogram(props) {
  const {
    geneSelection,
    data,
    theme,
    width,
    height,
    marginRight = 90,
    marginBottom = 50
  } = props;
  const xTitle = geneSelection && geneSelection.length >= 1 ? "Normalized Expression Value" : "Total Normalized Transcript Count";
  const spec = {
    mark: { type: "bar" },
    encoding: {
      x: {
        field: "value",
        type: "quantitative",
        bin: { maxbins: 50 },
        title: xTitle
      },
      y: {
        type: "quantitative",
        aggregate: "count",
        title: "Number of Cells"
      },
      color: { value: "gray" }
    },
    width: clamp5(width - marginRight, 10, Infinity),
    height: clamp5(height - marginBottom, 10, Infinity),
    config: VEGA_THEMES[theme]
  };
  return /* @__PURE__ */ React69.createElement(VegaPlot, {
    data,
    spec
  });
}

// src/components/genes/ExpressionHistogramSubscriber.js
var EXPRESSION_HISTOGRAM_DATA_TYPES = ["expression-matrix"];
function ExpressionHistogramSubscriber(props) {
  const {
    coordinationScopes,
    removeGridComponent,
    theme
  } = props;
  const loaders = useLoaders();
  const [{
    dataset,
    geneSelection
  }] = useCoordination(COMPONENT_COORDINATION_TYPES.expressionHistogram, coordinationScopes);
  const [width, height, containerRef] = useGridItemSize();
  const [urls, addUrl, resetUrls] = useUrls();
  const [
    isReady,
    setItemIsReady,
    setItemIsNotReady,
    resetReadyItems
  ] = useReady(EXPRESSION_HISTOGRAM_DATA_TYPES);
  useEffect23(() => {
    resetUrls();
    resetReadyItems();
  }, [loaders, dataset]);
  const [expressionMatrix] = useExpressionMatrixData(loaders, dataset, setItemIsReady, addUrl, true);
  const [expressionData] = useGeneSelection(loaders, dataset, setItemIsReady, false, geneSelection, setItemIsNotReady);
  const firstGeneSelected = geneSelection && geneSelection.length >= 1 ? geneSelection[0] : null;
  const data = useMemo15(() => {
    if (firstGeneSelected && expressionMatrix && expressionData) {
      return Array.from(expressionData[0]).map((_, index) => {
        const value = expressionData[0][index];
        const normValue = value * 100 / 255;
        return { value: normValue, gene: firstGeneSelected };
      });
    }
    if (expressionMatrix) {
      const numGenes = expressionMatrix.cols.length;
      return expressionMatrix.rows.map((cellId, cellIndex) => {
        const values = expressionMatrix.matrix.subarray(cellIndex * numGenes, (cellIndex + 1) * numGenes);
        const sumValue = sum3(values) * 100 / 255;
        return { value: sumValue, gene: null };
      });
    }
    return null;
  }, [expressionMatrix, firstGeneSelected, expressionData]);
  return /* @__PURE__ */ React70.createElement(TitleInfo, {
    title: `Expression Histogram${firstGeneSelected ? ` (${firstGeneSelected})` : ""}`,
    removeGridComponent,
    urls,
    theme,
    isReady
  }, /* @__PURE__ */ React70.createElement("div", {
    ref: containerRef,
    className: "vega-container"
  }, /* @__PURE__ */ React70.createElement(ExpressionHistogram, {
    geneSelection,
    data,
    theme,
    width,
    height
  })));
}

// src/components/sets/CellSetExpressionPlotSubscriber.js
import React73, { useEffect as useEffect24, useReducer as useReducer2 } from "react";

// src/components/sets/hooks.js
import { useMemo as useMemo16 } from "react";
function useExpressionByCellSet(expressionData, expressionDataAttrs, cellSets, additionalCellSets, geneSelection, cellSetSelection, cellSetColor, useGeneExpressionTransform, theme) {
  const mergedCellSets = useMemo16(() => mergeCellSets(cellSets, additionalCellSets), [cellSets, additionalCellSets]);
  const [expressionArr, expressionMax] = useMemo16(() => {
    if (mergedCellSets && cellSetSelection && geneSelection && geneSelection.length >= 1 && expressionData) {
      const cellObjects = treeToObjectsBySetNames(mergedCellSets, cellSetSelection, cellSetColor, theme);
      const firstGeneSelected = geneSelection[0];
      let exprMax = -Infinity;
      const cellIndices = {};
      for (let i = 0; i < expressionDataAttrs.rows.length; i += 1) {
        cellIndices[expressionDataAttrs.rows[i]] = i;
      }
      const exprValues = cellObjects.map((cell) => {
        const cellIndex = cellIndices[cell.obsId];
        const value = expressionData[0][cellIndex];
        const normValue = value * 100 / 255;
        const transformedValue = useGeneExpressionTransform ? Math.log(1 + normValue) : normValue;
        exprMax = Math.max(transformedValue, exprMax);
        return { value: transformedValue, gene: firstGeneSelected, set: cell.name };
      });
      return [exprValues, exprMax];
    }
    return [null, null];
  }, [
    expressionData,
    expressionDataAttrs,
    geneSelection,
    theme,
    mergedCellSets,
    cellSetSelection,
    cellSetColor,
    useGeneExpressionTransform
  ]);
  const setArr = useMemo16(() => mergedCellSets && cellSetSelection && cellSetColor ? treeToSetSizesBySetNames(mergedCellSets, cellSetSelection, cellSetColor, theme) : [], [mergedCellSets, cellSetSelection, cellSetColor, theme]);
  return [expressionArr, setArr, expressionMax];
}

// src/components/sets/CellSetExpressionPlotOptions.js
import React71 from "react";
import Checkbox6 from "@material-ui/core/Checkbox";
import TableCell5 from "@material-ui/core/TableCell";
import TableRow5 from "@material-ui/core/TableRow";
function CellSetExpressionPlotOptions(props) {
  const { toggleGeneExpressionTransform, useGeneExpressionTransform } = props;
  const classes = useStyles2();
  function handleGeneExpressionTransformChange() {
    toggleGeneExpressionTransform();
  }
  return /* @__PURE__ */ React71.createElement(OptionsContainer, null, /* @__PURE__ */ React71.createElement(TableRow5, null, /* @__PURE__ */ React71.createElement(TableCell5, {
    className: classes.labelCell
  }, "Log Transform"), /* @__PURE__ */ React71.createElement(TableCell5, {
    className: classes.inputCell
  }, /* @__PURE__ */ React71.createElement(Checkbox6, {
    className: classes.checkbox,
    checked: Boolean(useGeneExpressionTransform),
    onChange: handleGeneExpressionTransformChange,
    name: "scatterplot-option-cell-set-labels",
    color: "default"
  }))));
}

// src/components/sets/CellSetExpressionPlot.js
import React72 from "react";
import clamp6 from "lodash/clamp";
function CellSetExpressionPlot(props) {
  const {
    domainMax = 100,
    colors,
    data,
    theme,
    width,
    height,
    marginRight = 90,
    marginBottom,
    useGeneExpressionTransform
  } = props;
  const maxCharactersForLabel = data.reduce((acc, val) => {
    acc = acc === void 0 || val.set.length > acc ? val.set.length : acc;
    return acc;
  }, 0);
  const autoMarginBottom = marginBottom || 30 + Math.sqrt(maxCharactersForLabel / 2) * 30;
  const colorScale = {
    domain: colors.map((d) => d.name),
    range: colors.map((d) => colorArrayToString(d.color))
  };
  const plotWidth = clamp6(width - marginRight, 10, Infinity);
  const plotHeight = clamp6(height - autoMarginBottom, 10, Infinity);
  const numBands = colors.length;
  const bandWidth = plotWidth / numBands;
  const rectColor = theme === "dark" ? "white" : "black";
  const spec = {
    $schema: "https://vega.github.io/schema/vega/v5.json",
    description: "A violin plot showing distributions of expression levels for selected cell sets.",
    width: plotWidth,
    height: plotHeight,
    config: __spreadProps(__spreadValues({}, VEGA_THEMES[theme]), {
      axisBand: {
        bandPosition: 1,
        tickExtra: true,
        tickOffset: 0
      }
    }),
    signals: [
      { name: "bandWidth", value: bandWidth },
      { name: "width", value: plotWidth },
      { name: "height", value: plotHeight },
      { name: "trim", value: true }
    ],
    data: [
      {
        name: "density",
        source: DATASET_NAME,
        transform: [
          {
            type: "kde",
            field: "value",
            groupby: ["set"],
            bandwidth: 0,
            extent: [0, domainMax]
          }
        ]
      },
      {
        name: "stats",
        source: DATASET_NAME,
        transform: [
          {
            type: "aggregate",
            groupby: ["set"],
            fields: ["value", "value", "value"],
            ops: ["q1", "median", "q3"],
            as: ["q1", "median", "q3"]
          }
        ]
      }
    ],
    scales: [
      {
        name: "layout",
        type: "band",
        range: "width",
        domain: { data: DATASET_NAME, field: "set" }
      },
      {
        name: "yscale",
        type: "linear",
        range: "height",
        domain: [0, domainMax]
      },
      {
        name: "wscale",
        type: "linear",
        range: [0, { signal: "bandWidth" }],
        domain: { data: "density", field: "density" }
      },
      {
        name: "wscaleReversed",
        type: "linear",
        reverse: true,
        range: [0, { signal: "bandWidth" }],
        domain: { data: "density", field: "density" }
      },
      __spreadValues({
        name: "color",
        type: "ordinal"
      }, colorScale)
    ],
    axes: [
      {
        orient: "left",
        scale: "yscale",
        zindex: 1,
        title: useGeneExpressionTransform ? ["Log-Transformed", "Normalized Expression Values"] : "Normalized Expression Values"
      },
      {
        orient: "bottom",
        scale: "layout",
        tickCount: 5,
        zindex: 1,
        title: "Cell Set",
        labelAngle: -45,
        labelAlign: "right"
      }
    ],
    marks: [
      {
        type: "group",
        from: {
          facet: {
            data: "density",
            name: "violin",
            groupby: "set"
          }
        },
        encode: {
          enter: {
            xc: { scale: "layout", field: "set", band: 0.5 },
            width: { signal: "bandWidth" },
            height: { signal: "height" }
          }
        },
        data: [
          {
            name: "summary",
            source: "stats",
            transform: [
              {
                type: "filter",
                expr: "datum.set === parent.set"
              }
            ]
          }
        ],
        marks: [
          {
            type: "area",
            orient: "vertical",
            from: { data: "violin" },
            encode: {
              enter: {
                fill: { scale: "color", field: { parent: "set" } }
              },
              update: {
                width: { scale: "wscale", field: "density" },
                xc: { signal: "bandWidth / 2" },
                y2: { scale: "yscale", field: "value" },
                y: { scale: "yscale", value: 0 }
              }
            }
          },
          {
            type: "area",
            orient: "vertical",
            from: { data: "violin" },
            encode: {
              enter: {
                fill: { scale: "color", field: { parent: "set" } }
              },
              update: {
                width: { scale: "wscaleReversed", field: "density" },
                xc: { signal: "bandWidth" },
                y2: { scale: "yscale", field: "value" },
                y: { scale: "yscale", value: 0 }
              }
            }
          },
          {
            type: "rect",
            from: { data: "summary" },
            encode: {
              enter: {
                fill: { value: rectColor },
                width: { value: 2 }
              },
              update: {
                y: { scale: "yscale", field: "q1" },
                y2: { scale: "yscale", field: "q3" },
                xc: { signal: "bandWidth / 2" }
              }
            }
          },
          {
            type: "rect",
            from: { data: "summary" },
            encode: {
              enter: {
                fill: { value: rectColor },
                height: { value: 2 },
                width: { value: 8 }
              },
              update: {
                y: { scale: "yscale", field: "median" },
                xc: { signal: "bandWidth / 2" }
              }
            }
          }
        ]
      }
    ]
  };
  return /* @__PURE__ */ React72.createElement(VegaPlot, {
    data,
    spec
  });
}

// src/components/sets/CellSetExpressionPlotSubscriber.js
var CELL_SET_EXPRESSION_DATA_TYPES = ["cell-sets", "expression-matrix"];
function CellSetExpressionPlotSubscriber(props) {
  const {
    coordinationScopes,
    removeGridComponent,
    theme
  } = props;
  const loaders = useLoaders();
  const [{
    dataset,
    geneSelection,
    geneExpressionTransform,
    cellSetSelection,
    cellSetColor,
    additionalCellSets
  }, {
    setGeneExpressionTransform
  }] = useCoordination(COMPONENT_COORDINATION_TYPES.cellSetExpression, coordinationScopes);
  const [width, height, containerRef] = useGridItemSize();
  const [urls, addUrl, resetUrls] = useUrls();
  const [
    isReady,
    setItemIsReady,
    setItemIsNotReady,
    resetReadyItems
  ] = useReady(CELL_SET_EXPRESSION_DATA_TYPES);
  const [useGeneExpressionTransform, toggleGeneExpressionTransform] = useReducer2((v) => {
    const newValue = !v;
    setGeneExpressionTransform(newValue ? "log1p" : null);
    return newValue;
  }, geneExpressionTransform);
  useEffect24(() => {
    resetUrls();
    resetReadyItems();
  }, [loaders, dataset]);
  const [expressionData] = useGeneSelection(loaders, dataset, setItemIsReady, false, geneSelection, setItemIsNotReady);
  const [attrs] = useExpressionAttrs(loaders, dataset, setItemIsReady, addUrl, false);
  const [cellSets] = useCellSetsData(loaders, dataset, setItemIsReady, addUrl, true);
  const [expressionArr, setArr, expressionMax] = useExpressionByCellSet(expressionData, attrs, cellSets, additionalCellSets, geneSelection, cellSetSelection, cellSetColor, useGeneExpressionTransform, theme);
  const firstGeneSelected = geneSelection && geneSelection.length >= 1 ? geneSelection[0] : null;
  return /* @__PURE__ */ React73.createElement(TitleInfo, {
    title: `Expression by Cell Set${firstGeneSelected ? ` (${firstGeneSelected})` : ""}`,
    removeGridComponent,
    urls,
    theme,
    isReady,
    options: /* @__PURE__ */ React73.createElement(CellSetExpressionPlotOptions, {
      useGeneExpressionTransform,
      toggleGeneExpressionTransform
    })
  }, /* @__PURE__ */ React73.createElement("div", {
    ref: containerRef,
    className: "vega-container"
  }, expressionArr ? /* @__PURE__ */ React73.createElement(CellSetExpressionPlot, {
    domainMax: expressionMax,
    colors: setArr,
    data: expressionArr,
    theme,
    width,
    height,
    useGeneExpressionTransform
  }) : /* @__PURE__ */ React73.createElement("span", null, "Select a gene.")));
}

// src/app/component-registry.js
var registry = {
  description: DescriptionSubscriber,
  status: StatusSubscriber,
  genes: GenesSubscriber,
  cellSets: CellSetsManagerSubscriber,
  scatterplot: ScatterplotSubscriber,
  spatial: SpatialSubscriber,
  heatmap: HeatmapSubscriber,
  layerController: LayerControllerSubscriber_default,
  cellSetSizes: CellSetSizesPlotSubscriber,
  expressionHistogram: ExpressionHistogramSubscriber,
  genomicProfiles: GenomicProfilesSubscriber,
  cellSetExpression: CellSetExpressionPlotSubscriber,
  higlass: HiGlassSubscriber
};
function getComponent(name2) {
  const component = registry[name2];
  if (component === void 0) {
    throw new Error(`Could not find definition for "${name2}" in registry.`);
  }
  return registry[name2];
}

// src/app/view-config-utils.js
function getExistingScopesForCoordinationType(config, coordinationType) {
  var _a2;
  const spaceScopes = Object.keys(((_a2 = config == null ? void 0 : config.coordinationSpace) == null ? void 0 : _a2[coordinationType]) || {});
  const componentScopes = config.layout.map((c) => {
    var _a3;
    return (_a3 = c.coordinationScopes) == null ? void 0 : _a3[coordinationType];
  });
  return Array.from(new Set([...spaceScopes, ...componentScopes]));
}
function coordinateComponentsTogether(config, coordinationType, scopeValue) {
  var _a2;
  const scopeName = getNextScope(getExistingScopesForCoordinationType(config, coordinationType));
  const newConfig = __spreadProps(__spreadValues({}, config), {
    coordinationSpace: __spreadProps(__spreadValues({}, config.coordinationSpace), {
      [coordinationType]: __spreadProps(__spreadValues({}, (_a2 = config == null ? void 0 : config.coordinationSpace) == null ? void 0 : _a2[coordinationType]), {
        [scopeName]: scopeValue
      })
    }),
    layout: config.layout.map((component) => {
      var _a3;
      return __spreadProps(__spreadValues({}, component), {
        coordinationScopes: __spreadValues(__spreadValues({}, component.coordinationScopes), COMPONENT_COORDINATION_TYPES[component.component].includes(coordinationType) && !((_a3 = component.coordinationScopes) == null ? void 0 : _a3[coordinationType]) ? {
          [coordinationType]: scopeName
        } : {})
      });
    })
  });
  return newConfig;
}
function coordinateComponentsIndependent(config, coordinationType, scopeValue) {
  const newConfig = __spreadProps(__spreadValues({}, config), {
    layout: [...config.layout]
  });
  const newScopes = {};
  newConfig.layout.forEach((component, i) => {
    var _a2;
    if (COMPONENT_COORDINATION_TYPES[component.component].includes(coordinationType) && !((_a2 = component.coordinationScopes) == null ? void 0 : _a2[coordinationType])) {
      const scopeName = getNextScope([
        ...getExistingScopesForCoordinationType(config, coordinationType),
        ...Object.keys(newScopes)
      ]);
      newScopes[scopeName] = scopeValue;
      newConfig.layout[i] = __spreadProps(__spreadValues({}, component), {
        coordinationScopes: __spreadProps(__spreadValues({}, component.coordinationScopes), {
          [coordinationType]: scopeName
        })
      });
    }
  });
  newConfig.coordinationSpace = __spreadProps(__spreadValues({}, newConfig.coordinationSpace), {
    [coordinationType]: __spreadValues(__spreadValues({}, newConfig.coordinationSpace[coordinationType]), newScopes)
  });
  return newConfig;
}
function initializeAuto(config) {
  let newConfig = config;
  const { layout, datasets } = newConfig;
  Object.values(COORDINATION_TYPES).forEach((coordinationType) => {
    const requiresCoordination = !layout.every((c) => {
      var _a2;
      return !COMPONENT_COORDINATION_TYPES[c.component].includes(coordinationType) || ((_a2 = c.coordinationScopes) == null ? void 0 : _a2[coordinationType]);
    });
    if (requiresCoordination) {
      let defaultValue = DEFAULT_COORDINATION_VALUES[coordinationType];
      if (coordinationType === "dataset" && datasets.length >= 1) {
        defaultValue = datasets[0].uid;
      }
      if (AUTO_INDEPENDENT_COORDINATION_TYPES.includes(coordinationType)) {
        newConfig = coordinateComponentsIndependent(newConfig, coordinationType, defaultValue);
      } else {
        newConfig = coordinateComponentsTogether(newConfig, coordinationType, defaultValue);
      }
    }
  });
  return newConfig;
}
function initialize(config) {
  if (config.initStrategy === "auto") {
    return initializeAuto(config);
  }
  return config;
}
function upgradeAndValidate(oldConfig) {
  let nextConfig = oldConfig;
  let fromVersion;
  let upgradeFunction;
  let validateFunction;
  do {
    fromVersion = nextConfig.version;
    if (!Object.keys(SCHEMA_HANDLERS).includes(fromVersion)) {
      return [{
        title: "Config validation failed",
        preformatted: "Unknown config version."
      }, false];
    }
    [validateFunction, upgradeFunction] = SCHEMA_HANDLERS[fromVersion];
    const validLegacy = validateFunction(nextConfig);
    if (!validLegacy) {
      const failureReason = JSON.stringify(validateFunction.errors, null, 2);
      return [{
        title: "Config validation failed",
        preformatted: failureReason
      }, false];
    }
    if (upgradeFunction) {
      nextConfig = upgradeFunction(nextConfig);
    }
  } while (upgradeFunction);
  console.groupCollapsed(`\u{1F684} Vitessce (${package_default.version}) view configuration`);
  console.info(`data:,${JSON.stringify(nextConfig)}`);
  console.info(JSON.stringify(nextConfig, null, 2));
  console.groupEnd();
  return [nextConfig, true];
}

// src/app/Vitessce.js
var generateClassName = createGenerateClassName({
  disableGlobal: true
});
function Vitessce(props) {
  const {
    config,
    rowHeight,
    height,
    theme,
    onWarn,
    onConfigChange,
    onLoaderChange,
    validateOnConfigChange = false
  } = props;
  const [configOrWarning, success] = useMemo17(() => {
    if (!config) {
      return [{
        title: "No such dataset",
        unformatted: "The dataset configuration could not be found."
      }, false];
    }
    if (!config.version) {
      return [{
        title: "Missing version",
        unformatted: "The dataset configuration is missing a version, preventing validation."
      }, false];
    }
    const [upgradedConfig, upgradeSuccess] = upgradeAndValidate(config);
    if (upgradeSuccess) {
      const initializedConfig = initialize(upgradedConfig);
      return [initializedConfig, true];
    }
    return [upgradedConfig, false];
  }, [config]);
  useEffect25(() => {
    if (success && !isEqual14(configOrWarning, config) && onConfigChange) {
      onConfigChange(configOrWarning);
    }
  }, [success, config, configOrWarning, onConfigChange]);
  return success ? /* @__PURE__ */ React74.createElement(StylesProvider, {
    generateClassName
  }, /* @__PURE__ */ React74.createElement(ThemeProvider, {
    theme: muiTheme[theme]
  }, /* @__PURE__ */ React74.createElement(ViewConfigProvider, {
    createStore: createViewConfigStore
  }, /* @__PURE__ */ React74.createElement(AuxiliaryProvider, {
    createStore: createAuxiliaryStore
  }, /* @__PURE__ */ React74.createElement(VitessceGrid, {
    config: configOrWarning,
    getComponent,
    rowHeight,
    height,
    theme
  }), /* @__PURE__ */ React74.createElement(CallbackPublisher, {
    onWarn,
    onConfigChange,
    onLoaderChange,
    validateOnConfigChange
  }))))) : /* @__PURE__ */ React74.createElement(Warning, __spreadValues({
    theme
  }, configOrWarning));
}

// src/app/app.js
function AwaitResponse(props) {
  const {
    response,
    theme
  } = props;
  const [isLoading, setIsLoading] = useState21(true);
  const responseRef = useRef11();
  useEffect26(() => {
    response.then((c) => {
      responseRef.current = c;
      setIsLoading(false);
    });
  }, [response]);
  return !isLoading ? React75.createElement(responseRef.current) : /* @__PURE__ */ React75.createElement(Warning, {
    title: "Loading...",
    theme
  });
}
function preformattedDetails(response) {
  return `
    ok: ${response.ok}
    status: ${response.status}
    statusText: ${response.statusText}
    redirected: ${response.redirected}
    type: ${response.type}
    url: ${response.url}`;
}
function checkResponse(response, theme, debug) {
  if (!response.ok) {
    return Promise.resolve(() => /* @__PURE__ */ React75.createElement(Warning, {
      title: "Fetch response not OK",
      preformatted: preformattedDetails(response),
      theme
    }));
  }
  return response.text().then((text) => {
    try {
      const config = JSON.parse(text);
      return Promise.resolve(() => /* @__PURE__ */ React75.createElement(Vitessce, {
        config,
        theme,
        onConfigChange: debug ? console.log : void 0,
        validateOnConfigChange: debug
      }));
    } catch (e) {
      return Promise.resolve(() => /* @__PURE__ */ React75.createElement(Warning, {
        title: "Error parsing JSON",
        preformatted: preformattedDetails(response),
        unformatted: `${e.message}: ${text}`,
        theme
      }));
    }
  });
}
function validateTheme(theme) {
  return ["light", "dark"].includes(theme) ? theme : "dark";
}
function createApp(params) {
  const { rowHeight = null, showBetaHeader = false } = params;
  const urlParams = new URLSearchParams(window.location.search);
  const datasetId = urlParams.get("dataset");
  const debug = urlParams.get("debug") === "true";
  const datasetUrl = urlParams.get("url");
  const showAll = urlParams.get("show") === "all";
  const theme = validateTheme(urlParams.get("theme"));
  if (datasetId) {
    const config = getConfig(datasetId);
    return /* @__PURE__ */ React75.createElement(Vitessce, {
      config,
      rowHeight,
      theme,
      onConfigChange: debug ? console.log : void 0,
      validateOnConfigChange: debug
    });
  }
  if (datasetUrl) {
    const responsePromise = fetch(datasetUrl).then((response) => checkResponse(response, theme, debug)).catch((error) => Promise.resolve(() => /* @__PURE__ */ React75.createElement(Warning, {
      title: "Error fetching",
      unformatted: error.message,
      theme
    })));
    return /* @__PURE__ */ React75.createElement(AwaitResponse, {
      response: responsePromise,
      theme
    });
  }
  const configs2 = listConfigs(showAll);
  return /* @__PURE__ */ React75.createElement(Welcome, {
    configs: configs2,
    theme,
    showBetaHeader
  });
}

// src/app/export-utils.js
import Bowser from "bowser";
import { compressToEncodedURIComponent, decompressFromEncodedURIComponent } from "lz-string";
var CURRENT_VERSION = "0.0.1";
var VITESSCE_CONF_QUERY_STRING = "vitessce_conf";
var VERSION_QUERY_STRING = "vitessce_conf_version";
var LENGTH_QUERY_STRING = "vitessce_conf_length";
function sniffBrowser() {
  const { browser } = Bowser.parse(window.navigator.userAgent);
  return browser.name;
}
var MAX_BROWSER_URL_LENGTHS = {
  Chrome: 32779,
  "Internet Explorer": 2047,
  Edge: 2047,
  Safari: 65e3,
  Firefox: 65e3
};
var CompressedConfLengthError = class {
  constructor(message) {
    this.message = message;
  }
};
function encodeConfInUrl({
  conf,
  onOverMaximumUrlLength = () => {
  }
}) {
  const compressedConf = compressToEncodedURIComponent(JSON.stringify(conf));
  const newParams = `${LENGTH_QUERY_STRING}=${compressedConf.length}&${VERSION_QUERY_STRING}=${CURRENT_VERSION}&${VITESSCE_CONF_QUERY_STRING}=${compressedConf}`;
  const browser = sniffBrowser();
  const maxLength = MAX_BROWSER_URL_LENGTHS[browser];
  if (newParams.length > maxLength) {
    const willWorkOn = Object.entries(MAX_BROWSER_URL_LENGTHS).filter((entry) => entry[1] > newParams.length).map((entry) => entry[0]);
    const message = `Configuration is ${compressedConf.length} characters; max URL for ${browser} is ${maxLength}: it will work on ${willWorkOn.join(", ") || "no browser"}.`;
    console.error(message);
    onOverMaximumUrlLength({ message, willWorkOn });
  }
  return newParams;
}
function decodeURLParamsToConf(queryString) {
  const params = new URLSearchParams(queryString.replace("#", "&"));
  const compressedConfString = params.get(VITESSCE_CONF_QUERY_STRING);
  const expectedConfLength = Number(params.get(LENGTH_QUERY_STRING));
  if (expectedConfLength !== compressedConfString.length) {
    throw new CompressedConfLengthError(`Compressed conf length (${compressedConfString.length}) != expected (${expectedConfLength}). URL truncated?`);
  }
  const version2 = params.get(VERSION_QUERY_STRING);
  if (version2 === CURRENT_VERSION) {
    const conf = JSON.parse(decompressFromEncodedURIComponent(compressedConfString));
    return conf;
  }
  throw new Error("Unrecognized URL Param Version");
}

// src/api/VitessceConfig.js
var VitessceConfigDatasetFile = class {
  constructor(url, dataType, fileType) {
    this.file = {
      url,
      type: dataType,
      fileType
    };
  }
  toJSON() {
    return this.file;
  }
};
var VitessceConfigDataset = class {
  constructor(uid, name2, description2) {
    this.dataset = {
      uid,
      name: name2,
      description: description2,
      files: []
    };
  }
  addFile(url, dataType, fileType) {
    this.dataset.files.push(new VitessceConfigDatasetFile(url, dataType, fileType));
    return this;
  }
  toJSON() {
    return __spreadProps(__spreadValues({}, this.dataset), {
      files: this.dataset.files.map((f) => f.toJSON())
    });
  }
};
var VitessceConfigView = class {
  constructor(component, coordinationScopes, x, y, w, h) {
    this.view = {
      component,
      coordinationScopes,
      x,
      y,
      w,
      h
    };
  }
  useCoordination(...args) {
    const cScopes = args;
    cScopes.forEach((cScope) => {
      this.view.coordinationScopes[cScope.cType] = cScope.cScope;
    });
    return this;
  }
  setXYWH(x, y, w, h) {
    this.view.x = x;
    this.view.y = y;
    this.view.w = w;
    this.view.h = h;
  }
  toJSON() {
    return this.view;
  }
};
var VitessceConfigViewHConcat = class {
  constructor(views) {
    this.views = views;
  }
};
var VitessceConfigViewVConcat = class {
  constructor(views) {
    this.views = views;
  }
};
function hconcat(...views) {
  const vcvhc = new VitessceConfigViewHConcat(views);
  return vcvhc;
}
function vconcat(...views) {
  const vcvvc = new VitessceConfigViewVConcat(views);
  return vcvvc;
}
var VitessceConfigCoordinationScope = class {
  constructor(cType, cScope) {
    this.cType = cType;
    this.cScope = cScope;
    this.cValue = null;
  }
  setValue(cValue) {
    this.cValue = cValue;
    return this;
  }
};
var VitessceConfig = class {
  constructor(name2 = void 0, description2 = void 0) {
    this.config = {
      version: "1.0.0",
      name: name2,
      description: description2,
      datasets: [],
      coordinationSpace: {},
      layout: [],
      initStrategy: "auto"
    };
  }
  addDataset(name2 = void 0, description2 = void 0, options = void 0) {
    const { uid } = options || {};
    const prevDatasetUids = this.config.datasets.map((d) => d.dataset.uid);
    const nextUid = uid || getNextScope(prevDatasetUids);
    const newDataset = new VitessceConfigDataset(nextUid, name2, description2);
    this.config.datasets.push(newDataset);
    const [newScope] = this.addCoordination(COORDINATION_TYPES.DATASET);
    newScope.setValue(nextUid);
    return newDataset;
  }
  addView(dataset, component, options) {
    const {
      x = 0,
      y = 0,
      w = 1,
      h = 1,
      mapping = null
    } = options || {};
    const datasetMatches = this.config.coordinationSpace[COORDINATION_TYPES.DATASET] ? Object.entries(this.config.coordinationSpace[COORDINATION_TYPES.DATASET]).filter(([scopeName, datasetScope2]) => datasetScope2.cValue === dataset.dataset.uid).map(([scopeName]) => scopeName) : [];
    let datasetScope;
    if (datasetMatches.length === 1) {
      [datasetScope] = datasetMatches;
    } else {
      throw new Error("No coordination scope matching the dataset parameter could be found in the coordination space.");
    }
    const coordinationScopes = {
      [COORDINATION_TYPES.DATASET]: datasetScope
    };
    const newView = new VitessceConfigView(component, coordinationScopes, x, y, w, h);
    if (mapping) {
      const [etScope] = this.addCoordination(COORDINATION_TYPES.EMBEDDING_TYPE);
      etScope.setValue(mapping);
      newView.useCoordination(etScope);
    }
    this.config.layout.push(newView);
    return newView;
  }
  addCoordination(...args) {
    const cTypes = args;
    const result = [];
    cTypes.forEach((cType) => {
      const prevScopes = this.config.coordinationSpace[cType] ? Object.keys(this.config.coordinationSpace[cType]) : [];
      const scope = new VitessceConfigCoordinationScope(cType, getNextScope(prevScopes));
      if (!this.config.coordinationSpace[scope.cType]) {
        this.config.coordinationSpace[scope.cType] = {};
      }
      this.config.coordinationSpace[scope.cType][scope.cScope] = scope;
      result.push(scope);
    });
    return result;
  }
  linkViews(views, cTypes, cValues = null) {
    const cScopes = this.addCoordination(...cTypes);
    views.forEach((view) => {
      cScopes.forEach((cScope) => {
        view.useCoordination(cScope);
      });
    });
    if (Array.isArray(cValues) && cValues.length === cTypes.length) {
      cScopes.forEach((cScope, i) => {
        cScope.setValue(cValues[i]);
      });
    }
    return this;
  }
  layout(viewConcat) {
    function layoutAux(obj, xMin, xMax, yMin, yMax) {
      const w = xMax - xMin;
      const h = yMax - yMin;
      if (obj instanceof VitessceConfigView) {
        obj.setXYWH(xMin, yMin, w, h);
      } else if (obj instanceof VitessceConfigViewHConcat) {
        const { views } = obj;
        const numViews = views.length;
        views.forEach((view, i) => {
          layoutAux(view, xMin + w / numViews * i, xMin + w / numViews * (i + 1), yMin, yMax);
        });
      } else if (obj instanceof VitessceConfigViewVConcat) {
        const { views } = obj;
        const numViews = views.length;
        views.forEach((view, i) => {
          layoutAux(view, xMin, xMax, yMin + h / numViews * i, yMin + h / numViews * (i + 1));
        });
      }
    }
    layoutAux(viewConcat, 0, 12, 0, 12);
    return this;
  }
  toJSON() {
    return __spreadProps(__spreadValues({}, this.config), {
      datasets: this.config.datasets.map((d) => d.toJSON()),
      coordinationSpace: fromEntries(Object.entries(this.config.coordinationSpace).map(([cType, cScopes]) => [
        cType,
        fromEntries(Object.entries(cScopes).map(([cScopeName, cScope]) => [
          cScopeName,
          cScope.cValue
        ]))
      ])),
      layout: this.config.layout.map((c) => c.toJSON())
    });
  }
  static fromJSON(config) {
    const { name: name2, description: description2 } = config;
    const vc = new VitessceConfig(name2, description2);
    config.datasets.forEach((d) => {
      const newDataset = vc.addDataset(d.name, d.description, { uid: d.uid });
      d.files.forEach((f) => {
        newDataset.addFile(f.url, f.type, f.fileType);
      });
    });
    Object.keys(config.coordinationSpace).forEach((cType) => {
      if (cType !== COORDINATION_TYPES.DATASET) {
        const cObj = config.coordinationSpace[cType];
        vc.config.coordinationSpace[cType] = {};
        Object.entries(cObj).forEach(([cScopeName, cScopeValue]) => {
          const scope = new VitessceConfigCoordinationScope(cType, cScopeName);
          scope.setValue(cScopeValue);
          vc.config.coordinationSpace[cType][cScopeName] = scope;
        });
      }
    });
    config.layout.forEach((c) => {
      const newView = new VitessceConfigView(c.component, c.coordinationScopes, c.x, c.y, c.w, c.h);
      vc.config.layout.push(newView);
    });
    return vc;
  }
};
export {
  Heatmap_default as Heatmap,
  Scatterplot_default as Scatterplot,
  Spatial_default as Spatial,
  Vitessce,
  VitessceConfig,
  VitessceGrid,
  createApp,
  decodeURLParamsToConf,
  encodeConfInUrl,
  hconcat,
  vconcat
};
//# sourceMappingURL=index.js.map
